# Diff created by create_repo_diff.py
# a = C:\_SOURCE\_CODE\quake2-rerelease-dll-main\rerelease
# b = C:\_SOURCE\_CODE\q2psx_1.2_src\psx\src
# excludes = ['*.dll', '*.exe', '*.pdb', '.git', '.vs', 'bin', 'build', 'obj']

--- a/bg_local.h	2023-10-03 19:43:06
+++ b/bg_local.h	2024-09-20 11:52:35
@@ -12,13 +12,38 @@
 #define GAME_INCLUDE
 #include "game.h"
 
+// physics modifiers
+enum physics_flags_t
+{
+	PHYSICS_PC = 0,
+
+	PHYSICS_N64_MOVEMENT	= bit_v<0>,
+	PHYSICS_PSX_MOVEMENT	= bit_v<1>,
+
+	PHYSICS_PSX_SCALE		= bit_v<2>,
+
+	PHYSICS_DEATHMATCH		= bit_v<3>
+};
+
+// the total number of levels we'll track for the
+// end of unit screen.
+constexpr size_t MAX_LEVELS_PER_UNIT = 16;
+
+MAKE_ENUM_BITFLAGS(physics_flags_t);
+
+// can't crouch in single player N64
+constexpr bool PM_CrouchingDisabled(physics_flags_t flags)
+{
+	return (flags & PHYSICS_N64_MOVEMENT) && !(flags & PHYSICS_DEATHMATCH);
+}
+
 //
 // p_move.c
 //
 struct pm_config_t
 {
-	int32_t		airaccel = 0;
-	bool		n64_physics = false;
+	int32_t			airaccel = 0;
+	physics_flags_t	physics_flags = PHYSICS_PC;
 };
 
 extern pm_config_t pm_config;
@@ -64,8 +89,8 @@
 	CONFIG_COOP_RESPAWN_STRING,
 	CONFIG_COOP_RESPAWN_STRING_END = CONFIG_COOP_RESPAWN_STRING + (COOP_RESPAWN_TOTAL - 1),
 
-	// [Paril-KEX] if 1, n64 player physics apply
-	CONFIG_N64_PHYSICS,
+	// [Paril-KEX] see enum physics_flags_t
+	CONFIG_PHYSICS_FLAGS,
 	CONFIG_HEALTH_BAR_NAME, // active health bar name
 
 	CONFIG_STORY,
@@ -262,3 +287,5 @@
 };
 
 static_assert(STAT_LAST <= MAX_STATS + 1, "stats list overflow");
+
+constexpr float PSX_PHYSICS_SCALAR = 0.875f;
--- a/cg_local.h	2023-10-03 19:43:06
+++ b/cg_local.h	2024-07-07 03:52:24
@@ -9,6 +9,5 @@
 extern cgame_import_t cgi;
 extern cgame_export_t cglobals;
 
-#define SERVER_TICK_RATE cgi.tick_rate // in hz
 #define FRAME_TIME_S cgi.frame_time_s
 #define FRAME_TIME_MS cgi.frame_time_ms
--- a/cg_main.cpp	2023-10-03 19:43:06
+++ b/cg_main.cpp	2024-09-19 05:10:03
@@ -22,8 +22,8 @@
 
 	cgame_init_time = cgi.CL_ClientRealTime();
 
-	pm_config.n64_physics = !!atoi(cgi.get_configstring(CONFIG_N64_PHYSICS));
 	pm_config.airaccel = atoi(cgi.get_configstring(CS_AIRACCEL));
+	pm_config.physics_flags = (physics_flags_t) atoi(cgi.get_configstring(CONFIG_PHYSICS_FLAGS));
 }
 
 static void ShutdownCGame()
@@ -66,8 +66,8 @@
 
 static void CG_ParseConfigString(int32_t i, const char *s)
 {
-	if (i == CONFIG_N64_PHYSICS)
-		pm_config.n64_physics = !!atoi(s);
+	if (i == CONFIG_PHYSICS_FLAGS)
+		pm_config.physics_flags = (physics_flags_t) atoi(s);
 	else if (i == CS_AIRACCEL)
 		pm_config.airaccel = atoi(s);
 }
--- a/cg_screen.cpp	2023-10-03 19:43:06
+++ b/cg_screen.cpp	2024-09-20 11:53:09
@@ -36,7 +36,7 @@
         struct {
             char    text[24];
         } table_cells[6];
-    } table_rows[11]; // just enough to store 8 levels + header + total (+ one slack)
+    } table_rows[MAX_LEVELS_PER_UNIT + 1 + 1 + 1]; // just enough to store all levels + header + total (+ one slack)
 
     size_t column_widths[6];
     int32_t num_rows = 0;
@@ -146,7 +146,7 @@
             break;
 
     // none left, so expire the topmost one
-    if (i == max)
+    if (i >= max)
     {
         data.notify[0].time = 0;
         CG_Notify_CheckExpire(data);
--- a/ctf/g_ctf.h	2023-10-03 19:43:06
+++ b/ctf/g_ctf.h	2024-07-07 03:52:24
@@ -1,10 +1,7 @@
 // Copyright (c) ZeniMax Media Inc.
 // Licensed under the GNU General Public License 2.0.
 
-#define CTF_VERSION 1.52
-#define CTF_VSTRING2(x) #x
-#define CTF_VSTRING(x) CTF_VSTRING2(x)
-#define CTF_STRING_VERSION CTF_VSTRING(CTF_VERSION)
+constexpr const char *CTF_VERSION_STRING = "1.52";
 
 enum ctfteam_t
 {
--- a/g_ai.cpp	2023-10-03 19:43:06
+++ b/g_ai.cpp	2024-10-22 19:27:52
@@ -428,7 +428,7 @@
     spot2 = other->s.origin;
     spot2[2] += other->viewheight;
 
-    contents_t mask = MASK_OPAQUE;
+    contents_t mask = MASK_OPAQUE | CONTENTS_PROJECTILECLIP;
 
     if (!through_glass)
         mask |= CONTENTS_WINDOW;
@@ -439,6 +439,24 @@
 
 /*
 =============
+infront_cone
+
+returns 1 if the entity is in front (in sight) of self
+=============
+*/
+bool infront_cone(edict_t *self, edict_t *other, float cone)
+{
+    vec3_t forward;
+
+    AngleVectors(self->s.angles, forward, nullptr, nullptr);
+
+    vec3_t vec = (other->s.origin - self->s.origin).normalized();
+
+    return vec.dot(forward) > cone;
+}
+
+/*
+=============
 infront
 
 returns 1 if the entity is in front (in sight) of self
@@ -446,21 +464,19 @@
 */
 bool infront(edict_t *self, edict_t *other)
 {
-    vec3_t vec;
-    float  dot;
-    vec3_t forward;
-
-    AngleVectors(self->s.angles, forward, nullptr, nullptr);
-    vec = other->s.origin - self->s.origin;
-    vec.normalize();
-    dot = vec.dot(forward);
-
-    // [Paril-KEX] if we're an ambush monster, reduce our cone of
-    // vision to not ruin surprises, unless we already had an enemy.
-    if (self->spawnflags.has(SPAWNFLAG_MONSTER_AMBUSH) && !self->monsterinfo.trail_time && !self->enemy)
-        return dot > 0.15f;
-
-    return dot > -0.30f;
+    float cone = self->vision_cone;
+
+    if (self->vision_cone < -1.0f)
+    {
+        // [Paril-KEX] if we're an ambush monster, reduce our cone of
+        // vision to not ruin surprises, unless we already had an enemy.
+        if (self->spawnflags.has(SPAWNFLAG_MONSTER_AMBUSH) && !self->monsterinfo.trail_time && !self->enemy)
+            cone = 0.15f;
+        else
+            cone = -0.30f;
+    }
+
+    return infront_cone(self, other, cone);
 }
 
 //============================================================================
@@ -935,7 +951,7 @@
             spot2[2] += self->enemy->viewheight;
 
             tr = gi.traceline(spot1, spot2, self,
-                MASK_SOLID | CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_SLIME | CONTENTS_LAVA);
+                MASK_SOLID | CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_SLIME | CONTENTS_LAVA | CONTENTS_PROJECTILECLIP);
         }
         else
         {
@@ -1330,7 +1346,7 @@
     enemy_vis = visible(self, self->enemy);
     if (enemy_vis)
     {
-        self->monsterinfo.had_visibility = true;
+        self->monsterinfo.had_visibility = visible(self, self->enemy, false);
         self->enemy->show_hostile = level.time + 1_sec; // wake up other monsters
         self->monsterinfo.search_time = level.time + 5_sec;
         self->monsterinfo.last_sighting = self->monsterinfo.saved_goal = self->enemy->s.origin;
@@ -1341,6 +1357,8 @@
 
             if (self->monsterinfo.move_block_change_time < level.time)
                 self->monsterinfo.aiflags &= ~AI_TEMP_MELEE_COMBAT;
+
+            self->monsterinfo.checkattack_time = level.time + random_time(50_ms, 200_ms);
         }
         self->monsterinfo.trail_time = level.time;
         self->monsterinfo.blind_fire_target = self->monsterinfo.last_sighting + (self->enemy->velocity * -0.1f);
@@ -1523,7 +1541,7 @@
 
         bool touching_noise = SV_CloseEnough(self, self->enemy, dist * (gi.tick_rate / 10));
 
-        if ((!self->enemy) || (touching_noise && FacingIdeal(self)))
+        if ((!self->enemy || !self->enemy->inuse) || (touching_noise && FacingIdeal(self)))
         // pmm
         {
             self->monsterinfo.aiflags |= (AI_STAND_GROUND | AI_TEMP_STAND_GROUND);
--- a/g_cmds.cpp	2023-10-03 19:43:06
+++ b/g_cmds.cpp	2024-09-24 14:23:33
@@ -121,7 +121,7 @@
 
 	edict_t *it_ent = G_Spawn();
 	it_ent->classname = it->classname;
-	SpawnItem(it_ent, it);
+	SpawnItem(it_ent, it, spawn_temp_t::empty);
 
 	if (it_ent->inuse)
 	{
@@ -283,7 +283,7 @@
 	{
 		it_ent = G_Spawn();
 		it_ent->classname = it->classname;
-		SpawnItem(it_ent, it);
+		SpawnItem(it_ent, it, spawn_temp_t::empty);
 		// PMM - since some items don't actually spawn when you say to ..
 		if (!it_ent->inuse)
 			return;
@@ -354,7 +354,6 @@
 
 	gi.LocClient_Print(ent, PRINT_HIGH, msg);
 }
-void ED_ParseField(const char *key, const char *value, edict_t *ent);
 
 /*
 ==================
@@ -408,15 +407,15 @@
 	other->s.origin = ent->s.origin + (AngleVectors(ent->s.angles).forward * 24.f);
 	other->s.angles[1] = ent->s.angles[1];
 
-	st = {};
+	spawn_temp_t st {};
 
 	if (gi.argc() > 3)
 	{
 		for (int i = 2; i < gi.argc(); i += 2)
-			ED_ParseField(gi.argv(i), gi.argv(i + 1), other);
-	}
-
-	ED_CallSpawn(other);
+			ED_ParseField(gi.argv(i), gi.argv(i + 1), other, st);
+	}
+
+	ED_CallSpawn(other, st);
 
 	if (other->inuse)
 	{
--- a/g_combat.cpp	2023-10-03 19:43:06
+++ b/g_combat.cpp	2024-07-07 03:52:24
@@ -29,7 +29,7 @@
 	{
 		dest = closest_point_to_box(inflictor_center, targ->absmin, targ->absmax);
 
-		trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID);
+		trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 		if (trace.fraction == 1.0f)
 			return true;
 	}
@@ -41,35 +41,35 @@
 	else
 		targ_center = targ->s.origin;
 
-	trace = gi.traceline(inflictor_center, targ_center, inflictor, MASK_SOLID);
+	trace = gi.traceline(inflictor_center, targ_center, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 	if (trace.fraction == 1.0f)
 		return true;
 
 	dest = targ_center;
 	dest[0] += 15.0f;
 	dest[1] += 15.0f;
-	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID);
+	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 	if (trace.fraction == 1.0f)
 		return true;
 
 	dest = targ_center;
 	dest[0] += 15.0f;
 	dest[1] -= 15.0f;
-	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID);
+	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 	if (trace.fraction == 1.0f)
 		return true;
 
 	dest = targ_center;
 	dest[0] -= 15.0f;
 	dest[1] += 15.0f;
-	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID);
+	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 	if (trace.fraction == 1.0f)
 		return true;
 
 	dest = targ_center;
 	dest[0] -= 15.0f;
 	dest[1] -= 15.0f;
-	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID);
+	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 	if (trace.fraction == 1.0f)
 		return true;
 
--- a/g_func.cpp	2023-10-03 19:43:06
+++ b/g_func.cpp	2024-10-04 07:15:58
@@ -47,6 +47,7 @@
 constexpr spawnflags_t SPAWNFLAG_DOOR_ROTATING_Y_AXIS = 128_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_DOOR_ROTATING_INACTIVE = 0x10000_spawnflag; // Paril: moved to non-reserved
 constexpr spawnflags_t SPAWNFLAG_DOOR_ROTATING_SAFE_OPEN = 0x20000_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_DOOR_ROTATING_NO_COLLISION = 0x40000_spawnflag;
 
 // support routine for setting moveinfo sounds
 inline int32_t G_GetMoveinfoSoundIndex(edict_t *self, const char *default_value, const char *wanted_value)
@@ -66,6 +67,8 @@
 
 void G_SetMoveinfoSounds(edict_t *self, const char *default_start, const char *default_mid, const char *default_end)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->moveinfo.sound_start = G_GetMoveinfoSoundIndex(self, default_start, st.noise_start);
 	self->moveinfo.sound_middle = G_GetMoveinfoSoundIndex(self, default_mid, st.noise_middle);
 	self->moveinfo.sound_end = G_GetMoveinfoSoundIndex(self, default_end, st.noise_end);
@@ -647,6 +650,8 @@
 // PGM - plat2's change the trigger field
 edict_t *plat_spawn_inside_trigger(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	edict_t *trigger;
 	vec3_t	 tmin, tmax;
 
@@ -710,6 +715,8 @@
 */
 void SP_func_plat(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	ent->s.angles = {};
 	ent->solid = SOLID_BSP;
 	ent->movetype = MOVETYPE_PUSH;
@@ -736,16 +743,18 @@
 	if (!ent->dmg)
 		ent->dmg = 2;
 
-	if (!st.lip)
-		st.lip = 8;
+	float lip = st.lip;
+
+	if (!st.was_key_specified("lip"))
+		lip = 8;
 
 	// pos1 is the top position, pos2 is the bottom
 	ent->pos1 = ent->s.origin;
-	ent->pos2 = ent->s.origin;
+	ent->pos2 = ent->s.origin; 
 	if (st.height)
 		ent->pos2[2] -= st.height;
 	else
-		ent->pos2[2] -= (ent->maxs[2] - ent->mins[2]) - st.lip;
+		ent->pos2[2] -= (ent->maxs[2] - ent->mins[2]) - lip;
 
 	ent->use = Use_Plat;
 
@@ -898,6 +907,8 @@
 
 void SP_func_rotating(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	ent->solid = SOLID_BSP;
 	if (ent->spawnflags.has(SPAWNFLAG_ROTATING_STOP))
 		ent->movetype = MOVETYPE_STOP;
@@ -1135,6 +1146,7 @@
 
 void SP_func_button(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	vec3_t abs_movedir;
 	float  dist;
 
@@ -1157,14 +1169,17 @@
 
 	if (!ent->wait)
 		ent->wait = 3;
-	if (!st.lip)
-		st.lip = 4;
+
+	float lip = st.lip;
+
+	if (!lip)
+		lip = 4;
 
 	ent->pos1 = ent->s.origin;
 	abs_movedir[0] = fabsf(ent->movedir[0]);
 	abs_movedir[1] = fabsf(ent->movedir[1]);
 	abs_movedir[2] = fabsf(ent->movedir[2]);
-	dist = abs_movedir[0] * ent->size[0] + abs_movedir[1] * ent->size[1] + abs_movedir[2] * ent->size[2] - st.lip;
+	dist = abs_movedir[0] * ent->size[0] + abs_movedir[1] * ent->size[1] + abs_movedir[2] * ent->size[2] - lip;
 	ent->pos2 = ent->pos1 + (ent->movedir * dist);
 
 	ent->use = button_use;
@@ -1532,8 +1547,15 @@
 	if (!(other->svflags & SVF_MONSTER) && (!other->client))
 		return;
 
-	if (self->owner->spawnflags.has(SPAWNFLAG_DOOR_NOMONSTER) && (other->svflags & SVF_MONSTER))
-		return;
+	if (other->svflags & SVF_MONSTER)
+	{
+		if (self->owner->spawnflags.has(SPAWNFLAG_DOOR_NOMONSTER))
+			return;
+		// [Paril-KEX] this is for PSX; the scale is so small that monsters walking
+		// around to path_corners often initiate doors unintentionally.
+		else if (other->spawnflags.has(SPAWNFLAG_MONSTER_NO_IDLE_DOORS) && !other->enemy)
+			return;
+	}
 
 	if (level.time < self->touch_debounce_time)
 		return;
@@ -1695,6 +1717,7 @@
 
 void SP_func_door(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	vec3_t abs_movedir;
 
 	if (ent->sounds != 1)
@@ -1731,7 +1754,7 @@
 		ent->speed = 100;
 	if (deathmatch->integer)
 		ent->speed *= 2;
-
+	
 	if (!ent->accel)
 		ent->accel = ent->speed;
 	if (!ent->decel)
@@ -1739,8 +1762,9 @@
 
 	if (!ent->wait)
 		ent->wait = 3;
-	if (!st.lip)
-		st.lip = 8;
+	float lip = st.lip;
+	if (!lip)
+		lip = 8;
 	if (!ent->dmg)
 		ent->dmg = 2;
 
@@ -1750,7 +1774,7 @@
 	abs_movedir[1] = fabsf(ent->movedir[1]);
 	abs_movedir[2] = fabsf(ent->movedir[2]);
 	ent->moveinfo.distance =
-		abs_movedir[0] * ent->size[0] + abs_movedir[1] * ent->size[1] + abs_movedir[2] * ent->size[2] - st.lip;
+		abs_movedir[0] * ent->size[0] + abs_movedir[1] * ent->size[1] + abs_movedir[2] * ent->size[2] - lip;
 	ent->pos2 = ent->pos1 + (ent->movedir * ent->moveinfo.distance);
 
 	// if it starts open, switch the positions
@@ -1881,16 +1905,19 @@
 	if (ent->spawnflags.has(SPAWNFLAG_DOOR_REVERSE))
 		ent->movedir = -ent->movedir;
 
-	if (!st.distance)
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+	int distance = st.distance;
+
+	if (!distance)
 	{
 		gi.Com_PrintFmt("{}: no distance set\n", *ent);
-		st.distance = 90;
+		distance = 90;
 	}
 
 	ent->pos1 = ent->s.angles;
-	ent->pos2 = ent->s.angles + (ent->movedir * st.distance);
-	ent->pos3 = ent->s.angles + (ent->movedir * -st.distance);
-	ent->moveinfo.distance = (float) st.distance;
+	ent->pos2 = ent->s.angles + (ent->movedir * distance);
+	ent->pos3 = ent->s.angles + (ent->movedir * -distance);
+	ent->moveinfo.distance = (float) distance;
 
 	ent->movetype = MOVETYPE_PUSH;
 	ent->solid = SOLID_BSP;
@@ -1947,6 +1974,9 @@
 		ent->pos1 = ent->s.angles;
 		ent->movedir = -ent->movedir;
 	}
+
+	if (ent->spawnflags.has(SPAWNFLAG_DOOR_ROTATING_NO_COLLISION))
+		ent->clipmask = CONTENTS_AREAPORTAL; // just because zero is automatic
 
 	if (ent->health)
 	{
@@ -2036,6 +2066,7 @@
 
 void SP_func_water(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	vec3_t abs_movedir;
 
 	G_SetMovedir(self->s.angles, self->movedir);
@@ -2337,6 +2368,23 @@
 			dest -= vec3_t{1.f, 1.f, 1.f};
 	}
 
+	// PGM (Paril)
+	if (ent->speed)
+	{
+		self->speed = ent->speed;
+		self->moveinfo.speed = ent->speed;
+		if (ent->accel)
+			self->moveinfo.accel = ent->accel;
+		else
+			self->moveinfo.accel = ent->speed;
+		if (ent->decel)
+			self->moveinfo.decel = ent->decel;
+		else
+			self->moveinfo.decel = ent->speed;
+		self->moveinfo.current_speed = 0;
+	}
+	// PGM
+
 	self->s.sound = self->moveinfo.sound_middle;
 
 	self->moveinfo.state = STATE_TOP;
@@ -2410,6 +2458,7 @@
 
 void SP_func_train(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	self->movetype = MOVETYPE_PUSH;
 
 	self->s.angles = {};
@@ -2566,6 +2615,7 @@
 
 void SP_func_timer(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	if (!self->wait)
 		self->wait = 1.0;
 
@@ -2768,7 +2818,10 @@
 	if (!ent->wait)
 		ent->wait = 5;
 
-	ent->moveinfo.accel = ent->moveinfo.decel = ent->moveinfo.speed = 50;
+	if (!ent->speed)
+		ent->moveinfo.accel = ent->moveinfo.decel = ent->moveinfo.speed = 50;
+	else
+		ent->moveinfo.accel = ent->moveinfo.decel = ent->moveinfo.speed = ent->speed * 0.1f;
 
 	// calculate positions
 	AngleVectors(ent->s.angles, forward, right, up);
@@ -2960,6 +3013,7 @@
 
 void SP_func_eye(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	ent->movetype = MOVETYPE_PUSH;
 	ent->solid = SOLID_BSP;
 	gi.setmodel(ent, ent->model);
@@ -2971,6 +3025,10 @@
 
 	if (!ent->speed)
 		ent->speed = 45;
+
+	// set vision cone
+	if (st.was_key_specified("vision_cone"))
+		ent->yaw_speed = ent->vision_cone;
 
 	if (!ent->yaw_speed)
 		ent->yaw_speed = 0.5f;
--- a/g_items.cpp	2023-10-03 19:43:06
+++ b/g_items.cpp	2024-09-25 20:43:44
@@ -1139,32 +1139,35 @@
 	else
 		gi.setmodel(ent, ent->item->world_model);
 	ent->solid = SOLID_TRIGGER;
-	ent->movetype = MOVETYPE_TOSS;
 	ent->touch = Touch_Item;
 
-	dest = ent->s.origin + vec3_t { 0, 0, -128 };
-
-	tr = gi.trace(ent->s.origin, ent->mins, ent->maxs, dest, ent, MASK_SOLID);
-	if (tr.startsolid)
-	{
-		if (G_FixStuckObject(ent, ent->s.origin) == stuck_result_t::NO_GOOD_POSITION)
+	if (!ent->spawnflags.has(SPAWNFLAG_ITEM_NO_DROP))
+	{
+		ent->movetype = MOVETYPE_TOSS;
+		dest = ent->s.origin + vec3_t { 0, 0, -128 };
+
+		tr = gi.trace(ent->s.origin, ent->mins, ent->maxs, dest, ent, MASK_SOLID);
+		if (tr.startsolid)
 		{
-			// RAFAEL
-			if (strcmp(ent->classname, "item_foodcube") == 0)
-				ent->velocity[2] = 0;
-			else
+			if (G_FixStuckObject(ent, ent->s.origin) == stuck_result_t::NO_GOOD_POSITION)
 			{
 				// RAFAEL
-				gi.Com_PrintFmt("{}: droptofloor: startsolid\n", *ent);
-				G_FreeEdict(ent);
-				return;
+				if (strcmp(ent->classname, "item_foodcube") == 0)
+					ent->velocity[2] = 0;
+				else
+				{
+					// RAFAEL
+					gi.Com_PrintFmt("{}: droptofloor: startsolid\n", *ent);
+					G_FreeEdict(ent);
+					return;
+					// RAFAEL
+				}
 				// RAFAEL
 			}
-			// RAFAEL
 		}
-	}
-	else
-		ent->s.origin = tr.endpos;
+		else
+			ent->s.origin = tr.endpos;
+	}
 
 	if (ent->team)
 	{
@@ -1278,7 +1281,7 @@
 be on an entity that hasn't spawned yet.
 ============
 */
-void SpawnItem(edict_t *ent, gitem_t *item)
+void SpawnItem(edict_t *ent, gitem_t *item, const spawn_temp_t &st)
 {
 	// [Sam-KEX]
 	// Paril: allow all keys to be trigger_spawn'd (N64 uses this
@@ -1462,8 +1465,11 @@
 	ent->item = item;
 	ent->nextthink = level.time + 20_hz; // items start after other solids
 	ent->think = droptofloor;
-	ent->s.effects = item->world_model_flags;
-	ent->s.renderfx = RF_GLOW | RF_NO_LOD;
+	if (!(level.is_spawning && st.was_key_specified("effects")) && !ent->s.effects)
+		ent->s.effects = item->world_model_flags;
+	if (!(level.is_spawning && st.was_key_specified("renderfx")) && !ent->s.renderfx)
+		ent->s.renderfx = RF_GLOW;
+	ent->s.renderfx |= RF_NO_LOD;
 	if (ent->model)
 		gi.modelindex(ent->model);
 
@@ -1869,7 +1875,7 @@
 		/* quantity */ 0,
 		/* ammo */ IT_NULL,
 		/* chain */ IT_WEAPON_BLASTER,
-		/* flags */ IF_WEAPON | IF_STAY_COOP | IF_NO_HASTE,
+		/* flags */ IF_WEAPON | IF_STAY_COOP,
 		/* vwep_model */ "#w_chainfist.md2",
 		/* armor_info */ nullptr,
 		/* tag */ 0,
--- a/g_local.h	2023-10-03 19:43:06
+++ b/g_local.h	2024-10-20 18:45:47
@@ -464,7 +464,6 @@
 	return gtime_t::from_ms(static_cast<int64_t>((1.0 / s) * 1000));
 }
 
-#define SERVER_TICK_RATE gi.tick_rate // in hz
 extern gtime_t FRAME_TIME_S;
 extern gtime_t FRAME_TIME_MS;
 
@@ -677,9 +676,8 @@
 	// PMM - FIXME - last second added for E3 .. there's probably a better way to do this, but
 	// this works
 	AI_DO_NOT_COUNT = bit_v<21>,	 // set for healed monsters
-	AI_SPAWNED_CARRIER = bit_v<22>, // both do_not_count and spawned are set for spawned monsters
-	AI_SPAWNED_MEDIC_C = bit_v<23>, // both do_not_count and spawned are set for spawned monsters
-	AI_SPAWNED_WIDOW = bit_v<24>,	 // both do_not_count and spawned are set for spawned monsters
+	AI_SPAWNED_COMMANDER = bit_v<22>, // both do_not_count and spawned are set for spawned monsters
+	AI_SPAWNED_NEEDS_GIB = bit_v<23>, // only return commander slots when gibbed
 	AI_BLOCKED = bit_v<25>, // used by blocked_checkattack: set to say I'm attacking while blocked
 							// (prevents run-attacks)
 							// ROGUE
@@ -700,8 +698,10 @@
 };
 MAKE_ENUM_BITFLAGS(monster_ai_flags_t);
 
-constexpr monster_ai_flags_t AI_SPAWNED_MASK =
-	AI_SPAWNED_CARRIER | AI_SPAWNED_MEDIC_C | AI_SPAWNED_WIDOW; // mask to catch all three flavors of spawned
+// flags saved when monster is respawned
+constexpr monster_ai_flags_t AI_RESPAWN_MASK = AI_STINKY | AI_SPAWNED_COMMANDER | AI_SPAWNED_NEEDS_GIB;
+// flags saved when a monster dies
+constexpr monster_ai_flags_t AI_DEATH_MASK = (AI_DOUBLE_TROUBLE | AI_GOOD_GUY | AI_RESPAWN_MASK);
 
 // monster attack state
 enum monster_attack_state_t
@@ -1092,10 +1092,6 @@
 	}
 };
 
-// the total number of levels we'll track for the
-// end of unit screen.
-constexpr size_t MAX_LEVELS_PER_UNIT = 8;
-
 struct level_entry_t
 {
 	// bsp name
@@ -1154,8 +1150,9 @@
 //
 struct level_locals_t
 {
-	bool in_frame;
-	gtime_t time;
+	bool in_frame = false;
+	bool is_spawning = false; // whether we're still doing SpawnEntities
+	gtime_t time = {};
 
 	char level_name[MAX_QPATH]; // the descriptive name (Outer Base, etc)
 	char mapname[MAX_QPATH];	// the server name (base1, etc)
@@ -1201,7 +1198,7 @@
 	// ROGUE
 	
 	int32_t shadow_light_count; // [Sam-KEX]
-	bool is_n64;
+	bool is_n64, is_psx;
 	gtime_t coop_level_restart_time; // restart the level after this time
 	bool instantitems; // instantitems 1 set in worldspawn
 
@@ -1250,6 +1247,12 @@
 	bool story_active;
 	gtime_t next_auto_save;
 	gtime_t next_match_report;
+
+	const char *primary_objective_string;
+	const char *secondary_objective_string;
+
+	const char *primary_objective_title;
+	const char *secondary_objective_title;
 };
 
 struct shadow_light_temp_t
@@ -1275,9 +1278,9 @@
 	int32_t skyautorotate = 1;
 	const char	 *nextmap;
 
-	int32_t		lip;
-	int32_t		distance;
-	int32_t		height;
+	float		lip;
+	float		distance;
+	float		height;
 	const char	*noise;
 	float		pausetime;
 	const char	*item;
@@ -1306,6 +1309,7 @@
 	const char *start_items;
 	int no_grapple = 0;
 	float health_multiplier = 1.0f;
+	int physics_flags_sp = 0, physics_flags_dm = 0;
 
 	const char *reinforcements; // [Paril-KEX]
 	const char *noise_start, *noise_middle, *noise_end; // [Paril-KEX]
@@ -1313,10 +1317,18 @@
 
 	std::unordered_set<const char *> keys_specified;
 
+	const char *primary_objective_string;
+	const char *secondary_objective_string;
+
+	const char *primary_objective_title;
+	const char *secondary_objective_title;
+
 	inline bool was_key_specified(const char *key) const
 	{
 		return keys_specified.find(key) != keys_specified.end();
 	}
+
+	static const spawn_temp_t empty;
 };
 
 enum move_state_t
@@ -1468,14 +1480,6 @@
 	int32_t lerp_frame = -1;
 };
 
-// this check only works on windows, and is only
-// of importance to developers anyways
-#if defined(_WIN32) && defined(_MSC_VER)
-#if _MSC_VER >= 1934
-#define COMPILE_TIME_MOVE_CHECK
-#endif
-#endif
-
 struct mmove_t
 {
 	int32_t	  firstframe;
@@ -1484,33 +1488,29 @@
 	void (*endfunc)(edict_t *self);
 	float sidestep_scale;
 
-#ifdef COMPILE_TIME_MOVE_CHECK
+#ifdef _DEBUG
+	size_t framecount;
+#endif
+
 	template<size_t N>
-	constexpr mmove_t(int32_t firstframe, int32_t lastframe, const mframe_t (&frames)[N], void (*endfunc)(edict_t *self) = nullptr, float sidestep_scale = 0.0f) :
+	inline mmove_t(int32_t firstframe, int32_t lastframe, const mframe_t (&frames)[N], void (*endfunc)(edict_t *self) = nullptr, float sidestep_scale = 0.0f) :
 		firstframe(firstframe),
 		lastframe(lastframe),
 		frame(frames),
 		endfunc(endfunc),
 		sidestep_scale(sidestep_scale)
-	{
-		if ((lastframe - firstframe + 1) != N)
-			throw std::exception("bad animation frames; check your numbers!");
-	}
+#ifdef _DEBUG
+		, framecount(N)
 #endif
+	{
+	}
 };
 
 using save_mmove_t = save_data_t<mmove_t, SAVE_DATA_MMOVE>;
-#ifdef COMPILE_TIME_MOVE_CHECK
-#define MMOVE_T(n) \
-	extern const mmove_t n; \
-	static const save_data_list_t save__##n(#n, SAVE_DATA_MMOVE, &n); \
-	constexpr mmove_t n
-#else
 #define MMOVE_T(n) \
 	extern const mmove_t n; \
 	static const save_data_list_t save__##n(#n, SAVE_DATA_MMOVE, &n); \
 	const mmove_t n
-#endif
 
 DEFINE_DATA_FUNC(monsterinfo_stand, MONSTERINFO_STAND, void, edict_t *self);
 #define MONSTERINFO_STAND(n) \
@@ -1599,6 +1599,9 @@
 };
 
 constexpr size_t MAX_REINFORCEMENTS = 5; // max number of spawns we can do at once.
+
+void M_SetupReinforcements(const char *reinforcements, reinforcement_list_t &list);
+std::array<uint8_t, MAX_REINFORCEMENTS> M_PickReinforcements(edict_t *self, int32_t &num_chosen, int32_t max_slots = 0);
 
 constexpr gtime_t HOLD_FOREVER = gtime_t::from_ms(std::numeric_limits<int64_t>::max());
 
@@ -1669,8 +1672,9 @@
 	gtime_t blind_fire_delay;
 	vec3_t	blind_fire_target;
 	// used by the spawners to not spawn too much and keep track of #s of monsters spawned
-	int32_t	 monster_slots; // nb: for spawned monsters, this is how many slots we took from our commander
-	int32_t	 monster_used;
+	int32_t  slots_from_commander; // for spawned monsters, this is how many slots we took from our commander
+	int32_t	 monster_slots; // for commanders, total slots we can occupy
+	int32_t	 monster_used; // for commanders, total slots currently used
 	edict_t *commander;
 	// powerup timers, used by widow, our friend
 	gtime_t quad_time;
@@ -1777,7 +1781,6 @@
 extern game_locals_t  game;
 extern level_locals_t level;
 extern game_export_t  globals;
-extern spawn_temp_t	  st;
 
 extern edict_t *g_edicts;
 
@@ -1878,6 +1881,7 @@
 	return irandom(2) == 0;
 }
 
+extern cvar_t *developer;
 extern cvar_t *deathmatch;
 extern cvar_t *coop;
 extern cvar_t *skill;
@@ -1912,6 +1916,7 @@
 extern cvar_t *sv_cheats;
 extern cvar_t *g_debug_monster_paths;
 extern cvar_t *g_debug_monster_kills;
+extern cvar_t *g_debug_poi;
 extern cvar_t *maxspectators;
 
 extern cvar_t *bot_debug_follow_actor;
@@ -1994,7 +1999,8 @@
 constexpr spawnflags_t SPAWNFLAG_ITEM_TRIGGER_SPAWN = 0x00000001_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_ITEM_NO_TOUCH = 0x00000002_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_ITEM_TOSS_SPAWN = 0x00000004_spawnflag;
-constexpr spawnflags_t SPAWNFLAG_ITEM_MAX = 0x00000008_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_ITEM_NO_DROP = 0x00000008_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_ITEM_MAX = 0x00000016_spawnflag;
 // 8 bits reserved for editor flags & power cube bits
 // (see SPAWNFLAG_NOT_EASY above)
 constexpr spawnflags_t SPAWNFLAG_ITEM_DROPPED = 0x00010000_spawnflag;
@@ -2021,7 +2027,7 @@
 edict_t	*Drop_Item(edict_t *ent, gitem_t *item);
 void	  SetRespawn(edict_t *ent, gtime_t delay, bool hide_self = true);
 void	  ChangeWeapon(edict_t *ent);
-void	  SpawnItem(edict_t *ent, gitem_t *item);
+void	  SpawnItem(edict_t *ent, gitem_t *item, const spawn_temp_t &st);
 void	  Think_Weapon(edict_t *ent);
 item_id_t ArmorIndex(edict_t *ent);
 item_id_t PowerArmorType(edict_t *ent);
@@ -2039,7 +2045,7 @@
 //
 // g_utils.c
 //
-bool KillBox(edict_t *ent, bool from_spawning, mod_id_t mod = MOD_TELEFRAG, bool bsp_clipping = true);
+bool KillBox(edict_t *ent, bool from_spawning, mod_id_t mod = MOD_TELEFRAG, bool bsp_clipping = true, bool allow_safety = false);
 edict_t *G_Find(edict_t *from, std::function<bool(edict_t *e)> matcher);
 
 // utility template for getting the type of a field
@@ -2085,6 +2091,9 @@
 //
 // g_spawn.c
 //
+const spawn_temp_t &ED_GetSpawnTemp();
+void  ED_ParseField(const char *key, const char *value, edict_t *ent, spawn_temp_t &st);
+void  ED_CallSpawn(edict_t *ent, const spawn_temp_t &spawntemp);
 void  ED_CallSpawn(edict_t *ent);
 char *ED_NewString(char *string);
 
@@ -2103,6 +2112,8 @@
 constexpr spawnflags_t SPAWNFLAG_LASER_FAT = 0x0040_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_LASER_ZAP = 0x80000000_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_LASER_LIGHTNING = 0x10000_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_LASER_REACTOR = 0x20000_spawnflag; // PSX reactor effect instead of beam
+constexpr spawnflags_t SPAWNFLAG_LASER_NO_PROTECTION = 0x40000_spawnflag; // no protection
 
 constexpr spawnflags_t SPAWNFLAG_HEALTHBAR_PVS_ONLY = 1_spawnflag;
 
@@ -2177,7 +2188,7 @@
 						 int vspread, monster_muzzleflash_id_t flashtype);
 void monster_fire_shotgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick, int hspread,
 						  int vspread, int count, monster_muzzleflash_id_t flashtype);
-void monster_fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
+edict_t *monster_fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 						  monster_muzzleflash_id_t flashtype, effects_t effect);
 void monster_fire_flechette(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 						    monster_muzzleflash_id_t flashtype);
@@ -2185,7 +2196,7 @@
 						  monster_muzzleflash_id_t flashtype, float right_adjust, float up_adjust);
 void monster_fire_rocket(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 						 monster_muzzleflash_id_t flashtype);
-void monster_fire_railgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick,
+bool monster_fire_railgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick,
 						  monster_muzzleflash_id_t flashtype);
 void monster_fire_bfg(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, int kick,
 					  float damage_radius, monster_muzzleflash_id_t flashtype);
@@ -2217,13 +2228,15 @@
 // used in N64, appears to change their behavior for the end scene.
 constexpr size_t HACKFLAG_END_CUTSCENE = 4;
 
-bool monster_start(edict_t *self);
+bool monster_start(edict_t *self, const spawn_temp_t &st);
 void monster_start_go(edict_t *self);
 // RAFAEL
 void monster_fire_ionripper(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 							monster_muzzleflash_id_t flashtype, effects_t effect);
 void monster_fire_heat(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 					   monster_muzzleflash_id_t flashtype, float lerp_factor);
+constexpr spawnflags_t SPAWNFLAG_DABEAM_SECONDARY = 1_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_DABEAM_SPAWNED = 2_spawnflag;
 void monster_fire_dabeam(edict_t *self, int damage, bool secondary, void(*update_func)(edict_t *self));
 void dabeam_update(edict_t *self, bool damage);
 void monster_fire_blueblaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
@@ -2237,7 +2250,7 @@
 						  monster_muzzleflash_id_t flashtype);
 void monster_fire_heatbeam(edict_t *self, const vec3_t &start, const vec3_t &dir, const vec3_t &offset, int damage,
 						   int kick, monster_muzzleflash_id_t flashtype);
-void stationarymonster_start(edict_t *self);
+void stationarymonster_start(edict_t *self, const spawn_temp_t &st);
 void monster_done_dodge(edict_t *self);
 // ROGUE
 
@@ -2253,6 +2266,7 @@
 constexpr spawnflags_t SPAWNFLAG_MONSTER_SUPER_STEP = 17_spawnflag_bit;
 constexpr spawnflags_t SPAWNFLAG_MONSTER_NO_DROP = 18_spawnflag_bit;
 constexpr spawnflags_t SPAWNFLAG_MONSTER_SCENIC = 19_spawnflag_bit;
+constexpr spawnflags_t SPAWNFLAG_MONSTER_NO_IDLE_DOORS = 20_spawnflag_bit;
 
 // fixbot spawnflags
 constexpr spawnflags_t SPAWNFLAG_FIXBOT_FIXIT = 4_spawnflag;
@@ -2265,7 +2279,7 @@
 //
 void ThrowClientHead(edict_t *self, int damage);
 void gib_die(edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, const vec3_t &point, const mod_t &mod);
-edict_t *ThrowGib(edict_t *self, const char *gibname, int damage, gib_type_t type, float scale);
+edict_t *ThrowGib(edict_t *self, const char *gibname, int damage, gib_type_t type, float scale, int frame = 0);
 void BecomeExplosion1(edict_t *self);
 void misc_viper_use(edict_t *self, edict_t *other, edict_t *activator);
 void misc_strogg_ship_use(edict_t *self, edict_t *other, edict_t *activator);
@@ -2303,6 +2317,7 @@
 
 void FoundTarget(edict_t *self);
 void HuntTarget(edict_t *self, bool animate_state = true);
+bool infront_cone(edict_t *self, edict_t *other, float cone);
 bool infront(edict_t *self, edict_t *other);
 bool visible(edict_t *self, edict_t *other, bool through_glass = true);
 bool FacingIdeal(edict_t *self);
@@ -2318,7 +2333,7 @@
 void fire_shotgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick, int hspread,
 				  int vspread, int count, mod_t mod);
 void blaster_touch(edict_t *self, edict_t *other, const trace_t &tr, bool other_touching_self);
-void fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, effects_t effect,
+edict_t *fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, effects_t effect,
 				  mod_t mod);
 void Grenade_Explode(edict_t *ent);
 void fire_grenade(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, gtime_t timer,
@@ -2328,7 +2343,7 @@
 void rocket_touch(edict_t *ent, edict_t *other, const trace_t &tr, bool other_touching_self);
 edict_t *fire_rocket(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed, float damage_radius,
 				 int radius_damage);
-void fire_rail(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick);
+bool fire_rail(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick);
 void fire_bfg(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed, float damage_radius);
 // RAFAEL
 void fire_ionripper(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, effects_t effect);
@@ -2431,6 +2446,15 @@
 //
 // p_view.c
 //
+struct step_parameters_t
+{
+	float			xyspeed;
+	float			bobmove;
+	int				bobcycle, bobcycle_run;	  // odd cycles are right foot going forward
+	float			bobfracsin; // sinf(bobfrac*M_PI)
+};
+
+void G_SetClientFrame(edict_t *ent, const step_parameters_t &step);
 void ClientEndServerFrame(edict_t *ent);
 void G_LagCompensate(edict_t *from_player, const vec3_t &start, const vec3_t &dir);
 void G_UnLagCompensate();
@@ -2451,7 +2475,7 @@
 // p_weapon.c
 //
 void PlayerNoise(edict_t *who, const vec3_t &where, player_noise_t type);
-void P_ProjectSource(edict_t *ent, const vec3_t &angles, vec3_t distance, vec3_t &result_start, vec3_t &result_dir);
+void P_ProjectSource(edict_t *ent, const vec3_t &angles, vec3_t distance, vec3_t &result_start, vec3_t &result_dir, bool adjust_for_pierce = false);
 void NoAmmoWeaponChange(edict_t *ent, bool sound);
 void G_RemoveAmmo(edict_t *ent);
 void G_RemoveAmmo(edict_t *ent, int32_t quantity);
@@ -3233,6 +3257,8 @@
 	mod_t	lastMOD;
 	const char	*style_on, *style_off;
 	uint32_t crosslevel_flags;
+	gtime_t no_gravity_time;
+	float vision_cone; // TODO: migrate vision_cone on old loads to -2.0f
 	// NOTE: if adding new elements, make sure to add them
 	// in g_save.cpp too!
 };
@@ -3442,6 +3468,7 @@
 	const char *gibname;
 	float scale;
 	gib_type_t type;
+	int framenum = 0;
 
 	constexpr gib_def_t(size_t count, const char *gibname) :
 		count(count),
@@ -3506,6 +3533,12 @@
 		type(GIB_NONE)
 	{
 	}
+
+	inline gib_def_t &frame(int f)
+	{
+		framenum = f;
+		return *this;
+	}
 };
 
 // convenience function to throw different gib types
@@ -3515,7 +3548,7 @@
 {
 	for (auto &gib : gibs)
 		for (size_t i = 0; i < gib.count; i++)
-			ThrowGib(self, gib.gibname, damage, gib.type, gib.scale * (self->s.scale ? self->s.scale : 1));
+			ThrowGib(self, gib.gibname, damage, gib.type, gib.scale * (self->s.scale ? self->s.scale : 1), gib.framenum);
 }
 
 inline bool M_CheckGib(edict_t *self, const mod_t &mod)
@@ -3534,17 +3567,16 @@
 struct fmt::formatter<edict_t>
 {
 	template<typename ParseContext>
-	constexpr auto parse(ParseContext& ctx)
+	constexpr auto parse(ParseContext &ctx)
 	{
 		return ctx.begin();
 	}
 
     template<typename FormatContext>
-    auto format(const edict_t &p, FormatContext &ctx) -> decltype(ctx.out())
+    auto format(const edict_t &p, FormatContext &ctx) const
     {
-		if (p.linked)
-			return fmt::format_to(ctx.out(), FMT_STRING("{} @ {}"), p.classname, (p.absmax + p.absmin) * 0.5f);
-		return fmt::format_to(ctx.out(), FMT_STRING("{} @ {}"), p.classname, p.s.origin);
+		vec3_t pos = p.linked ? ((p.absmax + p.absmin) * 0.5f) : p.s.origin;
+		return fmt::format_to(ctx.out(), FMT_STRING("{} @ {}"), p.classname, pos);
     }
 };
 
--- a/g_main.cpp	2023-10-03 19:43:06
+++ b/g_main.cpp	2024-10-20 21:14:45
@@ -20,13 +20,13 @@
 /*static*/ std::array<const char*, MAX_LOCALIZATION_ARGS> local_game_import_t::buffer_ptrs;
 
 game_export_t  globals;
-spawn_temp_t   st;
 
 cached_modelindex		sm_meat_index;
 cached_soundindex		snd_fry;
 
 edict_t *g_edicts;
 
+cvar_t *developer;
 cvar_t *deathmatch;
 cvar_t *coop;
 cvar_t *skill;
@@ -69,6 +69,7 @@
 
 cvar_t *g_debug_monster_paths;
 cvar_t *g_debug_monster_kills;
+cvar_t *g_debug_poi;
 
 cvar_t *bot_debug_follow_actor;
 cvar_t *bot_debug_move_to_point;
@@ -168,6 +169,7 @@
 */
 void PreInitGame()
 {
+	developer = gi.cvar("developer", "0", CVAR_NOFLAGS);
 	maxclients = gi.cvar("maxclients", G_Fmt("{}", MAX_SPLIT_PLAYERS).data(), CVAR_SERVERINFO | CVAR_LATCH);
 	deathmatch = gi.cvar("deathmatch", "0", CVAR_LATCH);
 	coop = gi.cvar("coop", "0", CVAR_LATCH);
@@ -259,6 +261,7 @@
 
 	g_debug_monster_paths = gi.cvar("g_debug_monster_paths", "0", CVAR_NOFLAGS);
 	g_debug_monster_kills = gi.cvar("g_debug_monster_kills", "0", CVAR_LATCH);
+	g_debug_poi = gi.cvar("g_debug_poi", "0", CVAR_NOFLAGS);
 
 	bot_debug_follow_actor = gi.cvar("bot_debug_follow_actor", "0", CVAR_NOFLAGS);
 	bot_debug_move_to_point = gi.cvar("bot_debug_move_to_point", "0", CVAR_NOFLAGS);
@@ -963,7 +966,7 @@
 
 		for (auto player : active_players())
 		{
-			if (player->health >= 0)
+			if (player->health > 0)
 			{
 				reset_coop_respawn = false;
 				break;
--- a/g_misc.cpp	2023-10-03 19:43:06
+++ b/g_misc.cpp	2024-10-19 22:33:02
@@ -83,7 +83,7 @@
 	}
 }
 
-edict_t *ThrowGib(edict_t *self, const char *gibname, int damage, gib_type_t type, float scale)
+edict_t *ThrowGib(edict_t *self, const char *gibname, int damage, gib_type_t type, float scale, int frame)
 {
 	edict_t *gib;
 	vec3_t	 vd;
@@ -153,7 +153,7 @@
 		gib->s.skinnum = self->s.skinnum;
 	else
 		gib->s.skinnum = 0;
-	gib->s.frame = 0;
+	gib->s.frame = frame;
 	gib->mins = gib->maxs = {};
 	gib->s.sound = 0;
 	gib->monsterinfo.engine_sound = 0;
@@ -624,6 +624,8 @@
 
 static void setup_dynamic_light(edict_t* self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	// [Sam-KEX] Shadow stuff
 	if (st.sl.data.radius > 0)
 	{
@@ -661,6 +663,8 @@
 
 void SP_light(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	// no targeted lights in deathmatch, because they cause global messages
 	if((!self->targetname || (deathmatch->integer && !(self->spawnflags.has(SPAWNFLAG_LIGHT_ALLOW_IN_DM)))) && st.sl.data.radius == 0) // [Sam-KEX]
 	{
@@ -709,6 +713,7 @@
 constexpr spawnflags_t SPAWNFLAG_WALL_START_ON = 4_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_WALL_ANIMATED = 8_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_WALL_ANIMATED_FAST = 16_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_SAFE_APPEAR = 32_spawnflag;
 
 USE(func_wall_use) (edict_t *self, edict_t *other, edict_t *activator) -> void
 {
@@ -717,7 +722,7 @@
 		self->solid = SOLID_BSP;
 		self->svflags &= ~SVF_NOCLIENT;
 		gi.linkentity(self);
-		KillBox(self, false);
+		KillBox(self, false, MOD_TELEFRAG, true, self->spawnflags.has(SPAWNFLAG_SAFE_APPEAR));
 	}
 	else
 	{
@@ -1188,6 +1193,8 @@
 // PGM
 //=========
 
+constexpr spawnflags_t SPAWNFLAG_EXPLOBOX_NO_MOVE = 1_spawnflag;
+
 void SP_misc_explobox(edict_t *self)
 {
 	if (deathmatch->integer)
@@ -1220,7 +1227,10 @@
 	self->takedamage = true;
 	self->flags |= FL_TRAP;
 
-	self->touch = barrel_touch;
+	if (!self->spawnflags.has(SPAWNFLAG_EXPLOBOX_NO_MOVE))
+		self->touch = barrel_touch;
+	else
+		self->flags |= FL_NO_KNOCKBACK;
 
 	// PGM - change so barrels will think and hence, blow up
 	self->think = barrel_start;
@@ -2133,6 +2143,8 @@
 
 void SP_misc_flare(edict_t* ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	ent->s.modelindex = 1;
 	ent->s.renderfx = RF_FLARE;
 	ent->solid = SOLID_NOT;
@@ -2352,6 +2364,8 @@
 		return;
 	} // not much point without something to print...
 
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->think = info_world_text_think;
 	self->use = info_world_text_use;
 	self->size[ 2 ] = st.radius ? st.radius : 0.2f;
@@ -2492,6 +2506,8 @@
  "radius"		- How much to scale the model in-game
 */
 void SP_misc_player_mannequin( edict_t * self ) {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->movetype = MOVETYPE_NONE;
 	self->solid = SOLID_BBOX;
 	if (!st.was_key_specified("effects"))
@@ -2528,10 +2544,28 @@
 	gi.linkentity( self );
 }
 
+constexpr spawnflags_t SPAWNFLAG_MODEL_TOGGLE = 1_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_MODEL_START_ON = 2_spawnflag;
+
+USE(misc_model_use) (edict_t *self, edict_t *other, edict_t *activator) -> void
+{
+	self->svflags ^= SVF_NOCLIENT;
+}
+
 /*QUAKED misc_model (1 0 0) (-8 -8 -8) (8 8 8)
 */
 void SP_misc_model(edict_t *ent)
 {
-	gi.setmodel(ent, ent->model);
+	if (ent->model && ent->model[0])
+		gi.setmodel(ent, ent->model);
+
+	if (ent->spawnflags.has(SPAWNFLAG_MODEL_TOGGLE))
+	{
+		ent->use = misc_model_use;
+
+		if (!ent->spawnflags.has(SPAWNFLAG_MODEL_START_ON))
+			ent->svflags |= SVF_NOCLIENT;
+	}
+
 	gi.linkentity(ent);
 }
--- a/g_monster.cpp	2023-10-03 19:43:06
+++ b/g_monster.cpp	2024-10-08 17:32:34
@@ -37,11 +37,12 @@
 	monster_muzzleflash(self, start, flashtype);
 }
 
-void monster_fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
+edict_t *monster_fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 						  monster_muzzleflash_id_t flashtype, effects_t effect)
 {
-	fire_blaster(self, start, dir, damage, speed, effect, MOD_BLASTER);
+	edict_t *e = fire_blaster(self, start, dir, damage, speed, effect, MOD_BLASTER);
 	monster_muzzleflash(self, start, flashtype);
+	return e;
 }
 
 void monster_fire_flechette(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
@@ -65,15 +66,17 @@
 	monster_muzzleflash(self, start, flashtype);
 }
 
-void monster_fire_railgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick,
+bool monster_fire_railgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick,
 						  monster_muzzleflash_id_t flashtype)
 {
 	if (gi.pointcontents(start) & MASK_SOLID)
-		return;
-
-	fire_rail(self, start, aimdir, damage, kick);
+		return false;
+
+	bool hit = fire_rail(self, start, aimdir, damage, kick);
 
 	monster_muzzleflash(self, start, flashtype);
+
+	return hit;
 }
 
 void monster_fire_bfg(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, int kick,
@@ -141,6 +144,10 @@
 {
 	vec3_t	point;
 	trace_t trace;
+
+	// [Paril-KEX]
+	if (ent->no_gravity_time > level.time)
+		return;
 
 	if (ent->flags & (FL_SWIM | FL_FLY))
 		return;
@@ -238,43 +245,31 @@
 
 	if (ent->health > 0)
 	{
+		bool take_drown_damage = false;
+
 		if (!(ent->flags & FL_SWIM))
 		{
 			if (ent->waterlevel < WATER_UNDER)
-			{
 				ent->air_finished = level.time + 12_sec;
-			}
 			else if (ent->air_finished < level.time)
-			{ // drown!
-				if (ent->pain_debounce_time < level.time)
-				{
-					dmg = 2 + (int) (2 * floorf((level.time - ent->air_finished).seconds()));
-					if (dmg > 15)
-						dmg = 15;
-					T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, dmg, 0, DAMAGE_NO_ARMOR,
-							 MOD_WATER);
-					ent->pain_debounce_time = level.time + 1_sec;
-				}
-			}
+				take_drown_damage = true;
 		}
 		else
 		{
 			if (ent->waterlevel > WATER_NONE)
-			{
 				ent->air_finished = level.time + 9_sec;
-			}
 			else if (ent->air_finished < level.time)
-			{ // suffocate!
-				if (ent->pain_debounce_time < level.time)
-				{
-					dmg = 2 + (int) (2 * floorf((level.time - ent->air_finished).seconds()));
-					if (dmg > 15)
-						dmg = 15;
-					T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, dmg, 0, DAMAGE_NO_ARMOR,
-							 MOD_WATER);
-					ent->pain_debounce_time = level.time + 1_sec;
-				}
-			}
+				take_drown_damage = true;
+		}
+
+		if (take_drown_damage && ent->pain_debounce_time < level.time)
+		{
+			dmg = 2 + (int) (2 * floorf((level.time - ent->air_finished).seconds()));
+			if (dmg > 15)
+				dmg = 15;
+			T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, dmg, 0, DAMAGE_NO_ARMOR,
+						MOD_WATER);
+			ent->pain_debounce_time = level.time + 1_sec;
 		}
 	}
 
@@ -666,30 +661,16 @@
 		}
 		// ROGUE
 
+		bool dead_commander_check = false;
+
 		if (!e->deadflag)
 		{
 			e->enemy = e->monsterinfo.damage_attacker;
 
 			// ROGUE
 			// ROGUE - free up slot for spawned monster if it's spawned
-			if (e->monsterinfo.aiflags & AI_SPAWNED_CARRIER)
-			{
-				if (e->monsterinfo.commander && e->monsterinfo.commander->inuse &&
-					!strcmp(e->monsterinfo.commander->classname, "monster_carrier"))
-					e->monsterinfo.commander->monsterinfo.monster_slots++;
-				e->monsterinfo.commander = nullptr;
-			}
-			if (e->monsterinfo.aiflags & AI_SPAWNED_WIDOW)
-			{
-				// need to check this because we can have variable numbers of coop players
-				if (e->monsterinfo.commander && e->monsterinfo.commander->inuse &&
-					!strncmp(e->monsterinfo.commander->classname, "monster_widow", 13))
-				{
-					if (e->monsterinfo.commander->monsterinfo.monster_used > 0)
-						e->monsterinfo.commander->monsterinfo.monster_used--;
-					e->monsterinfo.commander = nullptr;
-				}
-			}
+			if ((e->monsterinfo.aiflags & AI_SPAWNED_COMMANDER) && !(e->monsterinfo.aiflags & AI_SPAWNED_NEEDS_GIB))
+				dead_commander_check = true;
 
 			if (!(e->monsterinfo.aiflags & AI_DO_NOT_COUNT) && !(e->spawnflags & SPAWNFLAG_MONSTER_DEAD))
 				G_MonsterKilled(e);
@@ -703,13 +684,18 @@
 		// [Paril-KEX] medic commander only gets his slots back after the monster is gibbed, since we can revive them
 		if (e->health <= e->gib_health)
 		{
-			if (e->monsterinfo.aiflags & AI_SPAWNED_MEDIC_C)
-			{
-				if (e->monsterinfo.commander && e->monsterinfo.commander->inuse && !strcmp(e->monsterinfo.commander->classname, "monster_medic_commander"))
-					e->monsterinfo.commander->monsterinfo.monster_used -= e->monsterinfo.monster_slots;
-
-				e->monsterinfo.commander = nullptr;
-			}
+			if ((e->monsterinfo.aiflags & AI_SPAWNED_COMMANDER) && (e->monsterinfo.aiflags & AI_SPAWNED_NEEDS_GIB))
+				dead_commander_check = true;
+		}
+
+		if (dead_commander_check)
+		{
+			edict_t *&commander = e->monsterinfo.commander;
+
+			if (commander && commander->inuse)
+				commander->monsterinfo.monster_used = max(0, commander->monsterinfo.monster_used - e->monsterinfo.slots_from_commander);
+
+			commander = nullptr;
 		}
 
 		if (e->inuse && e->health > e->gib_health && e->s.frame == e->monsterinfo.active_move->lastframe)
@@ -1152,7 +1138,7 @@
 void monster_death_use(edict_t *self)
 {
 	self->flags &= ~(FL_FLY | FL_SWIM);
-	self->monsterinfo.aiflags &= (AI_DOUBLE_TROUBLE | AI_GOOD_GUY | AI_STINKY | AI_SPAWNED_MASK);
+	self->monsterinfo.aiflags &= AI_DEATH_MASK;
 
 	if (self->item)
 	{
@@ -1176,8 +1162,10 @@
 	// [Paril-KEX] fire health target
 	if (self->healthtarget)
 	{
+		const char *target = self->target;
 		self->target = self->healthtarget;
 		G_UseTargets(self, self->enemy);
+		self->target = target;
 	}
 }
 
@@ -1221,7 +1209,7 @@
 //============================================================================
 constexpr spawnflags_t SPAWNFLAG_MONSTER_FUBAR = 4_spawnflag;
 
-bool monster_start(edict_t *self)
+bool monster_start(edict_t *self, const spawn_temp_t &st)
 {
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
@@ -1284,6 +1272,9 @@
 		self->mass *= self->s.scale;
 	}
 
+	if (level.is_psx)
+		self->s.origin[2] -= self->mins[2] - (self->mins[2] * PSX_PHYSICS_SCALAR);
+
 	// set combat style if unset
 	if (self->monsterinfo.combat_style == COMBAT_UNKNOWN)
 	{
@@ -1326,6 +1317,12 @@
 	// [Paril-KEX] co-op health scale
 	G_Monster_ScaleCoopHealth(self);
 
+	// set vision cone
+	if (!st.was_key_specified("vision_cone"))
+	{
+		self->vision_cone = -2.0f; // special value to use old algorithm
+	}
+
 	return true;
 }
 
@@ -1341,7 +1338,7 @@
 
 	self->s.origin = check;
 
-	if (result == stuck_result_t::FIXED)
+	if (result == stuck_result_t::FIXED && developer->integer)
 		gi.Com_PrintFmt("fixed stuck {}\n", *self);
 
 	return result;
@@ -1569,7 +1566,7 @@
 void walkmonster_start(edict_t *self)
 {
 	self->think = walkmonster_start_go;
-	monster_start(self);
+	monster_start(self, ED_GetSpawnTemp());
 }
 
 THINK(flymonster_start_go) (edict_t *self) -> void
@@ -1587,7 +1584,7 @@
 {
 	self->flags |= FL_FLY;
 	self->think = flymonster_start_go;
-	monster_start(self);
+	monster_start(self, ED_GetSpawnTemp());
 }
 
 THINK(swimmonster_start_go) (edict_t *self) -> void
@@ -1605,7 +1602,7 @@
 {
 	self->flags |= FL_SWIM;
 	self->think = swimmonster_start_go;
-	monster_start(self);
+	monster_start(self, ED_GetSpawnTemp());
 }
 
 USE(trigger_health_relay_use) (edict_t *self, edict_t *other, edict_t *activator) -> void
--- a/g_phys.cpp	2023-10-03 19:43:06
+++ b/g_phys.cpp	2024-07-07 03:52:24
@@ -52,6 +52,9 @@
 	if ((ent->svflags & (SVF_MONSTER | SVF_PLAYER)) && (ent->svflags & SVF_DEADMONSTER))
 		mask &= ~(CONTENTS_MONSTER | CONTENTS_PLAYER);
 
+	// remove special mask value
+	mask &= ~CONTENTS_AREAPORTAL;
+
 	return mask;
 }
 
@@ -179,6 +182,9 @@
 */
 void SV_AddGravity(edict_t *ent)
 {
+	if (ent->no_gravity_time > level.time)
+		return;
+
 	ent->velocity += ent->gravityVector * (ent->gravity * level.gravity * gi.frame_time_s);
 }
 
@@ -281,6 +287,10 @@
 	pusher->s.origin += move;
 	pusher->s.angles += amove;
 	gi.linkentity(pusher);
+
+	// no clip mask, so it won't move anything
+	if (!G_GetClipMask(pusher))
+		return true;
 
 	// see if any solid entities are inside the final position
 	check = g_edicts + 1;
@@ -415,7 +425,7 @@
 void SV_Physics_Pusher(edict_t *ent)
 {
 	vec3_t	 move, amove;
-	edict_t *part, *mv;
+	edict_t *part;
 
 	// if not a team captain, so movement will be handled elsewhere
 	if (ent->flags & FL_TEAMSLAVE)
@@ -741,8 +751,11 @@
 	edict_t	*groundentity;
 	contents_t mask = G_GetClipMask(ent);
 
+	// [Paril-KEX]
+	if (ent->no_gravity_time > level.time)
+		ent->groundentity = nullptr;
 	// airborne monsters should always check for ground
-	if (!ent->groundentity)
+	else if (!ent->groundentity)
 		M_CheckGround(ent, mask);
 
 	groundentity = ent->groundentity;
@@ -799,7 +812,7 @@
 		ent->velocity[2] *= newspeed;
 	}
 
-	if (ent->velocity[2] || ent->velocity[1] || ent->velocity[0])
+	if (ent->velocity[2] || ent->velocity[1] || ent->velocity[0] || ent->no_gravity_time > level.time)
 	{
 		// apply friction
 		if ((wasonground || (ent->flags & (FL_SWIM | FL_FLY))) && !(ent->monsterinfo.aiflags & AI_ALTERNATE_FLY))
--- a/g_save.cpp	2023-10-03 19:43:06
+++ b/g_save.cpp	2024-10-22 19:28:35
@@ -22,7 +22,6 @@
 // - backwards & forwards compatible with this same format
 // - I wrote this initially when the codebase was in C, so it
 //   does have some C-isms in here.
-constexpr size_t SAVE_FORMAT_VERSION = 1;
 
 #include <unordered_map>
 
@@ -105,6 +104,26 @@
 		list_str_hash.emplace(link->name, link);
 		list_from_ptr_hash.emplace(std::make_tuple(link->ptr, link->tag), link);
 	}
+
+#ifdef _DEBUG
+	// verify integrity of mmove_t's; ideally this would be done
+	// at compile time but it complicates the code a bit
+	for (const save_data_list_t *link = list_head; link; link = link->next)
+	{
+		if (link->tag == SAVE_DATA_MMOVE)
+		{
+			// mmove_t integrity check
+			const mmove_t *move = reinterpret_cast<const mmove_t *>(link->ptr);
+			size_t defined_frames = (move->lastframe - move->firstframe + 1);
+
+			if (defined_frames != move->framecount)
+			{
+				gi.Com_ErrorFmt("monster move {} has mismatched frame counts (defined as {} frames, but array has {} elements)",
+					link->name, defined_frames, move->framecount);
+			}
+		}
+	}
+#endif
 
 	save_data_initialized = true;
 }
@@ -223,6 +242,12 @@
 
 	void (*read)(void *data, const Json::Value &json, const char *field) = nullptr; // for custom reading
 	bool (*write)(const void *data, bool null_for_empty, Json::Value &output) = nullptr; // for custom writing
+};
+
+constexpr size_t SAVE_FORMAT_VERSION = 2;
+
+constexpr save_type_t save_version_type = {
+	ST_UINT32
 };
 
 struct save_field_t
@@ -738,7 +763,11 @@
 	FIELD_AUTO(health_bar_entities),
 	FIELD_AUTO(intermission_server_frame),
 	FIELD_AUTO(story_active),
-	FIELD_AUTO(next_auto_save)
+	FIELD_AUTO(next_auto_save),
+	FIELD_LEVEL_STRING(primary_objective_string),
+	FIELD_LEVEL_STRING(secondary_objective_string),
+	FIELD_LEVEL_STRING(primary_objective_title),
+	FIELD_LEVEL_STRING(secondary_objective_title)
 SAVE_STRUCT_END
 #undef DECLARE_SAVE_STRUCT
 
@@ -966,6 +995,8 @@
 	FIELD_AUTO(s.alpha),
 	FIELD_AUTO(s.scale),
 	FIELD_AUTO(s.instance_bits),
+	FIELD_AUTO(s.loop_volume),
+	FIELD_AUTO(s.loop_attenuation),
 
 	// server stuff
 	// client is auto-set
@@ -1095,6 +1126,7 @@
 
 	FIELD_AUTO(item),
 	FIELD_AUTO(crosslevel_flags),
+	FIELD_AUTO(no_gravity_time),
 
 	// moveinfo_t
 	FIELD_AUTO(moveinfo.start_origin),
@@ -1193,6 +1225,7 @@
 	FIELD_AUTO(monsterinfo.jump_height),
 	FIELD_AUTO(monsterinfo.blind_fire_delay),
 	FIELD_AUTO(monsterinfo.blind_fire_target),
+	FIELD_AUTO(monsterinfo.slots_from_commander),
 	FIELD_AUTO(monsterinfo.monster_slots),
 	FIELD_AUTO(monsterinfo.monster_used),
 	FIELD_AUTO(monsterinfo.commander),
@@ -1302,6 +1335,8 @@
 	
 	FIELD_AUTO( lastMOD.id ),
 	FIELD_AUTO( lastMOD.friendly_fire ),
+
+	FIELD_AUTO(vision_cone),
 
 SAVE_STRUCT_END
 #undef DECLARE_SAVE_STRUCT
@@ -2420,6 +2455,10 @@
 
 void G_PrecacheInventoryItems();
 
+static void upgrade_client(gclient_t *client, const Json::Value &json, const uint32_t &save_version)
+{
+}
+
 // new entry point for ReadGame.
 // takes in pointer to JSON data. does
 // not store or modify it.
@@ -2431,6 +2470,10 @@
 
 	uint32_t max_entities = game.maxentities;
 	uint32_t max_clients = game.maxclients;
+
+	// pull version
+	uint32_t save_version;
+	read_save_type_json(json["save_version"], &save_version, &save_version_type, "save_version");
 	
 	game = {};
 	g_edicts = (edict_t *) gi.TagMalloc(max_entities * sizeof(g_edicts[0]), TAG_GAME);
@@ -2455,8 +2498,10 @@
 	for (auto &v : clients)
 	{
 		json_push_stack(fmt::format("clients[{}]", i));
-		read_save_struct_json(v, &game.clients[i++], &gclient_t_savestruct);
+		read_save_struct_json(v, &game.clients[i], &gclient_t_savestruct);
+		upgrade_client(&game.clients[i], v, save_version);
 		json_pop_stack();
+		i++;
 	}
 
 	G_PrecacheInventoryItems();
@@ -2506,6 +2551,24 @@
 	return saveJson(json, out_size);
 }
 
+static void upgrade_edict(edict_t *ent, const Json::Value &json, const uint32_t &save_version)
+{
+	// 1 -> 2
+	if (save_version <= 1)
+	{
+		// func_plat2 gained "wait" key.
+		// used to be hardcoded to 2.0f
+		if (ent->classname && !strcmp(ent->classname, "func_plat2"))
+		{
+			ent->wait = 2.0f;
+		}
+	}
+}
+
+static void upgrade_level(const Json::Value &json, const uint32_t &save_version)
+{
+}
+
 // new entry point for ReadLevel.
 // takes in pointer to JSON data. does
 // not store or modify it.
@@ -2521,9 +2584,14 @@
 	memset(g_edicts, 0, game.maxentities * sizeof(g_edicts[0]));
 	globals.num_edicts = game.maxclients + 1;
 
+	// pull version
+	uint32_t save_version;
+	read_save_type_json(json["save_version"], &save_version, &save_version_type, "save_version");
+
 	// read level
 	json_push_stack("level");
 	read_save_struct_json(json["level"], &level, &level_locals_t_savestruct);
+	upgrade_level(json["level"], save_version);
 	json_pop_stack();
 
 	// read entities
@@ -2532,13 +2600,11 @@
 	if (!entities.isObject())
 		gi.Com_Error("expected \"entities\" to be object");
 
-	//for (auto key : json.getMemberNames())
 	for (auto it = entities.begin(); it != entities.end(); it++)
 	{
-		//const char		   *classname = key.c_str();
 		const char *dummy;
 		const char *id = it.memberName(&dummy);
-		const Json::Value  &value = *it;//json[key];
+		const Json::Value  &value = *it;
 		uint32_t		   number = strtoul(id, nullptr, 10);
 
 		if (number >= globals.num_edicts)
@@ -2548,6 +2614,7 @@
 		G_InitEdict(ent);
 		json_push_stack(fmt::format("entities[{}]", number));
 		read_save_struct_json(value, ent, &edict_t_savestruct);
+		upgrade_edict(ent, value, save_version);
 		json_pop_stack();
 		gi.linkentity(ent);
 	}
--- a/g_spawn.cpp	2023-10-03 19:43:06
+++ b/g_spawn.cpp	2024-10-21 12:41:07
@@ -49,6 +49,7 @@
 void SP_trigger_fog(edict_t *self); // [Paril-KEX]
 void SP_trigger_coop_relay(edict_t *self); // [Paril-KEX]
 void SP_trigger_health_relay(edict_t *self); // [Paril-KEX]
+void SP_trigger_safe_fall(edict_t *ent); // [Paril-KEX]
 
 void SP_target_temp_entity(edict_t *ent);
 void SP_target_speaker(edict_t *ent);
@@ -259,6 +260,7 @@
 	{ "trigger_fog", SP_trigger_fog }, // [Paril-KEX]
 	{ "trigger_coop_relay", SP_trigger_coop_relay }, // [Paril-KEX]
 	{ "trigger_health_relay", SP_trigger_health_relay }, // [Paril-KEX]
+	{ "trigger_safe_fall", SP_trigger_safe_fall }, // [Paril-KEX]
 
 	{ "target_temp_entity", SP_target_temp_entity },
 	{ "target_speaker", SP_target_speaker },
@@ -437,6 +439,20 @@
 };
 // clang-format on
 
+static const spawn_temp_t *current_st;
+/*static*/ const spawn_temp_t spawn_temp_t::empty = {};
+
+const spawn_temp_t &ED_GetSpawnTemp()
+{
+	if (!current_st)
+	{
+		gi.Com_Print("WARNING: empty spawntemp accessed; this is probably a code bug.\n");
+		return spawn_temp_t::empty;
+	}
+
+	return *current_st;
+}
+
 /*
 ===============
 ED_CallSpawn
@@ -444,7 +460,7 @@
 Finds the spawn function for the entity and calls it
 ===============
 */
-void ED_CallSpawn(edict_t *ent)
+void ED_CallSpawn(edict_t *ent, const spawn_temp_t &spawntemp)
 {
 	gitem_t *item;
 	int		 i;
@@ -455,6 +471,8 @@
 		G_FreeEdict(ent);
 		return;
 	}
+
+	current_st = &spawntemp;
 
 	// PGM - do this before calling the spawn function so it can be overridden.
 	ent->gravityVector[0] = 0.0;
@@ -494,7 +512,12 @@
 				}
 			}
 
-			SpawnItem(ent, item);
+			SpawnItem(ent, item, spawntemp);
+
+			if (level.is_psx)
+				ent->s.origin[2] += 15.f - (15.f * PSX_PHYSICS_SCALAR);
+
+			current_st = nullptr;
 			return;
 		}
 	}
@@ -509,12 +532,21 @@
 			// Paril: swap classname with stored constant if we didn't change it
 			if (strcmp(ent->classname, s.name) == 0)
 				ent->classname = s.name;
+
+			current_st = nullptr;
 			return;
 		}
 	}
 
 	gi.Com_PrintFmt("{} doesn't have a spawn function\n", *ent);
 	G_FreeEdict(ent);
+	current_st = nullptr;
+}
+
+// Quick redirect to use empty spawntemp
+void  ED_CallSpawn(edict_t *ent)
+{
+	ED_CallSpawn(ent, spawn_temp_t::empty);
 }
 
 /*
@@ -745,7 +777,7 @@
 
 	// [Paril-KEX] func_eye stuff
 	FIELD_AUTO_NAMED("eye_position", move_origin),
-	FIELD_AUTO_NAMED("vision_cone", yaw_speed),
+	FIELD_AUTO(vision_cone),
 
 	// [Paril-KEX] for trigger_coop_relay
 	FIELD_AUTO_NAMED("message2", map),
@@ -840,13 +872,21 @@
 	FIELD_AUTO(start_items),
 	FIELD_AUTO(no_grapple),
 	FIELD_AUTO(health_multiplier),
+	FIELD_AUTO(physics_flags_sp),
+	FIELD_AUTO(physics_flags_dm),
 
 	FIELD_AUTO(reinforcements),
 	FIELD_AUTO(noise_start),
 	FIELD_AUTO(noise_middle),
 	FIELD_AUTO(noise_end),
 
-	FIELD_AUTO(loop_count)
+	FIELD_AUTO(loop_count),
+
+	FIELD_AUTO(primary_objective_string),
+	FIELD_AUTO(secondary_objective_string),
+
+	FIELD_AUTO(primary_objective_title),
+	FIELD_AUTO(secondary_objective_title)
 };
 // clang-format on
 
@@ -858,7 +898,7 @@
 in an edict
 ===============
 */
-void ED_ParseField(const char *key, const char *value, edict_t *ent)
+void ED_ParseField(const char *key, const char *value, edict_t *ent, spawn_temp_t &st)
 {
 	// check st first
 	for (auto &f : temp_fields)
@@ -905,14 +945,13 @@
 ed should be a properly initialized empty edict.
 ====================
 */
-const char *ED_ParseEdict(const char *data, edict_t *ent)
+const char *ED_ParseEdict(const char *data, edict_t *ent, spawn_temp_t &st)
 {
 	bool  init;
 	char  keyname[256];
 	const char *com_token;
 
 	init = false;
-	st = {};
 	
 	// go through all the dictionary pairs
 	while (1)
@@ -947,7 +986,7 @@
 			continue;
 		}
 
-		ED_ParseField(keyname, com_token, ent);
+		ED_ParseField(keyname, com_token, ent, st);
 	}
 
 	if (!init)
@@ -1134,6 +1173,8 @@
 	}
 }
 
+#include <map>
+
 /*
 ==============
 SpawnEntities
@@ -1144,6 +1185,8 @@
 */
 void SpawnEntities(const char *mapname, const char *entities, const char *spawnpoint)
 {
+	level.is_spawning = true;
+
 	// clear cached indices
 	cached_soundindex::clear_all();
 	cached_modelindex::clear_all();
@@ -1175,6 +1218,7 @@
 		Q_strlcpy(game.spawnpoint, spawnpoint, sizeof(game.spawnpoint));
 
 	level.is_n64 = strncmp(level.mapname, "q64/", 4) == 0;
+	level.is_psx = strncmp(level.mapname, "psx/", 4) == 0;
 
 	level.coop_scale_players = 0;
 	level.coop_health_scaling = clamp(g_coop_health_scaling->value, 0.f, 1.f);
@@ -1209,7 +1253,10 @@
 			ent = g_edicts;
 		else
 			ent = G_Spawn();
-		entities = ED_ParseEdict(entities, ent);
+
+		spawn_temp_t st {};
+
+		entities = ED_ParseEdict(entities, ent, st);
 
 		// remove things (except the world) from different skill levels or deathmatch
 		if (ent != g_edicts)
@@ -1232,7 +1279,8 @@
 		ent->gravityVector[1] = 0.0;
 		ent->gravityVector[2] = -1.0;
 		// PGM
-		ED_CallSpawn(ent);
+
+		ED_CallSpawn(ent, st);
 
 		ent->s.renderfx |= RF_IR_VISIBLE; // PGM
 	}
@@ -1272,6 +1320,61 @@
 	// ROGUE
 
 	setup_shadow_lights();
+
+	if (gi.cvar("g_print_spawned_entities", "0", CVAR_NOFLAGS)->integer)
+	{
+		std::map<std::string, int> entities;
+		int total_monster_health = 0;
+
+		for (size_t i = 0; i < globals.num_edicts; i++)
+		{
+			edict_t *e = &globals.edicts[i];
+
+			if (!e->inuse)
+				continue;
+			else if (!e->item && !e->monsterinfo.stand)
+				continue;
+
+			const char *cn = e->classname ? e->classname : "noclass";
+
+			if (auto f = entities.find(cn); f != entities.end())
+			{
+				f->second++;
+			}
+			else
+			{
+				entities.insert({ cn, 1 });
+			}
+
+			if (e->monsterinfo.stand)
+			{
+				total_monster_health += e->health;
+			}
+
+			if (e->item && strcmp(e->classname, e->item->classname))
+			{
+				cn = e->item->classname ? e->item->classname : "noclass";
+
+				if (auto f = entities.find(cn); f != entities.end())
+				{
+					f->second++;
+				}
+				else
+				{
+					entities.insert({ cn, 1 });
+				}
+			}
+		}
+
+		gi.Com_PrintFmt("total monster health: {}\n", total_monster_health);
+		
+		for (auto &e : entities)
+		{
+			gi.Com_PrintFmt("{}: {}\n", e.first, e.second);
+		}
+	}
+
+	level.is_spawning = false;
 }
 
 //===================================================================
@@ -1425,6 +1528,8 @@
 	ent->s.modelindex = MODELINDEX_WORLD;
 	ent->gravity = 1.0f;
 
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (st.hub_map)
 	{
 		level.hub_map = true;
@@ -1514,11 +1619,47 @@
 
 	gi.configstring(CS_MAXCLIENTS, G_Fmt("{}", game.maxclients).data());
 
-	if (level.is_n64 && !deathmatch->integer)
-	{
-		gi.configstring(CONFIG_N64_PHYSICS, "1");
-		pm_config.n64_physics = true;
-	}
+	int override_physics = gi.cvar("g_override_physics_flags", "-1", CVAR_NOFLAGS)->integer;
+
+	if (override_physics == -1)
+	{
+		if (deathmatch->integer && st.was_key_specified("physics_flags_dm"))
+			override_physics = st.physics_flags_dm;
+		else if (!deathmatch->integer && st.was_key_specified("physics_flags_sp"))
+			override_physics = st.physics_flags_sp;
+	}
+
+	if (override_physics >= 0)
+		pm_config.physics_flags = (physics_flags_t) override_physics;
+	else
+	{
+		if (level.is_n64)
+			pm_config.physics_flags |= PHYSICS_N64_MOVEMENT;
+
+		if (level.is_psx)
+			pm_config.physics_flags |= PHYSICS_PSX_MOVEMENT | PHYSICS_PSX_SCALE;
+
+		if (deathmatch->integer)
+			pm_config.physics_flags |= PHYSICS_DEATHMATCH;
+	}
+
+	gi.configstring(CONFIG_PHYSICS_FLAGS, G_Fmt("{}", (int) pm_config.physics_flags).data());
+	
+	level.primary_objective_string = "$g_primary_mission_objective";
+	level.secondary_objective_string = "$g_secondary_mission_objective";
+
+	if (st.primary_objective_string && st.primary_objective_string[0])
+		level.primary_objective_string = st.primary_objective_string;
+	if (st.secondary_objective_string && st.secondary_objective_string[0])
+		level.secondary_objective_string = st.secondary_objective_string;
+	
+	level.primary_objective_title = "$g_pc_primary_objective";
+	level.secondary_objective_title = "$g_pc_secondary_objective";
+
+	if (st.primary_objective_title && st.primary_objective_title[0])
+		level.primary_objective_title = st.primary_objective_title;
+	if (st.secondary_objective_title && st.secondary_objective_title[0])
+		level.secondary_objective_title = st.secondary_objective_title;
 
 	// statusbar prog
 	G_InitStatusbar();
@@ -1634,6 +1775,12 @@
 	gi.soundindex("player/wade2.wav");
 	gi.soundindex("player/wade3.wav");
 
+#ifdef PSX_ASSETS
+	gi.soundindex("player/breathout1.wav");
+	gi.soundindex("player/breathout2.wav");
+	gi.soundindex("player/breathout3.wav");
+#endif
+
 	gi.soundindex("items/pkup.wav");   // bonus item pickup
 	gi.soundindex("world/land.wav");   // landing thud
 	gi.soundindex("misc/h2ohit1.wav"); // landing splash
--- a/g_target.cpp	2023-10-03 19:43:06
+++ b/g_target.cpp	2024-10-07 01:57:34
@@ -70,6 +70,8 @@
 
 void SP_target_speaker(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!st.noise)
 	{
 		gi.Com_PrintFmt("{}: no noise set\n", *ent);
@@ -154,6 +156,8 @@
 */
 void SP_target_help(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{ // auto-remove for deathmatch
 		G_FreeEdict(ent);
@@ -204,6 +208,8 @@
 
 void SP_target_secret(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{ // auto-remove for deathmatch
 		G_FreeEdict(ent);
@@ -215,8 +221,9 @@
 
 	ent->use = use_target_secret;
 	if (!st.noise)
-		st.noise = "misc/secret.wav";
-	ent->noise_index = gi.soundindex(st.noise);
+		ent->noise_index = gi.soundindex("misc/secret.wav");
+	else
+		ent->noise_index = gi.soundindex(st.noise);
 	ent->svflags = SVF_NOCLIENT;
 	level.total_secrets++;
 }
@@ -285,7 +292,7 @@
 
 		if (*game.helpmessage1)
 			// [Sam-KEX] Print objective to screen
-			gi.LocClient_Print(player, PRINT_TYPEWRITER, "$g_primary_mission_objective", game.helpmessage1);
+			gi.LocClient_Print(player, PRINT_TYPEWRITER, level.primary_objective_string, game.helpmessage1);
 	}
 	
 	if (player->client->pers.game_help2changed != game.help2changed)
@@ -296,7 +303,7 @@
 
 		if (*game.helpmessage2)
 			// [Sam-KEX] Print objective to screen
-			gi.LocClient_Print(player, PRINT_TYPEWRITER, "$g_secondary_mission_objective", game.helpmessage2);
+			gi.LocClient_Print(player, PRINT_TYPEWRITER, level.secondary_objective_string, game.helpmessage2);
 	}
 }
 
@@ -336,6 +343,8 @@
 
 void SP_target_goal(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{ // auto-remove for deathmatch
 		G_FreeEdict(ent);
@@ -344,8 +353,9 @@
 
 	ent->use = use_target_goal;
 	if (!st.noise)
-		st.noise = "misc/secret.wav";
-	ent->noise_index = gi.soundindex(st.noise);
+		ent->noise_index = gi.soundindex("misc/secret.wav");
+	else
+		ent->noise_index = gi.soundindex(st.noise);
 	ent->svflags = SVF_NOCLIENT;
 	level.total_goals++;
 }
@@ -537,20 +547,16 @@
 	speed how fast it should be moving otherwise it
 	will just be dropped
 */
-void ED_CallSpawn(edict_t *ent);
 
 USE(use_target_spawner) (edict_t *self, edict_t *other, edict_t *activator) -> void
 {
-	edict_t *ent;
-
-	ent = G_Spawn();
+	edict_t *ent = G_Spawn();
 	ent->classname = self->target;
 	// RAFAEL
 	ent->flags = self->flags;
 	// RAFAEL
 	ent->s.origin = self->s.origin;
 	ent->s.angles = self->s.angles;
-	st = {};
 
 	// [Paril-KEX] although I fixed these in our maps, this is just
 	// in case anybody else does this by accident. Don't count these monsters
@@ -560,7 +566,9 @@
 	ED_CallSpawn(ent);
 	gi.linkentity(ent);
 
-	KillBox(ent, false);
+	if (ent->solid == SOLID_BBOX || (G_GetClipMask(ent) & (CONTENTS_PLAYER)))
+		KillBox(ent, false);
+
 	if (self->speed)
 		ent->velocity = self->movedir;
 
@@ -697,7 +705,12 @@
 		if (self->dmg > 0 && (tr.ent->takedamage) && !(tr.ent->flags & FL_IMMUNE_LASER) && self->damage_debounce_time <= level.time)
 		{
 			damaged_thing = true;
-			T_Damage(tr.ent, self, self->activator, self->movedir, tr.endpos, vec3_origin, self->dmg, 1, DAMAGE_ENERGY, MOD_TARGET_LASER);
+			damageflags_t dmg = DAMAGE_ENERGY;
+
+			if (self->spawnflags.has(SPAWNFLAG_LASER_NO_PROTECTION))
+				dmg |= DAMAGE_NO_PROTECTION;
+
+			T_Damage(tr.ent, self, self->activator, self->movedir, tr.endpos, vec3_origin, self->dmg, 1, dmg, MOD_TARGET_LASER);
 		}
 
 		// if we hit something that's not a monster or player or is immune to lasers, we're done
@@ -756,6 +769,9 @@
 
 	contents_t mask = self->spawnflags.has(SPAWNFLAG_LASER_STOPWINDOW) ? MASK_SHOT : (CONTENTS_SOLID | CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_DEADMONSTER);
 
+	if (!self->dmg)
+		mask &= ~(CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_DEADMONSTER);
+
 	pierce_trace(start, end, self, args, mask);
 
 	self->s.old_origin = args.tr.endpos;
@@ -814,22 +830,9 @@
 		}
 	}
 
-	if (self->spawnflags.has(SPAWNFLAG_LASER_LIGHTNING))
-	{
-		self->s.renderfx |= RF_BEAM_LIGHTNING; // tell renderer it is lightning
-
-		if (!self->s.skinnum)
-			self->s.skinnum = 0xf3f3f1f1; // default lightning color
-	}
-
-	// set the beam diameter
-	// [Paril-KEX] lab has this set prob before lightning was implemented
-	if (!level.is_n64 && self->spawnflags.has(SPAWNFLAG_LASER_FAT))
-		self->s.frame = 16;
-	else
-		self->s.frame = 4;
-
 	// set the color
+	// [Paril-KEX] moved it here so that color takes place
+	// before lightning/reactor check
 	if (!self->s.skinnum)
 	{
 		if (self->spawnflags.has(SPAWNFLAG_LASER_RED))
@@ -844,6 +847,26 @@
 			self->s.skinnum = 0xe0e1e2e3;
 	}
 
+	if (self->spawnflags.has(SPAWNFLAG_LASER_REACTOR))
+		self->spawnflags |= SPAWNFLAG_LASER_LIGHTNING;
+
+	if (self->spawnflags.has(SPAWNFLAG_LASER_LIGHTNING))
+	{
+		self->s.renderfx |= RF_BEAM_LIGHTNING; // tell renderer it is lightning
+
+		if (!self->s.skinnum)
+			self->s.skinnum = 0xf3f3f1f1; // default lightning color
+	}
+	/*
+	else if (self->spawnflags.has(SPAWNFLAG_LASER_REACTOR))
+	{
+		self->s.renderfx |= RF_BEAM_REACTOR;
+
+		if (!self->s.skinnum)
+			self->s.skinnum = 0xf3f3f1f1; // default reactor color
+	}
+	*/
+
 	if (!self->enemy)
 	{
 		if (self->target)
@@ -869,9 +892,6 @@
 	self->use = target_laser_use;
 	self->think = target_laser_think;
 
-	if (!self->dmg)
-		self->dmg = 1;
-
 	self->mins = { -8, -8, -8 };
 	self->maxs = { 8, 8, 8 };
 	gi.linkentity(self);
@@ -884,6 +904,33 @@
 
 void SP_target_laser(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
+	// set the beam diameter
+	// [Paril-KEX] lab has this set prob before lightning was implemented
+	// [Paril-KEX] moved this here because st
+	if (!st.was_key_specified("frame"))
+	{
+		if (!level.is_n64 && self->spawnflags.has(SPAWNFLAG_LASER_FAT))
+			self->s.frame = 16;
+		else
+			self->s.frame = 4;
+	}
+
+	// [Paril-KEX] upper 2 bytes of reactor laser are count
+	/*
+	if (self->spawnflags.has(SPAWNFLAG_LASER_REACTOR))
+	{
+		self->s.frame &= 0xFFFF;
+
+		self->s.frame |= (self->count << 16) & 0xFFFF0000;
+	}
+	*/
+
+	// [Paril-KEX] moved this here because st
+	if (!st.was_key_specified("dmg"))
+		self->dmg = 1;
+
 	// let everything else get spawned before we start firing
 	self->think = target_laser_start;
 	self->flags |= FL_TRAP_LASER_FIELD;
@@ -1249,17 +1296,16 @@
     self->nextthink = level.time + FRAME_TIME_S;
 }
 
-void G_SetClientFrame(edict_t *ent);
-
-extern float xyspeed;
-
 THINK(target_camera_dummy_think) (edict_t *self) -> void
 {
 	// bit of a hack, but this will let the dummy
 	// move like a player
 	self->client = self->owner->client;
-	xyspeed = sqrtf(self->velocity[0] * self->velocity[0] + self->velocity[1] * self->velocity[1]);
-	G_SetClientFrame(self);
+
+	step_parameters_t step {};
+	step.xyspeed = sqrtf(self->velocity[0] * self->velocity[0] + self->velocity[1] * self->velocity[1]);
+	G_SetClientFrame(self, step);
+
 	self->client = nullptr;
 
 	// alpha fade out for voops
@@ -1376,6 +1422,8 @@
 
 void SP_target_gravity(edict_t* self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->use = use_target_gravity;
 	self->gravity = atof(st.gravity);
 }
@@ -1397,6 +1445,8 @@
 
 void SP_target_soundfx(edict_t* self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!self->volume)
 		self->volume = 1.0;
 
@@ -1529,6 +1579,8 @@
 
 void SP_target_light(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->s.modelindex = 1;
 	self->s.renderfx = RF_CUSTOM_LIGHT;
 	self->s.frame = st.radius ? st.radius : 150;
@@ -1622,19 +1674,35 @@
 
 USE(target_poi_use) (edict_t *ent, edict_t *other, edict_t *activator) -> void
 {
+	bool debug = !!g_debug_poi->integer;
+
+	if (debug)
+		gi.Com_PrintFmt("POI {} used by {}\n", *ent, *other);
+
 	// we were disabled, so remove the disable check
 	if (ent->spawnflags.has(SPAWNFLAG_POI_DISABLED))
+	{
 		ent->spawnflags &= ~SPAWNFLAG_POI_DISABLED;
+		if (debug)
+			gi.Com_Print(" - POI was disabled, made re-enabled\n");
+	}
 
 	// early stage check
 	if (ent->count && level.current_poi_stage > ent->count)
-		return;
+	{
+		if (debug)
+			gi.Com_PrintFmt(" - POI count is {}, current stage {}, early exit\n", ent->count, level.current_poi_stage);
+		return;
+	}
 
 	// teamed POIs work a bit differently
 	if (ent->team)
 	{
 		edict_t *poi_master = ent->teammaster;
 
+		if (debug)
+			gi.Com_PrintFmt(" - teamed POI \"{}\"; master is {}\n", ent->team, *poi_master);
+
 		// unset ent, since we need to find one that matches
 		ent = nullptr;
 
@@ -1645,42 +1713,79 @@
 
 		for (edict_t *poi = poi_master; poi; poi = poi->teamchain)
 		{
+			if (debug)
+				gi.Com_PrintFmt("  - checking team member {}\n", *poi);
+
 			// currently disabled
 			if (poi->spawnflags.has(SPAWNFLAG_POI_DISABLED))
+			{
+				if (debug)
+					gi.Com_Print("  - disabled, skipping\n");
+
 				continue;
+			}
 
 			// ignore dummy POI
 			if (poi->spawnflags.has(SPAWNFLAG_POI_DUMMY))
 			{
+				if (debug)
+					gi.Com_Print("  - dummy, skipping (but storing as fallback)\n");
+
 				dummy_fallback = poi;
 				continue;
 			}
 			// POI is not part of current stage
 			else if (poi->count && level.current_poi_stage > poi->count)
+			{
+				if (debug)
+					gi.Com_PrintFmt("  - staged POI; level stage {} = POI count {}, skipping\n", level.current_poi_stage, poi->count);
+
 				continue;
 			// POI isn't the right style
+			}
 			else if (poi->style > best_style)
+			{
+				if (debug)
+					gi.Com_PrintFmt("  - style {} > current best style {}, skipping\n", poi->style, best_style);
+
 				continue;
+			}
 
 			float dist = distance_to_poi(activator->s.origin, poi->s.origin);
+
+			if (debug)
+				gi.Com_PrintFmt("  - resolved distance as {} (used for nearest)\n", dist);
 
 			// we have one already and it's farther away, don't bother
 			if (poi_master->spawnflags.has(SPAWNFLAG_POI_NEAREST) &&
 				ent &&
 				dist > best_distance)
+			{
+				if (debug)
+					gi.Com_PrintFmt("  - nearest used; distance > best distance of {}, skipping\n", best_distance);
 				continue;
+			}
 
 			// found a better style; overwrite dist
 			if (poi->style < best_style)
 			{
+				if (debug)
+					gi.Com_PrintFmt("  - style {} < current best style {} - potentially better pick\n", poi->style, best_style);
+
 				// unless we weren't reachable...
 				if (poi_master->spawnflags.has(SPAWNFLAG_POI_NEAREST) && std::isinf(dist))
+				{
+					if (debug)
+						gi.Com_Print("  - not reachable; skipped\n");
 					continue;
+				}
 
 				best_style = poi->style;
 				if (poi_master->spawnflags.has(SPAWNFLAG_POI_NEAREST))
 					best_distance = dist;
 				ent = poi;
+				if (debug)
+					gi.Com_Print("  - marked as current best due to style\n");
 				continue;
 			}
 
@@ -1691,6 +1796,8 @@
 				{
 					best_distance = dist;
 					ent = poi;
+					if (debug)
+						gi.Com_Print("  - marked as current best due to distance\n");
 					continue;
 				}
 			}
@@ -1698,6 +1805,8 @@
 			{
 				// not picking by distance, so it's order of appearance
 				ent = poi;
+				if (debug)
+					gi.Com_Print("  - marked as current best due to order of appearance\n");
 			}
 		}
 
@@ -1706,36 +1815,66 @@
 		if (!ent)
 		{
 			if (dummy_fallback && dummy_fallback->spawnflags.has(SPAWNFLAG_POI_DYNAMIC))
+			{
+				if (debug)
+					gi.Com_Print(" - no valid POI found, but we had a dummy fallback\n");
 				ent = dummy_fallback;
+			}
 			else
+			{
+				if (debug)
+					gi.Com_Print(" - no valid POI found, skipping\n");
 				return;
+			}
 		}
 
 		// copy over POI stage value
 		if (ent->count)
 		{
 			if (level.current_poi_stage <= ent->count)
+			{
 				level.current_poi_stage = ent->count;
+				if (debug)
+					gi.Com_PrintFmt(" - current POI stage set to {}\n", ent->count);
+			}
 		}
 	}
 	else
 	{
+		if (debug)
+			gi.Com_Print(" - non-teamed POI\n");
+
 		if (ent->count)
 		{
 			if (level.current_poi_stage <= ent->count)
+			{
 				level.current_poi_stage = ent->count;
+				if (debug)
+					gi.Com_PrintFmt(" - level stage {} <= POI count {}, using new stage value\n", level.current_poi_stage, ent->count);
+			}
 			else
+			{
+				if (debug)
+					gi.Com_PrintFmt(" - level stage {} <= POI count {}, not part of current stage, skipping\n", level.current_poi_stage, ent->count);
 				return; // this POI is not part of our current stage
+			}
 		}
 	}
 
 	// dummy POI; not valid
 	if (!strcmp(ent->classname, "target_poi") && ent->spawnflags.has(SPAWNFLAG_POI_DUMMY) && !ent->spawnflags.has(SPAWNFLAG_POI_DYNAMIC))
-		return;
+	{
+		if (debug)
+			gi.Com_Print(" - POI is target_poi, dummy & not dynamic; not a valid POI\n");
+		return;
+	}
 
 	level.valid_poi = true;
 	level.current_poi = ent->s.origin;
 	level.current_poi_image = ent->noise_index;
+	
+	if (debug)
+		gi.Com_Print(" - got valid POI!\n");
 
 	if (!strcmp(ent->classname, "target_poi") && ent->spawnflags.has(SPAWNFLAG_POI_DYNAMIC))
 	{
@@ -1748,11 +1887,13 @@
 			if (m->spawnflags.has(SPAWNFLAG_POI_DUMMY))
 			{
 				level.current_dynamic_poi = m;
+				if (debug)
+					gi.Com_Print(" - setting dynamic POI\n");
 				break;
 			}
 
 		if (!level.current_dynamic_poi)
-			gi.Com_PrintFmt("can't activate poi for {}; need DUMMY in chain\n", *ent);
+			gi.Com_PrintFmt("can't activate dynamic poi for {}; need DUMMY in chain\n", *ent);
 	}
 	else
 		level.current_dynamic_poi = nullptr;
@@ -1777,6 +1918,8 @@
 
 void SP_target_poi(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{ // auto-remove for deathmatch
 		G_FreeEdict(self);
@@ -1957,6 +2100,8 @@
 
 void SP_target_sky(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->use = use_target_sky;
 	if (st.was_key_specified("sky"))
 		self->map = st.sky;
@@ -2045,6 +2190,8 @@
 
 void SP_target_achievement(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{
 		G_FreeEdict(self);
--- a/g_trigger.cpp	2023-10-03 19:43:06
+++ b/g_trigger.cpp	2024-09-24 14:39:08
@@ -13,6 +13,8 @@
 
 void InitTrigger(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (st.was_key_specified("angle") || st.was_key_specified("angles") || self->s.angles)
 		G_SetMovedir(self->s.angles, self->movedir);
 
@@ -176,7 +178,12 @@
 
 void SP_trigger_multiple(edict_t *ent)
 {
-	if (ent->sounds == 1)
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
+	// [Paril-KEX] PSX
+	if (st.noise && *st.noise)
+		ent->noise_index = gi.soundindex(st.noise);
+	else if (ent->sounds == 1)
 		ent->noise_index = gi.soundindex("misc/secret.wav");
 	else if (ent->sounds == 2)
 		ent->noise_index = gi.soundindex("misc/talk.wav");
@@ -198,7 +205,7 @@
 		ent->use = Use_Multi;
 		return;
 	}
-	else
+	else if (ent->model || ent->mins || ent->maxs)
 		ent->touch = Touch_Multi;
 
 	// PGM
@@ -278,6 +285,8 @@
 
 ==============================================================================
 */
+
+constexpr spawnflags_t SPAWNFLAGS_TRIGGER_KEY_BECOME_RELAY = 1_spawnflag;
 
 /*QUAKED trigger_key (.5 .5 .5) (-8 -8 -8) (8 8 8)
 A relay trigger that only fires it's targets if player has the proper key.
@@ -362,11 +371,16 @@
 
 	G_UseTargets(self, activator);
 
-	self->use = nullptr;
+	if (self->spawnflags.has(SPAWNFLAGS_TRIGGER_KEY_BECOME_RELAY))
+		self->use = trigger_relay_use;
+	else
+		self->use = nullptr;
 }
 
 void SP_trigger_key(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!st.item)
 	{
 		gi.Com_PrintFmt("{}: no key item\n", *self);
@@ -478,6 +492,7 @@
 constexpr spawnflags_t SPAWNFLAG_PUSH_SILENT = 0x04_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_PUSH_START_OFF = 0x08_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_PUSH_CLIP = 0x10_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_PUSH_ADDITIVE = 0x20_spawnflag;
 // PGM
 
 static cached_soundindex windsound;
@@ -492,13 +507,23 @@
 			return;
 	}
 
-	if (strcmp(other->classname, "grenade") == 0)
-	{
-		other->velocity = self->movedir * (self->speed * 10);
-	}
-	else if (other->health > 0)
-	{
-		other->velocity = self->movedir * (self->speed * 10);
+	if (strcmp(other->classname, "grenade") == 0 || other->health > 0)
+	{
+		// [Paril-KEX]
+		if (self->spawnflags.has(SPAWNFLAG_PUSH_ADDITIVE))
+		{
+			vec3_t velocity_in_dir = other->velocity.scaled(self->movedir);
+			float max_speed = (self->speed * 10);
+
+			if (velocity_in_dir.normalized().dot(self->movedir) < 0 || velocity_in_dir.length() < max_speed)
+			{
+				float speed_adjust = (max_speed * gi.frame_time_s) * 2;
+				other->velocity += self->movedir * speed_adjust;
+				other->no_gravity_time = level.time + 100_ms;
+			}
+		}
+		else
+			other->velocity = self->movedir * (self->speed * 10);
 
 		if (other->client)
 		{
@@ -650,7 +675,7 @@
 ==============================================================================
 */
 
-/*QUAKED trigger_hurt (.5 .5 .5) ? START_OFF TOGGLE SILENT NO_PROTECTION SLOW NO_PLAYERS NO_MONSTERS
+/*QUAKED trigger_hurt (.5 .5 .5) ? START_OFF TOGGLE SILENT NO_PROTECTION SLOW NO_PLAYERS NO_MONSTERS PASSIVE
 Any entity that touches this will be hurt.
 
 It does dmg points of damage each server frame
@@ -671,6 +696,7 @@
 constexpr spawnflags_t SPAWNFLAG_HURT_NO_PLAYERS = 32_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_HURT_NO_MONSTERS = 64_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_HURT_CLIPPED = 128_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_HURT_PASSIVE = 16_spawnflag_bit;
 
 USE(hurt_use) (edict_t *self, edict_t *other, edict_t *activator) -> void
 {
@@ -682,12 +708,87 @@
 
 	if (!(self->spawnflags & SPAWNFLAG_HURT_TOGGLE))
 		self->use = nullptr;
+
+	if (self->spawnflags.has(SPAWNFLAG_HURT_PASSIVE))
+	{
+		if (self->solid == SOLID_TRIGGER)
+		{
+			if (self->spawnflags.has(SPAWNFLAG_HURT_SLOW))
+				self->nextthink = level.time + 1_sec;
+			else
+				self->nextthink = level.time + 10_hz;
+		}
+		else
+			self->nextthink = 0_ms;
+	}
+}
+
+struct hurt_filter_data_t
+{
+	edict_t *self;
+	std::vector<edict_t *> hurt;
+};
+
+static BoxEdictsResult_t hurt_filter(edict_t *other, void *self_ptr)
+{
+	hurt_filter_data_t *data = (hurt_filter_data_t *) self_ptr;
+	edict_t *self = data->self;
+
+	if (!other->takedamage)
+		return BoxEdictsResult_t::Skip;
+	else if (!(other->svflags & SVF_MONSTER) && !(other->flags & FL_DAMAGEABLE) && (!other->client) && (strcmp(other->classname, "misc_explobox") != 0))
+		return BoxEdictsResult_t::Skip;
+	else if (self->spawnflags.has(SPAWNFLAG_HURT_NO_MONSTERS) && (other->svflags & SVF_MONSTER))
+		return BoxEdictsResult_t::Skip;
+	else if (self->spawnflags.has(SPAWNFLAG_HURT_NO_PLAYERS) && (other->client))
+		return BoxEdictsResult_t::Skip;
+
+	if (self->spawnflags.has(SPAWNFLAG_HURT_CLIPPED))
+	{
+		trace_t clip = gi.clip(self, other->s.origin, other->mins, other->maxs, other->s.origin, G_GetClipMask(other));
+
+		if (clip.fraction == 1.0f)
+			return BoxEdictsResult_t::Skip;
+	}
+
+	data->hurt.push_back(other);
+	return BoxEdictsResult_t::Skip;
+}
+
+THINK(hurt_think) (edict_t *self) -> void
+{
+	hurt_filter_data_t data { self };
+	gi.BoxEdicts(self->absmin, self->absmax, nullptr, 0, AREA_SOLID, hurt_filter, &data);
+	
+	damageflags_t dflags;
+
+	if (self->spawnflags.has(SPAWNFLAG_HURT_NO_PROTECTION))
+		dflags = DAMAGE_NO_PROTECTION;
+	else
+		dflags = DAMAGE_NONE;
+
+	for (auto &other : data.hurt)
+	{
+		if (!(self->spawnflags & SPAWNFLAG_HURT_SILENT))
+		{
+			if (self->fly_sound_debounce_time < level.time)
+			{
+				gi.sound(other, CHAN_AUTO, self->noise_index, 1, ATTN_NORM, 0);
+				self->fly_sound_debounce_time = level.time + 1_sec;
+			}
+		}
+
+		T_Damage(other, self, self, vec3_origin, other->s.origin, vec3_origin, self->dmg, self->dmg, dflags, MOD_TRIGGER_HURT);
+	}
+
+	if (self->spawnflags.has(SPAWNFLAG_HURT_SLOW))
+		self->nextthink = level.time + 1_sec;
+	else
+		self->nextthink = level.time + 10_hz;
 }
 
 TOUCH(hurt_touch) (edict_t *self, edict_t *other, const trace_t &tr, bool other_touching_self) -> void
 {
-	damageflags_t dflags;
-
 	if (!other->takedamage)
 		return;
 	else if (!(other->svflags & SVF_MONSTER) && !(other->flags & FL_DAMAGEABLE) && (!other->client) && (strcmp(other->classname, "misc_explobox") != 0))
@@ -722,6 +823,8 @@
 		}
 	}
 
+	damageflags_t dflags;
+
 	if (self->spawnflags.has(SPAWNFLAG_HURT_NO_PROTECTION))
 		dflags = DAMAGE_NO_PROTECTION;
 	else
@@ -735,7 +838,21 @@
 	InitTrigger(self);
 
 	self->noise_index = gi.soundindex("world/electro.wav");
-	self->touch = hurt_touch;
+
+	if (self->spawnflags.has(SPAWNFLAG_HURT_PASSIVE))
+	{
+		self->think = hurt_think;
+
+		if (!self->spawnflags.has(SPAWNFLAG_HURT_START_OFF))
+		{
+			if (self->spawnflags.has(SPAWNFLAG_HURT_SLOW))
+				self->nextthink = level.time + 1_sec;
+			else
+				self->nextthink = level.time + 10_hz;
+		}
+	}
+	else
+		self->touch = hurt_touch;
 
 	if (!self->dmg)
 		self->dmg = 5;
@@ -800,6 +917,8 @@
 
 void SP_trigger_gravity(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!st.gravity || !*st.gravity)
 	{
 		gi.Com_PrintFmt("{}: no gravity set\n", *self);
@@ -890,15 +1009,18 @@
 
 void SP_trigger_monsterjump(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!self->speed)
 		self->speed = 200;
-	if (!st.height)
-		st.height = 200;
+	float height = st.height;
+	if (!height)
+		height = 200;
 	if (self->s.angles[YAW] == 0)
 		self->s.angles[YAW] = 360;
 	InitTrigger(self);
 	self->touch = trigger_monsterjump_touch;
-	self->movedir[2] = (float) st.height;
+	self->movedir[2] = height;
 
 	if (self->spawnflags.has(SPAWNFLAG_MONSTERJUMP_TOGGLE))
 		self->use = trigger_monsterjump_use;
@@ -961,11 +1083,13 @@
 
 void SP_trigger_flashlight(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (self->s.angles[YAW] == 0)
 		self->s.angles[YAW] = 360;
 	InitTrigger(self);
 	self->touch = trigger_flashlight_touch;
-	self->movedir[2] = (float) st.height;
+	self->movedir[2] = st.height;
 
 	if (self->spawnflags.has(SPAWNFLAG_FLASHLIGHT_CLIPPED))
 		self->svflags |= SVF_HULL;
@@ -1331,3 +1455,25 @@
 	self->svflags |= SVF_NOCLIENT;
 	gi.linkentity(self);
 }
+
+/*QUAKED trigger_safe_fall (.5 .5 .5) ?
+Players that touch this trigger are granted one (1)
+free safe fall damage exemption.
+
+They must already be in the air to get this ability.
+*/
+
+TOUCH(trigger_safe_fall_touch) (edict_t *self, edict_t *other, const trace_t &tr, bool other_touching_self) -> void
+{
+	if (other->client && !other->groundentity)
+		other->client->landmark_free_fall = true;
+}
+
+void SP_trigger_safe_fall(edict_t *self)
+{
+	InitTrigger(self);
+	self->touch = trigger_safe_fall_touch;
+	self->svflags |= SVF_NOCLIENT;
+	self->solid = SOLID_TRIGGER;
+	gi.linkentity(self);
+}
--- a/g_turret.cpp	2023-10-03 19:43:06
+++ b/g_turret.cpp	2024-09-25 12:50:12
@@ -217,6 +217,8 @@
 
 void SP_turret_breach(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->solid = SOLID_BSP;
 	self->movetype = MOVETYPE_PUSH;
 
@@ -230,17 +232,21 @@
 	if (!self->dmg)
 		self->dmg = 10;
 
-	if (!st.minpitch)
-		st.minpitch = -30;
-	if (!st.maxpitch)
-		st.maxpitch = 30;
-	if (!st.maxyaw)
-		st.maxyaw = 360;
-
-	self->pos1[PITCH] = -1 * st.minpitch;
+	float minpitch = st.minpitch;
+	float maxpitch = st.maxpitch;
+	float maxyaw = st.maxyaw;
+
+	if (!minpitch)
+		minpitch = -30;
+	if (!maxpitch)
+		maxpitch = 30;
+	if (!maxyaw)
+		maxyaw = 360;
+
+	self->pos1[PITCH] = -1 * minpitch;
 	self->pos1[YAW] = st.minyaw;
-	self->pos2[PITCH] = -1 * st.maxpitch;
-	self->pos2[YAW] = st.maxyaw;
+	self->pos2[PITCH] = -1 * maxpitch;
+	self->pos2[YAW] = maxyaw;
 
 	// scale used for rocket scale
 	self->dmg_radius = self->s.scale;
@@ -263,6 +269,8 @@
 
 void SP_turret_base(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->solid = SOLID_BSP;
 	self->movetype = MOVETYPE_PUSH;
 
@@ -310,6 +318,7 @@
 		self->movetype = MOVETYPE_STEP;
 
 		self->think = monster_think;
+		self->classname = "monster_infantry"; // [Paril-KEX] fix revive
 	}
 
 	infantry_die(self, inflictor, attacker, damage, point, mod);
@@ -412,6 +421,8 @@
 
 void SP_turret_driver(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{
 		G_FreeEdict(self);
--- a/g_utils.cpp	2023-10-03 19:43:06
+++ b/g_utils.cpp	2024-07-07 03:52:24
@@ -508,7 +508,7 @@
 	return BoxEdictsResult_t::Keep;
 }
 
-bool KillBox(edict_t *ent, bool from_spawning, mod_id_t mod, bool bsp_clipping)
+bool KillBox(edict_t *ent, bool from_spawning, mod_id_t mod, bool bsp_clipping, bool allow_safety)
 {
 	// don't telefrag as spectator...
 	if (ent->movetype == MOVETYPE_NOCLIP)
@@ -555,6 +555,9 @@
 			continue;
 		}
 
+		if (allow_safety && G_FixStuckObject(hit, hit->s.origin) != stuck_result_t::NO_GOOD_POSITION)
+			continue;
+
 		T_Damage(hit, ent, ent, vec3_origin, ent->s.origin, vec3_origin, 100000, 0, DAMAGE_NO_PROTECTION, mod);
 	}
 
--- a/g_weapon.cpp	2023-10-03 19:43:06
+++ b/g_weapon.cpp	2024-09-26 12:37:28
@@ -379,7 +379,7 @@
 	G_FreeEdict(self);
 }
 
-void fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed, effects_t effect, mod_t mod)
+edict_t *fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed, effects_t effect, mod_t mod)
 {
 	edict_t *bolt;
 	trace_t	 tr;
@@ -415,6 +415,8 @@
 		bolt->s.origin = tr.endpos + (tr.plane.normal * 1.f);
 		bolt->touch(bolt, tr.ent, tr, false);
 	}
+
+	return bolt;
 }
 
 constexpr spawnflags_t SPAWNFLAG_GRENADE_HAND = 1_spawnflag;
@@ -425,7 +427,7 @@
 fire_grenade
 =================
 */
-THINK(Grenade_Explode) (edict_t *ent) -> void
+static void Grenade_ExplodeReal(edict_t *ent, edict_t *other, vec3_t normal)
 {
 	vec3_t origin;
 	mod_t  mod;
@@ -434,22 +436,14 @@
 		PlayerNoise(ent->owner, ent->s.origin, PNOISE_IMPACT);
 
 	// FIXME: if we are onground then raise our Z just a bit since we are a point?
-	if (ent->enemy)
-	{
-		float  points;
-		vec3_t v;
-		vec3_t dir;
-
-		v = ent->enemy->mins + ent->enemy->maxs;
-		v = ent->enemy->s.origin + (v * 0.5f);
-		v = ent->s.origin - v;
-		points = ent->dmg - 0.5f * v.length();
-		dir = ent->enemy->s.origin - ent->s.origin;
+	if (other)
+	{
+		vec3_t dir = other->s.origin - ent->s.origin;
 		if (ent->spawnflags.has(SPAWNFLAG_GRENADE_HAND))
 			mod = MOD_HANDGRENADE;
 		else
 			mod = MOD_GRENADE;
-		T_Damage(ent->enemy, ent, ent->owner, dir, ent->s.origin, vec3_origin, (int) points, (int) points, DAMAGE_RADIUS, mod);
+		T_Damage(other, ent, ent->owner, dir, ent->s.origin, normal, ent->dmg, ent->dmg, mod.id == MOD_HANDGRENADE ? DAMAGE_RADIUS : DAMAGE_NONE, mod);
 	}
 
 	if (ent->spawnflags.has(SPAWNFLAG_GRENADE_HELD))
@@ -458,9 +452,9 @@
 		mod = MOD_HG_SPLASH;
 	else
 		mod = MOD_G_SPLASH;
-	T_RadiusDamage(ent, ent->owner, (float) ent->dmg, ent->enemy, ent->dmg_radius, DAMAGE_NONE, mod);
-
-	origin = ent->s.origin + (ent->velocity * -0.02f);
+	T_RadiusDamage(ent, ent->owner, (float) ent->dmg, other, ent->dmg_radius, DAMAGE_NONE, mod);
+
+	origin = ent->s.origin + normal;
 	gi.WriteByte(svc_temp_entity);
 	if (ent->waterlevel)
 	{
@@ -480,6 +474,11 @@
 	gi.multicast(ent->s.origin, MULTICAST_PHS, false);
 
 	G_FreeEdict(ent);
+}
+
+THINK(Grenade_Explode) (edict_t *ent) -> void
+{
+	Grenade_ExplodeReal(ent, nullptr, ent->velocity * -0.02f);
 }
 
 TOUCH(Grenade_Touch) (edict_t *ent, edict_t *other, const trace_t &tr, bool other_touching_self) -> void
@@ -509,8 +508,7 @@
 		return;
 	}
 
-	ent->enemy = other;
-	Grenade_Explode(ent);
+	Grenade_ExplodeReal(ent, other, tr.plane.normal);
 }
 
 THINK(Grenade4_Think) (edict_t *self) -> void
@@ -669,7 +667,7 @@
 
 	if (other->takedamage)
 	{
-		T_Damage(other, ent, ent->owner, ent->velocity, ent->s.origin, tr.plane.normal, ent->dmg, 0, DAMAGE_NONE, MOD_ROCKET);
+		T_Damage(other, ent, ent->owner, ent->velocity, ent->s.origin, tr.plane.normal, ent->dmg, ent->dmg, DAMAGE_NONE, MOD_ROCKET);
 	}
 	else
 	{
@@ -832,7 +830,7 @@
 fire_rail
 =================
 */
-void fire_rail(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick)
+bool fire_rail(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick)
 {
 	fire_rail_pierce_t args = {
 		self,
@@ -872,6 +870,8 @@
 
 	if (self->client)
 		PlayerNoise(self, args.tr.endpos, PNOISE_IMPACT);
+
+	return args.num_pierced;
 }
 
 static vec3_t bfg_laser_pos(vec3_t p, float dist)
@@ -904,7 +904,7 @@
 static void bfg_spawn_laser(edict_t *self)
 {
 	vec3_t end = bfg_laser_pos(self->s.origin, 256);
-	trace_t tr = gi.traceline(self->s.origin, end, self, MASK_OPAQUE);
+	trace_t tr = gi.traceline(self->s.origin, end, self, MASK_OPAQUE | CONTENTS_PROJECTILECLIP);
 
 	if (tr.fraction == 1.0f)
 		return;
@@ -1053,10 +1053,10 @@
 			gi.WriteByte(svc_temp_entity);
 			gi.WriteByte(TE_LASER_SPARKS);
 			gi.WriteByte(4);
-			gi.WritePosition(tr.endpos);
+			gi.WritePosition(tr.endpos + tr.plane.normal);
 			gi.WriteDir(tr.plane.normal);
-			gi.WriteByte(self->s.skinnum);
-			gi.multicast(tr.endpos, MULTICAST_PVS, false);
+			gi.WriteByte(208);
+			gi.multicast(tr.endpos + tr.plane.normal, MULTICAST_PVS, false);
 			return false;
 		}
 
@@ -1114,10 +1114,12 @@
 		end = start + (dir * 2048);
 
 		// [Paril-KEX] don't fire a laser if we're blocked by the world
-		tr = gi.traceline(start, point, nullptr, MASK_SOLID);
+		tr = gi.traceline(start, point, nullptr, CONTENTS_SOLID | CONTENTS_PROJECTILECLIP);
 
 		if (tr.fraction < 1.0f)
 			continue;
+
+		tr = gi.traceline(start, end, nullptr, CONTENTS_SOLID | CONTENTS_PROJECTILECLIP);
 
 		bfg_laser_pierce_t args {
 			self,
@@ -1125,7 +1127,7 @@
 			dmg
 		};
 		
-		pierce_trace(start, end, self, args, CONTENTS_SOLID | CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_DEADMONSTER);
+		pierce_trace(start, end, self, args, CONTENTS_SOLID | CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_DEADMONSTER | CONTENTS_PROJECTILECLIP);
 
 		gi.WriteByte(svc_temp_entity);
 		gi.WriteByte(TE_BFG_LASER);
--- a/game.h	2023-10-03 19:43:06
+++ b/game.h	2024-10-03 07:15:46
@@ -19,8 +19,12 @@
     using gvec3_t = float[3];
     using gvec3_ptr_t = gvec3_t;
     using gvec3_ref_t = gvec3_t;
-    using gvec3_cref_t = const gvec3_t;
-    using gvec3_cptr_t = const gvec3_t;
+    // FIXME: MSVC bug
+    //using gvec3_cref_t = const gvec3_t;
+    typedef const gvec3_t gvec3_cref_t;
+    // FIXME: MSVC bug
+    //using gvec3_cptr_t = const gvec3_t;
+    typedef const gvec3_t gvec3_cptr_t;
     using gvec4_t = float[4];
 #endif
     
@@ -388,6 +392,7 @@
     PMF_NO_ANGULAR_PREDICTION = bit_v<8>, // temporary disables angular prediction
     PMF_IGNORE_PLAYER_COLLISION = bit_v<9>, // don't collide with other players
     PMF_TIME_TRICK = bit_v<10>, // pm_time is trick jump time
+    PMF_NO_GROUND_SEEK = bit_v<11>, // temporarily disable ground seeking
 };
 
 MAKE_ENUM_BITFLAGS(pmflags_t);
@@ -612,6 +617,7 @@
 MAKE_ENUM_BITFLAGS(renderfx_t);
 
 constexpr renderfx_t RF_BEAM_LIGHTNING = RF_BEAM | RF_GLOW; // [Paril-KEX] make a lightning bolt instead of a laser
+//constexpr renderfx_t RF_BEAM_REACTOR = RF_BEAM | RF_USE_DISGUISE; // [Paril-KEX] make reactor FX, like PSX version
 
 MAKE_ENUM_BITFLAGS(refdef_flags_t);
 
--- a/game.sln	2023-10-03 19:43:06
+++ /dev/null
@@ -1,25 +0,0 @@
-﻿
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio Version 17
-VisualStudioVersion = 17.7.33808.371
-MinimumVisualStudioVersion = 10.0.40219.1
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "game", "game.vcxproj", "{C994B5EA-3058-403C-953D-3673C2C4D64E}"
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|x64 = Debug|x64
-		Release|x64 = Release|x64
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{C994B5EA-3058-403C-953D-3673C2C4D64E}.Debug|x64.ActiveCfg = Debug|x64
-		{C994B5EA-3058-403C-953D-3673C2C4D64E}.Debug|x64.Build.0 = Debug|x64
-		{C994B5EA-3058-403C-953D-3673C2C4D64E}.Release|x64.ActiveCfg = Release|x64
-		{C994B5EA-3058-403C-953D-3673C2C4D64E}.Release|x64.Build.0 = Release|x64
-	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
-	GlobalSection(ExtensibilityGlobals) = postSolution
-		SolutionGuid = {5E7547B5-6A49-45CD-97AA-956B8460495D}
-	EndGlobalSection
-EndGlobal
--- a/game.vcxproj	2023-10-03 19:43:06
+++ /dev/null
@@ -1,246 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <VCProjectVersion>16.0</VCProjectVersion>
-    <Keyword>Win32Proj</Keyword>
-    <ProjectGuid>{c994b5ea-3058-403c-953d-3673c2c4d64e}</ProjectGuid>
-    <RootNamespace>game</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v143</PlatformToolset>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseDebugLibraries>false</UseDebugLibraries>
-    <PlatformToolset>v143</PlatformToolset>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Label="Shared">
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <OutDir>../</OutDir>
-    <TargetName>$(ProjectName)_x64</TargetName>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <OutDir>../</OutDir>
-    <TargetName>$(ProjectName)_x64</TargetName>
-  </PropertyGroup>
-  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <VcpkgUseStatic>true</VcpkgUseStatic>
-  </PropertyGroup>
-  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <VcpkgUseStatic>true</VcpkgUseStatic>
-  </PropertyGroup>
-  <PropertyGroup Label="Vcpkg">
-    <VcpkgEnableManifest>true</VcpkgEnableManifest>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <SDLCheck>true</SDLCheck>
-      <PreprocessorDefinitions>KEX_Q2_GAME;KEX_Q2GAME_EXPORTS;NO_FMT_SOURCE;KEX_Q2GAME_DYNAMIC;_CRT_SECURE_NO_WARNINGS;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <ConformanceMode>true</ConformanceMode>
-      <LanguageStandard>stdcpp17</LanguageStandard>
-      <DisableSpecificWarnings>4267;4244</DisableSpecificWarnings>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-    </ClCompile>
-    <Link>
-      <SubSystem>NotSet</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <SDLCheck>true</SDLCheck>
-      <PreprocessorDefinitions>KEX_Q2_GAME;KEX_Q2GAME_EXPORTS;NO_FMT_SOURCE;KEX_Q2GAME_DYNAMIC;_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <ConformanceMode>true</ConformanceMode>
-      <LanguageStandard>stdcpp17</LanguageStandard>
-      <DisableSpecificWarnings>4267;4244</DisableSpecificWarnings>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-    </ClCompile>
-    <Link>
-      <SubSystem>NotSet</SubSystem>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <OptimizeReferences>true</OptimizeReferences>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClInclude Include="bg_local.h" />
-    <ClInclude Include="bots\bot_debug.h" />
-    <ClInclude Include="bots\bot_exports.h" />
-    <ClInclude Include="bots\bot_includes.h" />
-    <ClInclude Include="bots\bot_think.h" />
-    <ClInclude Include="bots\bot_utils.h" />
-    <ClInclude Include="cg_local.h" />
-    <ClInclude Include="ctf\g_ctf.h" />
-    <ClInclude Include="ctf\p_ctf_menu.h" />
-    <ClInclude Include="game.h" />
-    <ClInclude Include="g_local.h" />
-    <ClInclude Include="g_statusbar.h" />
-    <ClInclude Include="m_actor.h" />
-    <ClInclude Include="m_arachnid.h" />
-    <ClInclude Include="m_berserk.h" />
-    <ClInclude Include="m_boss2.h" />
-    <ClInclude Include="m_boss31.h" />
-    <ClInclude Include="m_boss32.h" />
-    <ClInclude Include="m_brain.h" />
-    <ClInclude Include="m_chick.h" />
-    <ClInclude Include="m_flash.h" />
-    <ClInclude Include="m_flipper.h" />
-    <ClInclude Include="m_float.h" />
-    <ClInclude Include="m_flyer.h" />
-    <ClInclude Include="m_gladiator.h" />
-    <ClInclude Include="m_guardian.h" />
-    <ClInclude Include="m_gunner.h" />
-    <ClInclude Include="m_hover.h" />
-    <ClInclude Include="m_infantry.h" />
-    <ClInclude Include="m_insane.h" />
-    <ClInclude Include="m_medic.h" />
-    <ClInclude Include="m_mutant.h" />
-    <ClInclude Include="m_parasite.h" />
-    <ClInclude Include="m_player.h" />
-    <ClInclude Include="m_rider.h" />
-    <ClInclude Include="m_shambler.h" />
-    <ClInclude Include="m_soldier.h" />
-    <ClInclude Include="m_supertank.h" />
-    <ClInclude Include="m_tank.h" />
-    <ClInclude Include="q_std.h" />
-    <ClInclude Include="q_vec3.h" />
-    <ClInclude Include="rogue\m_rogue_carrier.h" />
-    <ClInclude Include="rogue\m_rogue_stalker.h" />
-    <ClInclude Include="rogue\m_rogue_turret.h" />
-    <ClInclude Include="rogue\m_rogue_widow.h" />
-    <ClInclude Include="rogue\m_rogue_widow2.h" />
-    <ClInclude Include="xatrix\m_xatrix_fixbot.h" />
-    <ClInclude Include="xatrix\m_xatrix_gekk.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="bots\bot_debug.cpp" />
-    <ClCompile Include="bots\bot_exports.cpp" />
-    <ClCompile Include="bots\bot_think.cpp" />
-    <ClCompile Include="bots\bot_utils.cpp" />
-    <ClCompile Include="cg_main.cpp" />
-    <ClCompile Include="cg_screen.cpp" />
-    <ClCompile Include="ctf\g_ctf.cpp" />
-    <ClCompile Include="ctf\p_ctf_menu.cpp" />
-    <ClCompile Include="g_ai.cpp" />
-    <ClCompile Include="g_chase.cpp" />
-    <ClCompile Include="g_cmds.cpp" />
-    <ClCompile Include="g_combat.cpp" />
-    <ClCompile Include="g_func.cpp" />
-    <ClCompile Include="g_items.cpp" />
-    <ClCompile Include="g_main.cpp" />
-    <ClCompile Include="g_misc.cpp" />
-    <ClCompile Include="g_monster.cpp" />
-    <ClCompile Include="g_phys.cpp" />
-    <ClCompile Include="g_save.cpp" />
-    <ClCompile Include="g_spawn.cpp" />
-    <ClCompile Include="g_svcmds.cpp" />
-    <ClCompile Include="g_target.cpp" />
-    <ClCompile Include="g_trigger.cpp" />
-    <ClCompile Include="g_turret.cpp" />
-    <ClCompile Include="g_utils.cpp" />
-    <ClCompile Include="g_weapon.cpp" />
-    <ClCompile Include="m_actor.cpp" />
-    <ClCompile Include="m_arachnid.cpp" />
-    <ClCompile Include="m_berserk.cpp" />
-    <ClCompile Include="m_boss2.cpp" />
-    <ClCompile Include="m_boss3.cpp" />
-    <ClCompile Include="m_boss31.cpp" />
-    <ClCompile Include="m_boss32.cpp" />
-    <ClCompile Include="m_brain.cpp" />
-    <ClCompile Include="m_chick.cpp" />
-    <ClCompile Include="m_flipper.cpp" />
-    <ClCompile Include="m_float.cpp" />
-    <ClCompile Include="m_flyer.cpp" />
-    <ClCompile Include="m_gladiator.cpp" />
-    <ClCompile Include="m_guardian.cpp" />
-    <ClCompile Include="m_guncmdr.cpp" />
-    <ClCompile Include="m_gunner.cpp" />
-    <ClCompile Include="m_hover.cpp" />
-    <ClCompile Include="m_infantry.cpp" />
-    <ClCompile Include="m_insane.cpp" />
-    <ClCompile Include="m_medic.cpp" />
-    <ClCompile Include="m_move.cpp" />
-    <ClCompile Include="m_mutant.cpp" />
-    <ClCompile Include="m_parasite.cpp" />
-    <ClCompile Include="m_shambler.cpp" />
-    <ClCompile Include="m_soldier.cpp" />
-    <ClCompile Include="m_supertank.cpp" />
-    <ClCompile Include="m_tank.cpp" />
-    <ClCompile Include="p_client.cpp" />
-    <ClCompile Include="p_hud.cpp" />
-    <ClCompile Include="p_move.cpp" />
-    <ClCompile Include="p_trail.cpp" />
-    <ClCompile Include="p_view.cpp" />
-    <ClCompile Include="p_weapon.cpp" />
-    <ClCompile Include="q_std.cpp" />
-    <ClCompile Include="rogue\g_rogue_combat.cpp" />
-    <ClCompile Include="rogue\g_rogue_func.cpp" />
-    <ClCompile Include="rogue\g_rogue_items.cpp" />
-    <ClCompile Include="rogue\g_rogue_misc.cpp" />
-    <ClCompile Include="rogue\g_rogue_monster.cpp" />
-    <ClCompile Include="rogue\g_rogue_newai.cpp" />
-    <ClCompile Include="rogue\g_rogue_newdm.cpp" />
-    <ClCompile Include="rogue\g_rogue_newfnc.cpp" />
-    <ClCompile Include="rogue\g_rogue_newtarg.cpp" />
-    <ClCompile Include="rogue\g_rogue_newtrig.cpp" />
-    <ClCompile Include="rogue\g_rogue_newweap.cpp" />
-    <ClCompile Include="rogue\g_rogue_phys.cpp" />
-    <ClCompile Include="rogue\g_rogue_spawn.cpp" />
-    <ClCompile Include="rogue\g_rogue_sphere.cpp" />
-    <ClCompile Include="rogue\g_rogue_utils.cpp" />
-    <ClCompile Include="rogue\m_rogue_carrier.cpp" />
-    <ClCompile Include="rogue\m_rogue_stalker.cpp" />
-    <ClCompile Include="rogue\m_rogue_turret.cpp" />
-    <ClCompile Include="rogue\m_rogue_widow.cpp" />
-    <ClCompile Include="rogue\m_rogue_widow2.cpp" />
-    <ClCompile Include="rogue\p_rogue_weapon.cpp" />
-    <ClCompile Include="rogue\rogue_dm_ball.cpp" />
-    <ClCompile Include="rogue\rogue_dm_tag.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_func.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_items.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_misc.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_monster.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_target.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_weapon.cpp" />
-    <ClCompile Include="xatrix\m_xatrix_fixbot.cpp" />
-    <ClCompile Include="xatrix\m_xatrix_gekk.cpp" />
-    <ClCompile Include="xatrix\p_xatrix_weapon.cpp" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
--- a/game.vcxproj.filters	2023-10-03 19:43:06
+++ /dev/null
@@ -1,265 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <ClInclude Include="bg_local.h" />
-    <ClInclude Include="cg_local.h" />
-    <ClInclude Include="g_local.h" />
-    <ClInclude Include="g_statusbar.h" />
-    <ClInclude Include="game.h" />
-    <ClInclude Include="m_actor.h" />
-    <ClInclude Include="m_arachnid.h" />
-    <ClInclude Include="m_berserk.h" />
-    <ClInclude Include="m_boss2.h" />
-    <ClInclude Include="m_boss31.h" />
-    <ClInclude Include="m_boss32.h" />
-    <ClInclude Include="m_brain.h" />
-    <ClInclude Include="m_chick.h" />
-    <ClInclude Include="m_flash.h" />
-    <ClInclude Include="m_flipper.h" />
-    <ClInclude Include="m_float.h" />
-    <ClInclude Include="m_flyer.h" />
-    <ClInclude Include="m_gladiator.h" />
-    <ClInclude Include="m_guardian.h" />
-    <ClInclude Include="m_gunner.h" />
-    <ClInclude Include="m_hover.h" />
-    <ClInclude Include="m_infantry.h" />
-    <ClInclude Include="m_insane.h" />
-    <ClInclude Include="m_medic.h" />
-    <ClInclude Include="m_mutant.h" />
-    <ClInclude Include="m_parasite.h" />
-    <ClInclude Include="m_player.h" />
-    <ClInclude Include="m_rider.h" />
-    <ClInclude Include="m_shambler.h" />
-    <ClInclude Include="m_soldier.h" />
-    <ClInclude Include="m_supertank.h" />
-    <ClInclude Include="m_tank.h" />
-    <ClInclude Include="q_std.h" />
-    <ClInclude Include="q_vec3.h" />
-    <ClInclude Include="bots\bot_debug.h">
-      <Filter>bots</Filter>
-    </ClInclude>
-    <ClInclude Include="bots\bot_exports.h">
-      <Filter>bots</Filter>
-    </ClInclude>
-    <ClInclude Include="bots\bot_includes.h">
-      <Filter>bots</Filter>
-    </ClInclude>
-    <ClInclude Include="bots\bot_think.h">
-      <Filter>bots</Filter>
-    </ClInclude>
-    <ClInclude Include="bots\bot_utils.h">
-      <Filter>bots</Filter>
-    </ClInclude>
-    <ClInclude Include="ctf\g_ctf.h">
-      <Filter>ctf</Filter>
-    </ClInclude>
-    <ClInclude Include="ctf\p_ctf_menu.h">
-      <Filter>ctf</Filter>
-    </ClInclude>
-    <ClInclude Include="rogue\m_rogue_carrier.h">
-      <Filter>rogue</Filter>
-    </ClInclude>
-    <ClInclude Include="rogue\m_rogue_stalker.h">
-      <Filter>rogue</Filter>
-    </ClInclude>
-    <ClInclude Include="rogue\m_rogue_turret.h">
-      <Filter>rogue</Filter>
-    </ClInclude>
-    <ClInclude Include="rogue\m_rogue_widow.h">
-      <Filter>rogue</Filter>
-    </ClInclude>
-    <ClInclude Include="rogue\m_rogue_widow2.h">
-      <Filter>rogue</Filter>
-    </ClInclude>
-    <ClInclude Include="xatrix\m_xatrix_fixbot.h">
-      <Filter>xatrix</Filter>
-    </ClInclude>
-    <ClInclude Include="xatrix\m_xatrix_gekk.h">
-      <Filter>xatrix</Filter>
-    </ClInclude>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="cg_main.cpp" />
-    <ClCompile Include="cg_screen.cpp" />
-    <ClCompile Include="g_ai.cpp" />
-    <ClCompile Include="g_chase.cpp" />
-    <ClCompile Include="g_cmds.cpp" />
-    <ClCompile Include="g_combat.cpp" />
-    <ClCompile Include="g_func.cpp" />
-    <ClCompile Include="g_items.cpp" />
-    <ClCompile Include="g_main.cpp" />
-    <ClCompile Include="g_misc.cpp" />
-    <ClCompile Include="g_monster.cpp" />
-    <ClCompile Include="g_phys.cpp" />
-    <ClCompile Include="g_save.cpp" />
-    <ClCompile Include="g_spawn.cpp" />
-    <ClCompile Include="g_svcmds.cpp" />
-    <ClCompile Include="g_target.cpp" />
-    <ClCompile Include="g_trigger.cpp" />
-    <ClCompile Include="g_turret.cpp" />
-    <ClCompile Include="g_utils.cpp" />
-    <ClCompile Include="g_weapon.cpp" />
-    <ClCompile Include="m_actor.cpp" />
-    <ClCompile Include="m_arachnid.cpp" />
-    <ClCompile Include="m_berserk.cpp" />
-    <ClCompile Include="m_boss2.cpp" />
-    <ClCompile Include="m_boss3.cpp" />
-    <ClCompile Include="m_boss31.cpp" />
-    <ClCompile Include="m_boss32.cpp" />
-    <ClCompile Include="m_brain.cpp" />
-    <ClCompile Include="m_chick.cpp" />
-    <ClCompile Include="m_flipper.cpp" />
-    <ClCompile Include="m_float.cpp" />
-    <ClCompile Include="m_flyer.cpp" />
-    <ClCompile Include="m_gladiator.cpp" />
-    <ClCompile Include="m_guardian.cpp" />
-    <ClCompile Include="m_guncmdr.cpp" />
-    <ClCompile Include="m_gunner.cpp" />
-    <ClCompile Include="m_hover.cpp" />
-    <ClCompile Include="m_infantry.cpp" />
-    <ClCompile Include="m_insane.cpp" />
-    <ClCompile Include="m_medic.cpp" />
-    <ClCompile Include="m_move.cpp" />
-    <ClCompile Include="m_mutant.cpp" />
-    <ClCompile Include="m_parasite.cpp" />
-    <ClCompile Include="m_shambler.cpp" />
-    <ClCompile Include="m_soldier.cpp" />
-    <ClCompile Include="m_supertank.cpp" />
-    <ClCompile Include="m_tank.cpp" />
-    <ClCompile Include="p_client.cpp" />
-    <ClCompile Include="p_hud.cpp" />
-    <ClCompile Include="p_move.cpp" />
-    <ClCompile Include="p_trail.cpp" />
-    <ClCompile Include="p_view.cpp" />
-    <ClCompile Include="p_weapon.cpp" />
-    <ClCompile Include="q_std.cpp" />
-    <ClCompile Include="bots\bot_debug.cpp">
-      <Filter>bots</Filter>
-    </ClCompile>
-    <ClCompile Include="bots\bot_exports.cpp">
-      <Filter>bots</Filter>
-    </ClCompile>
-    <ClCompile Include="bots\bot_think.cpp">
-      <Filter>bots</Filter>
-    </ClCompile>
-    <ClCompile Include="bots\bot_utils.cpp">
-      <Filter>bots</Filter>
-    </ClCompile>
-    <ClCompile Include="ctf\g_ctf.cpp">
-      <Filter>ctf</Filter>
-    </ClCompile>
-    <ClCompile Include="ctf\p_ctf_menu.cpp">
-      <Filter>ctf</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_combat.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_func.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_items.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_misc.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_monster.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newai.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newdm.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newfnc.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newtarg.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newtrig.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newweap.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_phys.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_spawn.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_sphere.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_utils.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\m_rogue_carrier.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\m_rogue_stalker.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\m_rogue_turret.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\m_rogue_widow.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\m_rogue_widow2.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\p_rogue_weapon.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\rogue_dm_ball.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\rogue_dm_tag.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_func.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_items.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_misc.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_monster.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_target.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_weapon.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\m_xatrix_fixbot.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\m_xatrix_gekk.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\p_xatrix_weapon.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <Filter Include="bots">
-      <UniqueIdentifier>{185665ce-b604-4d9a-b22b-02a83797d112}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="ctf">
-      <UniqueIdentifier>{2b0fdaa0-3de9-4bbd-9bc6-3cadf798c291}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="rogue">
-      <UniqueIdentifier>{76ef0be8-1c1d-472a-ada1-3aa1b354e022}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="xatrix">
-      <UniqueIdentifier>{6565427e-a805-4dc7-ba57-3ce0b62e4336}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-</Project>
--- a/m_actor.cpp	2023-10-03 19:43:06
+++ b/m_actor.cpp	2024-09-24 14:11:43
@@ -539,6 +539,8 @@
 
 void SP_target_actor(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!self->targetname)
 		gi.Com_PrintFmt("{}: no targetname\n", *self);
 
@@ -552,8 +554,9 @@
 	{
 		if (!self->speed)
 			self->speed = 200;
-		if (!st.height)
-			st.height = 200;
+		int height = st.height;
+		if (!height)
+			height = 200;
 		if (self->s.angles[YAW] == 0)
 			self->s.angles[YAW] = 360;
 		G_SetMovedir(self->s.angles, self->movedir);
--- a/m_arachnid.cpp	2023-10-03 19:43:06
+++ b/m_arachnid.cpp	2024-10-22 23:49:16
@@ -15,6 +15,8 @@
 static cached_soundindex sound_pain;
 static cached_soundindex sound_death;
 static cached_soundindex sound_sight;
+static cached_soundindex sound_spawn;
+static cached_soundindex sound_pissed;
 
 MONSTERINFO_SIGHT(arachnid_sight) (edict_t *self, edict_t *other) -> void
 {
@@ -59,16 +61,16 @@
 }
 
 mframe_t arachnid_frames_walk[] = {
+	{ ai_walk, 2, arachnid_footstep },
+	{ ai_walk, 5 },
+	{ ai_walk, 12 },
+	{ ai_walk, 16 },
+	{ ai_walk, 5 },
 	{ ai_walk, 8, arachnid_footstep },
 	{ ai_walk, 8 },
-	{ ai_walk, 8 },
-	{ ai_walk, 8 },
-	{ ai_walk, 8 },
-	{ ai_walk, 8, arachnid_footstep },
-	{ ai_walk, 8 },
-	{ ai_walk, 8 },
-	{ ai_walk, 8 },
-	{ ai_walk, 8 }
+	{ ai_walk, 12 },
+	{ ai_walk, 9 },
+	{ ai_walk, 5 }
 };
 MMOVE_T(arachnid_move_walk) = { FRAME_walk1, FRAME_walk10, arachnid_frames_walk, nullptr };
 
@@ -82,16 +84,16 @@
 //
 
 mframe_t arachnid_frames_run[] = {
+	{ ai_run, 2, arachnid_footstep },
+	{ ai_run, 5 },
+	{ ai_run, 12 },
+	{ ai_run, 16 },
+	{ ai_run, 5 },
 	{ ai_run, 8, arachnid_footstep },
 	{ ai_run, 8 },
-	{ ai_run, 8 },
-	{ ai_run, 8 },
-	{ ai_run, 8 },
-	{ ai_run, 8, arachnid_footstep },
-	{ ai_run, 8 },
-	{ ai_run, 8 },
-	{ ai_run, 8 },
-	{ ai_run, 8 }
+	{ ai_run, 12 },
+	{ ai_run, 9 },
+	{ ai_run, 5 }
 };
 MMOVE_T(arachnid_move_run) = { FRAME_walk1, FRAME_walk10, arachnid_frames_run, nullptr };
 
@@ -139,6 +141,8 @@
 
 	if (!M_ShouldReactToPain(self, mod))
 		return; // no pain anims in nightmare
+
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
 
 	float r = frandom();
 
@@ -150,21 +154,112 @@
 
 static cached_soundindex sound_charge;
 
-void arachnid_charge_rail(edict_t *self)
+static void arachnid_charge_rail(edict_t *self, monster_muzzleflash_id_t mz)
 {
 	if (!self->enemy || !self->enemy->inuse)
 		return;
 
 	gi.sound(self, CHAN_WEAPON, sound_charge, 1.f, ATTN_NORM, 0.f);
-	self->pos1 = self->enemy->s.origin;
-	self->pos1[2] += self->enemy->viewheight;
-}
-
-void arachnid_rail(edict_t *self)
+
+	vec3_t forward, right, start;
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[mz], forward, right);
+
+	PredictAim(self, self->enemy, start, 0, false, 0.0f, nullptr, &self->pos1);
+}
+
+static void arachnid_charge_rail_left(edict_t *self)
+{
+	arachnid_charge_rail(self, MZ2_ARACHNID_RAIL1);
+}
+
+static void arachnid_charge_rail_right(edict_t *self)
+{
+	arachnid_charge_rail(self, MZ2_ARACHNID_RAIL2);
+}
+
+static void arachnid_charge_rail_up_left(edict_t *self)
+{
+	arachnid_charge_rail(self, MZ2_ARACHNID_RAIL_UP1);
+}
+
+static void arachnid_charge_rail_up_right(edict_t *self)
+{
+	arachnid_charge_rail(self, MZ2_ARACHNID_RAIL_UP2);
+}
+
+void arachnid_rail_real(edict_t *self, monster_muzzleflash_id_t id)
 {
 	vec3_t start;
 	vec3_t dir;
-	vec3_t forward, right;
+	vec3_t forward, right, up;
+
+	AngleVectors(self->s.angles, forward, right, up);
+	start = M_ProjectFlashSource(self, monster_flash_offset[id], forward, right);
+	int dmg = 50;
+
+	if (self->s.frame >= FRAME_melee_in1 && self->s.frame <= FRAME_melee_in16)
+	{
+		// scan our current direction for players
+		std::array<edict_t *, 8> players_scanned {};
+		size_t num_players = 0;
+
+		for (auto player : active_players())
+		{
+			if (!visible(self, player, false))
+				continue;
+
+			if (infront_cone(self, player, 0.5f))
+			{
+				players_scanned[num_players++] = player;
+
+				if (num_players == players_scanned.size())
+					break;
+			}
+		}
+
+		if (num_players != 0)
+		{
+			edict_t *chosen = players_scanned[irandom(num_players)];
+
+			PredictAim(self, chosen, start, 0, false, 0.0f, nullptr, &self->pos1);
+
+			dir = (chosen->s.origin - self->s.origin).normalized();
+
+			self->ideal_yaw = vectoyaw(dir);
+			self->s.angles[YAW] = self->ideal_yaw;
+
+			dir = (self->pos1 - start).normalized();
+
+			for (int i = 0; i < 3; i++)
+				dir[i] += crandom_open() * 0.018f;
+			dir = dir.normalized();
+		}
+		else
+		{
+			dir = forward;
+		}
+	}
+	else
+	{
+		// calc direction to where we targeted
+		dir = (self->pos1 - start).normalized();
+		dmg = 50;
+	}
+
+	bool hit = monster_fire_railgun(self, start, dir, dmg, dmg * 2.0f, id);
+
+	if (dmg == 50)
+	{
+		if (hit)
+			self->count = 0;
+		else
+			self->count++;
+	}
+}
+
+void arachnid_rail(edict_t *self)
+{
 	monster_muzzleflash_id_t id;
 
 	switch (self->s.frame)
@@ -184,23 +279,16 @@
 			break;
 	}
 
-	AngleVectors(self->s.angles, forward, right, nullptr);
-	start = M_ProjectFlashSource(self, monster_flash_offset[id], forward, right);
-
-	// calc direction to where we targeted
-	dir = self->pos1 - start;
-	dir.normalize();
-
-	monster_fire_railgun(self, start, dir, 35, 100, id);
+	arachnid_rail_real(self, id);
 }
 
 mframe_t arachnid_frames_attack1[] = {
-	{ ai_charge, 0, arachnid_charge_rail },
-	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, arachnid_charge_rail_left },
 	{ ai_charge },
 	{ ai_charge, 0, arachnid_rail },
-	{ ai_charge, 0, arachnid_charge_rail },
-	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, arachnid_charge_rail_right },
 	{ ai_charge },
 	{ ai_charge, 0, arachnid_rail },
 	{ ai_charge },
@@ -213,12 +301,12 @@
 	{ ai_charge },
 	{ ai_charge },
 	{ ai_charge },
-	{ ai_charge, 0, arachnid_charge_rail },
-	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, arachnid_charge_rail_up_left },
 	{ ai_charge },
 	{ ai_charge, 0, arachnid_rail },
-	{ ai_charge, 0, arachnid_charge_rail },
-	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, arachnid_charge_rail_up_right },
 	{ ai_charge },
 	{ ai_charge, 0, arachnid_rail },
 	{ ai_charge },
@@ -239,7 +327,25 @@
 void arachnid_melee_hit(edict_t *self)
 {
 	if (!fire_hit(self, { MELEE_DISTANCE, 0, 0 }, 15, 50))
+	{
 		self->monsterinfo.melee_debounce_time = level.time + 1000_ms;
+		self->count++;
+	}
+	else if (self->s.frame == FRAME_melee_atk11 &&
+		     self->monsterinfo.melee_debounce_time < level.time)
+		self->monsterinfo.nextframe = FRAME_melee_atk2;
+}
+
+mframe_t arachnid_frames_melee_out[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(arachnid_melee_out) = { FRAME_melee_out1, FRAME_melee_out3, arachnid_frames_melee_out, arachnid_run };
+
+void arachnid_to_out_melee(edict_t *self)
+{
+	M_SetAnimation(self, &arachnid_melee_out);
 }
 
 mframe_t arachnid_frames_melee[] = {
@@ -256,7 +362,144 @@
 	{ ai_charge, 0, arachnid_melee_hit },
 	{ ai_charge }
 };
-MMOVE_T(arachnid_melee) = { FRAME_melee_atk1, FRAME_melee_atk12, arachnid_frames_melee, arachnid_run };
+MMOVE_T(arachnid_melee) = { FRAME_melee_atk1, FRAME_melee_atk12, arachnid_frames_melee, arachnid_to_out_melee };
+
+void arachnid_to_melee(edict_t *self)
+{
+	M_SetAnimation(self, &arachnid_melee);
+}
+
+mframe_t arachnid_frames_melee_in[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(arachnid_melee_in) = { FRAME_melee_in1, FRAME_melee_in3, arachnid_frames_melee_in, arachnid_to_melee };
+
+static void arachnid_stop_rails(edict_t *self)
+{
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+	arachnid_run(self);
+}
+
+static void arachnid_rail_left(edict_t *self)
+{
+	arachnid_rail_real(self, MZ2_ARACHNID_RAIL1);
+}
+
+static void arachnid_rail_right(edict_t *self)
+{
+	arachnid_rail_real(self, MZ2_ARACHNID_RAIL2);
+}
+
+static void arachnid_rail_rapid(edict_t *self)
+{
+	bool left_shot = self->s.frame == FRAME_melee_in9; //((self->s.frame - FRAME_melee_in5) / 2) % 2;
+
+	arachnid_rail_real(self, left_shot ? MZ2_ARACHNID_RAIL1 : MZ2_ARACHNID_RAIL2);
+}
+
+mframe_t arachnid_frames_attack3[] = {
+	{ ai_charge },
+	{ ai_move, 0, arachnid_rail_rapid },
+	{ ai_move },
+	{ ai_move/*, 0, arachnid_rail_rapid*/ },
+	{ ai_move },
+	{ ai_move, 0, arachnid_rail_rapid },
+	{ ai_move },
+	{ ai_move/*, 0, arachnid_rail_rapid*/ },
+	{ ai_move },
+	{ ai_move, 0, arachnid_rail_rapid },
+	{ ai_move },
+	{ ai_move/*, 0, arachnid_rail_rapid*/ },
+	{ ai_charge }
+};
+MMOVE_T(arachnid_attack3) = { FRAME_melee_in4, FRAME_melee_in16, arachnid_frames_attack3, arachnid_to_out_melee };
+
+static void arachnid_rapid_fire(edict_t *self)
+{
+	self->count = 0;
+	M_SetAnimation(self, &arachnid_attack3);
+}
+
+static void arachnid_spawn(edict_t *self)
+{
+	if (skill->integer != 3)
+		return;
+
+	static constexpr vec3_t reinforcement_position[] = { { -24.f, 124.f, 0 }, { -24.f, -124.f, 0 } };
+	vec3_t f, r, offset, startpoint, spawnpoint;
+	int	   count;
+
+	AngleVectors(self->s.angles, f, r, nullptr);
+
+	int num_summoned;
+	self->monsterinfo.chosen_reinforcements = M_PickReinforcements(self, num_summoned, 2);
+
+	for (count = 0; count < num_summoned; count++)
+	{
+		offset = reinforcement_position[count];
+
+		if (self->s.scale)
+			offset *= self->s.scale;
+
+		startpoint = M_ProjectFlashSource(self, offset, f, r);
+		// a little off the ground
+		startpoint[2] += 10 * (self->s.scale ? self->s.scale : 1.0f);
+
+		auto &reinforcement = self->monsterinfo.reinforcements.reinforcements[self->monsterinfo.chosen_reinforcements[count]];
+
+		if (FindSpawnPoint(startpoint, reinforcement.mins, reinforcement.maxs, spawnpoint, 32))
+		{
+			if (CheckGroundSpawnPoint(spawnpoint, reinforcement.mins, reinforcement.maxs, 256, -1))
+			{
+				edict_t *ent = CreateGroundMonster(spawnpoint, self->s.angles, reinforcement.mins, reinforcement.maxs, reinforcement.classname, 256);
+
+				if (!ent)
+					return;
+
+				ent->nextthink = level.time;
+				ent->think(ent);
+
+				ent->monsterinfo.aiflags |= AI_SPAWNED_COMMANDER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
+				ent->monsterinfo.commander = self;
+				ent->monsterinfo.slots_from_commander = reinforcement.strength;
+				self->monsterinfo.monster_used += reinforcement.strength;
+
+				gi.sound(ent, CHAN_BODY, sound_spawn, 1, ATTN_NONE, 0);
+
+				if ((self->enemy->inuse) && (self->enemy->health > 0))
+				{
+					ent->enemy = self->enemy;
+					FoundTarget(ent);
+				}
+
+				float radius = (reinforcement.maxs - reinforcement.mins).length() * 0.5f;
+				SpawnGrow_Spawn(spawnpoint + (reinforcement.mins + reinforcement.maxs), radius, radius * 2.f);
+			}
+		}
+	}
+}
+
+mframe_t arachnid_frames_taunt[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, arachnid_spawn },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(arachnid_taunt) = { FRAME_melee_pain1, FRAME_melee_pain16, arachnid_frames_taunt, arachnid_rapid_fire };
 
 MONSTERINFO_ATTACK(arachnid_attack) (edict_t *self) -> void
 {
@@ -264,10 +507,24 @@
 		return;
 
 	if (self->monsterinfo.melee_debounce_time < level.time && range_to(self, self->enemy) < MELEE_DISTANCE)
-		M_SetAnimation(self, &arachnid_melee);
-	else if ((self->enemy->s.origin[2] - self->s.origin[2]) > 150.f)
+		M_SetAnimation(self, &arachnid_melee_in);
+	// annoyed rapid fire attack
+	else if (self->enemy->client &&
+		self->last_move_time <= level.time &&
+		self->count >= 4 &&
+		frandom() < (max(self->count / 2.0f, 4.0f) + 1.0f) * 0.2f &&
+		(M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL1]) || M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL2])))
+	{
+		M_SetAnimation(self, &arachnid_taunt);
+		gi.sound(self, CHAN_VOICE, sound_pissed, 1.f, 0.25f, 0.f);
+		self->count = 0;
+		self->pain_debounce_time = level.time + 4.5_sec;
+		self->last_move_time = level.time + 10_sec;
+	}
+	else if ((self->enemy->s.origin[2] - self->s.origin[2]) > 150.f &&
+		(M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL_UP1]) || M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL_UP2])))
 		M_SetAnimation(self, &arachnid_attack_up1);
-	else
+	else if (M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL1]) || M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL2]))
 		M_SetAnimation(self, &arachnid_attack1);
 }
 
@@ -315,11 +572,26 @@
 	if (M_CheckGib(self, mod))
 	{
 		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+#ifdef PSX_ASSETS
+		ThrowGibs(self, damage, {
+			{ "models/monsters/arachnid/gibs/chest.md2" },
+			{ "models/monsters/arachnid/gibs/stomach.md2" },
+			(gib_def_t { 3, "models/monsters/arachnid/gibs/leg.md2", GIB_UPRIGHT }).frame(0),
+			(gib_def_t { 3, "models/monsters/arachnid/gibs/leg.md2", GIB_UPRIGHT }).frame(1),
+			(gib_def_t { "models/monsters/arachnid/gibs/l_rail.md2", GIB_UPRIGHT }).frame(brandom() ? 1 : 0),
+			(gib_def_t { "models/monsters/arachnid/gibs/r_rail.md2", GIB_UPRIGHT }).frame(brandom() ? 1 : 0),
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+			{ 2, "models/objects/gibs/gear/tris.md2", GIB_METALLIC },
+			{ "models/monsters/arachnid/gibs/head.md2", GIB_HEAD }
+		});
+#else
 		ThrowGibs(self, damage, {
 			{ 2, "models/objects/gibs/bone/tris.md2" },
 			{ 4, "models/objects/gibs/sm_meat/tris.md2" },
 			{ "models/objects/gibs/head2/tris.md2", GIB_HEAD }
 		});
+#endif
 		self->deadflag = true;
 		return;
 	}
@@ -332,17 +604,32 @@
 	self->deadflag = true;
 	self->takedamage = true;
 
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+
 	M_SetAnimation(self, &arachnid_move_death);
 }
 
+MONSTERINFO_SETSKIN(arachnid_setskin) (edict_t *self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum = 1;
+	else
+		self->s.skinnum = 0;
+}
+
 //
 // monster_arachnid
 //
-
-/*QUAKED monster_arachnid (1 .5 0) (-48 -48 -20) (48 48 48) Ambush Trigger_Spawn Sight
+// 
+constexpr const char *default_reinforcements = "monster_stalker 1";
+constexpr int32_t default_monster_slots_base = 2;
+
+/*QUAKED monster_arachnid (1 .5 0) (-40 -40 -20) (40 40 48) Ambush Trigger_Spawn Sight
  */
 void SP_monster_arachnid(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -355,10 +642,35 @@
 	sound_pain.assign("arachnid/pain.wav");
 	sound_death.assign("arachnid/death.wav");
 	sound_sight.assign("arachnid/sight.wav");
+	sound_pissed.assign("arachnid/angry.wav");
+	
+#ifdef PSX_ASSETS
+	gi.modelindex("models/monsters/arachnid/gibs/head.md2");
+	gi.modelindex("models/monsters/arachnid/gibs/chest.md2");
+	gi.modelindex("models/monsters/arachnid/gibs/stomach.md2");
+	gi.modelindex("models/monsters/arachnid/gibs/leg.md2");
+	gi.modelindex("models/monsters/arachnid/gibs/l_rail.md2");
+	gi.modelindex("models/monsters/arachnid/gibs/r_rail.md2");
+#endif
+
+	if (skill->value >= 3)
+	{
+		sound_spawn.assign("medic_commander/monsterspawn1.wav");
+
+		const char *reinforcements = default_reinforcements;
+
+		if (!st.was_key_specified("monster_slots"))
+			self->monsterinfo.monster_slots = default_monster_slots_base;
+		if (st.was_key_specified("reinforcements"))
+			reinforcements = st.reinforcements;
+
+		if (self->monsterinfo.monster_slots && reinforcements && *reinforcements)
+			M_SetupReinforcements(reinforcements, self->monsterinfo.reinforcements);
+	}
 
 	self->s.modelindex = gi.modelindex("models/monsters/arachnid/tris.md2");
-	self->mins = { -48, -48, -20 };
-	self->maxs = { 48, 48, 48 };
+	self->mins = { -40, -40, -20 };
+	self->maxs = { 40, 40, 48 };
 	self->movetype = MOVETYPE_STEP;
 	self->solid = SOLID_BBOX;
 
@@ -376,6 +688,9 @@
 	self->monsterinfo.run = arachnid_run;
 	self->monsterinfo.attack = arachnid_attack;
 	self->monsterinfo.sight = arachnid_sight;
+	self->monsterinfo.setskin = arachnid_setskin;
+
+	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
 
 	gi.linkentity(self);
 
--- a/m_berserk.cpp	2023-10-03 19:43:06
+++ b/m_berserk.cpp	2024-09-24 14:11:48
@@ -158,7 +158,7 @@
 {
 	constexpr vec3_t aim = { MELEE_DISTANCE, 0, -24 };
 	
-	if (!fire_hit(self, aim, irandom(5, 11), 80)) //	Faster attack -- upwards and backwards
+	if (!fire_hit(self, aim, irandom(5, 11), 400)) //	Faster attack -- upwards and backwards
 		self->monsterinfo.melee_debounce_time = level.time + 1.2_sec;
 }
 
@@ -183,7 +183,7 @@
 {
 	vec3_t aim = { MELEE_DISTANCE, self->mins[0], -4 };
 	
-	if (!fire_hit(self, aim, irandom(15, 21), 400)) // Slower attack
+	if (!fire_hit(self, aim, irandom(15, 21), 250)) // Slower attack
 		self->monsterinfo.melee_debounce_time = level.time + 2.5_sec;
 }
 
@@ -295,10 +295,14 @@
 
 static void berserk_high_gravity(edict_t *self)
 {
+	float gravity_scale = (800.f / level.gravity);
+
 	if (self->velocity[2] < 0)
-		self->gravity = 2.25f * (800.f / level.gravity);
-	else
-		self->gravity = 5.25f * (800.f / level.gravity);
+		self->gravity = 2.25f;
+	else
+		self->gravity = 5.25f;
+
+	self->gravity *= gravity_scale;
 }
 
 void berserk_jump_takeoff(edict_t *self)
@@ -317,12 +321,18 @@
 	AngleVectors(self->s.angles, forward, nullptr, nullptr);
 	self->s.origin[2] += 1;
 	self->velocity = forward * fwd_speed;
-	self->velocity[2] = 450;
+	self->velocity[2] = 400;
 	self->groundentity = nullptr;
 	self->monsterinfo.aiflags |= AI_DUCKED;
 	self->monsterinfo.attack_finished = level.time + 3_sec;
 	self->touch = berserk_jump_touch;
 	berserk_high_gravity(self);
+
+	self->gravity = -self->gravity;
+	SV_AddGravity(self);
+	self->gravity = -self->gravity;
+
+	gi.linkentity(self);
 }
 
 void berserk_check_landing(edict_t *self)
@@ -770,6 +780,8 @@
  */
 void SP_monster_berserk(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_boss2.cpp	2023-10-03 19:43:06
+++ b/m_boss2.cpp	2024-10-20 17:24:09
@@ -22,6 +22,17 @@
 static cached_soundindex sound_pain3;
 static cached_soundindex sound_death;
 static cached_soundindex sound_search1;
+
+// he fly
+static void boss2_set_fly_parameters(edict_t *self, bool firing)
+{
+	self->monsterinfo.fly_thrusters = false;
+	self->monsterinfo.fly_acceleration = firing ? 1.5f : 3.f;
+	self->monsterinfo.fly_speed = firing ? 10.f : 80.f;
+	// BOSS2 stays far-ish away if he's in the open
+	self->monsterinfo.fly_min_distance = 400.f;
+	self->monsterinfo.fly_max_distance = 600.f;
+}
 
 MONSTERINFO_SEARCH(boss2_search) (edict_t *self) -> void
 {
@@ -462,6 +473,8 @@
 
 MONSTERINFO_RUN(boss2_run) (edict_t *self) -> void
 {
+	boss2_set_fly_parameters(self, false);
+
 	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
 		M_SetAnimation(self, &boss2_move_stand);
 	else
@@ -485,6 +498,8 @@
 		M_SetAnimation(self, self->spawnflags.has(SPAWNFLAG_BOSS2_N64) ? &boss2_move_attack_hb : &boss2_move_attack_pre_mg);
 	else
 		M_SetAnimation(self, self->spawnflags.has(SPAWNFLAG_BOSS2_N64) ? &boss2_move_attack_rocket2 : &boss2_move_attack_rocket);
+
+	boss2_set_fly_parameters(self, true);
 }
 
 void boss2_attack_mg(edict_t *self)
@@ -617,6 +632,8 @@
  */
 void SP_monster_boss2(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -657,7 +674,7 @@
 
 	self->health = 2000 * st.health_multiplier;
 	self->gib_health = -200;
-	self->mass = 1000;
+	self->mass = 2000;
 
 	self->yaw_speed = 50;
 
@@ -681,5 +698,8 @@
 	// [Paril-KEX]
 	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
 
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+	boss2_set_fly_parameters(self, false);
+
 	flymonster_start(self);
 }
--- a/m_boss31.cpp	2023-10-03 19:43:06
+++ b/m_boss31.cpp	2024-09-24 14:12:45
@@ -571,6 +571,8 @@
  */
 void SP_monster_jorg(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_boss32.cpp	2023-10-03 19:43:06
+++ b/m_boss32.cpp	2024-09-24 14:11:50
@@ -726,6 +726,8 @@
  */
 void SP_monster_makron(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_brain.cpp	2023-10-03 19:43:06
+++ b/m_brain.cpp	2024-09-24 14:10:38
@@ -724,6 +724,8 @@
  */
 void SP_monster_brain(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_chick.cpp	2023-10-03 19:43:06
+++ b/m_chick.cpp	2024-09-24 14:13:22
@@ -790,6 +790,8 @@
  */
 void SP_monster_chick(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_flipper.cpp	2023-10-03 19:43:06
+++ b/m_flipper.cpp	2024-09-24 14:12:41
@@ -338,6 +338,8 @@
  */
 void SP_monster_flipper(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_float.cpp	2023-10-03 19:43:06
+++ b/m_float.cpp	2024-09-24 14:12:49
@@ -653,6 +653,8 @@
  */
 void SP_monster_floater(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_flyer.cpp	2023-10-03 19:43:06
+++ b/m_flyer.cpp	2024-09-24 14:14:16
@@ -699,6 +699,8 @@
  */
 void SP_monster_flyer(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_gladiator.cpp	2023-10-03 19:43:06
+++ b/m_gladiator.cpp	2024-09-28 00:14:24
@@ -392,6 +392,8 @@
  */
 void SP_monster_gladiator(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_guardian.cpp	2023-10-03 19:43:06
+++ b/m_guardian.cpp	2024-10-02 23:09:43
@@ -12,6 +12,11 @@
 #include "m_guardian.h"
 #include "m_flash.h"
 
+static cached_soundindex sound_sight;
+static cached_soundindex sound_pain1;
+static cached_soundindex sound_pain2;
+static cached_soundindex sound_death;
+
 //
 // stand
 //
@@ -72,9 +77,62 @@
 };
 MMOVE_T(guardian_move_stand) = { FRAME_idle1, FRAME_idle52, guardian_frames_stand, nullptr };
 
+constexpr spawnflags_t SPAWNFLAG_GUARDIAN_SLEEPY = 8_spawnflag;
+
+/*
+=============
+ai_sleep
+
+honk shoo honk shoo
+==============
+*/
+void ai_sleep(edict_t *self, float dist)
+{
+}
+
+mframe_t guardian_frames_sleep[] = {
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep }
+};
+MMOVE_T(guardian_move_sleep) = { FRAME_sleep1, FRAME_sleep14, guardian_frames_sleep, nullptr };
+
 MONSTERINFO_STAND(guardian_stand) (edict_t *self) -> void
 {
-	M_SetAnimation(self, &guardian_move_stand);
+	if (self->spawnflags.has(SPAWNFLAG_GUARDIAN_SLEEPY))
+		M_SetAnimation(self, &guardian_move_sleep);
+	else
+		M_SetAnimation(self, &guardian_move_stand);
+}
+
+void guardian_run(edict_t *self);
+
+mframe_t guardian_frames_wake[] = {
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep }
+};
+MMOVE_T(guardian_move_wake) = { FRAME_wake1, FRAME_wake5, guardian_frames_wake, guardian_run };
+
+USE(guardian_use) (edict_t *self, edict_t *other, edict_t *activator) -> void
+{
+	self->spawnflags &= ~SPAWNFLAG_GUARDIAN_SLEEPY;
+	M_SetAnimation(self, &guardian_move_wake);
+	self->use = monster_use;
+	gi.sound(self, CHAN_BODY, sound_sight, 1.f, 0.1f, 0.0f);
 }
 
 //
@@ -85,7 +143,7 @@
 
 void guardian_footstep(edict_t *self)
 {
-	gi.sound(self, CHAN_BODY, sound_step, 1.f, ATTN_NORM, 0.0f);
+	gi.sound(self, CHAN_BODY, sound_step, 1.f, 0.1f, 0.0f);
 }
 
 mframe_t guardian_frames_walk[] = {
@@ -145,6 +203,8 @@
 
 MONSTERINFO_RUN(guardian_run) (edict_t *self) -> void
 {
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+
 	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
 	{
 		M_SetAnimation(self, &guardian_move_stand);
@@ -191,13 +251,18 @@
 		return;
 
 	self->pain_debounce_time = level.time + 3_sec;
-	//gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	if (brandom())
+		gi.sound(self, CHAN_BODY, sound_pain1, 1.f, 0.1f, 0.0f);
+	else
+		gi.sound(self, CHAN_BODY, sound_pain2, 1.f, 0.1f, 0.0f);
 
 	if (!M_ShouldReactToPain(self, mod))
 		return; // no pain anims in nightmare
 
 	M_SetAnimation(self, &guardian_move_pain1);
 	self->monsterinfo.weapon_sound = 0;
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
 }
 
 mframe_t guardian_frames_atk1_out[] = {
@@ -224,20 +289,25 @@
 
 void guardian_fire_blaster(edict_t *self)
 {
-	vec3_t forward, right, target;
+	vec3_t forward, right, up;
 	vec3_t start;
 	monster_muzzleflash_id_t id = MZ2_GUARDIAN_BLASTER;
 
-	AngleVectors(self->s.angles, forward, right, nullptr);
+	if (!self->enemy || !self->enemy->inuse)
+	{
+		self->monsterinfo.nextframe = FRAME_atk1_spin13;
+		return;
+	}
+
+	AngleVectors(self->s.angles, forward, right, up);
 	start = M_ProjectFlashSource(self, monster_flash_offset[id], forward, right);
-	target = self->enemy->s.origin;
-	target[2] += self->enemy->viewheight;
-	for (int i = 0; i < 3; i++)
-		target[i] += crandom_open() * 5.f;
-	forward = target - start;
+	PredictAim(self, self->enemy, start, 1000, false, crandom() * 0.1f, &forward, nullptr);
+	forward += right * crandom() * 0.02f;
+	forward += up * crandom() * 0.02f;
 	forward.normalize();
 
-	monster_fire_blaster(self, start, forward, 2, 1000, id, (self->s.frame % 4) ? EF_NONE : EF_HYPERBLASTER);
+	edict_t *bolt = monster_fire_blaster(self, start, forward, 3, 1100, id, (self->s.frame % 4) ? EF_NONE : EF_HYPERBLASTER);
+	bolt->s.scale = 2.0f;
 
 	if (self->enemy && self->enemy->health > 0 && 
 		self->s.frame == FRAME_atk1_spin12 && self->timestamp > level.time && visible(self, self->enemy))
@@ -293,6 +363,7 @@
 }
 
 static cached_soundindex sound_laser;
+static cached_soundindex sound_pew;
 
 constexpr vec3_t laser_positions[] = {
 	{ 125.0f, -70.f, 60.f },
@@ -301,29 +372,31 @@
 
 PRETHINK(guardian_fire_update) (edict_t *laser) -> void
 {
-	edict_t *self = laser->owner;
-
-	vec3_t forward, right, target;
-	vec3_t start;
-
-	AngleVectors(self->s.angles, forward, right, nullptr);
-	start = M_ProjectFlashSource(self, laser_positions[1 - (self->s.frame & 1)], forward, right);
-	target = self->enemy->s.origin + self->enemy->mins;
-	for (int i = 0; i < 3; i++)
-		target[i] += frandom() * self->enemy->size[i];
-	forward = target - start;
-	forward.normalize();
-
-	laser->s.origin = start;
-	laser->movedir = forward;
-	gi.linkentity(laser);
+	if (!laser->spawnflags.has(SPAWNFLAG_DABEAM_SPAWNED))
+	{
+		edict_t *self = laser->owner;
+
+		vec3_t forward, right, target;
+		vec3_t start;
+
+		AngleVectors(self->s.angles, forward, right, nullptr);
+		start = M_ProjectFlashSource(self, laser_positions[laser->spawnflags.has(SPAWNFLAG_DABEAM_SECONDARY) ? 1 : 0], forward, right);
+		PredictAim(self, self->enemy, start, 0, false, 0.3f, &forward, &target);
+
+		laser->s.origin = start;
+		forward[0] += crandom() * 0.02f;
+		forward[1] += crandom() * 0.02f;
+		forward.normalize();
+		laser->movedir = forward;
+		gi.linkentity(laser);
+	}
 	dabeam_update(laser, false);
 }
 
 void guardian_laser_fire(edict_t *self)
 {
 	gi.sound(self, CHAN_WEAPON, sound_laser, 1.f, ATTN_NORM, 0.f);
-	monster_fire_dabeam(self, 25, self->s.frame & 1, guardian_fire_update);
+	monster_fire_dabeam(self, 15, self->s.frame & 1, guardian_fire_update);
 }
 
 mframe_t guardian_frames_atk2_fire[] = {
@@ -357,40 +430,346 @@
 
 void guardian_kick(edict_t *self)
 {
-	if (!fire_hit(self, { MELEE_DISTANCE, 0, -80 }, 85, 700))
-		self->monsterinfo.melee_debounce_time = level.time + 1000_ms;
+	if (!fire_hit(self, { 160.f, 0, -80.f }, 85, 700))
+		self->monsterinfo.melee_debounce_time = level.time + 3500_ms;
 }
 
 mframe_t guardian_frames_kick[] = {
+	{ ai_charge, 12.f },
+	{ ai_charge, 18.f, guardian_footstep },
+	{ ai_charge, 11.f },
+	{ ai_charge, 9.f },
+	{ ai_charge, 8.f },
+	{ ai_charge, 0, guardian_kick },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
 	{ ai_charge },
 	{ ai_charge, 0, guardian_footstep },
 	{ ai_charge },
-	{ ai_charge },
-	{ ai_charge },
-	{ ai_charge, 0, guardian_kick },
-	{ ai_charge },
-	{ ai_charge },
-	{ ai_charge },
-	{ ai_charge },
-	{ ai_charge, 0, guardian_footstep },
-	{ ai_charge },
 	{ ai_charge }
 };
 MMOVE_T(guardian_move_kick) = { FRAME_kick_in1, FRAME_kick_in13, guardian_frames_kick, guardian_run };
 
+
+// RAFAEL
+/*
+fire_heat
+*/
+
+static inline vec3_t heat_guardian_get_dist_vec(edict_t *heat, edict_t *target, float dist_to_target)
+{
+	return (((target->s.origin + vec3_t{0.f, 0.f, target->mins.z}) + (target->velocity * (clamp(dist_to_target / 500.f, 0.f, 1.f)) * 0.5f)) - heat->s.origin).normalized();
+}
+
+THINK(heat_guardian_think) (edict_t *self) -> void
+{
+	edict_t *acquire = nullptr;
+	float	 oldlen = 0;
+	float	 olddot = 1;
+
+	if (self->timestamp < level.time)
+	{
+		vec3_t fwd = AngleVectors(self->s.angles).forward;
+
+		if (self->oldenemy)
+		{
+			self->enemy = self->oldenemy;
+			self->oldenemy = nullptr;
+		}
+	
+		if (self->enemy)
+		{
+			acquire = self->enemy;
+
+			if (acquire->health <= 0 ||
+				!visible(self, acquire))
+			{
+				self->enemy = acquire = nullptr;
+			}
+			else
+			{
+				float dist_to_target = (self->s.origin - acquire->s.origin).normalize();
+				self->pos1 = heat_guardian_get_dist_vec(self, acquire, dist_to_target);
+			}
+		}
+
+		if (!acquire)
+		{
+			// acquire new target
+			edict_t *target = nullptr;
+
+			while ((target = findradius(target, self->s.origin, 1024)) != nullptr)
+			{
+				if (self->owner == target)
+					continue;
+				if (!target->client)
+					continue;
+				if (target->health <= 0)
+					continue;
+				if (!visible(self, target))
+					continue;
+
+				float dist_to_target = (self->s.origin - target->s.origin).normalize();
+				vec3_t vec = heat_guardian_get_dist_vec(self, target, dist_to_target);
+
+				float len = vec.normalize();
+				float dot = vec.dot(fwd);
+
+				// targets that require us to turn less are preferred
+				if (dot >= olddot)
+					continue;
+
+				if (acquire == nullptr || dot < olddot || len < oldlen)
+				{
+					acquire = target;
+					oldlen = len;
+					olddot = dot;
+					self->pos1 = vec;
+				}
+			}
+		}
+	}
+
+	vec3_t preferred_dir = self->pos1;
+
+	if (acquire != nullptr)
+	{
+		if (self->enemy != acquire)
+		{
+			gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/railgr1a.wav"), 1.f, 0.25f, 0);
+			self->enemy = acquire;
+		}
+	}
+	else
+		self->enemy = nullptr;
+
+	float t = self->accel;
+
+	if (self->enemy)
+		t *= 0.85f;
+
+	float d = self->movedir.dot(preferred_dir);
+
+	self->movedir = slerp(self->movedir, preferred_dir, t).normalized();
+	self->s.angles = vectoangles(self->movedir);
+
+	if (self->speed < self->yaw_speed)
+	{
+		self->speed += self->yaw_speed * gi.frame_time_s;
+	}
+
+	self->velocity = self->movedir * self->speed;
+	self->nextthink = level.time + FRAME_TIME_MS;
+}
+
+DIE(guardian_heat_die) (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, const vec3_t &point, const mod_t &mod) -> void
+{
+	BecomeExplosion1(self);
+}
+
+// RAFAEL
+void fire_guardian_heat(edict_t *self, const vec3_t &start, const vec3_t &dir, const vec3_t &rest_dir, int damage, int speed, float damage_radius, int radius_damage, float turn_fraction)
+{
+	edict_t *heat;
+
+	heat = G_Spawn();
+	heat->s.origin = start;
+	heat->movedir = dir;
+	heat->s.angles = vectoangles(dir);
+	heat->velocity = dir * speed;
+	heat->movetype = MOVETYPE_FLYMISSILE;
+	heat->clipmask = MASK_PROJECTILE;
+	heat->flags |= FL_DAMAGEABLE;
+	heat->solid = SOLID_BBOX;
+	heat->s.effects |= EF_ROCKET;
+	heat->s.modelindex = gi.modelindex("models/objects/rocket/tris.md2");
+	heat->s.scale = 1.5f;
+	heat->owner = self;
+	heat->touch = rocket_touch;
+	heat->speed = speed / 2;
+	heat->yaw_speed = speed * 2;
+	heat->accel = turn_fraction;
+	heat->pos1 = rest_dir;
+	heat->mins = { -5, -5, -5 };
+	heat->maxs = { 5, 5, 5 };
+	heat->health = 15;
+	heat->takedamage = true;
+	heat->die = guardian_heat_die;
+
+	heat->nextthink = level.time + 0.20_sec;
+	heat->think = heat_guardian_think;
+
+	heat->dmg = damage;
+	heat->radius_dmg = radius_damage;
+	heat->dmg_radius = damage_radius;
+	heat->s.sound = gi.soundindex("weapons/rockfly.wav");
+
+	if (visible(heat, self->enemy))
+	{
+		heat->oldenemy = self->enemy;
+		heat->timestamp = level.time + 0.6_sec;
+		gi.sound(heat, CHAN_WEAPON, gi.soundindex("weapons/railgr1a.wav"), 1.f, 0.25f, 0);
+	}
+
+	gi.linkentity(heat);
+}
+
+// RAFAEL
+
+static void guardian_fire_rocket(edict_t *self, float offset)
+{
+	vec3_t forward, right, up;
+	vec3_t start;
+
+	AngleVectors(self->s.angles, forward, right, up);
+	start = self->s.origin;
+	start -= forward * 8.0f;
+	start += right * offset;
+	start += up * 50.f;
+
+	AngleVectors({ 20.0f, self->s.angles[1] - offset, 0.f }, forward, nullptr, nullptr);
+
+	fire_guardian_heat(self, start, up, forward, 20, 250, 150, 35, 0.085f);
+	gi.sound(self, CHAN_WEAPON, sound_pew, 1.f, 0.5f, 0.0f);
+}
+
+static void guardian_fire_rocket_l(edict_t *self)
+{
+	guardian_fire_rocket(self, -14.0f);
+}
+
+static void guardian_fire_rocket_r(edict_t *self)
+{
+	guardian_fire_rocket(self, 14.0f);
+}
+
+static void guardian_blind_fire_check(edict_t *self)
+{
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+	{
+		vec3_t aim = self->monsterinfo.blind_fire_target - self->s.origin;
+		self->ideal_yaw = vectoyaw(aim);
+	}
+}
+
+mframe_t guardian_frames_rocket[] = {
+	{ ai_charge, 0, guardian_blind_fire_check },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, guardian_fire_rocket_l },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, guardian_fire_rocket_r },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, guardian_fire_rocket_l },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, guardian_fire_rocket_r },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(guardian_move_rocket) = { FRAME_turnl_1, FRAME_turnr_11, guardian_frames_rocket, guardian_run };
+
 MONSTERINFO_ATTACK(guardian_attack) (edict_t *self) -> void
 {
 	if (!self->enemy || !self->enemy->inuse)
 		return;
 
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		float chance;
+
+		// setup shot probabilities
+		if (self->count == 0)
+			chance = 1.0;
+		else if (self->count <= 2)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		float r = frandom();
+
+		self->monsterinfo.blind_fire_delay += random_time(8.5_sec, 15.5_sec);
+
+		// don't shoot at the origin
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		// shot the rockets way too soon
+		if (self->count)
+		{
+			self->count--;
+			return;
+		}
+
+		// don't shoot if the dice say not to
+		if (r > chance)
+			return;
+
+		// turn on manual steering to signal both manual steering and blindfire
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+		M_SetAnimation(self, &guardian_move_rocket);
+		self->monsterinfo.attack_finished = level.time + random_time(3_sec);
+		return;
+	}
+	else if (self->bad_area)
+	{
+		M_SetAnimation(self, &guardian_move_atk1_in);
+		return;
+	}
+
 	float r = range_to(self, self->enemy);
-
-	if (r > RANGE_NEAR)
-		M_SetAnimation(self, &guardian_move_atk2_in);
-	else if (self->monsterinfo.melee_debounce_time < level.time && r < 120.f)
+	bool changedAttack = false;
+
+	if (self->monsterinfo.melee_debounce_time < level.time && r < 160.f)
+	{
 		M_SetAnimation(self, &guardian_move_kick);
-	else
+		changedAttack = true;
+		self->style = 0;
+	}
+	else if (r > 300.f && frandom() < (max(r, 1000.f) / 1200.f))
+	{
+		if (self->count <= 0 && frandom() * 0.25f)
+		{
+			M_SetAnimation(self, &guardian_move_rocket);
+			self->count = 6;
+			self->style = 0;
+			return;
+		}
+		else if (M_CheckClearShot(self, laser_positions[0]) && self->style != 1)
+		{
+			M_SetAnimation(self, &guardian_move_atk2_in);
+			self->style = 1;
+			changedAttack = true;
+
+			if (skill->integer >= 2)
+				self->monsterinfo.nextframe = FRAME_atk2_in8;
+		}
+		else if (M_CheckClearShot(self, monster_flash_offset[MZ2_GUARDIAN_BLASTER]))
+		{
+			M_SetAnimation(self, &guardian_move_atk1_in);
+			changedAttack = true;
+			self->style = 0;
+		}
+	}
+	else if (M_CheckClearShot(self, monster_flash_offset[MZ2_GUARDIAN_BLASTER]))
+	{
 		M_SetAnimation(self, &guardian_move_atk1_in);
+		changedAttack = true;
+		self->style = 0;
+	}
+
+	if (changedAttack && self->count)
+		self->count--;
 }
 
 //
@@ -465,23 +844,85 @@
 
 DIE(guardian_die) (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, const vec3_t &point, const mod_t &mod) -> void
 {
+	if (self->deadflag)
+		return;
+
 	// regular death
-	//gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
 	self->monsterinfo.weapon_sound = 0;
 	self->deadflag = true;
 	self->takedamage = true;
 
 	M_SetAnimation(self, &guardian_move_death);
-}
-
-//
-// monster_tank
+	gi.sound(self, CHAN_BODY, sound_death, 1.f, 0.1f, 0.0f);
+}
+
+void GuardianPowerArmor(edict_t *self)
+{
+	self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+	// I don't like this, but it works
+	if (self->monsterinfo.power_armor_power <= 0)
+		self->monsterinfo.power_armor_power += 200 * skill->integer;
+}
+
+void GuardianRespondPowerup(edict_t *self, edict_t *other)
+{
+	if (other->s.effects & (EF_QUAD | EF_DOUBLE | EF_DUALFIRE | EF_PENT))
+	{
+		GuardianPowerArmor(self);
+	}
+}
+
+static void GuardianPowerups(edict_t *self)
+{
+	edict_t *ent;
+
+	if (!coop->integer)
+	{
+		GuardianRespondPowerup(self, self->enemy);
+	}
+	else
+	{
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			GuardianRespondPowerup(self, ent);
+		}
+	}
+}
+
+MONSTERINFO_CHECKATTACK(Guardian_CheckAttack) (edict_t *self) -> bool
+{
+	if (!self->enemy)
+		return false;
+
+	GuardianPowerups(self);
+
+	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.6f, 0.7f, 0.85f, 0.f);
+}
+
+MONSTERINFO_SETSKIN(guardian_setskin) (edict_t *self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum = 1;
+	else
+		self->s.skinnum = 0;
+}
+
+
+//
+// monster_guardian
 //
 
 /*QUAKED monster_guardian (1 .5 0) (-96 -96 -66) (96 96 62) Ambush Trigger_Spawn Sight
  */
 void SP_monster_guardian(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -491,22 +932,33 @@
 	sound_charge.assign("weapons/hyprbu1a.wav");
 	sound_spin_loop.assign("weapons/hyprbl1a.wav");
 	sound_laser.assign("weapons/laser2.wav");
+	sound_pew.assign("makron/blaster.wav");
+	
+	sound_sight.assign("guardian/sight.wav");
+	sound_pain1.assign("guardian/pain1.wav");
+	sound_pain2.assign("guardian/pain2.wav");
+	sound_death.assign("guardian/death.wav");
 
 	for (auto &gib : gibs)
 		gi.modelindex(gib);
 
 	self->s.modelindex = gi.modelindex("models/monsters/guardian/tris.md2");
-	self->mins = { -96, -96, -66 };
-	self->maxs = { 96, 96, 62 };
+	self->mins = { -78, -78, -66 };
+	self->maxs = { 78, 78, 76 };
 	self->movetype = MOVETYPE_STEP;
 	self->solid = SOLID_BBOX;
 
 	self->health = 2500 * st.health_multiplier;
 	self->gib_health = -200;
 
+	if (skill->integer >= 3 || coop->integer)
+		self->health *= 2;
+	else if (skill->integer == 2)
+		self->health *= 1.5f;
+
 	self->monsterinfo.scale = MODEL_SCALE;
 
-	self->mass = 850;
+	self->mass = 1650;
 
 	self->pain = guardian_pain;
 	self->die = guardian_die;
@@ -514,10 +966,17 @@
 	self->monsterinfo.walk = guardian_walk;
 	self->monsterinfo.run = guardian_run;
 	self->monsterinfo.attack = guardian_attack;
+	self->monsterinfo.checkattack = Guardian_CheckAttack;
+	self->monsterinfo.setskin = guardian_setskin;
+
+	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
+	self->monsterinfo.blindfire = true;
 
 	gi.linkentity(self);
 
-	M_SetAnimation(self, &guardian_move_stand);
+	guardian_stand(self);
 
 	walkmonster_start(self);
-}
+
+	self->use = guardian_use;
+}
--- a/m_guncmdr.cpp	2023-10-03 19:43:06
+++ b/m_guncmdr.cpp	2024-10-20 21:14:45
@@ -297,7 +297,7 @@
 
 void guncmdr_pain5_to_death1(edict_t *self)
 {
-	if (self->health < 0)
+	if (self->health <= 0)
 		M_SetAnimation(self, &guncmdr_move_death1, false);
 }
 
@@ -311,7 +311,7 @@
 
 void guncmdr_pain5_to_death2(edict_t *self)
 {
-	if (self->health < 0 && brandom())
+	if (self->health <= 0 && brandom())
 		M_SetAnimation(self, &guncmdr_move_death2, false);
 }
 
@@ -380,7 +380,7 @@
 
 static void guncmdr_pain6_to_death6(edict_t *self)
 {
-	if (self->health < 0)
+	if (self->health <= 0)
 		M_SetAnimation(self, &guncmdr_move_death6, false);
 }
 
@@ -1399,6 +1399,8 @@
 */
 void SP_monster_guncmdr(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_gunner.cpp	2023-10-03 19:43:06
+++ b/m_gunner.cpp	2024-09-24 14:09:16
@@ -853,6 +853,8 @@
 */
 void SP_monster_gunner(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_hover.cpp	2023-10-03 19:43:06
+++ b/m_hover.cpp	2024-09-24 14:14:34
@@ -564,8 +564,8 @@
 	self->monsterinfo.fly_speed = 120.f;
 	// Icarus prefers to keep its distance, but flies slower than the flyer.
 	// he never pins because of this.
-	self->monsterinfo.fly_min_distance = 150.f;
-	self->monsterinfo.fly_max_distance = 350.f;
+	self->monsterinfo.fly_min_distance = 250.f;
+	self->monsterinfo.fly_max_distance = 450.f;
 }
 
 /*QUAKED monster_hover (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
@@ -575,6 +575,8 @@
 */
 void SP_monster_hover(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_infantry.cpp	2023-10-03 19:43:06
+++ b/m_infantry.cpp	2024-09-24 14:14:37
@@ -869,6 +869,8 @@
  */
 void SP_monster_infantry(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_insane.cpp	2023-10-03 19:43:06
+++ b/m_insane.cpp	2024-09-24 14:32:23
@@ -620,6 +620,8 @@
  */
 void SP_misc_insane(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	//	static int skin = 0;	//@@
 
 	if ( !M_AllowSpawn( self ) ) {
@@ -683,7 +685,7 @@
 	if (self->spawnflags.has(SPAWNFLAG_INSANE_CRUCIFIED)) // Crucified ?
 	{
 		self->flags |= FL_NO_KNOCKBACK | FL_STATIONARY;
-		stationarymonster_start(self);
+		stationarymonster_start(self, st);
 	}
 	else
 		walkmonster_start(self);
--- a/m_medic.cpp	2023-10-03 19:43:06
+++ b/m_medic.cpp	2024-09-26 12:13:32
@@ -27,7 +27,6 @@
 void M_SetEffects(edict_t *ent);
 bool FindTarget(edict_t *self);
 void FoundTarget(edict_t *self);
-void ED_CallSpawn(edict_t *ent);
 
 static cached_soundindex sound_idle1;
 static cached_soundindex sound_pain1;
@@ -77,7 +76,7 @@
 }
 
 // pick an array of reinforcements to use; note that this does not modify `self`
-std::array<uint8_t, MAX_REINFORCEMENTS> M_PickReinforcements(edict_t *self, int32_t &num_chosen, int32_t max_slots = 0)
+std::array<uint8_t, MAX_REINFORCEMENTS> M_PickReinforcements(edict_t *self, int32_t &num_chosen, int32_t max_slots)
 {
 	static std::vector<uint8_t> available;
 	std::array<uint8_t, MAX_REINFORCEMENTS> chosen;
@@ -134,8 +133,6 @@
 	const char *p = reinforcements;
 	reinforcement_t *r = list.reinforcements;
 
-	st = {};
-
 	while (true)
 	{
 		const char *token = COM_ParseEx(&p, "; ");
@@ -166,12 +163,8 @@
 	}
 }
 
-void cleanupHeal(edict_t *self, bool change_frame)
-{
-	// clean up target, if we have one and it's legit
-	if (self->enemy && self->enemy->inuse)
-		cleanupHealTarget(self->enemy);
-
+void fixHealerEnemy(edict_t *self)
+{
 	if (self->oldenemy && self->oldenemy->inuse && self->oldenemy->health > 0)
 	{
 		self->enemy = self->oldenemy;
@@ -185,21 +178,26 @@
 		{
 			// no valid enemy, so stop acting
 			self->monsterinfo.pausetime = HOLD_FOREVER;
-			self->monsterinfo.stand(self);
 			return;
 		}
 	}
-
-	if (change_frame)
-		self->monsterinfo.nextframe = FRAME_attack52;
-}
-
-void abortHeal(edict_t *self, bool change_frame, bool gib, bool mark)
+}
+
+void cleanupHeal(edict_t *self)
+{
+	// clean up target, if we have one and it's legit
+	if (self->enemy && self->enemy->inuse && !self->enemy->client && (self->monsterinfo.aiflags & AI_MEDIC))
+		cleanupHealTarget(self->enemy);
+
+	fixHealerEnemy(self);
+}
+
+void abortHeal(edict_t *self, bool gib, bool mark)
 {
 	int				 hurt;
 	constexpr vec3_t pain_normal = { 0, 0, 1 };
 
-	if (self->enemy && self->enemy->inuse)
+	if (self->enemy && self->enemy->inuse && !self->enemy->client && (self->monsterinfo.aiflags & AI_MEDIC))
 	{
 		cleanupHealTarget(self->enemy);
 
@@ -219,22 +217,122 @@
 
 		if (gib)
 		{
+			// [Paril-KEX] health added in case of weird edge case
+			// with fixbot "healing" the corpses
 			if (self->enemy->gib_health)
-				hurt = -self->enemy->gib_health;
+				hurt = -self->enemy->gib_health + max(0, self->enemy->health);
 			else
 				hurt = 500;
 
 			T_Damage(self->enemy, self, self, vec3_origin, self->enemy->s.origin,
 					 pain_normal, hurt, 0, DAMAGE_NONE, MOD_UNKNOWN);
 		}
-	}
-	// clean up self
-
-	// clean up target
-	cleanupHeal(self, change_frame);
+
+		cleanupHeal(self);
+	}
 
 	self->monsterinfo.aiflags &= ~AI_MEDIC;
 	self->monsterinfo.medicTries = 0;
+}
+
+bool finishHeal(edict_t *self)
+{
+	edict_t *healee = self->enemy;
+
+	healee->spawnflags = SPAWNFLAG_NONE;
+	healee->monsterinfo.aiflags &= AI_RESPAWN_MASK;
+	healee->target = nullptr;
+	healee->targetname = nullptr;
+	healee->combattarget = nullptr;
+	healee->deathtarget = nullptr;
+	healee->healthtarget = nullptr;
+	healee->itemtarget = nullptr;
+	healee->monsterinfo.healer = self;
+
+	vec3_t maxs = healee->maxs;
+	maxs[2] += 48; // compensate for change when they die
+
+	trace_t tr = gi.trace(healee->s.origin, healee->mins, maxs, healee->s.origin, healee, MASK_MONSTERSOLID);
+
+	if (tr.startsolid || tr.allsolid)
+	{
+		abortHeal(self, true, false);
+		return false;
+	}
+	else if (tr.ent != world)
+	{
+		abortHeal(self, true, false);
+		return false;
+	}
+
+	healee->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT;
+
+	// backup & restore health stuff, because of multipliers
+	int32_t old_max_health = healee->max_health;
+	item_id_t old_power_armor_type = healee->monsterinfo.initial_power_armor_type;
+	int32_t old_power_armor_power = healee->monsterinfo.max_power_armor_power;
+	int32_t old_base_health = healee->monsterinfo.base_health;
+	int32_t old_health_scaling = healee->monsterinfo.health_scaling;
+	auto reinforcements = healee->monsterinfo.reinforcements;
+	int32_t slots_from_commander = healee->monsterinfo.slots_from_commander;
+	int32_t monster_slots = healee->monsterinfo.monster_slots;
+	int32_t monster_used = healee->monsterinfo.monster_used;
+	int32_t old_gib_health = healee->gib_health;
+
+	spawn_temp_t st {};
+	st.keys_specified.emplace("reinforcements");
+	st.reinforcements = "";
+
+	ED_CallSpawn(healee, st);
+
+	healee->monsterinfo.slots_from_commander = slots_from_commander;
+	healee->monsterinfo.reinforcements = reinforcements;
+	healee->monsterinfo.monster_slots = monster_slots;
+	healee->monsterinfo.monster_used = monster_used;
+
+	healee->gib_health = old_gib_health / 2;
+	healee->health = healee->max_health = old_max_health;
+	healee->monsterinfo.power_armor_power = healee->monsterinfo.max_power_armor_power = old_power_armor_power;
+	healee->monsterinfo.power_armor_type = healee->monsterinfo.initial_power_armor_type = old_power_armor_type;
+	healee->monsterinfo.base_health = old_base_health;
+	healee->monsterinfo.health_scaling = old_health_scaling;
+
+	if (healee->monsterinfo.setskin)
+		healee->monsterinfo.setskin(healee);
+
+	if (healee->think)
+	{
+		healee->nextthink = level.time;
+		healee->think(healee);
+	}
+	healee->monsterinfo.aiflags &= ~AI_RESURRECTING;
+	healee->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT;
+	// turn off flies
+	healee->s.effects &= ~EF_FLIES;
+	healee->monsterinfo.healer = nullptr;
+
+	// switch our enemy
+	fixHealerEnemy(self);
+
+	// switch revivee's enemy
+	healee->oldenemy = nullptr;
+	healee->enemy = self->enemy;
+
+	if (healee->enemy)
+		FoundTarget(healee);
+	else
+	{
+		healee->enemy = nullptr;
+		if (!FindTarget(healee))
+		{
+			// no valid enemy, so stop acting
+			healee->monsterinfo.pausetime = HOLD_FOREVER;
+			healee->monsterinfo.stand(healee);
+		}
+	}
+
+	cleanupHeal(self);
+	return true;
 }
 
 bool canReach(edict_t *self, edict_t *other)
@@ -251,19 +349,10 @@
 	return trace.fraction == 1.0f || trace.ent == other;
 }
 
-edict_t *medic_FindDeadMonster(edict_t *self)
-{
-	float	 radius;
+edict_t *healFindMonster(edict_t *self, float radius)
+{
 	edict_t *ent = nullptr;
 	edict_t *best = nullptr;
-
-	if (self->monsterinfo.react_to_damage_time > level.time)
-		return nullptr;
-
-	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
-		radius = MEDIC_MAX_HEAL_DISTANCE;
-	else
-		radius = 1024;
 
 	while ((ent = findradius(ent, self->s.origin, radius)) != nullptr)
 	{
@@ -305,6 +394,23 @@
 		best = ent;
 	}
 
+	return best;
+}
+
+edict_t *medic_FindDeadMonster(edict_t *self)
+{
+	float	 radius;
+
+	if (self->monsterinfo.react_to_damage_time > level.time)
+		return nullptr;
+
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		radius = MEDIC_MAX_HEAL_DISTANCE;
+	else
+		radius = 1024;
+
+	edict_t *best = healFindMonster(self, radius);
+
 	if (best)
 		self->timestamp = level.time + MEDIC_TRY_TIME;
 
@@ -603,7 +709,7 @@
 	if (self->monsterinfo.aiflags & AI_DUCKED)
 		monster_duck_up(self);
 
-	abortHeal(self, false, false, false);
+	abortHeal(self, false, false);
 }
 
 MONSTERINFO_SETSKIN(medic_setskin) (edict_t *self) -> void
@@ -855,7 +961,7 @@
 
 	if ((!self->enemy) || (!self->enemy->inuse) || (self->enemy->s.effects & EF_GIB))
 	{
-		abortHeal(self, false, false, false);
+		abortHeal(self, false, false);
 		return;
 	}
 
@@ -867,7 +973,7 @@
 	// abort it .. we got switched to someone else due to damage
 	if (self->enemy->health > 0)
 	{
-		abortHeal(self, false, false, false);
+		abortHeal(self, false, false);
 		return;
 	}
 
@@ -882,7 +988,8 @@
 	distance = dir.length();
 	if (distance < MEDIC_MIN_DISTANCE)
 	{
-		abortHeal(self, true, true, false);
+		abortHeal(self, true, false);
+		self->monsterinfo.nextframe = FRAME_attack52;
 		return;
 	}
 
@@ -894,14 +1001,17 @@
 			// give up on second try
 			if (self->monsterinfo.medicTries > 1)
 			{
-				abortHeal(self, true, false, true);
+				abortHeal(self, false, true);
+				self->monsterinfo.nextframe = FRAME_attack52;
 				return;
 			}
 			self->monsterinfo.medicTries++;
-			cleanupHeal(self, 1);
+			cleanupHeal(self);
+			self->monsterinfo.nextframe = FRAME_attack52;
 			return;
 		}
-		abortHeal(self, true, false, false);
+		abortHeal(self, false, false);
+		self->monsterinfo.nextframe = FRAME_attack52;
 		return;
 	}
 
@@ -919,106 +1029,10 @@
 	}
 	else if (self->s.frame == FRAME_attack50)
 	{
-		vec3_t maxs;
-		self->enemy->spawnflags = SPAWNFLAG_NONE;
-		self->enemy->monsterinfo.aiflags &= AI_STINKY | AI_SPAWNED_MASK;
-		self->enemy->target = nullptr;
-		self->enemy->targetname = nullptr;
-		self->enemy->combattarget = nullptr;
-		self->enemy->deathtarget = nullptr;
-		self->enemy->healthtarget = nullptr;
-		self->enemy->itemtarget = nullptr;
-		self->enemy->monsterinfo.healer = self;
-
-		maxs = self->enemy->maxs;
-		maxs[2] += 48; // compensate for change when they die
-
-		tr = gi.trace(self->enemy->s.origin, self->enemy->mins, maxs, self->enemy->s.origin, self->enemy, MASK_MONSTERSOLID);
-
-		if (tr.startsolid || tr.allsolid)
-		{
-			abortHeal(self, true, true, false);
-			return;
-		}
-		else if (tr.ent != world)
-		{
-			abortHeal(self, true, true, false);
-			return;
-		}
-		else
-		{
-			self->enemy->monsterinfo.aiflags |= AI_DO_NOT_COUNT;
-
-			// backup & restore health stuff, because of multipliers
-			int32_t old_max_health = self->enemy->max_health;
-			item_id_t old_power_armor_type = self->enemy->monsterinfo.initial_power_armor_type;
-			int32_t old_power_armor_power = self->enemy->monsterinfo.max_power_armor_power;
-			int32_t old_base_health = self->enemy->monsterinfo.base_health;
-			int32_t old_health_scaling = self->enemy->monsterinfo.health_scaling;
-			auto reinforcements = self->enemy->monsterinfo.reinforcements;
-			int32_t monster_slots = self->enemy->monsterinfo.monster_slots;
-			int32_t monster_used = self->enemy->monsterinfo.monster_used;
-			int32_t old_gib_health = self->enemy->gib_health;
-
-			st = {};
-			st.keys_specified.emplace("reinforcements");
-			st.reinforcements = "";
-
-			ED_CallSpawn(self->enemy);
-
-			self->enemy->monsterinfo.reinforcements = reinforcements;
-			self->enemy->monsterinfo.monster_slots = monster_slots;
-			self->enemy->monsterinfo.monster_used = monster_used;
-
-			self->enemy->gib_health = old_gib_health / 2;
-			self->enemy->health = self->enemy->max_health = old_max_health;
-			self->enemy->monsterinfo.power_armor_power = self->enemy->monsterinfo.max_power_armor_power = old_power_armor_power;
-			self->enemy->monsterinfo.power_armor_type = self->enemy->monsterinfo.initial_power_armor_type = old_power_armor_type;
-			self->enemy->monsterinfo.base_health = old_base_health;
-			self->enemy->monsterinfo.health_scaling = old_health_scaling;
-
-			if (self->enemy->monsterinfo.setskin)
-				self->enemy->monsterinfo.setskin(self->enemy);
-
-			if (self->enemy->think)
-			{
-				self->enemy->nextthink = level.time;
-				self->enemy->think(self->enemy);
-			}
-			self->enemy->monsterinfo.aiflags &= ~AI_RESURRECTING;
-			self->enemy->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT;
-			// turn off flies
-			self->enemy->s.effects &= ~EF_FLIES;
-			self->enemy->monsterinfo.healer = nullptr;
-
-			if ((self->oldenemy) && (self->oldenemy->inuse) && (self->oldenemy->health > 0))
-			{
-				self->enemy->enemy = self->oldenemy;
-				FoundTarget(self->enemy);
-			}
-			else
-			{
-				self->enemy->enemy = nullptr;
-				if (!FindTarget(self->enemy))
-				{
-					// no valid enemy, so stop acting
-					self->enemy->monsterinfo.pausetime = HOLD_FOREVER;
-					self->enemy->monsterinfo.stand(self->enemy);
-				}
-				self->enemy = nullptr;
-				self->oldenemy = nullptr;
-				if (!FindTarget(self))
-				{
-					// no valid enemy, so stop acting
-					self->monsterinfo.pausetime = HOLD_FOREVER;
-					self->monsterinfo.stand(self);
-					return;
-				}
-			}
-
-			cleanupHeal(self, false);
-			return;
-		}
+		if (!finishHeal(self))
+			self->monsterinfo.nextframe = FRAME_attack52;
+
+		return;
 	}
 	else
 	{
@@ -1055,24 +1069,7 @@
 		gi.sound(self, CHAN_WEAPON, sound_hook_retract, 1, ATTN_NORM, 0);
 
 	self->monsterinfo.aiflags &= ~AI_MEDIC;
-
-	if (self->oldenemy && self->oldenemy->inuse && self->oldenemy->health > 0)
-	{
-		self->enemy = self->oldenemy;
-		HuntTarget(self, false);
-	}
-	else
-	{
-		self->enemy = self->goalentity = nullptr;
-		self->oldenemy = nullptr;
-		if (!FindTarget(self))
-		{
-			// no valid enemy, so stop acting
-			self->monsterinfo.pausetime = HOLD_FOREVER;
-			self->monsterinfo.stand(self);
-			return;
-		}
-	}
+	fixHealerEnemy(self);
 }
 
 mframe_t medic_frames_attackCable[] = {
@@ -1285,9 +1282,9 @@
 			ent->think(ent);
 		}
 
-		ent->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT | AI_SPAWNED_MEDIC_C;
+		ent->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT | AI_SPAWNED_COMMANDER | AI_SPAWNED_NEEDS_GIB;
 		ent->monsterinfo.commander = self;
-		ent->monsterinfo.monster_slots = reinforcement.strength;
+		ent->monsterinfo.slots_from_commander = reinforcement.strength;
 		self->monsterinfo.monster_used += reinforcement.strength;
 
 		if (self->monsterinfo.aiflags & AI_MEDIC)
@@ -1395,14 +1392,16 @@
 		// if our target went away
 		if ((!self->enemy) || (!self->enemy->inuse))
 		{
-			abortHeal(self, true, false, false);
+			abortHeal(self, false, false);
+			self->monsterinfo.nextframe = FRAME_attack52;
 			return false;
 		}
 
 		// if we ran out of time, give up
 		if (self->timestamp < level.time)
 		{
-			abortHeal(self, true, false, true);
+			abortHeal(self, false, true);
+			self->monsterinfo.nextframe = FRAME_attack52;
 			self->timestamp = 0_ms;
 			return false;
 		}
@@ -1508,6 +1507,8 @@
 */
 void SP_monster_medic(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_move.cpp	2023-10-03 19:43:06
+++ b/m_move.cpp	2024-10-20 11:28:53
@@ -184,7 +184,7 @@
 		phi = acos(frandom());
 	// non-buzzards pick a level around the center
 	else
-		phi = acos(crandom() * 0.06f);
+		phi = acos(frandom() * 0.7f);
 
     vec3_t d {
 		sin(phi) * cos(theta),
@@ -273,6 +273,8 @@
 	else
 		wanted_pos = (towards_origin + (towards_velocity * 0.25f)) + ent->monsterinfo.fly_ideal_position;
 
+	//gi.Draw_Point(wanted_pos, 8.0f, rgba_red, gi.frame_time_s, true);
+
 	// find a place we can fit in from here
 	trace_t tr = gi.trace(towards_origin, { -8.f, -8.f, -8.f }, { 8.f, 8.f, 8.f }, wanted_pos, ent, MASK_SOLID | CONTENTS_MONSTERCLIP);
 
@@ -337,9 +339,10 @@
 	// the closer we are to zero, the more we can change dir.
 	// if we're pushed past our max speed we shouldn't
 	// turn at all.
+	bool following_paths = ent->monsterinfo.aiflags & (AI_PATHING | AI_COMBAT_POINT | AI_LOST_SIGHT);
 	float turn_factor;
 			
-	if (((ent->monsterinfo.fly_thrusters && !ent->monsterinfo.fly_pinned) || ent->monsterinfo.aiflags & (AI_PATHING | AI_COMBAT_POINT | AI_LOST_SIGHT)) && dir.dot(wanted_dir) > 0.0f)
+	if (((ent->monsterinfo.fly_thrusters && !ent->monsterinfo.fly_pinned) || following_paths) && dir.dot(wanted_dir) > 0.0f)
 		turn_factor = 0.45f;
 	else
 		turn_factor = min(1.f, 0.84f + (0.08f * (current_speed / ent->monsterinfo.fly_speed)));
@@ -385,11 +388,18 @@
 	// the closer we are to the wanted position, we want to slow
 	// down so we don't fly past it.
 	float speed_factor;
-		
-	if (!ent->enemy || (ent->monsterinfo.fly_thrusters && !ent->monsterinfo.fly_pinned) || (ent->monsterinfo.aiflags & (AI_PATHING | AI_COMBAT_POINT | AI_LOST_SIGHT)))
-		speed_factor = 1.f;
-	else if (aim_fwd.dot(wanted_dir) < -0.25 && dir)
-		speed_factor = 0.f;
+	
+	//gi.Draw_Ray(ent->s.origin, aim_fwd, 16.0f, 8.0f, rgba_green, gi.frame_time_s, true);
+	//gi.Draw_Ray(ent->s.origin, final_dir, 16.0f, 8.0f, rgba_blue, gi.frame_time_s, true);
+	if (!ent->enemy || (ent->monsterinfo.fly_thrusters && !ent->monsterinfo.fly_pinned) || following_paths)
+	{
+		// Paril: only do this correction if we are following paths. we want to move backwards
+		// away from players.
+		if (following_paths && dir && wanted_dir.dot(dir) < -0.25)
+			speed_factor = 0.f;
+		else
+			speed_factor = 1.f;
+	}
 	else
 		speed_factor = min(1.f, dist_to_wanted / ent->monsterinfo.fly_speed);
 
@@ -1171,8 +1181,13 @@
 	vec3_t &path_to = (self->monsterinfo.nav_path.returnCode == PathReturnCode::TraversalPending) ?
 		self->monsterinfo.nav_path.secondMovePoint : self->monsterinfo.nav_path.firstMovePoint;
 
-	if ((self->monsterinfo.nav_path.returnCode != PathReturnCode::TraversalPending && (path_to - self->s.origin).length() <= (self->size.length() * 0.5f)) ||
-		self->monsterinfo.nav_path_cache_time <= level.time)
+	vec3_t ground_origin = self->s.origin + vec3_t { 0.f, 0.f, self->mins[2] } - vec3_t { 0.f, 0.f, PLAYER_MINS[2] };
+	vec3_t mon_mins = ground_origin + PLAYER_MINS;
+	vec3_t mon_maxs = ground_origin + PLAYER_MAXS;
+
+	if (self->monsterinfo.nav_path_cache_time <= level.time ||
+		(self->monsterinfo.nav_path.returnCode != PathReturnCode::TraversalPending &&
+		boxes_intersect(mon_mins, mon_maxs, path_to, path_to)))
 	{
 		PathRequest request;
 		if (self->enemy)
@@ -1184,6 +1199,15 @@
 			request.debugging.drawTime = gi.frame_time_s;
 		request.start = self->s.origin;
 		request.pathFlags = PathFlags::Walk;
+		
+		request.nodeSearch.minHeight = -(self->mins.z * 2);
+		request.nodeSearch.maxHeight = (self->maxs.z * 2);
+
+		// FIXME remove hardcoding
+		if (!strcmp(self->classname, "monster_guardian"))
+		{
+			request.nodeSearch.radius = 2048.f;
+		}
 
 		if (self->monsterinfo.can_jump || (self->flags & FL_FLY))
 		{
--- a/m_mutant.cpp	2023-10-03 19:43:06
+++ b/m_mutant.cpp	2024-09-24 14:08:05
@@ -674,6 +674,8 @@
 */
 void SP_monster_mutant(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_parasite.cpp	2023-10-03 19:43:06
+++ b/m_parasite.cpp	2024-09-24 14:09:16
@@ -904,6 +904,8 @@
  */
 void SP_monster_parasite(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_shambler.cpp	2023-10-03 19:43:06
+++ b/m_shambler.cpp	2024-09-24 14:09:16
@@ -546,6 +546,8 @@
 
 void SP_monster_shambler(edict_t* self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_soldier.cpp	2023-10-03 19:43:06
+++ b/m_soldier.cpp	2024-10-20 16:46:42
@@ -23,23 +23,62 @@
 static cached_soundindex sound_death_ss;
 static cached_soundindex sound_cock;
 
-void soldier_start_charge(edict_t *self)
+struct soldier_style_t
+{
+	enum weapon_t
+	{
+		Blaster,
+		Shotgun,
+		Machinegun,
+		Ripper,
+		BlueHyper,
+		Laser
+	};
+
+	weapon_t weapon;
+
+	constexpr soldier_style_t(edict_t *self) :
+		weapon((weapon_t) ((self->count / 2) + (self->style * 3)))
+	{
+	}
+	
+	// is ripper, bluehyper or laser
+	constexpr bool is_xatrix() { return weapon >= Ripper; }
+	// is blaster, shotgun or machinegun
+	constexpr bool is_vanilla() { return weapon < Ripper; }
+	
+	// is blaster or ripper
+	constexpr bool is_light() { return weapon == Blaster || weapon == Ripper; }
+	// is shotgun or bluehyper
+	constexpr bool is_blitz() { return weapon == Shotgun || weapon == BlueHyper; }
+	// is machinegun or laser
+	constexpr bool is_sustain() { return weapon == Machinegun || weapon == Laser; }
+	
+	constexpr bool has_blaster() { return weapon == Blaster; }
+	constexpr bool has_shotgun() { return weapon == Shotgun; }
+	constexpr bool has_machinegun() { return weapon == Machinegun; }
+	constexpr bool has_ripper() { return weapon == Ripper; }
+	constexpr bool has_bluehyper() { return weapon == BlueHyper; }
+	constexpr bool has_laser() { return weapon == Laser; }
+};
+
+static void soldier_start_charge(edict_t *self)
 {
 	self->monsterinfo.aiflags |= AI_CHARGING;
 }
 
-void soldier_stop_charge(edict_t *self)
+static void soldier_stop_charge(edict_t *self)
 {
 	self->monsterinfo.aiflags &= ~AI_CHARGING;
 }
 
-void soldier_idle(edict_t *self)
+static void soldier_idle(edict_t *self)
 {
 	if (frandom() > 0.8f)
 		gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
 }
 
-void soldier_cock(edict_t *self)
+static void soldier_cock(edict_t *self)
 {
 	if (self->s.frame == FRAME_stand322)
 		gi.sound(self, CHAN_WEAPON, sound_cock, 1, ATTN_IDLE, 0);
@@ -51,20 +90,17 @@
 }
 
 // RAFAEL
-void soldierh_hyper_laser_sound_start(edict_t *self)
-{
-	if (self->style == 1)
-	{
-		if (self->count >= 2 && self->count < 4)
-			self->monsterinfo.weapon_sound = gi.soundindex("weapons/hyprbl1a.wav");
-	}
-}
-
-void soldierh_hyper_laser_sound_end(edict_t *self)
+static void soldierh_hyper_sound_start(edict_t *self)
+{
+	if (soldier_style_t(self).has_bluehyper())
+		self->monsterinfo.weapon_sound = gi.soundindex("weapons/hyprbl1a.wav");
+}
+
+static void soldierh_hyper_sound_end(edict_t *self)
 {
 	if (self->monsterinfo.weapon_sound)
 	{
-		if (self->count >= 2 && self->count < 4)
+		if (soldier_style_t(self).has_bluehyper())
 			gi.sound(self, CHAN_AUTO, gi.soundindex("weapons/hyprbd1a.wav"), 1, ATTN_NORM, 0);
 
 		self->monsterinfo.weapon_sound = 0;
@@ -215,7 +251,7 @@
 		M_SetAnimation(self, &soldier_move_stand2);
 	else
 		M_SetAnimation(self, &soldier_move_stand3);
-	soldierh_hyper_laser_sound_end(self);
+	soldierh_hyper_sound_end(self);
 }
 
 //
@@ -313,7 +349,7 @@
 MONSTERINFO_RUN(soldier_run) (edict_t *self) -> void
 {
 	monster_done_dodge(self);
-	soldierh_hyper_laser_sound_end(self);
+	soldierh_hyper_sound_end(self);
 
 	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
 	{
@@ -404,7 +440,6 @@
 PAIN(soldier_pain) (edict_t *self, edict_t *other, float kick, int damage, const mod_t &mod) -> void
 {
 	float r;
-	int	  n;
 
 	monster_done_dodge(self);
 	soldier_stop_charge(self);
@@ -420,17 +455,18 @@
 			if (self->monsterinfo.aiflags & AI_DUCKED)
 				monster_duck_up(self);
 			M_SetAnimation(self, &soldier_move_pain4);
-			soldierh_hyper_laser_sound_end(self);
+			soldierh_hyper_sound_end(self);
 		}
 		return;
 	}
 
 	self->pain_debounce_time = level.time + 3_sec;
 
-	n = self->count | 1;
-	if (n == 1)
+	soldier_style_t style(self);
+
+	if (style.is_light())
 		gi.sound(self, CHAN_VOICE, sound_pain_light, 1, ATTN_NORM, 0);
-	else if (n == 3)
+	else if (style.is_blitz())
 		gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
 	else
 		gi.sound(self, CHAN_VOICE, sound_pain_ss, 1, ATTN_NORM, 0);
@@ -441,7 +477,7 @@
 		if (self->monsterinfo.aiflags & AI_DUCKED)
 			monster_duck_up(self);
 		M_SetAnimation(self, &soldier_move_pain4);
-		soldierh_hyper_laser_sound_end(self);
+		soldierh_hyper_sound_end(self);
 		return;
 	}
 	
@@ -460,7 +496,7 @@
 	// PMM - clear duck flag
 	if (self->monsterinfo.aiflags & AI_DUCKED)
 		monster_duck_up(self);
-	soldierh_hyper_laser_sound_end(self);
+	soldierh_hyper_sound_end(self);
 }
 
 MONSTERINFO_SETSKIN(soldier_setskin) (edict_t *self) -> void
@@ -479,7 +515,43 @@
 constexpr monster_muzzleflash_id_t shotgun_flash[] = { MZ2_SOLDIER_SHOTGUN_1, MZ2_SOLDIER_SHOTGUN_2, MZ2_SOLDIER_SHOTGUN_3, MZ2_SOLDIER_SHOTGUN_4, MZ2_SOLDIER_SHOTGUN_5, MZ2_SOLDIER_SHOTGUN_6, MZ2_SOLDIER_SHOTGUN_7, MZ2_SOLDIER_SHOTGUN_8, MZ2_SOLDIER_SHOTGUN_9 };
 constexpr monster_muzzleflash_id_t machinegun_flash[] = { MZ2_SOLDIER_MACHINEGUN_1, MZ2_SOLDIER_MACHINEGUN_2, MZ2_SOLDIER_MACHINEGUN_3, MZ2_SOLDIER_MACHINEGUN_4, MZ2_SOLDIER_MACHINEGUN_5, MZ2_SOLDIER_MACHINEGUN_6, MZ2_SOLDIER_MACHINEGUN_7, MZ2_SOLDIER_MACHINEGUN_8, MZ2_SOLDIER_MACHINEGUN_9 };
 
-void soldier_fire_vanilla(edict_t *self, int flash_number, bool angle_limited)
+PRETHINK(soldierh_laser_update) (edict_t *laser) -> void
+{
+	edict_t *self = laser->owner;
+
+	vec3_t forward, right, up;
+	vec3_t start;
+	vec3_t tempvec;
+
+	AngleVectors(self->s.angles, forward, right, up);
+	start = self->s.origin;
+	tempvec = monster_flash_offset[self->radius_dmg];
+	start += (forward * tempvec[0]);
+	start += (right * tempvec[1]);
+	start += (up * (tempvec[2] + 6));
+
+	if (!self->deadflag)
+		PredictAim(self, self->enemy, start, 0, false, frandom(0.1f, 0.2f), &forward, nullptr);
+	
+	laser->s.origin = start;
+	laser->movedir = forward;
+	gi.linkentity(laser);
+	dabeam_update(laser, false);
+}
+
+// RAFAEL
+void soldierh_laserbeam(edict_t *self, int flash_index)
+{
+	self->radius_dmg = flash_index;
+	monster_fire_dabeam(self, 1, false, soldierh_laser_update);
+}
+
+constexpr monster_muzzleflash_id_t ripper_flash[] = { MZ2_SOLDIER_RIPPER_1, MZ2_SOLDIER_RIPPER_2, MZ2_SOLDIER_RIPPER_3, MZ2_SOLDIER_RIPPER_4, MZ2_SOLDIER_RIPPER_5, MZ2_SOLDIER_RIPPER_6, MZ2_SOLDIER_RIPPER_7, MZ2_SOLDIER_RIPPER_8, MZ2_SOLDIER_RIPPER_9 };
+constexpr monster_muzzleflash_id_t hyper_flash[] = { MZ2_SOLDIER_HYPERGUN_1, MZ2_SOLDIER_HYPERGUN_2, MZ2_SOLDIER_HYPERGUN_3, MZ2_SOLDIER_HYPERGUN_4, MZ2_SOLDIER_HYPERGUN_5, MZ2_SOLDIER_HYPERGUN_6, MZ2_SOLDIER_HYPERGUN_7, MZ2_SOLDIER_HYPERGUN_8, MZ2_SOLDIER_HYPERGUN_9 };
+
+bool M_AdjustBlindfireTarget(edict_t *self, const vec3_t &start, const vec3_t &target, const vec3_t &right, vec3_t &out_dir);
+
+void soldier_fire(edict_t *self, int flash_number, bool angle_limited)
 {
 	vec3_t					 start;
 	vec3_t					 forward, right, up;
@@ -492,10 +564,16 @@
 	float					 angle;
 	vec3_t					 aim_good;
 
-	if (self->count < 2)
+	soldier_style_t style(self);
+
+	if (style.has_blaster())
 		flash_index = blaster_flash[flash_number];
-	else if (self->count < 4)
+	else if (style.has_shotgun())
 		flash_index = shotgun_flash[flash_number];
+	else if (style.has_ripper())
+		flash_index = ripper_flash[flash_number];
+	else if (style.has_bluehyper())
+		flash_index = hyper_flash[flash_number];
 	else
 		flash_index = machinegun_flash[flash_number];
 
@@ -503,143 +581,6 @@
 	start = M_ProjectFlashSource(self, monster_flash_offset[flash_index], forward, right);
 
 	if (flash_number == 5 || flash_number == 6) // he's dead
-	{
-		if (self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
-			return;
-
-		aim = forward;
-	}
-	else
-	{
-		if ((!self->enemy) || (!self->enemy->inuse))
-		{
-			self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
-			return;
-		}
-
-		// PMM
-		if (self->monsterinfo.attack_state == AS_BLIND)
-			end = self->monsterinfo.blind_fire_target;
-		else
-			end = self->enemy->s.origin;
-		// pmm
-		end[2] += self->enemy->viewheight;
-		aim = end - start;
-		aim_good = end;
-		// PMM
-		if (angle_limited)
-		{
-			aim_norm = aim;
-			aim_norm.normalize();
-			angle = aim_norm.dot(forward);
-			if (angle < 0.5f) // ~25 degree angle
-			{
-				if (level.time >= self->monsterinfo.fire_wait)
-					self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
-				else
-					self->monsterinfo.aiflags |= AI_HOLD_FRAME;
-
-				return;
-			}
-		}
-		//-PMM
-		dir = vectoangles(aim);
-		AngleVectors(dir, forward, right, up);
-
-		r = crandom() * 1000;
-		u = crandom() * 500;
-
-		end = start + (forward * 8192);
-		end += (right * r);
-		end += (up * u);
-
-		aim = end - start;
-		aim.normalize();
-	}
-
-	if (self->count <= 1)
-	{
-		monster_fire_blaster(self, start, aim, 5, 600, flash_index, EF_BLASTER);
-	}
-	else if (self->count <= 3)
-	{
-		monster_fire_shotgun(self, start, aim, 2, 1, 1500, 750, 9, flash_index);
-		// [Paril-KEX] indicates to soldier that he must cock
-		self->dmg = 1;
-	}
-	else
-	{
-		// PMM - changed to wait from pausetime to not interfere with dodge code
-		if (!(self->monsterinfo.aiflags & AI_HOLD_FRAME))
-			self->monsterinfo.fire_wait = level.time + random_time(300_ms, 1.1_sec);
-
-		monster_fire_bullet(self, start, aim, 2, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_index);
-
-		if (level.time >= self->monsterinfo.fire_wait)
-			self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
-		else
-			self->monsterinfo.aiflags |= AI_HOLD_FRAME;
-	}
-}
-
-PRETHINK(soldierh_laser_update) (edict_t *laser) -> void
-{
-	edict_t *self = laser->owner;
-
-	vec3_t forward, right, up;
-	vec3_t start;
-	vec3_t tempvec;
-
-	AngleVectors(self->s.angles, forward, right, up);
-	start = self->s.origin;
-	tempvec = monster_flash_offset[self->radius_dmg];
-	start += (forward * tempvec[0]);
-	start += (right * tempvec[1]);
-	start += (up * (tempvec[2] + 6));
-
-	if (!self->deadflag)
-		PredictAim(self, self->enemy, start, 0, false, frandom(0.1f, 0.2f), &forward, nullptr);
-	
-	laser->s.origin = start;
-	laser->movedir = forward;
-	gi.linkentity(laser);
-	dabeam_update(laser, false);
-}
-
-// RAFAEL
-void soldierh_laserbeam(edict_t *self, int flash_index)
-{
-	self->radius_dmg = flash_index;
-	monster_fire_dabeam(self, 1, false, soldierh_laser_update);
-}
-
-constexpr monster_muzzleflash_id_t ripper_flash[] = { MZ2_SOLDIER_RIPPER_1, MZ2_SOLDIER_RIPPER_2, MZ2_SOLDIER_RIPPER_3, MZ2_SOLDIER_RIPPER_4, MZ2_SOLDIER_RIPPER_5, MZ2_SOLDIER_RIPPER_6, MZ2_SOLDIER_RIPPER_7, MZ2_SOLDIER_RIPPER_8, MZ2_SOLDIER_RIPPER_9 };
-constexpr monster_muzzleflash_id_t hyper_flash[] = { MZ2_SOLDIER_HYPERGUN_1, MZ2_SOLDIER_HYPERGUN_2, MZ2_SOLDIER_HYPERGUN_3, MZ2_SOLDIER_HYPERGUN_4, MZ2_SOLDIER_HYPERGUN_5, MZ2_SOLDIER_HYPERGUN_6, MZ2_SOLDIER_HYPERGUN_7, MZ2_SOLDIER_HYPERGUN_8, MZ2_SOLDIER_HYPERGUN_9 };
-
-void soldier_fire_xatrix(edict_t *self, int flash_number, bool angle_limited)
-{
-	vec3_t					 start;
-	vec3_t					 forward, right, up;
-	vec3_t					 aim;
-	vec3_t					 dir;
-	vec3_t					 end;
-	float					 r, u;
-	monster_muzzleflash_id_t flash_index;
-	vec3_t					 aim_norm;
-	float					 angle;
-	vec3_t					 aim_good;
-
-	if (self->count < 2)
-		flash_index = ripper_flash[flash_number]; // ripper
-	else if (self->count < 4)
-		flash_index = hyper_flash[flash_number]; // hyperblaster
-	else
-		flash_index = machinegun_flash[flash_number]; // laserbeam
-
-	AngleVectors(self->s.angles, forward, right, nullptr);
-	start = M_ProjectFlashSource(self, monster_flash_offset[flash_index], forward, right);
-
-	if (flash_number == 5 || flash_number == 6)
 	{
 		if (self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
 			return;
@@ -656,7 +597,7 @@
 		}
 
 		// PMM
-		if (self->monsterinfo.attack_state == AS_BLIND)
+		if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
 			end = self->monsterinfo.blind_fire_target;
 		else
 			end = self->enemy->s.origin;
@@ -665,6 +606,9 @@
 
 		aim = end - start;
 		aim_good = end;
+
+		if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+			M_AdjustBlindfireTarget(self, start, end, right, dir);
 
 		// PMM
 		if (angle_limited)
@@ -688,8 +632,14 @@
 		dir = vectoangles(aim);
 		AngleVectors(dir, forward, right, up);
 
-		r = crandom() * 100;
-		u = crandom() * 50;
+		r = crandom() * 1000;
+		u = crandom() * 500;
+		
+		if (style.is_xatrix())
+		{
+			r /= 10;
+			u /= 10;
+		}
 		end = start + (forward * 8192);
 		end += (right * r);
 		end += (up * u);
@@ -698,15 +648,25 @@
 		aim.normalize();
 	}
 
-	if (self->count <= 1)
+	if (style.has_ripper())
 	{
 		// RAFAEL 24-APR-98
 		// droped the damage from 15 to 5
 		monster_fire_ionripper(self, start, aim, 5, 600, flash_index, EF_IONRIPPER);
 	}
-	else if (self->count <= 3)
+	else if (style.has_bluehyper())
 	{
 		monster_fire_blueblaster(self, start, aim, 1, 600, flash_index, EF_BLUEHYPERBLASTER);
+	}
+	else if (style.has_blaster())
+	{
+		monster_fire_blaster(self, start, aim, 5, 600, flash_index, EF_BLASTER);
+	}
+	else if (style.has_shotgun())
+	{
+		monster_fire_shotgun(self, start, aim, 2, 1, 1500, 750, 9, flash_index);
+		// [Paril-KEX] indicates to soldier that he must cock
+		self->dmg = 1;
 	}
 	else
 	{
@@ -714,25 +674,22 @@
 		if (!(self->monsterinfo.aiflags & AI_HOLD_FRAME))
 			self->monsterinfo.fire_wait = level.time + random_time(300_ms, 1.1_sec);
 
-		soldierh_laserbeam(self, flash_index);
+		if (style.has_laser())
+			soldierh_laserbeam(self, flash_index);
+		else
+			monster_fire_bullet(self, start, aim, 2, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_index);
 
 		if (level.time >= self->monsterinfo.fire_wait)
+		{
 			self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+			
+			if (self->s.frame == FRAME_attak303)
+				self->monsterinfo.nextframe = FRAME_attak306;
+		}
 		else
 			self->monsterinfo.aiflags |= AI_HOLD_FRAME;
 	}
 }
-// RAFAEL
-
-void soldier_fire(edict_t *self, int flash_number, bool angle_limited)
-{
-	// RAFAEL
-	if (self->style == 1)
-		soldier_fire_xatrix(self, flash_number, angle_limited);
-	else
-		// RAFAEL
-		soldier_fire_vanilla(self, flash_number, angle_limited);
-}
 
 // ATTACK1 (blaster/shotgun)
 
@@ -743,8 +700,10 @@
 
 void soldier_attack1_refire1(edict_t *self)
 {
+	soldier_style_t style(self);
+
 	// [Paril-KEX]
-	if (self->count <= 0)
+	if (style.is_light())
 		self->monsterinfo.nextframe = FRAME_attak110;
 
 	// PMM - blindfire
@@ -758,7 +717,7 @@
 	if (!self->enemy)
 		return;
 
-	if (self->count > 1)
+	if (!style.is_light())
 		return;
 
 	if (self->enemy->health <= 0)
@@ -774,8 +733,8 @@
 {
 	if (!self->enemy)
 		return;
-
-	if (self->count < 2)
+	
+	if (soldier_style_t(self).is_light())
 		return;
 
 	if (self->enemy->health <= 0)
@@ -828,8 +787,10 @@
 {
 	if (!self->enemy)
 		return;
-
-	if (self->count >= 2 && self->count < 4)
+	
+	soldier_style_t style(self);
+
+	if (style.has_bluehyper())
 	{
 		if (frandom() < 0.7f && visible(self, self->enemy))
 			self->s.frame = FRAME_attak103;
@@ -838,13 +799,15 @@
 
 void soldierh_hyperripper1(edict_t *self)
 {
-	if (self->count < 4)
+	soldier_style_t style(self);
+
+	if (!style.is_sustain())
 		soldier_fire(self, 0, false);
 }
 
 mframe_t soldierh_frames_attack1[] = {
 	{ ai_charge, 0, soldier_blind_check },
-	{ ai_charge, 0, soldierh_hyper_laser_sound_start },
+	{ ai_charge, 0, soldierh_hyper_sound_start },
 	{ ai_charge, 0, soldier_fire1 },
 	{ ai_charge, 0, soldierh_hyperripper1 },
 	{ ai_charge, 0, soldierh_hyperripper1 },
@@ -852,7 +815,7 @@
 	{ ai_charge, 0, soldierh_hyper_refire1 },
 	{ ai_charge, 0, soldier_cock },
 	{ ai_charge, 0, soldier_attack1_refire2 },
-	{ ai_charge, 0, soldierh_hyper_laser_sound_end },
+	{ ai_charge, 0, soldierh_hyper_sound_end },
 	{ ai_charge },
 	{ ai_charge }
 };
@@ -867,13 +830,15 @@
 
 void soldier_attack2_refire1(edict_t *self)
 {
-	if (self->count <= 0)
+	soldier_style_t style(self);
+
+	if (style.is_light())
 		self->monsterinfo.nextframe = FRAME_attak216;
 
 	if (!self->enemy)
 		return;
 
-	if (self->count > 1)
+	if (!style.is_light())
 		return;
 
 	if (self->enemy->health <= 0)
@@ -887,15 +852,20 @@
 {
 	if (!self->enemy)
 		return;
-
-	if (self->count < 2)
+	
+	soldier_style_t style(self);
+
+	if (style.is_light())
 		return;
 
 	if (self->enemy->health <= 0)
 		return;
 
 	// RAFAEL
-	if (((self->radius_dmg || frandom() < 0.5f) && visible(self, self->enemy)) || ((self->style == 0 || self->count < 4) && (range_to(self, self->enemy) <= RANGE_MELEE)))
+	if (
+		((self->radius_dmg || frandom() < 0.5f) && visible(self, self->enemy)) ||
+		range_to(self, self->enemy) <= RANGE_MELEE
+	)
 	{
 		// RAFAEL
 		self->monsterinfo.nextframe = FRAME_attak204;
@@ -941,9 +911,7 @@
 	if (!self->enemy)
 		return;
 
-	if (self->count < 2)
-		return;
-	else if (self->count < 4)
+	if (soldier_style_t(self).is_blitz())
 	{
 		if (frandom() < 0.7f && visible(self, self->enemy))
 			self->s.frame = FRAME_attak205;
@@ -952,7 +920,9 @@
 
 void soldierh_hyperripper2(edict_t *self)
 {
-	if (self->count < 4)
+	soldier_style_t style(self);
+
+	if (!style.is_sustain())
 		soldier_fire(self, 1, false);
 }
 
@@ -960,7 +930,7 @@
 	{ ai_charge },
 	{ ai_charge },
 	{ ai_charge },
-	{ ai_charge, 0, soldierh_hyper_laser_sound_start },
+	{ ai_charge, 0, soldierh_hyper_sound_start },
 	{ ai_charge, 0, soldier_fire2 },
 	{ ai_charge, 0, soldierh_hyperripper2 },
 	{ ai_charge, 0, soldierh_hyperripper2 },
@@ -972,7 +942,7 @@
 	{ ai_charge, 0, soldier_cock },
 	{ ai_charge },
 	{ ai_charge, 0, soldier_attack2_refire2 },
-	{ ai_charge, 0, soldierh_hyper_laser_sound_end },
+	{ ai_charge, 0, soldierh_hyper_sound_end },
 	{ ai_charge },
 	{ ai_charge }
 };
@@ -987,7 +957,9 @@
 
 void soldierh_hyperripper3(edict_t *self)
 {
-	if (self->s.skinnum >= 6 && self->count < 4)
+	soldier_style_t style(self);
+
+	if (style.has_ripper() || style.has_bluehyper())
 		soldier_fire(self, 2, false);
 }
 
@@ -1001,13 +973,13 @@
 
 mframe_t soldier_frames_attack3[] = {
 	{ ai_charge, 0, monster_duck_down },
-	{ ai_charge, 0, soldierh_hyper_laser_sound_start },
+	{ ai_charge, 0, soldierh_hyper_sound_start },
 	{ ai_charge, 0, soldier_fire3 },
 	{ ai_charge, 0, soldierh_hyperripper3 },
 	{ ai_charge, 0, soldierh_hyperripper3 },
 	{ ai_charge, 0, soldier_attack3_refire },
 	{ ai_charge, 0, monster_duck_up },
-	{ ai_charge, 0, soldierh_hyper_laser_sound_end },
+	{ ai_charge, 0, soldierh_hyper_sound_end },
 	{ ai_charge }
 };
 MMOVE_T(soldier_move_attack3) = { FRAME_attak301, FRAME_attak309, soldier_frames_attack3, soldier_run };
@@ -1021,9 +993,9 @@
 
 mframe_t soldier_frames_attack4[] = {
 	{ ai_charge },
-	{ ai_charge, 0, soldierh_hyper_laser_sound_start },
+	{ ai_charge, 0, soldierh_hyper_sound_start },
 	{ ai_charge, 0, soldier_fire4 },
-	{ ai_charge, 0, soldierh_hyper_laser_sound_end },
+	{ ai_charge, 0, soldierh_hyper_sound_end },
 	{ ai_charge },
 	{ ai_charge }
 };
@@ -1044,8 +1016,10 @@
 
 	if (!self->enemy)
 		return;
-
-	if (self->count > 1)
+	
+	soldier_style_t style(self);
+
+	if (!style.is_light())
 		return;
 
 	if (self->enemy->health <= 0 ||
@@ -1067,15 +1041,17 @@
 	// PMM - make sure dodge & charge bits are cleared
 	monster_done_dodge(self);
 	soldier_stop_charge(self);
-
-	if (!self->enemy || self->count <= 0)
+	
+	soldier_style_t style(self);
+
+	if (!self->enemy || style.is_light())
 		return;
 
 	if (self->enemy->health <= 0 ||
 		(!self->radius_dmg && range_to(self, self->enemy) < RANGE_NEAR) ||
 		!visible(self, self->enemy)) // don't endlessly run into walls
 	{
-		soldierh_hyper_laser_sound_end(self);
+		soldierh_hyper_sound_end(self);
 		return;
 	}
 
@@ -1088,24 +1064,38 @@
 
 static void soldier_attack6_shotgun_check(edict_t *self)
 {
+	soldier_style_t style(self);
+
 	if (self->dmg)
 	{
 		self->monsterinfo.nextframe = FRAME_runs09;
 		// [Paril-KEX] indicate that we should force a refire
 		self->radius_dmg = 1;
 	}
+	// [Paril-KEX] don't let the shotgun guard fire immediately.
+	else if (style.has_shotgun())
+	{
+		if (!self->sounds)
+		{
+			self->sounds = 1;
+			self->radius_dmg = 1;
+			self->monsterinfo.nextframe = FRAME_runs09;
+		}
+	}
 }
 
 void soldierh_hyperripper8(edict_t *self)
 {
-	if (self->s.skinnum >= 6 && self->count < 4)
+	soldier_style_t style(self);
+
+	if (style.has_ripper() || style.has_bluehyper())
 		soldier_fire(self, 7, true);
 }
 
 mframe_t soldier_frames_attack6[] = {
 	{ ai_run, 10, soldier_start_charge },
 	{ ai_run, 4, soldier_attack6_shotgun_check },
-	{ ai_run, 12, soldierh_hyper_laser_sound_start },
+	{ ai_run, 12, soldierh_hyper_sound_start },
 	{ ai_run, 11, [](edict_t *self) { soldier_fire8(self); monster_footstep(self); } },
 	{ ai_run, 13, [](edict_t *self ) { soldierh_hyperripper8(self); monster_done_dodge(self); } },
 	{ ai_run, 18, soldierh_hyperripper8 },
@@ -1126,6 +1116,8 @@
 
 	monster_done_dodge(self);
 
+	soldier_style_t style(self);
+
 	// PMM - blindfire!
 	if (self->monsterinfo.attack_state == AS_BLIND)
 	{
@@ -1154,10 +1146,10 @@
 		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
 
 		// RAFAEL
-		if (self->style == 1)
+		if (style.is_xatrix())
 			M_SetAnimation(self, &soldierh_move_attack1);
 		else
-			// RAFAEL
+		// RAFAEL
 			M_SetAnimation(self, &soldier_move_attack1);
 		self->monsterinfo.attack_finished = level.time + random_time(1.5_sec, 2.5_sec);
 		return;
@@ -1172,21 +1164,21 @@
 
 	if ((!(self->monsterinfo.aiflags & (AI_BLOCKED | AI_STAND_GROUND))) &&
 		(r < 0.25f &&
-		(self->count <= 3)) &&
+		(style.is_light() || style.is_blitz())) &&
 		(range_to(self, self->enemy) >= (RANGE_NEAR * 0.5f)))
 	{
+		// [Paril-KEX] 
 		M_SetAnimation(self, &soldier_move_attack6);
+		self->sounds = 0;
 	}
 	else
 	{
-		if (self->count < 4)
+		if (style.is_light() || style.is_blitz())
 		{
-			bool attack1_possible;
+			bool attack1_possible = false;
 
 			// [Paril-KEX] shotgun guard only uses attack2 at close range
-			if ((!self->style && self->count >= 2 && self->count <= 3) && range_to(self, self->enemy) <= (RANGE_NEAR * 0.65f))
-				attack1_possible = false;
-			else
+			if (!style.has_shotgun() || range_to(self, self->enemy) > (RANGE_NEAR * 0.65f))
 				attack1_possible = M_CheckClearShot(self, monster_flash_offset[MZ2_SOLDIER_BLASTER_1]);
 			
 			bool attack2_possible = M_CheckClearShot(self, monster_flash_offset[MZ2_SOLDIER_BLASTER_2]);
@@ -1194,7 +1186,7 @@
 			if (attack1_possible && (!attack2_possible || frandom() < 0.5f))
 			{
 				// RAFAEL
-				if (self->style == 1)
+				if (style.is_xatrix())
 					M_SetAnimation(self, &soldierh_move_attack1);
 				else
 					// RAFAEL
@@ -1203,7 +1195,7 @@
 			else if (attack2_possible)
 			{
 				// RAFAEL
-				if (self->style == 1)
+				if (style.is_xatrix())
 					M_SetAnimation(self, &soldierh_move_attack2);
 				else
 					// RAFAEL
@@ -1228,22 +1220,22 @@
 	else
 		gi.sound(self, CHAN_VOICE, sound_sight2, 1, ATTN_NORM, 0);
 
-	if (self->enemy && (range_to(self, self->enemy) >= RANGE_NEAR) &&
+	soldier_style_t style(self);
+
+	if (self->enemy &&
+		(range_to(self, self->enemy) >= RANGE_NEAR) &&
 		visible(self, self->enemy) // Paril: don't run-shoot if we can't see them
 	)
 	{
 		// RAFAEL
-		if (self->style == 1 || frandom() > 0.75f)
+		if (style.is_xatrix() || frandom() > 0.75f)
 		// RAFAEL
 		{
-			// RAFAEL + legacy bug fix
-			// don't use run+shoot for machinegun/laser because
-			// the animation is a bit weird
-			if (self->count < 4)
+			if (!style.is_sustain())
+			{
 				M_SetAnimation(self, &soldier_move_attack6);
-			else if (M_CheckClearShot(self, monster_flash_offset[MZ2_SOLDIER_MACHINEGUN_4]))
-				// RAFAEL
-				M_SetAnimation(self, &soldier_move_attack4);
+				self->sounds = 0;
+			}
 		}
 	}
 }
@@ -1264,7 +1256,7 @@
 
 static void soldier_stand_up(edict_t *self)
 {
-	soldierh_hyper_laser_sound_end(self);
+	soldierh_hyper_sound_end(self);
 	M_SetAnimation(self, &soldier_move_trip, false);
 	self->monsterinfo.nextframe = FRAME_runt08;
 }
@@ -1307,7 +1299,9 @@
 
 void soldierh_hyperripper5(edict_t *self)
 {
-	if (self->style && self->count < 4)
+	soldier_style_t style(self);
+
+	if (style.has_ripper() || style.has_bluehyper())
 		soldier_fire(self, 8, true);
 }
 
@@ -1316,7 +1310,7 @@
 	{ ai_move, 11, monster_footstep },
 	{ ai_move, 0, monster_footstep },
 	{ ai_soldier_move },
-	{ ai_soldier_move, 0, soldierh_hyper_laser_sound_start },
+	{ ai_soldier_move, 0, soldierh_hyper_sound_start },
 	{ ai_soldier_move, 0, soldier_fire5 },
 	{ ai_soldier_move, 0, soldierh_hyperripper5 },
 	{ ai_soldier_move, 0, soldierh_hyperripper5 },
@@ -1325,8 +1319,10 @@
 
 static void monster_check_prone(edict_t *self)
 {
+	soldier_style_t style(self);
+
 	// we're a shotgun guard waiting to cock
-	if (!self->style && self->count >= 2 && self->count <= 3 && self->dmg)
+	if (style.has_shotgun() && self->dmg)
 		return;
 
 	// not going to shoot at this angle
@@ -1424,12 +1420,12 @@
 	{ ai_move },
 	{ ai_move },
 
-	{ ai_move, 0, soldierh_hyper_laser_sound_start },
+	{ ai_move, 0, soldierh_hyper_sound_start },
 	{ ai_move, 0, soldier_fire6 },
 	{ ai_move },
 	{ ai_move },
 	{ ai_move, 0, soldier_fire7 },
-	{ ai_move, 0, soldierh_hyper_laser_sound_end },
+	{ ai_move, 0, soldierh_hyper_sound_end },
 	{ ai_move },
 	{ ai_move },
 	{ ai_move },
@@ -1649,7 +1645,7 @@
 {
 	int n;
 
-	soldierh_hyper_laser_sound_end(self);
+	soldierh_hyper_sound_end(self);
 
 	// check for gib
 	if (M_CheckGib(self, mod))
@@ -1684,13 +1680,13 @@
 	self->deadflag = true;
 	self->takedamage = true;
 	
-	n = self->count | 1;
-
-	if (n == 1)
+	soldier_style_t style(self);
+
+	if (style.is_light())
 		gi.sound(self, CHAN_VOICE, sound_death_light, 1, ATTN_NORM, 0);
-	else if (n == 3)
+	else if (style.is_blitz())
 		gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
-	else // (n == 5)
+	else
 		gi.sound(self, CHAN_VOICE, sound_death_ss, 1, ATTN_NORM, 0);
 
 	if (fabsf((self->s.origin[2] + self->viewheight) - point[2]) <= 4 &&
@@ -1741,12 +1737,15 @@
 		self->monsterinfo.active_move == &soldier_move_pain4)
 		return false;
 
-	if (self->count <= 3)
+	soldier_style_t style(self);
+
+	if (!style.is_sustain())
 	{
 		if (self->monsterinfo.active_move != &soldier_move_attack6)
 		{
 			M_SetAnimation(self, &soldier_move_attack6);
-			soldierh_hyper_laser_sound_end(self);
+			self->sounds = 0;
+			soldierh_hyper_sound_end(self);
 		}
 	}
 	else
@@ -1755,7 +1754,8 @@
 			self->monsterinfo.active_move != &soldier_move_run)
 		{
 			M_SetAnimation(self, &soldier_move_start_run);
-			soldierh_hyper_laser_sound_end(self);
+			soldierh_hyper_sound_end(self);
+			soldier_stop_charge(self);
 		}
 	}
 
@@ -1765,12 +1765,16 @@
 MONSTERINFO_DUCK(soldier_duck) (edict_t *self, gtime_t eta) -> bool
 {
 	self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+	soldier_stop_charge(self);
+
+	soldier_style_t style(self);
 
 	if (self->monsterinfo.active_move == &soldier_move_attack6)
 	{
 		M_SetAnimation(self, &soldier_move_trip);
 	}
-	else if (self->dmg || brandom())
+	else if (self->dmg ||
+		(style.is_sustain() ? (frandom() > 0.50f + (skill->integer * 0.12f)) : brandom()))
 	{
 		M_SetAnimation(self, &soldier_move_duck);
 	}
@@ -1779,7 +1783,7 @@
 		M_SetAnimation(self, &soldier_move_attack3);
 	}
 
-	soldierh_hyper_laser_sound_end(self);
+	soldierh_hyper_sound_end(self);
 	return true;
 }
 
@@ -1897,6 +1901,8 @@
  */
 void SP_monster_soldier_light(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1923,6 +1929,8 @@
  */
 void SP_monster_soldier(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1944,6 +1952,8 @@
  */
 void SP_monster_soldier_ss(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1975,6 +1985,8 @@
  */
 void SP_monster_soldier_ripper(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -2002,6 +2014,8 @@
  */
 void SP_monster_soldier_hypergun(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -2029,6 +2043,8 @@
  */
 void SP_monster_soldier_lasergun(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_supertank.cpp	2023-10-03 19:43:06
+++ b/m_supertank.cpp	2024-09-24 14:09:16
@@ -635,6 +635,8 @@
  */
 void SP_monster_supertank(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_tank.cpp	2023-10-03 19:43:06
+++ b/m_tank.cpp	2024-09-24 14:09:16
@@ -1026,6 +1026,8 @@
  */
 void SP_monster_tank(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/p_client.cpp	2023-10-03 19:43:06
+++ b/p_client.cpp	2024-10-07 05:15:09
@@ -16,6 +16,8 @@
 	gi.linkentity(self);
 }
 
+constexpr spawnflags_t SPAWNFLAG_SPAWN_RIDE = 1_spawnflag;
+
 /*QUAKED info_player_start (1 0 0) (-16 -16 -24) (16 16 32)
 The normal starting point for a level.
 */
@@ -27,11 +29,14 @@
 
 	// [Paril-KEX] on n64, since these can spawn riding elevators,
 	// allow them to "ride" the elevators so respawning works
-	if (level.is_n64)
+	if (level.is_n64 || level.is_psx || self->spawnflags.has(SPAWNFLAG_SPAWN_RIDE))
 	{
 		self->think = info_player_start_drop;
 		self->nextthink = level.time + FRAME_TIME_S;
 	}
+
+	if (level.is_psx)
+		self->s.origin[2] -= PLAYER_MINS[2] - (PLAYER_MINS[2] * PSX_PHYSICS_SCALAR);
 }
 
 /*QUAKED info_player_deathmatch (1 0 1) (-16 -16 -24) (16 16 32)
@@ -874,6 +879,9 @@
 			if (level.start_items && *level.start_items)
 				Player_GiveStartItems(ent, level.start_items);
 
+			// power armor from start items
+			G_CheckPowerArmor(ent);
+
 			if (!deathmatch->integer)
 				client->pers.inventory[IT_ITEM_COMPASS] = 1;
 
@@ -902,7 +910,7 @@
 		client->pers.lives = g_coop_num_lives->integer + 1;
 
 	if (ent->client->pers.autoshield >= AUTO_SHIELD_AUTO)
-		ent->flags |= FL_WANTS_POWER_ARMOR;
+		client->pers.savedFlags |= FL_WANTS_POWER_ARMOR;
 
 	client->pers.connected = true;
 	client->pers.spawned = true;
@@ -3047,7 +3055,10 @@
 
 	float delta = pm.impact_delta;
 
-	delta = delta * delta * 0.0001f;
+	if (level.is_psx)
+		delta = delta * delta * 0.000078f;
+	else
+		delta = delta * delta * 0.0001f;
 
 	if (pm.waterlevel == WATER_WAIST)
 		delta *= 0.25f;
@@ -3087,9 +3098,11 @@
 			ent->s.event = EV_FALL;
 
 		ent->pain_debounce_time = level.time + FRAME_TIME_S; // no normal pain sound
-		damage = (int) ((delta - 30) / 2);
-		if (damage < 1)
-			damage = 1;
+		damage = std::max((int) ((delta - 30) / 2), 1);
+
+		if (level.is_psx)
+			damage = std::min(4, damage);
+
 		dir = { 0, 0, 1 };
 
 		if (!deathmatch->integer || !g_dm_no_fall_damage->integer)
@@ -3161,7 +3174,7 @@
 	client->latched_buttons |= client->buttons & ~client->oldbuttons;
 	client->cmd = *ucmd;
 
-	if ((ucmd->buttons & BUTTON_CROUCH) && pm_config.n64_physics)
+	if ((ucmd->buttons & BUTTON_CROUCH) && PM_CrouchingDisabled(pm_config.physics_flags))
 	{
 		if (client->pers.n64_crouch_warn_times < 12 &&
 			client->pers.n64_crouch_warning < level.time &&
@@ -3242,7 +3255,17 @@
 			client->ps.pmove.pm_flags &= ~PMF_IGNORE_PLAYER_COLLISION;
 
 		// PGM	trigger_gravity support
-		client->ps.pmove.gravity = (short) (level.gravity * ent->gravity);
+		if (ent->no_gravity_time > level.time)
+		{
+			client->ps.pmove.gravity = 0;
+			client->ps.pmove.pm_flags |= PMF_NO_GROUND_SEEK;
+		}
+		else
+		{
+			client->ps.pmove.gravity = (short) (level.gravity * ent->gravity);
+			client->ps.pmove.pm_flags &= ~PMF_NO_GROUND_SEEK;
+		}
+
 		pm.s = client->ps.pmove;
 
 		pm.s.origin = ent->s.origin;
--- a/p_hud.cpp	2023-10-03 19:43:06
+++ b/p_hud.cpp	2024-07-07 03:52:24
@@ -613,25 +613,39 @@
 	}
 	else 
 	{
+		const char *first_message = game.helpmessage1;
+		const char *first_title = level.primary_objective_title;
+
+		const char *second_message = game.helpmessage2;
+		const char *second_title = level.secondary_objective_title;
+
+		if (level.is_psx)
+		{
+			std::swap(first_message, second_message);
+			std::swap(first_title, second_title);
+		}
+
 		int y = 54;
-		if (strlen(game.helpmessage1))
-		{
-			helpString += G_Fmt("xv 0 yv {} loc_cstring2 0 \"$g_pc_primary_objective\" "  // title
+		if (strlen(first_message))
+		{
+			helpString += G_Fmt("xv 0 yv {} loc_cstring2 0 \"{}\" "  // title
 				"xv 0 yv {} loc_cstring 0 \"{}\" ",
 				y,
+				first_title,
 				y + 11,
-				game.helpmessage1);
+				first_message);
 
 			y += 58;
 		}
 
-		if (strlen(game.helpmessage2))
-		{
-			helpString += G_Fmt("xv 0 yv {} loc_cstring2 0 \"$g_pc_secondary_objective\" "  // title
+		if (strlen(second_message))
+		{
+			helpString += G_Fmt("xv 0 yv {} loc_cstring2 0 \"{}\" "  // title
 				"xv 0 yv {} loc_cstring 0 \"{}\" ",
 				y,
+				second_title,
 				y + 11,
-				game.helpmessage2);
+				second_message);
 		}
 
 	}
--- a/p_move.cpp	2023-10-03 19:43:06
+++ b/p_move.cpp	2024-09-29 02:36:57
@@ -5,6 +5,36 @@
 
 #define GAME_INCLUDE
 #include "bg_local.h"
+
+// In PSX SP, step-ups aren't allowed
+inline bool PM_AllowStepUp()
+{
+	if (pm_config.physics_flags & PHYSICS_PSX_MOVEMENT)
+		return !!(pm_config.physics_flags & PHYSICS_DEATHMATCH);
+
+	return true;
+}
+
+template<typename T>
+inline T PM_ApplyPSXScalar(T v, float scalar = PSX_PHYSICS_SCALAR)
+{
+	if (pm_config.physics_flags & PHYSICS_PSX_SCALE)
+		return static_cast<T>(v * scalar);
+
+	return v;
+}
+
+// PSX / N64 can't trick-jump except in DM
+inline bool PM_AllowTrickJump()
+{
+	return !(pm_config.physics_flags & (PHYSICS_N64_MOVEMENT | PHYSICS_PSX_MOVEMENT)) || (pm_config.physics_flags & PHYSICS_DEATHMATCH);
+}
+
+// PSX / N64 (single player) require landing before a next jump
+inline bool PM_NeedsLandTime()
+{
+	return (pm_config.physics_flags & (PHYSICS_N64_MOVEMENT | PHYSICS_PSX_MOVEMENT)) && !(pm_config.physics_flags & PHYSICS_DEATHMATCH);
+}
 
 // [Paril-KEX] generic code to detect & fix a stuck object
 stuck_result_t G_FixStuckObject_Generic(vec3_t &origin, const vec3_t &own_mins, const vec3_t &own_maxs, std::function<stuck_object_trace_fn_t> trace)
@@ -458,6 +488,13 @@
 
 	PM_StepSlideMove_();
 
+	if (!PM_AllowStepUp())
+	{
+		// no step up
+		if (!(pm->s.pm_flags & PMF_ON_GROUND))
+			return;
+	}
+
 	down_o = pml.origin;
 	down_v = pml.velocity;
 
@@ -563,14 +600,16 @@
 	// apply ground friction
 	if ((pm->groundentity && pml.groundsurface && !(pml.groundsurface->flags & SURF_SLICK)) || (pm->s.pm_flags & PMF_ON_LADDER))
 	{
-		friction = pm_friction;
-		control = speed < pm_stopspeed ? pm_stopspeed : speed;
+		friction = PM_ApplyPSXScalar(pm_friction);
+		control = speed < PM_ApplyPSXScalar(pm_stopspeed) ? PM_ApplyPSXScalar(pm_stopspeed) : speed;
 		drop += control * friction * pml.frametime;
 	}
 
 	// apply water friction
 	if (pm->waterlevel && !(pm->s.pm_flags & PMF_ON_LADDER))
-		drop += speed * pm_waterfriction * (float) pm->waterlevel * pml.frametime;
+	{
+		drop += speed * PM_ApplyPSXScalar(pm_waterfriction) * (float) pm->waterlevel * pml.frametime;
+	}
 
 	// scale the velocity
 	newspeed = speed - drop;
@@ -594,37 +633,35 @@
 */
 void PM_Accelerate(const vec3_t &wishdir, float wishspeed, float accel)
 {
-	int	  i;
-	float addspeed, accelspeed, currentspeed;
-
-	currentspeed = pml.velocity.dot(wishdir);
-	addspeed = wishspeed - currentspeed;
+	wishspeed = PM_ApplyPSXScalar(wishspeed);
+	accel = PM_ApplyPSXScalar(accel);
+
+	float currentspeed = pml.velocity.dot(wishdir);
+	float addspeed = wishspeed - currentspeed;
 	if (addspeed <= 0)
 		return;
-	accelspeed = accel * pml.frametime * wishspeed;
+	float accelspeed = accel * pml.frametime * wishspeed;
 	if (accelspeed > addspeed)
 		accelspeed = addspeed;
 
-	for (i = 0; i < 3; i++)
+	for (int i = 0; i < 3; i++)
 		pml.velocity[i] += accelspeed * wishdir[i];
 }
 
 void PM_AirAccelerate(const vec3_t &wishdir, float wishspeed, float accel)
 {
-	int	  i;
-	float addspeed, accelspeed, currentspeed, wishspd = wishspeed;
-
+	float wishspd = wishspeed;
 	if (wishspd > 30)
 		wishspd = 30;
-	currentspeed = pml.velocity.dot(wishdir);
-	addspeed = wishspd - currentspeed;
+	float currentspeed = pml.velocity.dot(wishdir);
+	float addspeed = wishspd - currentspeed;
 	if (addspeed <= 0)
 		return;
-	accelspeed = accel * wishspeed * pml.frametime;
+	float accelspeed = accel * wishspeed * pml.frametime;
 	if (accelspeed > addspeed)
 		accelspeed = addspeed;
 
-	for (i = 0; i < 3; i++)
+	for (int i = 0; i < 3; i++)
 		pml.velocity[i] += accelspeed * wishdir[i];
 }
 
@@ -825,10 +862,12 @@
 	}
 	wishspeed *= 0.5f;
 
-	if ((pm->s.pm_flags & PMF_DUCKED) && wishspeed > pm_duckspeed)
-	{
-		wishvel *= pm_duckspeed / wishspeed;
-		wishspeed = pm_duckspeed;
+	float duckspeed = PM_ApplyPSXScalar(pm_duckspeed, 1.25f);
+
+	if ((pm->s.pm_flags & PMF_DUCKED) && wishspeed > duckspeed)
+	{
+		wishvel *= duckspeed / wishspeed;
+		wishspeed = duckspeed;
 	}
 
 	PM_Accelerate(wishdir, wishspeed, pm_wateraccelerate);
@@ -863,10 +902,12 @@
 	wishdir = wishvel;
 	wishspeed = wishdir.normalize();
 
+	float duckspeed = PM_ApplyPSXScalar(pm_duckspeed, 1.25f);
+
 	//
 	// clamp to server defined max speed
 	//
-	maxspeed = (pm->s.pm_flags & PMF_DUCKED) ? pm_duckspeed : pm_maxspeed;
+	maxspeed = (pm->s.pm_flags & PMF_DUCKED) ? duckspeed : pm_maxspeed;
 
 	if (wishspeed > maxspeed)
 	{
@@ -978,7 +1019,7 @@
 	point[1] = pml.origin[1];
 	point[2] = pml.origin[2] - 0.25f;
 
-	if (pml.velocity[2] > 180 || pm->s.pm_type == PM_GRAPPLE) //!!ZOID changed from 100 to 180 (ramp accel)
+	if ((pm->s.pm_flags & PMF_NO_GROUND_SEEK) || pml.velocity[2] > 180 || pm->s.pm_type == PM_GRAPPLE) //!!ZOID changed from 100 to 180 (ramp accel)
 	{
 		pm->s.pm_flags &= ~PMF_ON_GROUND;
 		pm->groundentity = nullptr;
@@ -1025,7 +1066,7 @@
 				// just hit the ground
 
 				// [Paril-KEX]
-				if (!pm_config.n64_physics && pml.velocity[2] >= 100.f && pm->groundplane.normal[2] >= 0.9f && !(pm->s.pm_flags & PMF_DUCKED))
+				if (PM_AllowTrickJump() && pml.velocity[2] >= 100.f && pm->groundplane.normal[2] >= 0.9f && !(pm->s.pm_flags & PMF_DUCKED))
 				{
 					pm->s.pm_flags |= PMF_TIME_TRICK;
 					pm->s.pm_time = 64;
@@ -1035,14 +1076,14 @@
 				vec3_t clipped_velocity;
 				PM_ClipVelocity(pml.velocity, pm->groundplane.normal, clipped_velocity, 1.01f);
 
-				pm->impact_delta = pml.start_velocity[2] - clipped_velocity[2];
+				pm->impact_delta = PM_ApplyPSXScalar(pml.start_velocity[2] - clipped_velocity[2], 1.f / PSX_PHYSICS_SCALAR);
 
 				pm->s.pm_flags |= PMF_ON_GROUND;
 
-				if (pm_config.n64_physics || (pm->s.pm_flags & PMF_DUCKED))
+				if (PM_NeedsLandTime() || (pm->s.pm_flags & PMF_DUCKED))
 				{
 					pm->s.pm_flags |= PMF_TIME_LAND;
-					pm->s.pm_time = 128;
+					pm->s.pm_time = PM_ApplyPSXScalar(128, 0.5f);
 				}
 			}
 		}
@@ -1095,7 +1136,7 @@
 	pm->groundentity = nullptr;
 	pm->s.pm_flags &= ~PMF_ON_GROUND;
 
-	float jump_height = 270.f;
+	float jump_height = PM_ApplyPSXScalar(270.f, (PSX_PHYSICS_SCALAR * 1.15f));
 
 	pml.velocity[2] += jump_height;
 	if (pml.velocity[2] < jump_height)
@@ -1381,7 +1422,7 @@
 		(pm->cmd.buttons & BUTTON_CROUCH) &&
 		(pm->groundentity || (pm->waterlevel <= WATER_FEET && !PM_AboveWater())) &&
 		!(pm->s.pm_flags & PMF_ON_LADDER) &&
-		!pm_config.n64_physics)
+		!PM_CrouchingDisabled(pm_config.physics_flags))
 	{ // duck
 		if (!(pm->s.pm_flags & PMF_DUCKED))
 		{
--- a/p_trail.cpp	2023-10-03 19:43:06
+++ b/p_trail.cpp	2024-10-22 19:27:52
@@ -70,7 +70,10 @@
 void PlayerTrail_Destroy(edict_t *player)
 {
 	for (size_t i = 0; i < globals.num_edicts; i++)
-		if (g_edicts[i].classname && strcmp(g_edicts[i].classname, "player_trail") == 0)
+		if (g_edicts[i].classname && 
+			(strcmp(g_edicts[i].classname, "player_trail") == 0 ||
+			strcmp(g_edicts[i].classname, "player_noise") == 0)
+			)
 			if (!player || g_edicts[i].owner == player)
 				G_FreeEdict(&g_edicts[i]);
 
--- a/p_view.cpp	2023-10-03 19:43:06
+++ b/p_view.cpp	2024-10-21 12:41:07
@@ -4,33 +4,22 @@
 #include "g_local.h"
 #include "m_player.h"
 #include "bots/bot_includes.h"
-
-static edict_t   *current_player;
-static gclient_t *current_client;
-
-static vec3_t forward, right, up;
-float		  xyspeed;
-
-float bobmove;
-int	  bobcycle, bobcycle_run;	  // odd cycles are right foot going forward
-float bobfracsin; // sinf(bobfrac*M_PI)
 
 /*
 ===============
 SkipViewModifiers
 ===============
 */
-inline bool SkipViewModifiers() {
+inline bool SkipViewModifiers(gclient_t *client) {
 	if ( g_skipViewModifiers->integer && sv_cheats->integer ) {
 		return true;
 	}
 	// don't do bobbing, etc on grapple
-	if (current_client->ctf_grapple &&
-		 current_client->ctf_grapplestate > CTF_GRAPPLE_STATE_FLY) {
+	if (client->ctf_grapple && client->ctf_grapplestate > CTF_GRAPPLE_STATE_FLY) {
 		return true;
 	}
 	// spectator mode
-	if (current_client->resp.spectator || (G_TeamplayEnabled() && current_client->resp.ctf_team == CTF_NOTEAM)) {
+	if (client->resp.spectator || (G_TeamplayEnabled() && client->resp.ctf_team == CTF_NOTEAM)) {
 		return true;
 	}
 	return false;
@@ -42,9 +31,9 @@
 
 ===============
 */
-float SV_CalcRoll(const vec3_t &angles, const vec3_t &velocity)
+static float SV_CalcRoll(gclient_t *client, const vec3_t &angles, const vec3_t &velocity, const vec3_t &right)
 {
-	if ( SkipViewModifiers() ) {
+	if ( SkipViewModifiers(client) ) {
 		return 0.0f;
 	}
 
@@ -73,7 +62,7 @@
 Handles color blends and view kicks
 ===============
 */
-void P_DamageFeedback(edict_t *player)
+static void P_DamageFeedback(edict_t *player, const vec3_t &forward, const vec3_t &right, const vec3_t &up)
 {
 	gclient_t		  *client;
 	float			 side;
@@ -294,7 +283,7 @@
 
 ===============
 */
-void SV_CalcViewOffset(edict_t *ent)
+static void SV_CalcViewOffset(edict_t *ent, const vec3_t &forward, const vec3_t &right, const step_parameters_t &step)
 {
 	float  bob;
 	float  ratio;
@@ -323,7 +312,7 @@
 		}
 		ent->client->ps.viewangles[YAW] = ent->client->killer_yaw;
 	}
-	else if (!ent->client->pers.bob_skip && !SkipViewModifiers())
+	else if (!ent->client->pers.bob_skip && !SkipViewModifiers(ent->client))
 	{
 		// add angles based on weapon kick
 		angles = P_CurrentKickAngles(ent);
@@ -371,7 +360,7 @@
 		}
 
 		// add angles based on velocity
-		if (!ent->client->pers.bob_skip && !SkipViewModifiers())
+		if (!ent->client->pers.bob_skip && !SkipViewModifiers(ent->client))
 		{
 			delta = ent->velocity.dot(forward);
 			angles[PITCH] += delta * run_pitch->value;
@@ -380,16 +369,16 @@
 			angles[ROLL] += delta * run_roll->value;
 
 			// add angles based on bob
-			delta = bobfracsin * bob_pitch->value * xyspeed;
+			delta = step.bobfracsin * bob_pitch->value * step.xyspeed;
 			if ((ent->client->ps.pmove.pm_flags & PMF_DUCKED) && ent->groundentity)
 				delta *= 6; // crouching
 			delta = min(delta, 1.2f);
 			angles[PITCH] += delta;
-			delta = bobfracsin * bob_roll->value * xyspeed;
+			delta = step.bobfracsin * bob_roll->value * step.xyspeed;
 			if ((ent->client->ps.pmove.pm_flags & PMF_DUCKED) && ent->groundentity)
 				delta *= 6; // crouching
 			delta = min(delta, 1.2f);
-			if (bobcycle & 1)
+			if (step.bobcycle & 1)
 				delta = -delta;
 			angles[ROLL] += delta;
 		}
@@ -417,7 +406,7 @@
 
 	// add fall height
 
-	if (!ent->client->pers.bob_skip && !SkipViewModifiers())
+	if (!ent->client->pers.bob_skip && !SkipViewModifiers(ent->client))
 	{
 		if (ent->client->fall_time > level.time)
 		{
@@ -439,7 +428,7 @@
 		}
 
 	// add bob height
-		bob = bobfracsin * xyspeed * bob_up->value;
+		bob = step.bobfracsin * step.xyspeed * bob_up->value;
 		if (bob > 6)
 			bob = 6;
 		// gi.DebugGraph (bob *2, 255);
@@ -448,7 +437,7 @@
 
 	// add kick offset
 
-	if (!ent->client->pers.bob_skip && !SkipViewModifiers())
+	if (!ent->client->pers.bob_skip && !SkipViewModifiers(ent->client))
 		v += P_CurrentKickOrigin(ent);
 
 	// absolutely bound offsets
@@ -475,7 +464,7 @@
 SV_CalcGunOffset
 ==============
 */
-void SV_CalcGunOffset(edict_t *ent)
+static void SV_CalcGunOffset(edict_t *ent, const vec3_t &forward, const vec3_t &right, const vec3_t &up, const step_parameters_t &step)
 {
 	int	  i;
 	// ROGUE
@@ -483,19 +472,19 @@
 	// ROGUE - heatbeam shouldn't bob so the beam looks right
 	if (ent->client->pers.weapon && 
 		!((ent->client->pers.weapon->id == IT_WEAPON_PLASMABEAM || ent->client->pers.weapon->id == IT_WEAPON_GRAPPLE) && ent->client->weaponstate == WEAPON_FIRING)
-		&& !SkipViewModifiers())
+		&& !SkipViewModifiers(ent->client))
 	{
 		// ROGUE
 		// gun angles from bobbing
-		ent->client->ps.gunangles[ROLL] = xyspeed * bobfracsin * 0.005f;
-		ent->client->ps.gunangles[YAW] = xyspeed * bobfracsin * 0.01f;
-		if (bobcycle & 1)
+		ent->client->ps.gunangles[ROLL] = step.xyspeed * step.bobfracsin * 0.005f;
+		ent->client->ps.gunangles[YAW] = step.xyspeed * step.bobfracsin * 0.01f;
+		if (step.bobcycle & 1)
 		{
 			ent->client->ps.gunangles[ROLL] = -ent->client->ps.gunangles[ROLL];
 			ent->client->ps.gunangles[YAW] = -ent->client->ps.gunangles[YAW];
 		}
 
-		ent->client->ps.gunangles[PITCH] = xyspeed * bobfracsin * 0.005f;
+		ent->client->ps.gunangles[PITCH] = step.xyspeed * step.bobfracsin * 0.005f;
 
 		vec3_t viewangles_delta = ent->client->oldviewangles - ent->client->ps.viewangles;
 		
@@ -561,7 +550,7 @@
 SV_CalcBlend
 =============
 */
-void SV_CalcBlend(edict_t *ent)
+static void SV_CalcBlend(edict_t *ent)
 {
 	gtime_t remaining;
 
@@ -686,41 +675,43 @@
 P_WorldEffects
 =============
 */
-void P_WorldEffects()
+static void P_WorldEffects(edict_t *ent, const step_parameters_t &step)
 {
 	bool		  breather;
 	bool		  envirosuit;
 	water_level_t waterlevel, old_waterlevel;
 
-	if (current_player->movetype == MOVETYPE_NOCLIP)
-	{
-		current_player->air_finished = level.time + 12_sec; // don't need air
+	if (ent->movetype == MOVETYPE_NOCLIP)
+	{
+		ent->air_finished = level.time + 12_sec; // don't need air
 		return;
 	}
 
-	waterlevel = current_player->waterlevel;
-	old_waterlevel = current_client->old_waterlevel;
-	current_client->old_waterlevel = waterlevel;
-
-	breather = current_client->breather_time > level.time;
-	envirosuit = current_client->enviro_time > level.time;
+	gclient_t *client = ent->client;
+
+	waterlevel = ent->waterlevel;
+	old_waterlevel = client->old_waterlevel;
+	client->old_waterlevel = waterlevel;
+
+	breather = client->breather_time > level.time;
+	envirosuit = client->enviro_time > level.time;
 
 	//
 	// if just entered a water volume, play a sound
 	//
 	if (!old_waterlevel && waterlevel)
 	{
-		PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
-		if (current_player->watertype & CONTENTS_LAVA)
-			gi.sound(current_player, CHAN_BODY, gi.soundindex("player/lava_in.wav"), 1, ATTN_NORM, 0);
-		else if (current_player->watertype & CONTENTS_SLIME)
-			gi.sound(current_player, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
-		else if (current_player->watertype & CONTENTS_WATER)
-			gi.sound(current_player, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
-		current_player->flags |= FL_INWATER;
+		PlayerNoise(ent, ent->s.origin, PNOISE_SELF);
+		if (ent->watertype & CONTENTS_LAVA)
+			gi.sound(ent, CHAN_BODY, gi.soundindex("player/lava_in.wav"), 1, ATTN_NORM, 0);
+		else if (ent->watertype & CONTENTS_SLIME)
+			gi.sound(ent, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
+		else if (ent->watertype & CONTENTS_WATER)
+			gi.sound(ent, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
+		ent->flags |= FL_INWATER;
 
 		// clear damage_debounce, so the pain sound will play immediately
-		current_player->damage_debounce_time = level.time - 1_sec;
+		ent->damage_debounce_time = level.time - 1_sec;
 	}
 
 	//
@@ -728,9 +719,9 @@
 	//
 	if (old_waterlevel && !waterlevel)
 	{
-		PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
-		gi.sound(current_player, CHAN_BODY, gi.soundindex("player/watr_out.wav"), 1, ATTN_NORM, 0);
-		current_player->flags &= ~FL_INWATER;
+		PlayerNoise(ent, ent->s.origin, PNOISE_SELF);
+		gi.sound(ent, CHAN_BODY, gi.soundindex("player/watr_out.wav"), 1, ATTN_NORM, 0);
+		ent->flags &= ~FL_INWATER;
 	}
 
 	//
@@ -738,22 +729,22 @@
 	//
 	if (old_waterlevel != WATER_UNDER && waterlevel == WATER_UNDER)
 	{
-		gi.sound(current_player, CHAN_BODY, gi.soundindex("player/watr_un.wav"), 1, ATTN_NORM, 0);
+		gi.sound(ent, CHAN_BODY, gi.soundindex("player/watr_un.wav"), 1, ATTN_NORM, 0);
 	}
 
 	//
 	// check for head just coming out of water
 	//
-	if (current_player->health > 0 && old_waterlevel == WATER_UNDER && waterlevel != WATER_UNDER)
-	{
-		if (current_player->air_finished < level.time)
+	if (ent->health > 0 && old_waterlevel == WATER_UNDER && waterlevel != WATER_UNDER)
+	{
+		if (ent->air_finished < level.time)
 		{ // gasp for air
-			gi.sound(current_player, CHAN_VOICE, gi.soundindex("player/gasp1.wav"), 1, ATTN_NORM, 0);
-			PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
-		}
-		else if (current_player->air_finished < level.time + 11_sec)
+			gi.sound(ent, CHAN_VOICE, gi.soundindex("player/gasp1.wav"), 1, ATTN_NORM, 0);
+			PlayerNoise(ent, ent->s.origin, PNOISE_SELF);
+		}
+		else if (ent->air_finished < level.time + 11_sec)
 		{ // just break surface
-			gi.sound(current_player, CHAN_VOICE, gi.soundindex("player/gasp2.wav"), 1, ATTN_NORM, 0);
+			gi.sound(ent, CHAN_VOICE, gi.soundindex("player/gasp2.wav"), 1, ATTN_NORM, 0);
 		}
 	}
 
@@ -765,89 +756,102 @@
 		// breather or envirosuit give air
 		if (breather || envirosuit)
 		{
-			current_player->air_finished = level.time + 10_sec;
-
-			if (((current_client->breather_time - level.time).milliseconds() % 2500) == 0)
+			ent->air_finished = level.time + 10_sec;
+
+			if (((client->breather_time - level.time).milliseconds() % 2500) == 0)
 			{
-				if (!current_client->breather_sound)
-					gi.sound(current_player, CHAN_AUTO, gi.soundindex("player/u_breath1.wav"), 1, ATTN_NORM, 0);
+				if (!client->breather_sound)
+					gi.sound(ent, CHAN_AUTO, gi.soundindex("player/u_breath1.wav"), 1, ATTN_NORM, 0);
 				else
-					gi.sound(current_player, CHAN_AUTO, gi.soundindex("player/u_breath2.wav"), 1, ATTN_NORM, 0);
-				current_client->breather_sound ^= 1;
-				PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
+					gi.sound(ent, CHAN_AUTO, gi.soundindex("player/u_breath2.wav"), 1, ATTN_NORM, 0);
+				client->breather_sound ^= 1;
+				PlayerNoise(ent, ent->s.origin, PNOISE_SELF);
 				// FIXME: release a bubble?
 			}
 		}
 
 		// if out of air, start drowning
-		if (current_player->air_finished < level.time)
+		if (ent->air_finished < level.time)
 		{ // drown!
-			if (current_player->client->next_drown_time < level.time && current_player->health > 0)
+			if (ent->client->next_drown_time < level.time && ent->health > 0)
 			{
-				current_player->client->next_drown_time = level.time + 1_sec;
+				ent->client->next_drown_time = level.time + 1_sec;
 
 				// take more damage the longer underwater
-				current_player->dmg += 2;
-				if (current_player->dmg > 15)
-					current_player->dmg = 15;
+				ent->dmg += 2;
+				if (ent->dmg > 15)
+					ent->dmg = 15;
 
 				// play a gurp sound instead of a normal pain sound
-				if (current_player->health <= current_player->dmg)
-					gi.sound(current_player, CHAN_VOICE, gi.soundindex("*drown1.wav"), 1, ATTN_NORM, 0); // [Paril-KEX]
+				if (ent->health <= ent->dmg)
+					gi.sound(ent, CHAN_VOICE, gi.soundindex("*drown1.wav"), 1, ATTN_NORM, 0); // [Paril-KEX]
 				else if (brandom())
-					gi.sound(current_player, CHAN_VOICE, gi.soundindex("*gurp1.wav"), 1, ATTN_NORM, 0);
+					gi.sound(ent, CHAN_VOICE, gi.soundindex("*gurp1.wav"), 1, ATTN_NORM, 0);
 				else
-					gi.sound(current_player, CHAN_VOICE, gi.soundindex("*gurp2.wav"), 1, ATTN_NORM, 0);
-
-				current_player->pain_debounce_time = level.time;
-
-				T_Damage(current_player, world, world, vec3_origin, current_player->s.origin, vec3_origin, current_player->dmg, 0, DAMAGE_NO_ARMOR, MOD_WATER);
+					gi.sound(ent, CHAN_VOICE, gi.soundindex("*gurp2.wav"), 1, ATTN_NORM, 0);
+
+				ent->pain_debounce_time = level.time;
+
+				T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, ent->dmg, 0, DAMAGE_NO_ARMOR, MOD_WATER);
 			}
 		}
 		// Paril: almost-drowning sounds
-		else if (current_player->air_finished <= level.time + 3_sec)
-		{
-			if (current_player->client->next_drown_time < level.time)
+		else if (ent->air_finished <= level.time + 3_sec)
+		{
+			if (ent->client->next_drown_time < level.time)
 			{
-				gi.sound(current_player, CHAN_VOICE, gi.soundindex(fmt::format("player/wade{}.wav", 1 + ((int32_t) level.time.seconds() % 3)).c_str()), 1, ATTN_NORM, 0);
-				current_player->client->next_drown_time = level.time + 1_sec;
+#ifdef PSX_ASSETS
+				gi.sound(ent, CHAN_VOICE, gi.soundindex(G_Fmt("player/breathout{}.wav", 1 + ((int32_t) level.time.seconds() % 3)).data()), 1, ATTN_NORM, 0);
+#else
+				gi.sound(ent, CHAN_VOICE, gi.soundindex(G_Fmt("player/wade{}.wav", 1 + ((int32_t) level.time.seconds() % 3)).data()), 1, ATTN_NORM, 0);
+#endif
+				ent->client->next_drown_time = level.time + 1_sec;
 			}
 		}
 	}
 	else
 	{
-		current_player->air_finished = level.time + 12_sec;
-		current_player->dmg = 2;
+		if (waterlevel == WATER_WAIST)
+		{
+			if (level.is_psx)
+			{
+				if ((int) (client->bobtime + step.bobmove) != step.bobcycle_run)
+					gi.sound(ent, CHAN_VOICE, gi.soundindex(G_Fmt("player/wade{}.wav", irandom(1, 4)).data()), 1, ATTN_NORM, 0);
+			}
+		}
+
+		ent->air_finished = level.time + 12_sec;
+		ent->dmg = 2;
 	}
 
 	//
 	// check for sizzle damage
 	//
-	if (waterlevel && (current_player->watertype & (CONTENTS_LAVA | CONTENTS_SLIME)) && current_player->slime_debounce_time <= level.time)
-	{
-		if (current_player->watertype & CONTENTS_LAVA)
-		{
-			if (current_player->health > 0 && current_player->pain_debounce_time <= level.time && current_client->invincible_time < level.time)
+	if (waterlevel && (ent->watertype & (CONTENTS_LAVA | CONTENTS_SLIME)) && ent->slime_debounce_time <= level.time)
+	{
+		if (ent->watertype & CONTENTS_LAVA)
+		{
+			if (ent->health > 0 && ent->pain_debounce_time <= level.time && client->invincible_time < level.time)
 			{
 				if (brandom())
-					gi.sound(current_player, CHAN_VOICE, gi.soundindex("player/burn1.wav"), 1, ATTN_NORM, 0);
+					gi.sound(ent, CHAN_VOICE, gi.soundindex("player/burn1.wav"), 1, ATTN_NORM, 0);
 				else
-					gi.sound(current_player, CHAN_VOICE, gi.soundindex("player/burn2.wav"), 1, ATTN_NORM, 0);
-				current_player->pain_debounce_time = level.time + 1_sec;
+					gi.sound(ent, CHAN_VOICE, gi.soundindex("player/burn2.wav"), 1, ATTN_NORM, 0);
+				ent->pain_debounce_time = level.time + 1_sec;
 			}
 
 			int dmg = (envirosuit ? 1 : 3) * waterlevel; // take 1/3 damage with envirosuit
 
-			T_Damage(current_player, world, world, vec3_origin, current_player->s.origin, vec3_origin, dmg, 0, DAMAGE_NONE, MOD_LAVA);
-			current_player->slime_debounce_time = level.time + 10_hz;
-		}
-
-		if (current_player->watertype & CONTENTS_SLIME)
+			T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, dmg, 0, DAMAGE_NONE, MOD_LAVA);
+			ent->slime_debounce_time = level.time + 10_hz;
+		}
+
+		if (ent->watertype & CONTENTS_SLIME)
 		{
 			if (!envirosuit)
 			{ // no damage from slime with envirosuit
-				T_Damage(current_player, world, world, vec3_origin, current_player->s.origin, vec3_origin, 1 * waterlevel, 0, DAMAGE_NONE, MOD_SLIME);
-				current_player->slime_debounce_time = level.time + 10_hz;
+				T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, 1 * waterlevel, 0, DAMAGE_NONE, MOD_SLIME);
+				ent->slime_debounce_time = level.time + 10_hz;
 			}
 		}
 	}
@@ -858,7 +862,7 @@
 G_SetClientEffects
 ===============
 */
-void G_SetClientEffects(edict_t *ent)
+static void G_SetClientEffects(edict_t *ent)
 {
 	int pa_type;
 
@@ -993,25 +997,27 @@
 G_SetClientEvent
 ===============
 */
-void G_SetClientEvent(edict_t *ent)
+static void G_SetClientEvent(edict_t *ent, const step_parameters_t &step)
 {
 	if (ent->s.event)
 		return;
 
+	gclient_t *client = ent->client;
+
 	if (ent->client->ps.pmove.pm_flags & PMF_ON_LADDER)
 	{
 		if (!deathmatch->integer &&
-			current_client->last_ladder_sound < level.time &&
-			(current_client->last_ladder_pos - ent->s.origin).length() > 48.f)
+			client->last_ladder_sound < level.time &&
+			(client->last_ladder_pos - ent->s.origin).length() > 48.f)
 		{
 			ent->s.event = EV_LADDER_STEP;
-			current_client->last_ladder_pos = ent->s.origin;
-			current_client->last_ladder_sound = level.time + LADDER_SOUND_TIME;
-		}
-	}
-	else if (ent->groundentity && xyspeed > 225)
-	{
-		if ((int) (current_client->bobtime + bobmove) != bobcycle_run)
+			client->last_ladder_pos = ent->s.origin;
+			client->last_ladder_sound = level.time + LADDER_SOUND_TIME;
+		}
+	}
+	else if (ent->groundentity && step.xyspeed > 225)
+	{
+		if ((int) (client->bobtime + step.bobmove) != step.bobcycle_run)
 			ent->s.event = EV_FOOTSTEP;
 	}
 }
@@ -1021,7 +1027,7 @@
 G_SetClientSound
 ===============
 */
-void G_SetClientSound(edict_t *ent)
+static void G_SetClientSound(edict_t *ent)
 {
 	// help beep (no more than three times)
 	if (ent->client->pers.helpchanged && ent->client->pers.helpchanged <= 3 && ent->client->pers.help_time < level.time)
@@ -1080,7 +1086,7 @@
 G_SetClientFrame
 ===============
 */
-void G_SetClientFrame(edict_t *ent)
+void G_SetClientFrame(edict_t *ent, const step_parameters_t &step)
 {
 	gclient_t *client;
 	bool	   duck, run;
@@ -1094,7 +1100,7 @@
 		duck = true;
 	else
 		duck = false;
-	if (xyspeed)
+	if (step.xyspeed)
 		run = true;
 	else
 		run = false;
@@ -1347,10 +1353,7 @@
 	if (!ent->client->pers.spawned)
 		return;
 
-	float bobtime, bobtime_run;
-
-	current_player = ent;
-	current_client = ent->client;
+	gclient_t *client = ent->client;
 
 	// check fog changes
 	P_ForceFogTransition(ent, false);
@@ -1369,8 +1372,8 @@
 	// If it wasn't updated here, the view position would lag a frame
 	// behind the body position when pushed -- "sinking into plats"
 	//
-	current_client->ps.pmove.origin = ent->s.origin;
-	current_client->ps.pmove.velocity = ent->velocity;
+	client->ps.pmove.origin = ent->s.origin;
+	client->ps.pmove.velocity = ent->velocity;
 
 	//
 	// If the end of unit layout is displayed, don't give
@@ -1380,9 +1383,9 @@
 	{
 		if (ent->client->awaiting_respawn || (level.intermission_eou || level.is_n64 || (deathmatch->integer && level.intermissiontime)))
 		{
-			current_client->ps.screen_blend[3] = current_client->ps.damage_blend[3] = 0;
-			current_client->ps.fov = 90;
-			current_client->ps.gunindex = 0;
+			client->ps.screen_blend[3] = client->ps.damage_blend[3] = 0;
+			client->ps.fov = 90;
+			client->ps.gunindex = 0;
 		}
 		G_SetStats(ent);
 		G_SetCoopStats(ent);
@@ -1403,10 +1406,8 @@
 	CTFApplyRegeneration(ent);
 	// ZOID
 
+	vec3_t forward, right, up;
 	AngleVectors(ent->client->v_angle, forward, right, up);
-
-	// burn from lava, etc
-	P_WorldEffects();
 
 	//
 	// set model angles from view angles so other things in
@@ -1420,47 +1421,50 @@
 	ent->s.angles[YAW] = ent->client->v_angle[YAW];
 	ent->s.angles[ROLL] = 0;
 	// [Paril-KEX] cl_rollhack
-	ent->s.angles[ROLL] = -SV_CalcRoll(ent->s.angles, ent->velocity) * 4;
+	ent->s.angles[ROLL] = -SV_CalcRoll(ent->client, ent->s.angles, ent->velocity, right) * 4;
 
 	//
 	// calculate speed and cycle to be used for
 	// all cyclic walking effects
 	//
-	xyspeed = sqrt(ent->velocity[0] * ent->velocity[0] + ent->velocity[1] * ent->velocity[1]);
-
-	if (xyspeed < 5)
-	{
-		bobmove = 0;
-		current_client->bobtime = 0; // start at beginning of cycle again
+	step_parameters_t step {};
+	step.xyspeed = sqrt(ent->velocity[0] * ent->velocity[0] + ent->velocity[1] * ent->velocity[1]);
+
+	if (step.xyspeed < 5)
+	{
+		client->bobtime = 0; // start at beginning of cycle again
 	}
 	else if (ent->groundentity)
 	{ // so bobbing only cycles when on ground
-		if (xyspeed > 210)
-			bobmove = gi.frame_time_ms / 400.f;
-		else if (xyspeed > 100)
-			bobmove = gi.frame_time_ms / 800.f;
+		if (step.xyspeed > 210)
+			step.bobmove = gi.frame_time_ms / 400.f;
+		else if (step.xyspeed > 100)
+			step.bobmove = gi.frame_time_ms / 800.f;
 		else
-			bobmove = gi.frame_time_ms / 1600.f;
-	}
-
-	bobtime = (current_client->bobtime += bobmove);
-	bobtime_run = bobtime;
-
-	if ((current_client->ps.pmove.pm_flags & PMF_DUCKED) && ent->groundentity)
+			step.bobmove = gi.frame_time_ms / 1600.f;
+	}
+
+	float bobtime = (client->bobtime += step.bobmove);
+	float bobtime_run = bobtime;
+
+	if ((client->ps.pmove.pm_flags & PMF_DUCKED) && ent->groundentity)
 		bobtime *= 4;
 
-	bobcycle = (int) bobtime;
-	bobcycle_run = (int) bobtime_run;
-	bobfracsin = fabsf(sinf(bobtime * PIf));
+	step.bobcycle = (int) bobtime;
+	step.bobcycle_run = (int) bobtime_run;
+	step.bobfracsin = fabsf(sinf(bobtime * PIf));
+
+	// burn from lava, etc
+	P_WorldEffects(ent, step);
 
 	// apply all the damage taken this frame
-	P_DamageFeedback(ent);
+	P_DamageFeedback(ent, forward, right, up);
 
 	// determine the view offsets
-	SV_CalcViewOffset(ent);
+	SV_CalcViewOffset(ent, forward, right, step);
 
 	// determine the gun offsets
-	SV_CalcGunOffset(ent);
+	SV_CalcGunOffset(ent, forward, right, up, step);
 
 	// determine the full screen color blend
 	// must be after viewoffset, so eye contents can be
@@ -1477,13 +1481,13 @@
 
 	G_SetCoopStats(ent);
 
-	G_SetClientEvent(ent);
+	G_SetClientEvent(ent, step);
 
 	G_SetClientEffects(ent);
 
 	G_SetClientSound(ent);
 
-	G_SetClientFrame(ent);
+	G_SetClientFrame(ent, step);
 
 	ent->client->oldvelocity = ent->velocity;
 	ent->client->oldviewangles = ent->client->ps.viewangles;
--- a/p_weapon.cpp	2023-10-03 19:43:06
+++ b/p_weapon.cpp	2024-10-28 12:37:33
@@ -88,7 +88,7 @@
 	ent->client->kick.time = level.time + ent->client->kick.total;
 }
 
-void P_ProjectSource(edict_t *ent, const vec3_t &angles, vec3_t distance, vec3_t &result_start, vec3_t &result_dir)
+void P_ProjectSource(edict_t *ent, const vec3_t &angles, vec3_t distance, vec3_t &result_start, vec3_t &result_dir, bool adjust_for_pierce)
 {
 	if (ent->client->pers.hand == LEFT_HANDED)
 		distance[1] *= -1;
@@ -111,27 +111,29 @@
 
 	trace_t tr = gi.traceline(eye_position, end, ent, mask);
 
-	// if the point was a monster & close to us, use raw forward
+	// if the point was damageable, use raw forward
 	// so railgun pierces properly
-	if (tr.startsolid || ((tr.contents & (CONTENTS_MONSTER | CONTENTS_PLAYER)) && (tr.fraction * 8192.f) < 128.f))
+	if ((tr.startsolid || adjust_for_pierce) && tr.ent->takedamage)
+	{
 		result_dir = forward;
-	else
-	{
-		end = tr.endpos;
+		return;
+	}
+
+	end = tr.endpos;
+	result_dir = (end - result_start).normalized();
+
+#if 0
+	// correction for blocked shots.
+	// disabled because it looks weird.
+	trace_t eye_tr = gi.traceline(result_start, result_start + (result_dir * tr.fraction * 8192.f), ent, mask);
+
+	if ((eye_tr.endpos - tr.endpos).length() > 32.f)
+	{
+		result_start = eye_position;
 		result_dir = (end - result_start).normalized();
-
-#if 0
-		// correction for blocked shots
-		trace_t eye_tr = gi.traceline(result_start, result_start + (result_dir * tr.fraction * 8192.f), ent, mask);
-
-		if ((eye_tr.endpos - tr.endpos).length() > 32.f)
-		{
-			result_start = eye_position;
-			result_dir = (end - result_start).normalized();
-			return;
-		}
+		return;
+	}
 #endif
-	}
 }
 
 /*
@@ -266,7 +268,15 @@
 			if (G_CheckInfiniteAmmo(ammo))
 				Add_Ammo(other, ammo, 1000);
 			else
-				Add_Ammo(other, ammo, ammo->quantity);
+			{
+				// in PSX, we get double ammo with pickups
+				int given_quantity = ammo->quantity;
+
+				if (level.is_psx && deathmatch->integer)
+					given_quantity *= 2;
+
+				Add_Ammo(other, ammo, given_quantity);
+			}
 		}
 
 		if (!(ent->spawnflags & SPAWNFLAG_ITEM_DROPPED_PLAYER))
@@ -1420,7 +1430,7 @@
 				damage = 15;
 			else
 				damage = 20;
-			Blaster_Fire(ent, offset, damage, true, (ent->client->ps.gunframe % 4) ? EF_NONE : EF_HYPERBLASTER);
+			Blaster_Fire(ent, offset, damage, true, ((ent->client->ps.gunframe - 6) % 4) == 0 ? EF_HYPERBLASTER : EF_NONE);
 			Weapon_PowerupSound(ent);
 
 			G_RemoveAmmo(ent);
@@ -1509,7 +1519,7 @@
 	// get start / end positions
 	vec3_t start, dir;
 	// Paril: kill sideways angle on hitscan
-	P_ProjectSource(ent, ent->client->v_angle, { 0, 0, -8 }, start, dir);
+	P_ProjectSource(ent, ent->client->v_angle, { 0, 0, -8 }, start, dir, true);
 	G_LagCompensate(ent, start, dir);
 	fire_bullet(ent, start, dir, damage, kick, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MOD_MACHINEGUN);
 	G_UnLagCompensate();
@@ -1638,7 +1648,7 @@
 	P_AddWeaponKick(ent, kick_origin, kick_angles);
 
 	vec3_t start, dir;
-	P_ProjectSource(ent, ent->client->v_angle, { 0, 0, -8 }, start, dir);
+	P_ProjectSource(ent, ent->client->v_angle, { 0, 0, -8 }, start, dir, true);
 
 	G_LagCompensate(ent, start, dir);
 	for (i = 0; i < shots; i++)
@@ -1647,7 +1657,7 @@
 		// Paril: kill sideways angle on hitscan
 		r = crandom() * 4;
 		u = crandom() * 4;
-		P_ProjectSource(ent, ent->client->v_angle, { 0, r, u + -8 }, start, dir);
+		P_ProjectSource(ent, ent->client->v_angle, { 0, r, u + -8 }, start, dir, true);
 
 		fire_bullet(ent, start, dir, damage, kick, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MOD_CHAINGUN);
 	}
@@ -1688,7 +1698,7 @@
 
 	vec3_t start, dir;
 	// Paril: kill sideways angle on hitscan
-	P_ProjectSource(ent, ent->client->v_angle, { 0, 0, -8 }, start, dir);
+	P_ProjectSource(ent, ent->client->v_angle, { 0, 0, -8 }, start, dir, true);
 
 	P_AddWeaponKick(ent, ent->client->v_forward * -2, { -2.f, 0.f, 0.f });
 
@@ -1744,10 +1754,10 @@
 	v[YAW] = ent->client->v_angle[YAW] - 5;
 	v[ROLL] = ent->client->v_angle[ROLL];
 	// Paril: kill sideways angle on hitscan
-	P_ProjectSource(ent, v, { 0, 0, -8 }, start, dir);
+	P_ProjectSource(ent, v, { 0, 0, -8 }, start, dir, true);
 	fire_shotgun(ent, start, dir, damage, kick, DEFAULT_SHOTGUN_HSPREAD, DEFAULT_SHOTGUN_VSPREAD, DEFAULT_SSHOTGUN_COUNT / 2, MOD_SSHOTGUN);
 	v[YAW] = ent->client->v_angle[YAW] + 5;
-	P_ProjectSource(ent, v, { 0, 0, -8 }, start, dir);
+	P_ProjectSource(ent, v, { 0, 0, -8 }, start, dir, true);
 	fire_shotgun(ent, start, dir, damage, kick, DEFAULT_SHOTGUN_HSPREAD, DEFAULT_SHOTGUN_VSPREAD, DEFAULT_SSHOTGUN_COUNT / 2, MOD_SSHOTGUN);
 	G_UnLagCompensate();
 
@@ -1803,7 +1813,7 @@
 	}
 
 	vec3_t start, dir;
-	P_ProjectSource(ent, ent->client->v_angle, { 0, 7, -8 }, start, dir);
+	P_ProjectSource(ent, ent->client->v_angle, { 0, 7, -8 }, start, dir, true);
 	G_LagCompensate(ent, start, dir);
 	fire_rail(ent, start, dir, damage, kick);
 	G_UnLagCompensate();
--- a/q_std.h	2023-10-03 19:43:06
+++ b/q_std.h	2024-07-07 03:52:24
@@ -24,11 +24,11 @@
 // format!
 #ifndef USE_CPP20_FORMAT
 #ifdef __cpp_lib_format
-#define USE_CPP20_FORMAT 1
-#endif
-#endif
-
-#if USE_CPP20_FORMAT
+#define USE_CPP20_FORMAT
+#endif
+#endif
+
+#ifdef USE_CPP20_FORMAT
 #include <format>
 namespace fmt = std;
 #define FMT_STRING(s) s
@@ -104,8 +104,8 @@
 
 using byte = uint8_t;
 
-// note: only works on actual arrays
-#define q_countof(a) std::extent_v<decltype(a)>
+template<class T, std::size_t N>
+constexpr size_t q_countof(const T (&array)[N]) { return std::size<T, N>(array); }
 
 using std::max;
 using std::min;
--- a/q_vec3.h	2023-10-03 19:43:06
+++ b/q_vec3.h	2024-09-28 02:37:06
@@ -514,10 +514,19 @@
     float dot = from.dot(to);
     float aFactor;
     float bFactor;
-    if (fabsf(dot) > 0.9995f)
+	if (dot >= 0.9995f)
+	{
+		aFactor = 1.0f - t;
+		bFactor = t;
+	}
+    else if (dot <= -0.9995f)
     {
-        aFactor = 1.0f - t;
-        bFactor = t;
+		vec3_t c = vec3_t { 1.0f, 0.0f, 0.0f }.cross(to);
+
+		if (t <= 0.5f)
+			return lerp(from, c, t * 2);
+		else
+			return lerp(c, to, (t - 0.5f) * 2);
     }
     else
     {
@@ -536,7 +545,7 @@
 struct fmt::formatter<vec3_t> : fmt::formatter<float>
 {
     template<typename FormatContext>
-    auto format(const vec3_t &p, FormatContext &ctx) -> decltype(ctx.out())
+    auto format(const vec3_t &p, FormatContext &ctx) const
     {
 		auto out = fmt::formatter<float>::format(p.x, ctx);
         out = fmt::format_to(out, " ");
--- a/rogue/g_rogue_func.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_func.cpp	2024-09-24 14:11:43
@@ -54,18 +54,18 @@
 		if (!ent->spawnflags.has(SPAWNFLAGS_PLAT2_TOGGLE))
 		{
 			ent->think = plat2_go_down;
-			ent->nextthink = level.time + 5_sec;
+			ent->nextthink = level.time + gtime_t::from_sec(ent->wait * 2.5f);
 		}
 		if (deathmatch->integer)
-			ent->last_move_time = level.time - 1_sec;
+			ent->last_move_time = level.time - gtime_t::from_sec(ent->wait * 0.5f);
 		else
-			ent->last_move_time = level.time - 2_sec;
+			ent->last_move_time = level.time - gtime_t::from_sec(ent->wait);
 	}
 	else if (!(ent->spawnflags & SPAWNFLAGS_PLAT2_TOP) && !ent->spawnflags.has(SPAWNFLAGS_PLAT2_TOGGLE))
 	{
 		ent->plat2flags = PLAT2_NONE;
 		ent->think = plat2_go_down;
-		ent->nextthink = level.time + 2_sec;
+		ent->nextthink = level.time + gtime_t::from_sec(ent->wait);
 		ent->last_move_time = level.time;
 	}
 	else
@@ -93,18 +93,18 @@
 		if (!(ent->spawnflags & SPAWNFLAGS_PLAT2_TOGGLE))
 		{
 			ent->think = plat2_go_up;
-			ent->nextthink = level.time + 5_sec;
+			ent->nextthink = level.time + gtime_t::from_sec(ent->wait * 2.5f);
 		}
 		if (deathmatch->integer)
-			ent->last_move_time = level.time - 1_sec;
+			ent->last_move_time = level.time - gtime_t::from_sec(ent->wait * 0.5f);
 		else
-			ent->last_move_time = level.time - 2_sec;
+			ent->last_move_time = level.time - gtime_t::from_sec(ent->wait);
 	}
 	else if (ent->spawnflags.has(SPAWNFLAGS_PLAT2_TOP) && !ent->spawnflags.has(SPAWNFLAGS_PLAT2_TOGGLE))
 	{
 		ent->plat2flags = PLAT2_NONE;
 		ent->think = plat2_go_up;
-		ent->nextthink = level.time + 2_sec;
+		ent->nextthink = level.time + gtime_t::from_sec(ent->wait);
 		ent->last_move_time = level.time;
 	}
 	else
@@ -164,7 +164,7 @@
 	if (ent->plat2flags & PLAT2_MOVING)
 		return;
 
-	if ((ent->last_move_time + 2_sec) > level.time)
+	if ((ent->last_move_time + gtime_t::from_sec(ent->wait)) > level.time)
 		return;
 
 	platCenter = (trigger->absmin[2] + trigger->absmax[2]) / 2;
@@ -338,6 +338,8 @@
 */
 void SP_func_plat2(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	edict_t *trigger;
 
 	ent->s.angles = {};
@@ -373,9 +375,6 @@
 	// PMM Added to kill things it's being blocked by
 	if (!ent->dmg)
 		ent->dmg = 2;
-
-	//	if (!st.lip)
-	//		st.lip = 8;
 
 	// pos1 is the top position, pos2 is the bottom
 	ent->pos1 = ent->s.origin;
@@ -426,5 +425,8 @@
 	ent->moveinfo.end_origin = ent->pos2;
 	ent->moveinfo.end_angles = ent->s.angles;
 
+	if (!ent->wait)
+		ent->wait = 2.0f;
+
 	G_SetMoveinfoSounds(ent, "plats/pt1_strt.wav", "plats/pt1_mid.wav", "plats/pt1_end.wav");
 }
--- a/rogue/g_rogue_items.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_items.cpp	2024-07-07 03:52:24
@@ -204,11 +204,16 @@
 		self->velocity = forward * 100;
 		self->velocity[2] = 300;
 	}
-
-	if (self->item->id != IT_KEY_POWER_CUBE && self->item->id != IT_KEY_EXPLOSIVE_CHARGES) // leave them be on key_power_cube..
-		self->spawnflags &= SPAWNFLAG_ITEM_NO_TOUCH;
-
-	droptofloor(self);
+	
+	if (!self->spawnflags.has(SPAWNFLAG_ITEM_NO_DROP))
+	{
+		if (self->item->id != IT_KEY_POWER_CUBE && self->item->id != IT_KEY_EXPLOSIVE_CHARGES) // leave them be on key_power_cube..
+			self->spawnflags &= SPAWNFLAG_ITEM_NO_TOUCH;
+	}
+	else
+		self->spawnflags &= ~SPAWNFLAG_ITEM_TRIGGER_SPAWN;
+
+    droptofloor(self);
 }
 
 //=================
--- a/rogue/g_rogue_monster.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_monster.cpp	2024-09-24 14:32:51
@@ -85,11 +85,11 @@
 		stationarymonster_triggered_start(self);
 }
 
-void stationarymonster_start(edict_t *self)
+void stationarymonster_start(edict_t *self, const spawn_temp_t &st)
 {
 	self->flags |= FL_STATIONARY;
 	self->think = stationarymonster_start_go;
-	monster_start(self);
+	monster_start(self, st);
 
 	// fix viewheight
 	self->viewheight = 0;
--- a/rogue/g_rogue_newdm.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_newdm.cpp	2024-09-24 11:14:15
@@ -13,7 +13,6 @@
 //=================
 constexpr item_flags_t IF_TYPE_MASK = (IF_WEAPON | IF_AMMO | IF_POWERUP | IF_ARMOR | IF_KEY);
 
-void ED_CallSpawn(edict_t *ent);
 bool Pickup_Health(edict_t *ent, edict_t *other);
 bool Pickup_Armor(edict_t *ent, edict_t *other);
 bool Pickup_PowerArmor(edict_t *ent, edict_t *other);
--- a/rogue/g_rogue_newweap.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_newweap.cpp	2024-09-26 12:58:12
@@ -86,11 +86,11 @@
 constexpr float	  PROX_BOUND_SIZE = 96;
 constexpr float	  PROX_DAMAGE_RADIUS = 192;
 constexpr int32_t PROX_HEALTH = 20;
-constexpr int32_t PROX_DAMAGE = 90;
+constexpr int32_t PROX_DAMAGE = 60;
+constexpr float   PROX_DAMAGE_OPEN_MULTIPLIER = 1.5f; // expands 60 to 90 when it opens
 
 //===============
-//===============
-THINK(Prox_Explode) (edict_t *ent) -> void
+static void Prox_ExplodeReal(edict_t *ent, edict_t *other, vec3_t normal)
 {
 	vec3_t	 origin;
 	edict_t *owner;
@@ -108,14 +108,20 @@
 		PlayerNoise(owner, ent->s.origin, PNOISE_IMPACT);
 	}
 
+	if (other)
+	{
+		vec3_t dir = other->s.origin - ent->s.origin;
+		T_Damage(other, ent, owner, dir, ent->s.origin, normal, ent->dmg, ent->dmg, DAMAGE_NONE, MOD_PROX);
+	}
+
 	// play quad sound if appopriate
-	if (ent->dmg > PROX_DAMAGE)
+	if (ent->dmg > PROX_DAMAGE * PROX_DAMAGE_OPEN_MULTIPLIER)
 		gi.sound(ent, CHAN_ITEM, gi.soundindex("items/damage3.wav"), 1, ATTN_NORM, 0);
 
 	ent->takedamage = false;
-	T_RadiusDamage(ent, owner, (float) ent->dmg, ent, PROX_DAMAGE_RADIUS, DAMAGE_NONE, MOD_PROX);
-
-	origin = ent->s.origin + (ent->velocity * -0.02f);
+	T_RadiusDamage(ent, owner, (float) ent->dmg, other, PROX_DAMAGE_RADIUS, DAMAGE_NONE, MOD_PROX);
+
+	origin = ent->s.origin + normal;
 	gi.WriteByte(svc_temp_entity);
 	if (ent->groundentity)
 		gi.WriteByte(TE_GRENADE_EXPLOSION);
@@ -125,6 +131,11 @@
 	gi.multicast(ent->s.origin, MULTICAST_PHS, false);
 
 	G_FreeEdict(ent);
+}
+
+THINK(Prox_Explode) (edict_t *ent) -> void
+{
+	Prox_ExplodeReal(ent, nullptr, (ent->velocity * -0.02f));
 }
 
 //===============
@@ -252,7 +263,7 @@
 			ent->wait = (level.time + PROX_TIME_TO_LIVE).seconds();
 		else
 		{
-			switch (ent->dmg / PROX_DAMAGE)
+			switch ((int) (ent->dmg / (PROX_DAMAGE * PROX_DAMAGE_OPEN_MULTIPLIER)))
 			{
 			case 1:
 				ent->wait = (level.time + PROX_TIME_TO_LIVE).seconds();
@@ -278,7 +289,10 @@
 	else
 	{
 		if (ent->s.frame == 0)
+		{
 			gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/proxopen.wav"), 1, ATTN_NORM, 0);
+			ent->dmg *= PROX_DAMAGE_OPEN_MULTIPLIER;
+		}
 		ent->s.frame++;
 		ent->think = prox_open;
 		ent->nextthink = level.time + 10_hz;
@@ -320,7 +334,7 @@
 	if (!tr.plane.normal || (other->svflags & SVF_MONSTER) || other->client || (other->flags & FL_DAMAGEABLE))
 	{
 		if (other != ent->teammaster)
-			Prox_Explode(ent);
+			Prox_ExplodeReal(ent, other, tr.plane.normal);
 
 		return;
 	}
--- a/rogue/g_rogue_spawn.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_spawn.cpp	2024-09-24 11:14:07
@@ -30,9 +30,7 @@
 //
 edict_t *CreateMonster(const vec3_t &origin, const vec3_t &angles, const char *classname)
 {
-	edict_t *newEnt;
-
-	newEnt = G_Spawn();
+	edict_t *newEnt = G_Spawn();
 
 	newEnt->s.origin = origin;
 	newEnt->s.angles = angles;
--- a/rogue/m_rogue_carrier.cpp	2023-10-03 19:43:06
+++ b/rogue/m_rogue_carrier.cpp	2024-09-26 12:13:32
@@ -28,8 +28,6 @@
 bool inback(edict_t *self, edict_t *other);
 bool below(edict_t *self, edict_t *other);
 void drawbbox(edict_t *self);
-
-void ED_CallSpawn(edict_t *ent);
 
 static cached_soundindex sound_pain1;
 static cached_soundindex sound_pain2;
@@ -42,9 +40,6 @@
 static cached_soundindex sound_cg_down, sound_cg_loop, sound_cg_up;
 
 float orig_yaw_speed;
-
-void M_SetupReinforcements(const char *reinforcements, reinforcement_list_t &list);
-std::array<uint8_t, MAX_REINFORCEMENTS> M_PickReinforcements(edict_t *self, int32_t &num_chosen, int32_t max_slots);
 
 extern const mmove_t flyer_move_attack2, flyer_move_attack3, flyer_move_kamikaze;
 
@@ -356,9 +351,9 @@
 		ent->nextthink = level.time;
 		ent->think(ent);
 
-		ent->monsterinfo.aiflags |= AI_SPAWNED_CARRIER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
+		ent->monsterinfo.aiflags |= AI_SPAWNED_COMMANDER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
 		ent->monsterinfo.commander = self;
-		ent->monsterinfo.monster_slots = reinforcement.strength;
+		ent->monsterinfo.slots_from_commander = reinforcement.strength;
 		self->monsterinfo.monster_used += reinforcement.strength;
 
 		if ((self->enemy->inuse) && (self->enemy->health > 0))
@@ -1055,6 +1050,8 @@
  */
 void SP_monster_carrier(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/rogue/m_rogue_stalker.cpp	2023-10-03 19:43:06
+++ b/rogue/m_rogue_stalker.cpp	2024-09-24 14:08:55
@@ -58,7 +58,7 @@
 	else
 	{
 		// her stalkers are just better
-		if (self->monsterinfo.aiflags & AI_SPAWNED_WIDOW)
+		if (self->monsterinfo.commander && self->monsterinfo.commander->inuse && !strncmp(self->monsterinfo.commander->classname, "monster_widow", 13))
 			max_dist = 256;
 		else
 			max_dist = 180;
@@ -974,6 +974,8 @@
 
 void SP_monster_stalker(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/rogue/m_rogue_turret.cpp	2023-10-03 19:43:06
+++ b/rogue/m_rogue_turret.cpp	2024-09-24 14:32:23
@@ -729,7 +729,7 @@
 
 	gi.linkentity(ent);
 
-	stationarymonster_start(ent);
+	stationarymonster_start(ent, spawn_temp_t::empty);
 
 	if (ent->spawnflags.has(SPAWNFLAG_TURRET_MACHINEGUN))
 	{
@@ -916,6 +916,7 @@
 */
 void SP_monster_turret(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	int angle;
 
 	if ( !M_AllowSpawn( self ) ) {
@@ -1030,7 +1031,7 @@
 	}
 	else
 	{
-		stationarymonster_start(self);
+		stationarymonster_start(self, ED_GetSpawnTemp());
 	}
 
 	if (self->spawnflags.has(SPAWNFLAG_TURRET_MACHINEGUN))
--- a/rogue/m_rogue_widow.cpp	2023-10-03 19:43:06
+++ b/rogue/m_rogue_widow.cpp	2024-09-27 17:43:02
@@ -274,11 +274,12 @@
 
 			self->monsterinfo.monster_used++;
 			ent->monsterinfo.commander = self;
+			ent->monsterinfo.slots_from_commander = 1;
 
 			ent->nextthink = level.time;
 			ent->think(ent);
 
-			ent->monsterinfo.aiflags |= AI_SPAWNED_WIDOW | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
+			ent->monsterinfo.aiflags |= AI_SPAWNED_COMMANDER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
 
 			if (!coop->integer)
 			{
@@ -1243,6 +1244,8 @@
  */
 void SP_monster_widow(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/rogue/m_rogue_widow2.cpp	2023-10-03 19:43:06
+++ b/rogue/m_rogue_widow2.cpp	2024-09-27 19:48:44
@@ -167,11 +167,12 @@
 
 			self->monsterinfo.monster_used++;
 			ent->monsterinfo.commander = self;
+			ent->monsterinfo.slots_from_commander = 1;
 
 			ent->nextthink = level.time;
 			ent->think(ent);
 
-			ent->monsterinfo.aiflags |= AI_SPAWNED_WIDOW | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
+			ent->monsterinfo.aiflags |= AI_SPAWNED_COMMANDER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
 
 			if (!coop->integer)
 			{
@@ -1002,6 +1003,8 @@
  */
 void SP_monster_widow2(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/rogue/rogue_dm_tag.cpp	2023-10-03 19:43:06
+++ b/rogue/rogue_dm_tag.cpp	2024-09-24 14:24:16
@@ -293,5 +293,5 @@
 	self->classname = "dm_tag_token";
 	self->model = "models/items/tagtoken/tris.md2";
 	self->count = 1;
-	SpawnItem(self, GetItemByIndex(IT_ITEM_TAG_TOKEN));
-}
+	SpawnItem(self, GetItemByIndex(IT_ITEM_TAG_TOKEN), ED_GetSpawnTemp());
+}
--- a/xatrix/g_xatrix_items.cpp	2023-10-03 19:43:06
+++ b/xatrix/g_xatrix_items.cpp	2024-09-24 14:24:16
@@ -13,7 +13,7 @@
 	}
 
 	self->model = "models/objects/trapfx/tris.md2";
-	SpawnItem(self, GetItemByIndex(IT_HEALTH_SMALL));
+	SpawnItem(self, GetItemByIndex(IT_HEALTH_SMALL), ED_GetSpawnTemp());
 	self->spawnflags |= SPAWNFLAG_ITEM_DROPPED;
 	self->style = HEALTH_IGNORE_MAX;
 	self->classname = "item_foodcube";
--- a/xatrix/g_xatrix_monster.cpp	2023-10-03 19:43:06
+++ b/xatrix/g_xatrix_monster.cpp	2024-09-25 22:56:24
@@ -97,8 +97,6 @@
 	gi.linkentity(self);
 }
 
-constexpr spawnflags_t SPAWNFLAG_DABEAM_SECONDARY = 1_spawnflag;
-
 THINK(beam_think) (edict_t *self) -> void
 {
 	if (self->spawnflags.has(SPAWNFLAG_DABEAM_SECONDARY))
@@ -137,6 +135,8 @@
 	}
 
 	beam_ptr->nextthink = level.time + 200_ms;
+	beam_ptr->spawnflags &= ~SPAWNFLAG_DABEAM_SPAWNED;
 	update_func(beam_ptr);
 	dabeam_update(beam_ptr, true);
+	beam_ptr->spawnflags |= SPAWNFLAG_DABEAM_SPAWNED;
 }
--- a/xatrix/g_xatrix_weapon.cpp	2023-10-03 19:43:06
+++ b/xatrix/g_xatrix_weapon.cpp	2024-09-28 04:01:49
@@ -135,51 +135,61 @@
 
 THINK(heat_think) (edict_t *self) -> void
 {
-	edict_t *target = nullptr;
 	edict_t *acquire = nullptr;
-	vec3_t	 vec;
-	vec3_t	 oldang;
-	float	 len;
 	float	 oldlen = 0;
-	float	 dot, olddot = 1;
+	float	 olddot = 1;
 
 	vec3_t fwd = AngleVectors(self->s.angles).forward;
 
-	// acquire new target
-	while ((target = findradius(target, self->s.origin, 1024)) != nullptr)
-	{
-		if (self->owner == target)
-			continue;
-		if (!target->client)
-			continue;
-		if (target->health <= 0)
-			continue;
-		if (!visible(self, target))
-			continue;
-		//if (!infront(self, target))
-		//	continue;
-
-		vec = self->s.origin - target->s.origin;
-		len = vec.length();
-
-		dot = vec.normalized().dot(fwd);
-
-		// targets that require us to turn less are preferred
-		if (dot >= olddot)
-			continue;
-
-		if (acquire == nullptr || dot < olddot || len < oldlen)
-		{
-			acquire = target;
-			oldlen = len;
-			olddot = dot;
+	// try to stay on current target if possible
+	if (self->enemy)
+	{
+		acquire = self->enemy;
+
+		if (acquire->health <= 0 ||
+			!visible(self, acquire))
+		{
+			self->enemy = acquire = nullptr;
+		}
+	}
+
+	if (!acquire)
+	{
+		edict_t *target = nullptr;
+
+		// acquire new target
+		while ((target = findradius(target, self->s.origin, 1024)) != nullptr)
+		{
+			if (self->owner == target)
+				continue;
+			if (!target->client)
+				continue;
+			if (target->health <= 0)
+				continue;
+			if (!visible(self, target))
+				continue;
+
+			vec3_t vec = self->s.origin - target->s.origin;
+			float len = vec.length();
+
+			float dot = vec.normalized().dot(fwd);
+
+			// targets that require us to turn less are preferred
+			if (dot >= olddot)
+				continue;
+
+			if (acquire == nullptr || dot < olddot || len < oldlen)
+			{
+				acquire = target;
+				oldlen = len;
+				olddot = dot;
+			}
 		}
 	}
 
 	if (acquire != nullptr)
 	{
-		oldang = self->s.angles;
-		vec = (acquire->s.origin - self->s.origin).normalized();
+		vec3_t vec = (acquire->s.origin - self->s.origin).normalized();
 		float t = self->accel;
 
 		float d = self->movedir.dot(vec);
@@ -190,7 +200,7 @@
 		self->movedir = slerp(self->movedir, vec, t).normalized();
 		self->s.angles = vectoangles(self->movedir);
 
-		if (!self->enemy)
+		if (self->enemy != acquire)
 		{
 			gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/railgr1a.wav"), 1.f, 0.25f, 0);
 			self->enemy = acquire;
@@ -233,6 +243,12 @@
 	heat->dmg_radius = damage_radius;
 	heat->s.sound = gi.soundindex("weapons/rockfly.wav");
 
+	if (visible(heat, self->enemy))
+	{
+		heat->enemy = self->enemy;
+		gi.sound(heat, CHAN_WEAPON, gi.soundindex("weapons/railgr1a.wav"), 1.f, 0.25f, 0);
+	}
+
 	gi.linkentity(heat);
 }
 
@@ -259,11 +275,11 @@
 		PlayerNoise(ent->owner, ent->s.origin, PNOISE_IMPACT);
 
 	// calculate position for the explosion entity
-	origin = ent->s.origin + (ent->velocity * -0.02f);
+	origin = ent->s.origin + tr.plane.normal;
 
 	if (other->takedamage)
 	{
-		T_Damage(other, ent, ent->owner, ent->velocity, ent->s.origin, tr.plane.normal, ent->dmg, 0, DAMAGE_ENERGY, MOD_PHALANX);
+		T_Damage(other, ent, ent->owner, ent->velocity, ent->s.origin, tr.plane.normal, ent->dmg, ent->dmg, DAMAGE_ENERGY, MOD_PHALANX);
 	}
 
 	T_RadiusDamage(ent, ent->owner, (float) ent->radius_dmg, other, ent->dmg_radius, DAMAGE_ENERGY, MOD_PHALANX);
--- a/xatrix/m_xatrix_fixbot.cpp	2023-10-03 19:43:06
+++ b/xatrix/m_xatrix_fixbot.cpp	2024-09-25 23:02:01
@@ -55,51 +55,14 @@
 	self->nextthink = level.time + 1_ms;
 }
 
-void ED_CallSpawn(edict_t *ent);
+edict_t *healFindMonster(edict_t *self, float radius);
 
 edict_t *fixbot_FindDeadMonster(edict_t *self)
 {
-	edict_t *ent = nullptr;
-	edict_t *best = nullptr;
-
-	while ((ent = findradius(ent, self->s.origin, 1024)) != nullptr)
-	{
-		if (ent == self)
-			continue;
-		if (!(ent->svflags & SVF_MONSTER))
-			continue;
-		if (ent->monsterinfo.aiflags & AI_GOOD_GUY)
-			continue;
-		// check to make sure we haven't bailed on this guy already
-		if ((ent->monsterinfo.badMedic1 == self) || (ent->monsterinfo.badMedic2 == self))
-			continue;
-		if (ent->monsterinfo.healer)
-			// FIXME - this is correcting a bug that is somewhere else
-			// if the healer is a monster, and it's in medic mode .. continue .. otherwise
-			//   we will override the healer, if it passes all the other tests
-			if ((ent->monsterinfo.healer->inuse) && (ent->monsterinfo.healer->health > 0) &&
-				(ent->monsterinfo.healer->svflags & SVF_MONSTER) && (ent->monsterinfo.healer->monsterinfo.aiflags & AI_MEDIC))
-				continue;
-		if (ent->health > 0)
-			continue;
-		if ((ent->nextthink) && (ent->think != monster_dead_think))
-			continue;
-		if (!visible(self, ent))
-			continue;
-		if (!best)
-		{
-			best = ent;
-			continue;
-		}
-		if (ent->max_health <= best->max_health)
-			continue;
-		best = ent;
-	}
-
-	return best;
-}
-
-static void fixbot_set_fly_parameters(edict_t *self, bool heal, bool weld)
+	return healFindMonster(self, 1024);
+}
+
+static void fixbot_set_fly_parameters(edict_t *self, bool heal, bool weld, bool roam)
 {
 	self->monsterinfo.fly_position_time = 0_sec;
 	self->monsterinfo.fly_acceleration = 5.f;
@@ -112,10 +75,10 @@
 		self->monsterinfo.fly_max_distance = 100.f;
 		self->monsterinfo.fly_thrusters = true;
 	}
-	else if (weld)
-	{
-		self->monsterinfo.fly_min_distance = 24.f;
-		self->monsterinfo.fly_max_distance = 24.f;
+	else if (weld || roam)
+	{
+		self->monsterinfo.fly_min_distance = 16.f;
+		self->monsterinfo.fly_max_distance = 16.f;
 	}
 	else
 	{
@@ -139,7 +102,7 @@
 			self->enemy->monsterinfo.healer = self;
 			self->monsterinfo.aiflags |= AI_MEDIC;
 			FoundTarget(self);
-			fixbot_set_fly_parameters(self, true, false);
+			fixbot_set_fly_parameters(self, true, false, false);
 			return (1);
 		}
 	}
@@ -204,33 +167,37 @@
 	M_SetAnimation(self, &fixbot_move_takeoff);
 }
 
+
+constexpr spawnflags_t SPAWNFLAG_FIXBOT_FLAGS = SPAWNFLAG_FIXBOT_FIXIT | SPAWNFLAG_FIXBOT_TAKEOFF | SPAWNFLAG_FIXBOT_LANDING | SPAWNFLAG_FIXBOT_WORKING;
+
 void change_to_roam(edict_t *self)
 {
 
 	if (fixbot_search(self))
 		return;
 
+	fixbot_set_fly_parameters(self, false, false, true);
 	M_SetAnimation(self, &fixbot_move_roamgoal);
 
 	if (self->spawnflags.has(SPAWNFLAG_FIXBOT_LANDING))
 	{
 		landing_goal(self);
 		M_SetAnimation(self, &fixbot_move_landing);
-		self->spawnflags &= ~SPAWNFLAG_FIXBOT_LANDING;
-		self->spawnflags = SPAWNFLAG_FIXBOT_WORKING;
+		self->spawnflags &= ~SPAWNFLAG_FIXBOT_FLAGS;
+		self->spawnflags |= SPAWNFLAG_FIXBOT_WORKING;
 	}
 	if (self->spawnflags.has(SPAWNFLAG_FIXBOT_TAKEOFF))
 	{
 		takeoff_goal(self);
 		M_SetAnimation(self, &fixbot_move_takeoff);
-		self->spawnflags &= ~SPAWNFLAG_FIXBOT_TAKEOFF;
-		self->spawnflags = SPAWNFLAG_FIXBOT_WORKING;
+		self->spawnflags &= ~SPAWNFLAG_FIXBOT_FLAGS;
+		self->spawnflags |= SPAWNFLAG_FIXBOT_WORKING;
 	}
 	if (self->spawnflags.has(SPAWNFLAG_FIXBOT_FIXIT))
 	{
 		M_SetAnimation(self, &fixbot_move_roamgoal);
-		self->spawnflags &= ~SPAWNFLAG_FIXBOT_FIXIT;
-		self->spawnflags = SPAWNFLAG_FIXBOT_WORKING;
+		self->spawnflags &= ~SPAWNFLAG_FIXBOT_FLAGS;
+		self->spawnflags |= SPAWNFLAG_FIXBOT_WORKING;
 	}
 	if (!self->spawnflags)
 	{
@@ -321,9 +288,9 @@
 					vec = self->s.origin - self->goalentity->s.origin;
 					len = vec.normalize();
 
-					fixbot_set_fly_parameters(self, false, true);
-
-					if (len < 32)
+					fixbot_set_fly_parameters(self, false, true, false);
+
+					if (len < 86.0f)
 					{
 						M_SetAnimation(self, &fixbot_move_weld_start);
 						return;
@@ -343,7 +310,7 @@
 	vec = self->s.origin - self->goalentity->s.origin;
 	len = vec.length();
 
-	if (len < 32)
+	if (len < 86.0f)
 	{
 		if (strcmp(self->goalentity->classname, "object_repair") == 0)
 		{
@@ -357,27 +324,6 @@
 			M_SetAnimation(self, &fixbot_move_stand);
 		}
 		return;
-	}
-
-	vec = self->s.origin - self->s.old_origin;
-	len = vec.length();
-
-	/*
-	  bot is stuck get new goalentity
-	*/
-	if (len == 0)
-	{
-		if (strcmp(self->goalentity->classname, "object_repair") == 0)
-		{
-			M_SetAnimation(self, &fixbot_move_stand);
-		}
-		else
-		{
-			self->goalentity->nextthink = level.time + 100_ms;
-			self->goalentity->think = G_FreeEdict;
-			self->goalentity = self->enemy = nullptr;
-			M_SetAnimation(self, &fixbot_move_stand);
-		}
 	}
 }
 
@@ -919,7 +865,8 @@
 MMOVE_T(fixbot_move_attack1) = { FRAME_shoot_01, FRAME_shoot_06, fixbot_frames_attack1, nullptr };
 #endif
 
-void abortHeal(edict_t *self, bool change_frame, bool gib, bool mark);
+void abortHeal(edict_t *self, bool gib, bool mark);
+bool finishHeal(edict_t *self);
 
 PRETHINK(fixbot_laser_update) (edict_t *laser) -> void
 {
@@ -955,114 +902,33 @@
 		return;
 	}
 
-	monster_fire_dabeam(self, -1, false, fixbot_laser_update);
-
-	if (self->enemy->health > (self->enemy->mass / 10))
-	{
-		vec3_t maxs;
-		self->enemy->spawnflags = SPAWNFLAG_NONE;
-		self->enemy->monsterinfo.aiflags &= AI_STINKY | AI_SPAWNED_MASK;
-		self->enemy->target = nullptr;
-		self->enemy->targetname = nullptr;
-		self->enemy->combattarget = nullptr;
-		self->enemy->deathtarget = nullptr;
-		self->enemy->healthtarget = nullptr;
-		self->enemy->itemtarget = nullptr;
-		self->enemy->monsterinfo.healer = self;
-
-		maxs = self->enemy->maxs;
-		maxs[2] += 48; // compensate for change when they die
-
-		trace_t tr = gi.trace(self->enemy->s.origin, self->enemy->mins, maxs, self->enemy->s.origin, self->enemy, MASK_MONSTERSOLID);
-		if (tr.startsolid || tr.allsolid)
+	// fire the beam until they're within res range
+	bool firedLaser = false;
+
+	if (self->enemy->health < (self->enemy->mass / 10))
+	{
+		firedLaser = true;
+		monster_fire_dabeam(self, -1, false, fixbot_laser_update);
+	}
+
+	if (self->enemy->health >= (self->enemy->mass / 10))
+	{
+		// we have enough health now; if we didn't fire
+		// a laser, just make a fake one
+		if (!firedLaser)
+			monster_fire_dabeam(self, 0, false, fixbot_laser_update);
+		else
+			self->monsterinfo.fly_position_time = {};
+		
+		// change our fly parameter slightly so we back away
+		self->monsterinfo.fly_min_distance = self->monsterinfo.fly_max_distance = 200.f;
+
+		// don't revive if we are too close
+		if ((self->s.origin - self->enemy->s.origin).length() > 86.f)
 		{
-			abortHeal(self, false, true, false);
-			return;
+			finishHeal(self);
+			M_SetAnimation(self, &fixbot_move_stand);
 		}
-		else if (tr.ent != world)
-		{
-			abortHeal(self, false, true, false);
-			return;
-		}
-		else
-		{
-			self->enemy->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT;
-
-			// backup & restore health stuff, because of multipliers
-			int32_t old_max_health = self->enemy->max_health;
-			item_id_t old_power_armor_type = self->enemy->monsterinfo.initial_power_armor_type;
-			int32_t old_power_armor_power = self->enemy->monsterinfo.max_power_armor_power;
-			int32_t old_base_health = self->enemy->monsterinfo.base_health;
-			int32_t old_health_scaling = self->enemy->monsterinfo.health_scaling;
-			auto reinforcements = self->enemy->monsterinfo.reinforcements;
-			int32_t monster_slots = self->enemy->monsterinfo.monster_slots;
-			int32_t monster_used = self->enemy->monsterinfo.monster_used;
-			int32_t old_gib_health = self->enemy->gib_health;
-
-			st = {};
-			st.keys_specified.emplace("reinforcements");
-			st.reinforcements = "";
-
-			ED_CallSpawn(self->enemy);
-
-			self->enemy->monsterinfo.reinforcements = reinforcements;
-			self->enemy->monsterinfo.monster_slots = monster_slots;
-			self->enemy->monsterinfo.monster_used = monster_used;
-
-			self->enemy->gib_health = old_gib_health / 2;
-			self->enemy->health = self->enemy->max_health = old_max_health;
-			self->enemy->monsterinfo.power_armor_power = self->enemy->monsterinfo.max_power_armor_power = old_power_armor_power;
-			self->enemy->monsterinfo.power_armor_type = self->enemy->monsterinfo.initial_power_armor_type = old_power_armor_type;
-			self->enemy->monsterinfo.base_health = old_base_health;
-			self->enemy->monsterinfo.health_scaling = old_health_scaling;
-
-			if (self->enemy->monsterinfo.setskin)
-				self->enemy->monsterinfo.setskin(self->enemy);
-
-			if (self->enemy->think)
-			{
-				self->enemy->nextthink = level.time;
-				self->enemy->think(self->enemy);
-			}
-			self->enemy->monsterinfo.aiflags &= ~AI_RESURRECTING;
-			self->enemy->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT;
-			// turn off flies
-			self->enemy->s.effects &= ~EF_FLIES;
-			self->enemy->monsterinfo.healer = nullptr;
-
-			// clean up target, if we have one and it's legit
-			if (self->enemy && self->enemy->inuse)
-			{
-				cleanupHealTarget(self->enemy);
-
-				if ((self->oldenemy) && (self->oldenemy->inuse) && (self->oldenemy->health > 0))
-				{
-					self->enemy->enemy = self->oldenemy;
-					FoundTarget(self->enemy);
-				}
-				else
-				{
-					self->enemy->enemy = nullptr;
-					if (!FindTarget(self->enemy))
-					{
-						// no valid enemy, so stop acting
-						self->enemy->monsterinfo.pausetime = HOLD_FOREVER;
-						self->enemy->monsterinfo.stand(self->enemy);
-					}
-					self->enemy = nullptr;
-					self->oldenemy = nullptr;
-					if (!FindTarget(self))
-					{
-						// no valid enemy, so stop acting
-						self->monsterinfo.pausetime = HOLD_FOREVER;
-						self->monsterinfo.stand(self);
-						return;
-					}
-				}
-			}
-		}
-
-		M_SetAnimation(self, &fixbot_move_stand);
 	}
 	else
 		self->enemy->monsterinfo.aiflags |= AI_RESURRECTING;
@@ -1132,7 +998,10 @@
 			M_SetAnimation(self, &fixbot_move_weld_end);
 		}
 		else
-			self->goalentity->health -= 10;
+		{
+			if (!(self->spawnflags.has(SPAWNFLAG_MONSTER_SCENIC)))
+				self->goalentity->health -= 10;
+		}
 	}
 	else
 	{
@@ -1206,6 +1075,14 @@
 	if (!self->enemy)
 		return;
 
+	if (self->spawnflags.has(SPAWNFLAG_MONSTER_SCENIC))
+	{
+		if (self->timestamp >= level.time)
+			return;
+
+		self->timestamp = level.time + random_time(450_ms, 1500_ms);
+	}
+
 	vec[0] = 24.0;
 	vec[1] = -0.8f;
 	vec[2] = -10.0;
@@ -1315,7 +1192,7 @@
 	}
 	else
 	{
-		fixbot_set_fly_parameters(self, false, false);
+		fixbot_set_fly_parameters(self, false, false, false);
 		M_SetAnimation(self, &fixbot_move_attack2);
 	}
 }
@@ -1325,7 +1202,7 @@
 	if (level.time < self->pain_debounce_time)
 		return;
 
-	fixbot_set_fly_parameters(self, false, false);
+	fixbot_set_fly_parameters(self, false, false, false);
 	self->pain_debounce_time = level.time + 3_sec;
 	gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
 
@@ -1336,7 +1213,7 @@
 	else
 		M_SetAnimation(self, &fixbot_move_paina);
 
-	abortHeal(self, false, false, false);
+	abortHeal(self, false, false);
 }
 
 void fixbot_dead(edict_t *self)
@@ -1361,6 +1238,8 @@
  */
 void SP_monster_fixbot(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1397,7 +1276,7 @@
 	M_SetAnimation(self, &fixbot_move_stand);
 	self->monsterinfo.scale = MODEL_SCALE;
 	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
-	fixbot_set_fly_parameters(self, false, false);
+	fixbot_set_fly_parameters(self, false, false, false);
 
 	flymonster_start(self);
 }
--- a/xatrix/m_xatrix_gekk.cpp	2023-10-03 19:43:06
+++ b/xatrix/m_xatrix_gekk.cpp	2024-10-20 21:14:44
@@ -752,7 +752,7 @@
 		return;
 	}
 
-	if (self->enemy->health >= 0)
+	if (self->enemy->health > 0)
 		if (frandom() > 0.7f && (range_to(self, self->enemy) <= RANGE_NEAR))
 			M_SetAnimation(self, &gekk_move_spit);
 }
@@ -1584,6 +1584,8 @@
  */
 void SP_monster_gekk(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
