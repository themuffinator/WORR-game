# Diff created by create_repo_diff.py
# a = C:\_SOURCE\_CODE\quake2-rerelease-dll-main\rerelease
# b = C:\_SOURCE\_CODE\quake2-rerelease-dll-ionized-main\rerelease
# excludes = ['*.dll', '*.exe', '*.pdb', '.git', '.vs', 'bin', 'build', 'obj']

--- a/bg_local.h	2023-10-03 19:43:06
+++ b/bg_local.h	2025-09-04 19:53:48
@@ -12,13 +12,38 @@
 #define GAME_INCLUDE
 #include "game.h"
 
+// physics modifiers
+enum physics_flags_t
+{
+	PHYSICS_PC = 0,
+
+	PHYSICS_N64_MOVEMENT	= bit_v<0>,
+	PHYSICS_PSX_MOVEMENT	= bit_v<1>,
+
+	PHYSICS_PSX_SCALE		= bit_v<2>,
+
+	PHYSICS_DEATHMATCH		= bit_v<3>
+};
+
+// the total number of levels we'll track for the
+// end of unit screen.
+constexpr size_t MAX_LEVELS_PER_UNIT = 16;
+
+MAKE_ENUM_BITFLAGS(physics_flags_t);
+
+// can't crouch in single player N64
+constexpr bool PM_CrouchingDisabled(physics_flags_t flags)
+{
+	return (flags & PHYSICS_N64_MOVEMENT) && !(flags & PHYSICS_DEATHMATCH);
+}
+
 //
 // p_move.c
 //
 struct pm_config_t
 {
-	int32_t		airaccel = 0;
-	bool		n64_physics = false;
+	int32_t			airaccel = 0;
+	physics_flags_t	physics_flags = PHYSICS_PC;
 };
 
 extern pm_config_t pm_config;
@@ -64,8 +89,8 @@
 	CONFIG_COOP_RESPAWN_STRING,
 	CONFIG_COOP_RESPAWN_STRING_END = CONFIG_COOP_RESPAWN_STRING + (COOP_RESPAWN_TOTAL - 1),
 
-	// [Paril-KEX] if 1, n64 player physics apply
-	CONFIG_N64_PHYSICS,
+	// [Paril-KEX] see enum physics_flags_t
+	CONFIG_PHYSICS_FLAGS,
 	CONFIG_HEALTH_BAR_NAME, // active health bar name
 
 	CONFIG_STORY,
@@ -262,3 +287,5 @@
 };
 
 static_assert(STAT_LAST <= MAX_STATS + 1, "stats list overflow");
+
+constexpr float PSX_PHYSICS_SCALAR = 0.875f;
--- a/cg_local.h	2023-10-03 19:43:06
+++ b/cg_local.h	2025-09-04 19:53:48
@@ -9,6 +9,5 @@
 extern cgame_import_t cgi;
 extern cgame_export_t cglobals;
 
-#define SERVER_TICK_RATE cgi.tick_rate // in hz
 #define FRAME_TIME_S cgi.frame_time_s
 #define FRAME_TIME_MS cgi.frame_time_ms
--- a/cg_main.cpp	2023-10-03 19:43:06
+++ b/cg_main.cpp	2025-09-04 19:53:48
@@ -22,8 +22,8 @@
 
 	cgame_init_time = cgi.CL_ClientRealTime();
 
-	pm_config.n64_physics = !!atoi(cgi.get_configstring(CONFIG_N64_PHYSICS));
 	pm_config.airaccel = atoi(cgi.get_configstring(CS_AIRACCEL));
+	pm_config.physics_flags = (physics_flags_t) atoi(cgi.get_configstring(CONFIG_PHYSICS_FLAGS));
 }
 
 static void ShutdownCGame()
@@ -66,8 +66,8 @@
 
 static void CG_ParseConfigString(int32_t i, const char *s)
 {
-	if (i == CONFIG_N64_PHYSICS)
-		pm_config.n64_physics = !!atoi(s);
+	if (i == CONFIG_PHYSICS_FLAGS)
+		pm_config.physics_flags = (physics_flags_t) atoi(s);
 	else if (i == CS_AIRACCEL)
 		pm_config.airaccel = atoi(s);
 }
--- a/cg_screen.cpp	2023-10-03 19:43:06
+++ b/cg_screen.cpp	2025-09-04 19:53:48
@@ -36,7 +36,7 @@
         struct {
             char    text[24];
         } table_cells[6];
-    } table_rows[11]; // just enough to store 8 levels + header + total (+ one slack)
+    } table_rows[MAX_LEVELS_PER_UNIT + 1 + 1 + 1]; // just enough to store all levels + header + total (+ one slack)
 
     size_t column_widths[6];
     int32_t num_rows = 0;
@@ -146,7 +146,7 @@
             break;
 
     // none left, so expire the topmost one
-    if (i == max)
+    if (i >= max)
     {
         data.notify[0].time = 0;
         CG_Notify_CheckExpire(data);
--- a/ctf/g_ctf.h	2023-10-03 19:43:06
+++ b/ctf/g_ctf.h	2025-09-04 19:53:48
@@ -1,10 +1,7 @@
 // Copyright (c) ZeniMax Media Inc.
 // Licensed under the GNU General Public License 2.0.
 
-#define CTF_VERSION 1.52
-#define CTF_VSTRING2(x) #x
-#define CTF_VSTRING(x) CTF_VSTRING2(x)
-#define CTF_STRING_VERSION CTF_VSTRING(CTF_VERSION)
+constexpr const char *CTF_VERSION_STRING = "1.52";
 
 enum ctfteam_t
 {
--- a/g_ai.cpp	2023-10-03 19:43:06
+++ b/g_ai.cpp	2025-09-04 19:53:48
@@ -266,6 +266,12 @@
     if (visible(self, self->enemy))
         self->monsterinfo.blind_fire_target = self->enemy->s.origin + (self->enemy->velocity * -0.1f);
     // pmm
+    
+    //ZAERO
+    if (self->monsterinfo.aiflags & AI_ONESHOTTARGET)
+    {
+        v = self->enemy->monsterinfo.shottarget - self->s.origin;
+    }
 
     if (!(self->monsterinfo.aiflags & AI_MANUAL_STEERING))
     {
@@ -428,7 +434,7 @@
     spot2 = other->s.origin;
     spot2[2] += other->viewheight;
 
-    contents_t mask = MASK_OPAQUE;
+    contents_t mask = MASK_OPAQUE | CONTENTS_PROJECTILECLIP;
 
     if (!through_glass)
         mask |= CONTENTS_WINDOW;
@@ -439,6 +445,24 @@
 
 /*
 =============
+infront_cone
+
+returns 1 if the entity is in front (in sight) of self
+=============
+*/
+bool infront_cone(edict_t *self, edict_t *other, float cone)
+{
+    vec3_t forward;
+
+    AngleVectors(self->s.angles, forward, nullptr, nullptr);
+
+    vec3_t vec = (other->s.origin - self->s.origin).normalized();
+
+    return vec.dot(forward) > cone;
+}
+
+/*
+=============
 infront
 
 returns 1 if the entity is in front (in sight) of self
@@ -446,21 +470,19 @@
 */
 bool infront(edict_t *self, edict_t *other)
 {
-    vec3_t vec;
-    float  dot;
-    vec3_t forward;
-
-    AngleVectors(self->s.angles, forward, nullptr, nullptr);
-    vec = other->s.origin - self->s.origin;
-    vec.normalize();
-    dot = vec.dot(forward);
-
-    // [Paril-KEX] if we're an ambush monster, reduce our cone of
-    // vision to not ruin surprises, unless we already had an enemy.
-    if (self->spawnflags.has(SPAWNFLAG_MONSTER_AMBUSH) && !self->monsterinfo.trail_time && !self->enemy)
-        return dot > 0.15f;
-
-    return dot > -0.30f;
+    float cone = self->vision_cone;
+
+    if (self->vision_cone < -1.0f)
+    {
+        // [Paril-KEX] if we're an ambush monster, reduce our cone of
+        // vision to not ruin surprises, unless we already had an enemy.
+        if (self->spawnflags.has(SPAWNFLAG_MONSTER_AMBUSH) && !self->monsterinfo.trail_time && !self->enemy)
+            cone = 0.15f;
+        else
+            cone = -0.30f;
+    }
+
+    return infront_cone(self, other, cone);
 }
 
 //============================================================================
@@ -935,7 +957,7 @@
             spot2[2] += self->enemy->viewheight;
 
             tr = gi.traceline(spot1, spot2, self,
-                MASK_SOLID | CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_SLIME | CONTENTS_LAVA);
+                MASK_SOLID | CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_SLIME | CONTENTS_LAVA | CONTENTS_PROJECTILECLIP);
         }
         else
         {
--- a/g_cmds.cpp	2023-10-03 19:43:06
+++ b/g_cmds.cpp	2025-09-04 19:53:48
@@ -121,7 +121,7 @@
 
 	edict_t *it_ent = G_Spawn();
 	it_ent->classname = it->classname;
-	SpawnItem(it_ent, it);
+	SpawnItem(it_ent, it, spawn_temp_t::empty);
 
 	if (it_ent->inuse)
 	{
@@ -283,7 +283,7 @@
 	{
 		it_ent = G_Spawn();
 		it_ent->classname = it->classname;
-		SpawnItem(it_ent, it);
+		SpawnItem(it_ent, it, spawn_temp_t::empty);
 		// PMM - since some items don't actually spawn when you say to ..
 		if (!it_ent->inuse)
 			return;
@@ -354,7 +354,6 @@
 
 	gi.LocClient_Print(ent, PRINT_HIGH, msg);
 }
-void ED_ParseField(const char *key, const char *value, edict_t *ent);
 
 /*
 ==================
@@ -408,15 +407,15 @@
 	other->s.origin = ent->s.origin + (AngleVectors(ent->s.angles).forward * 24.f);
 	other->s.angles[1] = ent->s.angles[1];
 
-	st = {};
+	spawn_temp_t st {};
 
 	if (gi.argc() > 3)
 	{
 		for (int i = 2; i < gi.argc(); i += 2)
-			ED_ParseField(gi.argv(i), gi.argv(i + 1), other);
-	}
-
-	ED_CallSpawn(other);
+			ED_ParseField(gi.argv(i), gi.argv(i + 1), other, st);
+	}
+
+	ED_CallSpawn(other, st);
 
 	if (other->inuse)
 	{
--- a/g_combat.cpp	2023-10-03 19:43:06
+++ b/g_combat.cpp	2025-09-04 19:53:48
@@ -29,7 +29,7 @@
 	{
 		dest = closest_point_to_box(inflictor_center, targ->absmin, targ->absmax);
 
-		trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID);
+		trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 		if (trace.fraction == 1.0f)
 			return true;
 	}
@@ -41,35 +41,35 @@
 	else
 		targ_center = targ->s.origin;
 
-	trace = gi.traceline(inflictor_center, targ_center, inflictor, MASK_SOLID);
+	trace = gi.traceline(inflictor_center, targ_center, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 	if (trace.fraction == 1.0f)
 		return true;
 
 	dest = targ_center;
 	dest[0] += 15.0f;
 	dest[1] += 15.0f;
-	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID);
+	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 	if (trace.fraction == 1.0f)
 		return true;
 
 	dest = targ_center;
 	dest[0] += 15.0f;
 	dest[1] -= 15.0f;
-	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID);
+	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 	if (trace.fraction == 1.0f)
 		return true;
 
 	dest = targ_center;
 	dest[0] -= 15.0f;
 	dest[1] += 15.0f;
-	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID);
+	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 	if (trace.fraction == 1.0f)
 		return true;
 
 	dest = targ_center;
 	dest[0] -= 15.0f;
 	dest[1] -= 15.0f;
-	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID);
+	trace = gi.traceline(inflictor_center, dest, inflictor, MASK_SOLID | CONTENTS_PROJECTILECLIP);
 	if (trace.fraction == 1.0f)
 		return true;
 
@@ -580,6 +580,14 @@
 	if (skill->integer == 0 && deathmatch->integer == 0 && targ->client && damage)
 	{
 		damage /= 2;
+		if (!damage)
+			damage = 1;
+	}
+
+	//ZAERO
+	if ((targ->svflags & SVF_MONSTER) && ((targ->monsterinfo.aiflags & AI_REDUCEDDAMAGE)))
+	{
+		damage *= 0.85;
 		if (!damage)
 			damage = 1;
 	}
--- a/g_func.cpp	2023-10-03 19:43:06
+++ b/g_func.cpp	2025-09-04 19:53:48
@@ -47,6 +47,7 @@
 constexpr spawnflags_t SPAWNFLAG_DOOR_ROTATING_Y_AXIS = 128_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_DOOR_ROTATING_INACTIVE = 0x10000_spawnflag; // Paril: moved to non-reserved
 constexpr spawnflags_t SPAWNFLAG_DOOR_ROTATING_SAFE_OPEN = 0x20000_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_DOOR_ROTATING_NO_COLLISION = 0x40000_spawnflag;
 
 // support routine for setting moveinfo sounds
 inline int32_t G_GetMoveinfoSoundIndex(edict_t *self, const char *default_value, const char *wanted_value)
@@ -66,6 +67,8 @@
 
 void G_SetMoveinfoSounds(edict_t *self, const char *default_start, const char *default_mid, const char *default_end)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->moveinfo.sound_start = G_GetMoveinfoSoundIndex(self, default_start, st.noise_start);
 	self->moveinfo.sound_middle = G_GetMoveinfoSoundIndex(self, default_mid, st.noise_middle);
 	self->moveinfo.sound_end = G_GetMoveinfoSoundIndex(self, default_end, st.noise_end);
@@ -647,6 +650,8 @@
 // PGM - plat2's change the trigger field
 edict_t *plat_spawn_inside_trigger(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	edict_t *trigger;
 	vec3_t	 tmin, tmax;
 
@@ -710,6 +715,8 @@
 */
 void SP_func_plat(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	ent->s.angles = {};
 	ent->solid = SOLID_BSP;
 	ent->movetype = MOVETYPE_PUSH;
@@ -736,16 +743,18 @@
 	if (!ent->dmg)
 		ent->dmg = 2;
 
-	if (!st.lip)
-		st.lip = 8;
+	float lip = st.lip;
+
+	if (!st.was_key_specified("lip"))
+		lip = 8;
 
 	// pos1 is the top position, pos2 is the bottom
 	ent->pos1 = ent->s.origin;
-	ent->pos2 = ent->s.origin;
+	ent->pos2 = ent->s.origin; 
 	if (st.height)
 		ent->pos2[2] -= st.height;
 	else
-		ent->pos2[2] -= (ent->maxs[2] - ent->mins[2]) - st.lip;
+		ent->pos2[2] -= (ent->maxs[2] - ent->mins[2]) - lip;
 
 	ent->use = Use_Plat;
 
@@ -898,6 +907,8 @@
 
 void SP_func_rotating(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	ent->solid = SOLID_BSP;
 	if (ent->spawnflags.has(SPAWNFLAG_ROTATING_STOP))
 		ent->movetype = MOVETYPE_STOP;
@@ -1135,6 +1146,7 @@
 
 void SP_func_button(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	vec3_t abs_movedir;
 	float  dist;
 
@@ -1157,14 +1169,17 @@
 
 	if (!ent->wait)
 		ent->wait = 3;
-	if (!st.lip)
-		st.lip = 4;
+
+	float lip = st.lip;
+
+	if (!lip)
+		lip = 4;
 
 	ent->pos1 = ent->s.origin;
 	abs_movedir[0] = fabsf(ent->movedir[0]);
 	abs_movedir[1] = fabsf(ent->movedir[1]);
 	abs_movedir[2] = fabsf(ent->movedir[2]);
-	dist = abs_movedir[0] * ent->size[0] + abs_movedir[1] * ent->size[1] + abs_movedir[2] * ent->size[2] - st.lip;
+	dist = abs_movedir[0] * ent->size[0] + abs_movedir[1] * ent->size[1] + abs_movedir[2] * ent->size[2] - lip;
 	ent->pos2 = ent->pos1 + (ent->movedir * dist);
 
 	ent->use = button_use;
@@ -1532,8 +1547,15 @@
 	if (!(other->svflags & SVF_MONSTER) && (!other->client))
 		return;
 
-	if (self->owner->spawnflags.has(SPAWNFLAG_DOOR_NOMONSTER) && (other->svflags & SVF_MONSTER))
-		return;
+	if (other->svflags & SVF_MONSTER)
+	{
+		if (self->owner->spawnflags.has(SPAWNFLAG_DOOR_NOMONSTER))
+			return;
+		// [Paril-KEX] this is for PSX; the scale is so small that monsters walking
+		// around to path_corners often initiate doors unintentionally.
+		else if (other->spawnflags.has(SPAWNFLAG_MONSTER_NO_IDLE_DOORS) && !other->enemy)
+			return;
+	}
 
 	if (level.time < self->touch_debounce_time)
 		return;
@@ -1695,6 +1717,7 @@
 
 void SP_func_door(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	vec3_t abs_movedir;
 
 	if (ent->sounds != 1)
@@ -1731,7 +1754,7 @@
 		ent->speed = 100;
 	if (deathmatch->integer)
 		ent->speed *= 2;
-
+	
 	if (!ent->accel)
 		ent->accel = ent->speed;
 	if (!ent->decel)
@@ -1739,8 +1762,9 @@
 
 	if (!ent->wait)
 		ent->wait = 3;
-	if (!st.lip)
-		st.lip = 8;
+	float lip = st.lip;
+	if (!lip)
+		lip = 8;
 	if (!ent->dmg)
 		ent->dmg = 2;
 
@@ -1750,7 +1774,7 @@
 	abs_movedir[1] = fabsf(ent->movedir[1]);
 	abs_movedir[2] = fabsf(ent->movedir[2]);
 	ent->moveinfo.distance =
-		abs_movedir[0] * ent->size[0] + abs_movedir[1] * ent->size[1] + abs_movedir[2] * ent->size[2] - st.lip;
+		abs_movedir[0] * ent->size[0] + abs_movedir[1] * ent->size[1] + abs_movedir[2] * ent->size[2] - lip;
 	ent->pos2 = ent->pos1 + (ent->movedir * ent->moveinfo.distance);
 
 	// if it starts open, switch the positions
@@ -1881,16 +1905,19 @@
 	if (ent->spawnflags.has(SPAWNFLAG_DOOR_REVERSE))
 		ent->movedir = -ent->movedir;
 
-	if (!st.distance)
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+	int distance = st.distance;
+
+	if (!distance)
 	{
 		gi.Com_PrintFmt("{}: no distance set\n", *ent);
-		st.distance = 90;
+		distance = 90;
 	}
 
 	ent->pos1 = ent->s.angles;
-	ent->pos2 = ent->s.angles + (ent->movedir * st.distance);
-	ent->pos3 = ent->s.angles + (ent->movedir * -st.distance);
-	ent->moveinfo.distance = (float) st.distance;
+	ent->pos2 = ent->s.angles + (ent->movedir * distance);
+	ent->pos3 = ent->s.angles + (ent->movedir * -distance);
+	ent->moveinfo.distance = (float) distance;
 
 	ent->movetype = MOVETYPE_PUSH;
 	ent->solid = SOLID_BSP;
@@ -1947,6 +1974,9 @@
 		ent->pos1 = ent->s.angles;
 		ent->movedir = -ent->movedir;
 	}
+
+	if (ent->spawnflags.has(SPAWNFLAG_DOOR_ROTATING_NO_COLLISION))
+		ent->clipmask = CONTENTS_AREAPORTAL; // just because zero is automatic
 
 	if (ent->health)
 	{
@@ -2036,6 +2066,7 @@
 
 void SP_func_water(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	vec3_t abs_movedir;
 
 	G_SetMovedir(self->s.angles, self->movedir);
@@ -2337,6 +2368,23 @@
 			dest -= vec3_t{1.f, 1.f, 1.f};
 	}
 
+	// PGM (Paril)
+	if (ent->speed)
+	{
+		self->speed = ent->speed;
+		self->moveinfo.speed = ent->speed;
+		if (ent->accel)
+			self->moveinfo.accel = ent->accel;
+		else
+			self->moveinfo.accel = ent->speed;
+		if (ent->decel)
+			self->moveinfo.decel = ent->decel;
+		else
+			self->moveinfo.decel = ent->speed;
+		self->moveinfo.current_speed = 0;
+	}
+	// PGM
+
 	self->s.sound = self->moveinfo.sound_middle;
 
 	self->moveinfo.state = STATE_TOP;
@@ -2410,6 +2458,7 @@
 
 void SP_func_train(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	self->movetype = MOVETYPE_PUSH;
 
 	self->s.angles = {};
@@ -2566,6 +2615,7 @@
 
 void SP_func_timer(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	if (!self->wait)
 		self->wait = 1.0;
 
@@ -2768,7 +2818,10 @@
 	if (!ent->wait)
 		ent->wait = 5;
 
-	ent->moveinfo.accel = ent->moveinfo.decel = ent->moveinfo.speed = 50;
+	if (!ent->speed)
+		ent->moveinfo.accel = ent->moveinfo.decel = ent->moveinfo.speed = 50;
+	else
+		ent->moveinfo.accel = ent->moveinfo.decel = ent->moveinfo.speed = ent->speed * 0.1f;
 
 	// calculate positions
 	AngleVectors(ent->s.angles, forward, right, up);
@@ -2960,6 +3013,7 @@
 
 void SP_func_eye(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	ent->movetype = MOVETYPE_PUSH;
 	ent->solid = SOLID_BSP;
 	gi.setmodel(ent, ent->model);
@@ -2971,6 +3025,10 @@
 
 	if (!ent->speed)
 		ent->speed = 45;
+
+	// set vision cone
+	if (st.was_key_specified("vision_cone"))
+		ent->yaw_speed = ent->vision_cone;
 
 	if (!ent->yaw_speed)
 		ent->yaw_speed = 0.5f;
--- a/g_items.cpp	2023-10-03 19:43:06
+++ b/g_items.cpp	2025-09-04 19:53:48
@@ -25,14 +25,13 @@
 // RAFAEL
 // ROGUE
 void Weapon_ChainFist(edict_t *ent);
-void Weapon_Disintegrator(edict_t *ent);
+void Weapon_Disruptor(edict_t *ent);
 void Weapon_ETF_Rifle(edict_t *ent);
 void Weapon_Heatbeam(edict_t *ent);
-void Weapon_Prox(edict_t *ent);
 void Weapon_Tesla(edict_t *ent);
 void Weapon_ProxLauncher(edict_t *ent);
 // ROGUE
-void Weapon_Beta_Disintegrator(edict_t *ent);
+void Weapon_Disintegrator(edict_t *ent);
 
 void	   Use_Quad(edict_t *ent, gitem_t *item);
 static gtime_t quad_drop_timeout_hack;
@@ -1139,32 +1138,35 @@
 	else
 		gi.setmodel(ent, ent->item->world_model);
 	ent->solid = SOLID_TRIGGER;
-	ent->movetype = MOVETYPE_TOSS;
 	ent->touch = Touch_Item;
 
-	dest = ent->s.origin + vec3_t { 0, 0, -128 };
-
-	tr = gi.trace(ent->s.origin, ent->mins, ent->maxs, dest, ent, MASK_SOLID);
-	if (tr.startsolid)
-	{
-		if (G_FixStuckObject(ent, ent->s.origin) == stuck_result_t::NO_GOOD_POSITION)
+	if (!ent->spawnflags.has(SPAWNFLAG_ITEM_NO_DROP))
+	{
+		ent->movetype = MOVETYPE_TOSS;
+		dest = ent->s.origin + vec3_t { 0, 0, -128 };
+
+		tr = gi.trace(ent->s.origin, ent->mins, ent->maxs, dest, ent, MASK_SOLID);
+		if (tr.startsolid)
 		{
-			// RAFAEL
-			if (strcmp(ent->classname, "item_foodcube") == 0)
-				ent->velocity[2] = 0;
-			else
+			if (G_FixStuckObject(ent, ent->s.origin) == stuck_result_t::NO_GOOD_POSITION)
 			{
 				// RAFAEL
-				gi.Com_PrintFmt("{}: droptofloor: startsolid\n", *ent);
-				G_FreeEdict(ent);
-				return;
+				if (strcmp(ent->classname, "item_foodcube") == 0)
+					ent->velocity[2] = 0;
+				else
+				{
+					// RAFAEL
+					gi.Com_PrintFmt("{}: droptofloor: startsolid\n", *ent);
+					G_FreeEdict(ent);
+					return;
+					// RAFAEL
+				}
 				// RAFAEL
 			}
-			// RAFAEL
 		}
-	}
-	else
-		ent->s.origin = tr.endpos;
+		else
+			ent->s.origin = tr.endpos;
+	}
 
 	if (ent->team)
 	{
@@ -1278,7 +1280,7 @@
 be on an entity that hasn't spawned yet.
 ============
 */
-void SpawnItem(edict_t *ent, gitem_t *item)
+void SpawnItem(edict_t *ent, gitem_t *item, const spawn_temp_t &st)
 {
 	// [Sam-KEX]
 	// Paril: allow all keys to be trigger_spawn'd (N64 uses this
@@ -1462,8 +1464,11 @@
 	ent->item = item;
 	ent->nextthink = level.time + 20_hz; // items start after other solids
 	ent->think = droptofloor;
-	ent->s.effects = item->world_model_flags;
-	ent->s.renderfx = RF_GLOW | RF_NO_LOD;
+	if (!(level.is_spawning && st.was_key_specified("effects")) && !ent->s.effects)
+		ent->s.effects = item->world_model_flags;
+	if (!(level.is_spawning && st.was_key_specified("renderfx")) && !ent->s.renderfx)
+		ent->s.renderfx = RF_GLOW;
+	ent->s.renderfx |= RF_NO_LOD;
 	if (ent->model)
 		gi.modelindex(ent->model);
 
@@ -1799,13 +1804,13 @@
 	{
 		/* id */ IT_WEAPON_GRAPPLE,
 		/* classname */ "weapon_grapple", 
-		/* pickup */ nullptr,
+		/* pickup */ Pickup_Weapon,
 		/* use */ Use_Weapon,
 		/* drop */ nullptr,
 		/* weaponthink */ CTFWeapon_Grapple,
-		/* pickup_sound */ nullptr,
-		/* world_model */ nullptr,
-		/* world_model_flags */ EF_NONE,
+		/* pickup_sound */ "misc/w_pkup.wav",
+		/* world_model */ "models/weapons/g_flareg/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
 		/* view_model */ "models/weapons/grapple/tris.md2",
 		/* icon */ "w_grapple",
 		/* use_name */  "Grapple",
@@ -1869,7 +1874,7 @@
 		/* quantity */ 0,
 		/* ammo */ IT_NULL,
 		/* chain */ IT_WEAPON_BLASTER,
-		/* flags */ IF_WEAPON | IF_STAY_COOP | IF_NO_HASTE,
+		/* flags */ IF_WEAPON | IF_STAY_COOP,
 		/* vwep_model */ "#w_chainfist.md2",
 		/* armor_info */ nullptr,
 		/* tag */ 0,
@@ -2383,7 +2388,7 @@
 		/* pickup */ Pickup_Weapon,
 		/* use */ Use_Weapon,
 		/* drop */ Drop_Weapon,
-		/* weaponthink */ Weapon_Disintegrator,
+		/* weaponthink */ Weapon_Disruptor,
 		/* pickup_sound */ "misc/w_pkup.wav",
 		/* world_model */ "models/weapons/g_dist/tris.md2",
 		/* world_model_flags */ EF_ROTATE | EF_BOB,
@@ -2404,20 +2409,22 @@
 
 	// ROGUE WEAPONS
 	// =========================
-
-#if 0 // sorry little guy
+	/* KONIG - Disintegrator restored; Dark Matter Gun Prototype - shoots sprite projectiles that functions like traps,
+	pulls in enemies and damages, insta-gibs if killed
+	QUAKED weapon_beta_disintegrator (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
+	*/
 	{
 		/* id */ IT_WEAPON_DISINTEGRATOR,
 		/* classname */ "weapon_beta_disintegrator",
 		/* pickup */ Pickup_Weapon,
 		/* use */ Use_Weapon,
 		/* drop */ Drop_Weapon,
-		/* weaponthink */ Weapon_Beta_Disintegrator,
+		/* weaponthink */ Weapon_Disintegrator,
 		/* pickup_sound */ "misc/w_pkup.wav",
-		/* world_model */ "models/weapons/g_disint/tris.md2",
-		/* world_model_flags */ EF_ROTATE | EF_BOB,
-		/* view_model */ "models/weapons/v_disint/tris.md2",
-		/* icon */ "w_bfg",
+		/* world_model */ "models/weapons/g_plasmr/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ "models/weapons/v_plasmr/tris.md2",
+		/* icon */ "w_plasmarifle",
 		/* use_name */  "Disintegrator",
 		/* pickup_name */  "$item_disintegrator",
 		/* pickup_name_definite */ "$item_disintegrator_def",
@@ -2425,12 +2432,11 @@
 		/* ammo */ IT_AMMO_ROUNDS,
 		/* chain */ IT_WEAPON_BFG,
 		/* flags */ IF_WEAPON | IF_STAY_COOP,
-		/* vwep_model */ "#w_bfg.md2",
+		/* vwep_model */ "#w_plasmarifle.md2",
 		/* armor_info */ nullptr,
 		/* tag */ 0,
-		/* precaches */ "",
-	},
-#endif
+		/* precaches */ "weapons/dist/energy_burst.wav weapons/dist/energy_loop.wav weapons/dist/fire.wav sprites/s_bfg1.sp2"
+	},
 
 	//
 	// AMMO ITEMS
@@ -2709,7 +2715,34 @@
 	//
 	// POWERUP ITEMS
 	//
-/*QUAKED item_quad (.3 .3 1) (-16 -16 -16) (16 16 16)
+	/* KONIG - moved to like powerups*/
+/*QUAKED item_double (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
+*/
+	{
+		/* id */ IT_ITEM_DOUBLE,
+		/* classname */ "item_double",
+		/* pickup */ Pickup_Powerup,
+		/* use */ Use_Double,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/items/ddamage/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "p_double",
+		/* use_name */  "Double Damage",
+		/* pickup_name */  "$item_double_damage",
+		/* pickup_name_definite */ "$item_double_damage_def",
+		/* quantity */ 60,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_POWERUP | IF_POWERUP_WHEEL,
+		/* vwep_model */ nullptr,
+		/* armor_info */ nullptr,
+		/* tag */ POWERUP_DOUBLE,
+		/* precaches */ "misc/ddamage1.wav misc/ddamage2.wav misc/ddamage3.wav ctf/tech2x.wav"
+	},
+	/*QUAKED item_quad (.3 .3 1) (-16 -16 -16) (16 16 16)
 */
 	{
 		/* id */ IT_ITEM_QUAD,
@@ -3055,33 +3088,6 @@
 		/* precaches */ "misc/ir_start.wav"
 	},
 
-/*QUAKED item_double (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
-*/
-	{
-		/* id */ IT_ITEM_DOUBLE,
-		/* classname */ "item_double", 
-		/* pickup */ Pickup_Powerup,
-		/* use */ Use_Double,
-		/* drop */ Drop_General,
-		/* weaponthink */ nullptr,
-		/* pickup_sound */ "items/pkup.wav",
-		/* world_model */ "models/items/ddamage/tris.md2",
-		/* world_model_flags */ EF_ROTATE | EF_BOB,
-		/* view_model */ nullptr,
-		/* icon */ "p_double",
-		/* use_name */  "Double Damage",
-		/* pickup_name */  "$item_double_damage",
-		/* pickup_name_definite */ "$item_double_damage_def",
-		/* quantity */ 60,
-		/* ammo */ IT_NULL,
-		/* chain */ IT_NULL,
-		/* flags */ IF_POWERUP | IF_POWERUP_WHEEL,
-		/* vwep_model */ nullptr,
-		/* armor_info */ nullptr,
-		/* tag */ POWERUP_DOUBLE,
-		/* precaches */ "misc/ddamage1.wav misc/ddamage2.wav misc/ddamage3.wav ctf/tech2x.wav"
-	},
-
 /*QUAKED item_sphere_vengeance (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
 */
 	{
@@ -3465,6 +3471,270 @@
 normal door key - blue
 */
 	{
+		/* id */ IT_KEY_GREEN_GEAR,
+		/* classname */ "key_green_gearkey",
+		/* pickup */ Pickup_Key,
+		/* use */ nullptr,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/items/keys/green_key/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "k_green",
+		/* use_name */  "Green Gear Key",
+		/* pickup_name */  "$item_green_key",
+		/* pickup_name_definite */ "$item_green_key_def",
+		/* quantity */ 0,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_STAY_COOP|IF_KEY
+	},
+// RAFAEL
+
+/*QUAKED key_commander_head (0 .5 .8) (-16 -16 -16) (16 16 16)
+tank commander's head
+*/
+	{
+		/* id */ IT_KEY_COMMANDER_HEAD,
+		/* classname */ "key_commander_head",
+		/* pickup */ Pickup_Key,
+		/* use */ nullptr,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/monsters/commandr/head/tris.md2",
+		/* world_model_flags */ EF_GIB,
+		/* view_model */ nullptr,
+		/* icon */ "k_comhead",
+		/* use_name */  "Commander's Head",
+		/* pickup_name */  "$item_commanders_head",
+		/* pickup_name_definite */ "$item_commanders_head_def",
+		/* quantity */ 0,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_STAY_COOP|IF_KEY
+	},
+
+/*QUAKED key_airstrike_target (0 .5 .8) (-16 -16 -16) (16 16 16)
+*/
+	{
+		/* id */ IT_KEY_AIRSTRIKE,
+		/* classname */ "key_airstrike_target",
+		/* pickup */ Pickup_Key,
+		/* use */ nullptr,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/items/keys/target/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "i_airstrike",
+		/* use_name */  "Airstrike Marker",
+		/* pickup_name */  "$item_airstrike_marker",
+		/* pickup_name_definite */ "$item_airstrike_marker_def",
+		/* quantity */ 0,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_STAY_COOP|IF_KEY
+	},
+	
+// ======================================
+// PGM
+
+/*QUAKED key_nuke_container (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
+*/
+	{
+		/* id */ IT_KEY_NUKE_CONTAINER,
+		/* classname */ "key_nuke_container",
+		/* pickup */ Pickup_Key,
+		/* use */ nullptr,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/weapons/g_nuke/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "i_contain",
+		/* use_name */  "Antimatter Pod",
+		/* pickup_name */  "$item_antimatter_pod",
+		/* pickup_name_definite */ "$item_antimatter_pod_def",
+		/* quantity */ 0,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_STAY_COOP|IF_KEY,
+	},
+
+/*QUAKED key_nuke (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
+*/
+	{
+		/* id */ IT_KEY_NUKE,
+		/* classname */ "key_nuke",
+		/* pickup */ Pickup_Key,
+		/* use */ nullptr,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/weapons/g_nuke/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "i_nuke",
+		/* use_name */  "Antimatter Bomb",
+		/* pickup_name */  "$item_antimatter_bomb",
+		/* pickup_name_definite */ "$item_antimatter_bomb_def",
+		/* quantity */ 0,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_STAY_COOP|IF_KEY,
+	},
+	//ZAERO
+/*QUAKED key_red_gearkey (0 .5 .8) (-16 -16 -16) (16 16 16)
+*/
+/*QUAKED key_clearancepass (0 .5 .8) (-16 -16 -16) (16 16 16)
+security pass for the security level
+*/
+	{
+		/* id */ IT_KEY_RED_GEAR,
+		/* classname */ "key_red_gearkey",
+		/* pickup */ Pickup_Key,
+		/* use */ nullptr,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/items/keys/red_gearkey/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "k_redkey",
+		/* use_name */  "Red Gear Key",
+		/* pickup_name */  "Red Gear Key",
+		/* pickup_name_definite */ "Red Gear Key",
+		/* quantity */ 0,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_STAY_COOP | IF_KEY
+	},
+
+	/*QUAKED key_yellow_gearkey (0 .5 .8) (-16 -16 -16) (16 16 16)
+	*/
+	/*QUAKED key_lab (0 .5 .8) (-16 -16 -16) (16 16 16)
+	security pass for the laboratory
+	*/
+	{
+		/* id */ IT_KEY_YELLOW_GEAR,
+		/* classname */ "key_yellow_gearkey",
+		/* pickup */ Pickup_Key,
+		/* use */ nullptr,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/items/keys/yellow_gearkey/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "n64/i_yellow_key",
+		/* use_name */  "Yellow Gear Key",
+		/* pickup_name */  "$item_yellow_key",
+		/* pickup_name_definite */ "$item_yellow_key_def",
+		/* quantity */ 0,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_STAY_COOP | IF_KEY
+	},
+	/*QUAKED key_blue_gearkey (0 .5 .8) (-16 -16 -16) (16 16 16)
+	*/
+	/*QUAKED key_landingarea (0 .5 .8) (-16 -16 -16) (16 16 16)
+	Zaero's landing arena key - blue
+	*/
+	{
+		/* id */ IT_KEY_BLUE_GEAR,
+		/* classname */ "key_blue_gearkey",
+		/* pickup */ Pickup_Key,
+		/* use */ nullptr,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/items/keys/blue_gearkey/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "k_bluekey",
+		/* use_name */  "Blue Gear Key",
+		/* pickup_name */  "$item_blue_key",
+		/* pickup_name_definite */ "$item_blue_key_def",
+		/* quantity */ 0,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_STAY_COOP | IF_KEY
+	},
+	/*QUAKED key_energy (0 .5 .8) (-16 -16 -16) (16 16 16)
+	*/
+	{
+		/* id */ IT_KEY_ENERGY,
+		/* classname */ "key_energy",
+		/* pickup */ Pickup_Key,
+		/* use */ nullptr,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/items/keys/energy/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "k_energy",
+		/* use_name */  "Energy Key",
+		/* pickup_name */  "Energy Key",
+		/* pickup_name_definite */ "Energy Key",
+		/* quantity */ 0,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_STAY_COOP | IF_KEY
+	},
+	/*QUAKED key_lava (0 .5 .8) (-16 -16 -16) (16 16 16)
+	*/
+	{
+		/* id */ IT_KEY_LAVA,
+		/* classname */ "key_lava",
+		/* pickup */ Pickup_Key,
+		/* use */ nullptr,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/items/keys/lava/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "k_lava",
+		/* use_name */  "Lava Key",
+		/* pickup_name */  "Lava Key",
+		/* pickup_name_definite */ "Lava Key",
+		/* quantity */ 0,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_STAY_COOP | IF_KEY
+	},
+	/*QUAKED key_slime (0 .5 .8) (-16 -16 -16) (16 16 16)
+	*/
+	{
+		/* id */ IT_KEY_SLIME,
+		/* classname */ "key_slime",
+		/* pickup */ Pickup_Key,
+		/* use */ nullptr,
+		/* drop */ Drop_General,
+		/* weaponthink */ nullptr,
+		/* pickup_sound */ "items/pkup.wav",
+		/* world_model */ "models/items/keys/slime/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "k_slime",
+		/* use_name */  "Slime Key",
+		/* pickup_name */  "Slime Key",
+		/* pickup_name_definite */ "Slime Key",
+		/* quantity */ 0,
+		/* ammo */ IT_NULL,
+		/* chain */ IT_NULL,
+		/* flags */ IF_STAY_COOP | IF_KEY
+	},
+	//PSX
+/*QUAKED key_green_key (0 .5 .8) (-16 -16 -16) (16 16 16)
+* replaces The Reckoning's key
+*/
+	{
 		/* id */ IT_KEY_GREEN_KEY,
 		/* classname */ "key_green_key",
 		/* pickup */ Pickup_Key,
@@ -3472,7 +3742,7 @@
 		/* drop */ Drop_General,
 		/* weaponthink */ nullptr,
 		/* pickup_sound */ "items/pkup.wav",
-		/* world_model */ "models/items/keys/green_key/tris.md2",
+		/* world_model */ "models/items/keys/green_key_psx/tris.md2",
 		/* world_model_flags */ EF_ROTATE | EF_BOB,
 		/* view_model */ nullptr,
 		/* icon */ "k_green",
@@ -3482,109 +3752,53 @@
 		/* quantity */ 0,
 		/* ammo */ IT_NULL,
 		/* chain */ IT_NULL,
-		/* flags */ IF_STAY_COOP|IF_KEY
-	},
-// RAFAEL
-
-/*QUAKED key_commander_head (0 .5 .8) (-16 -16 -16) (16 16 16)
-tank commander's head
-*/
-	{
-		/* id */ IT_KEY_COMMANDER_HEAD,
-		/* classname */ "key_commander_head",
+		/* flags */ IF_STAY_COOP | IF_KEY
+	},
+	//Q1 Keys and Runes
+	{
+		/* id */ IT_KEY_SILVER_KEY,
+		/* classname */ "key_silver_key",
 		/* pickup */ Pickup_Key,
 		/* use */ nullptr,
 		/* drop */ Drop_General,
 		/* weaponthink */ nullptr,
 		/* pickup_sound */ "items/pkup.wav",
-		/* world_model */ "models/monsters/commandr/head/tris.md2",
-		/* world_model_flags */ EF_GIB,
-		/* view_model */ nullptr,
-		/* icon */ "k_comhead",
-		/* use_name */  "Commander's Head",
-		/* pickup_name */  "$item_commanders_head",
-		/* pickup_name_definite */ "$item_commanders_head_def",
+		/* world_model */ "models/items/keys/w_s_key/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "k_silver",
+		/* use_name */  "Silver Key",
+		/* pickup_name */  "Silver Key",
+		/* pickup_name_definite */ "Silver Key",
 		/* quantity */ 0,
 		/* ammo */ IT_NULL,
 		/* chain */ IT_NULL,
-		/* flags */ IF_STAY_COOP|IF_KEY
-	},
-
-/*QUAKED key_airstrike_target (0 .5 .8) (-16 -16 -16) (16 16 16)
-*/
-	{
-		/* id */ IT_KEY_AIRSTRIKE,
-		/* classname */ "key_airstrike_target",
+		/* flags */ IF_STAY_COOP | IF_KEY
+	},
+	/*QUAKED key_gold_key (0 .5 .8) (-16 -16 -16) (16 16 16)
+	*/
+	{
+		/* id */ IT_KEY_GOLD_KEY,
+		/* classname */ "key_gold_key",
 		/* pickup */ Pickup_Key,
 		/* use */ nullptr,
 		/* drop */ Drop_General,
 		/* weaponthink */ nullptr,
 		/* pickup_sound */ "items/pkup.wav",
-		/* world_model */ "models/items/keys/target/tris.md2",
-		/* world_model_flags */ EF_ROTATE | EF_BOB,
-		/* view_model */ nullptr,
-		/* icon */ "i_airstrike",
-		/* use_name */  "Airstrike Marker",
-		/* pickup_name */  "$item_airstrike_marker",
-		/* pickup_name_definite */ "$item_airstrike_marker_def",
+		/* world_model */ "models/items/keys/w_g_key/tris.md2",
+		/* world_model_flags */ EF_ROTATE | EF_BOB,
+		/* view_model */ nullptr,
+		/* icon */ "k_gold",
+		/* use_name */  "Gold Key",
+		/* pickup_name */  "Gold Key",
+		/* pickup_name_definite */ "Gold Key",
 		/* quantity */ 0,
 		/* ammo */ IT_NULL,
 		/* chain */ IT_NULL,
-		/* flags */ IF_STAY_COOP|IF_KEY
-	},
-	
-// ======================================
-// PGM
-
-/*QUAKED key_nuke_container (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
-*/
-	{
-		/* id */ IT_KEY_NUKE_CONTAINER,
-		/* classname */ "key_nuke_container",
-		/* pickup */ Pickup_Key,
-		/* use */ nullptr,
-		/* drop */ Drop_General,
-		/* weaponthink */ nullptr,
-		/* pickup_sound */ "items/pkup.wav",
-		/* world_model */ "models/weapons/g_nuke/tris.md2",
-		/* world_model_flags */ EF_ROTATE | EF_BOB,
-		/* view_model */ nullptr,
-		/* icon */ "i_contain",
-		/* use_name */  "Antimatter Pod",
-		/* pickup_name */  "$item_antimatter_pod",
-		/* pickup_name_definite */ "$item_antimatter_pod_def",
-		/* quantity */ 0,
-		/* ammo */ IT_NULL,
-		/* chain */ IT_NULL,
-		/* flags */ IF_STAY_COOP|IF_KEY,
-	},
-
-/*QUAKED key_nuke (.3 .3 1) (-16 -16 -16) (16 16 16) TRIGGER_SPAWN
-*/
-	{
-		/* id */ IT_KEY_NUKE,
-		/* classname */ "key_nuke",
-		/* pickup */ Pickup_Key,
-		/* use */ nullptr,
-		/* drop */ Drop_General,
-		/* weaponthink */ nullptr,
-		/* pickup_sound */ "items/pkup.wav",
-		/* world_model */ "models/weapons/g_nuke/tris.md2",
-		/* world_model_flags */ EF_ROTATE | EF_BOB,
-		/* view_model */ nullptr,
-		/* icon */ "i_nuke",
-		/* use_name */  "Antimatter Bomb",
-		/* pickup_name */  "$item_antimatter_bomb",
-		/* pickup_name_definite */ "$item_antimatter_bomb_def",
-		/* quantity */ 0,
-		/* ammo */ IT_NULL,
-		/* chain */ IT_NULL,
-		/* flags */ IF_STAY_COOP|IF_KEY,
-	},
-
-// PGM
+		/* flags */ IF_STAY_COOP | IF_KEY
+	},
+
 //
-
 // PGM
 // ======================================
 
--- a/g_local.h	2023-10-03 19:43:06
+++ b/g_local.h	2025-09-04 19:53:48
@@ -464,7 +464,6 @@
 	return gtime_t::from_ms(static_cast<int64_t>((1.0 / s) * 1000));
 }
 
-#define SERVER_TICK_RATE gi.tick_rate // in hz
 extern gtime_t FRAME_TIME_S;
 extern gtime_t FRAME_TIME_MS;
 
@@ -677,9 +676,8 @@
 	// PMM - FIXME - last second added for E3 .. there's probably a better way to do this, but
 	// this works
 	AI_DO_NOT_COUNT = bit_v<21>,	 // set for healed monsters
-	AI_SPAWNED_CARRIER = bit_v<22>, // both do_not_count and spawned are set for spawned monsters
-	AI_SPAWNED_MEDIC_C = bit_v<23>, // both do_not_count and spawned are set for spawned monsters
-	AI_SPAWNED_WIDOW = bit_v<24>,	 // both do_not_count and spawned are set for spawned monsters
+	AI_SPAWNED_COMMANDER = bit_v<22>, // both do_not_count and spawned are set for spawned monsters
+	AI_SPAWNED_NEEDS_GIB = bit_v<23>, // only return commander slots when gibbed
 	AI_BLOCKED = bit_v<25>, // used by blocked_checkattack: set to say I'm attacking while blocked
 							// (prevents run-attacks)
 							// ROGUE
@@ -696,12 +694,18 @@
 	AI_FORGET_ENEMY = bit_v<35>,			// forget the current enemy
 	AI_DOUBLE_TROUBLE = bit_v<36>, // JORG only
 	AI_REACHED_HOLD_COMBAT = bit_v<37>,
-	AI_THIRD_EYE = bit_v<38>
+	AI_THIRD_EYE = bit_v<38>,
+	//ZAERO
+	AI_REDUCEDDAMAGE = bit_v<39>,
+	AI_DODGETIMEOUT = bit_v<40>,
+	AI_ONESHOTTARGET = bit_v<41>
 };
 MAKE_ENUM_BITFLAGS(monster_ai_flags_t);
 
-constexpr monster_ai_flags_t AI_SPAWNED_MASK =
-	AI_SPAWNED_CARRIER | AI_SPAWNED_MEDIC_C | AI_SPAWNED_WIDOW; // mask to catch all three flavors of spawned
+// flags saved when monster is respawned
+constexpr monster_ai_flags_t AI_RESPAWN_MASK = AI_STINKY | AI_SPAWNED_COMMANDER | AI_SPAWNED_NEEDS_GIB;
+// flags saved when a monster dies
+constexpr monster_ai_flags_t AI_DEATH_MASK = (AI_DOUBLE_TROUBLE | AI_GOOD_GUY | AI_RESPAWN_MASK);
 
 // monster attack state
 enum monster_attack_state_t
@@ -769,8 +773,10 @@
 	MOVETYPE_WALLBOUNCE,
 	// RAFAEL
 	// ROGUE
-	MOVETYPE_NEWTOSS // PGM - for deathball
-					 // ROGUE
+	MOVETYPE_NEWTOSS, // PGM - for deathball
+	//ZAERO
+	MOVETYPE_FALLFLOAT,
+	MOVETYPE_RIDE
 };
 
 // edict->flags
@@ -891,9 +897,7 @@
 	IT_WEAPON_PHALANX,
 	IT_WEAPON_BFG,
 	IT_WEAPON_DISRUPTOR,
-#if 0
 	IT_WEAPON_DISINTEGRATOR,
-#endif
 
 	IT_AMMO_SHELLS,
 	IT_AMMO_BULLETS,
@@ -906,6 +910,7 @@
 	IT_AMMO_NUKE,
 	IT_AMMO_ROUNDS,
 
+	IT_ITEM_DOUBLE,
 	IT_ITEM_QUAD,
 	IT_ITEM_QUADFIRE,
 	IT_ITEM_INVULNERABILITY,
@@ -919,7 +924,6 @@
 	IT_ITEM_BANDOLIER,
 	IT_ITEM_PACK,
 	IT_ITEM_IR_GOGGLES,
-	IT_ITEM_DOUBLE,
 	IT_ITEM_SPHERE_VENGEANCE,
 	IT_ITEM_SPHERE_HUNTER,
 	IT_ITEM_SPHERE_DEFENDER,
@@ -936,11 +940,23 @@
 	IT_KEY_PASS,
 	IT_KEY_BLUE_KEY,
 	IT_KEY_RED_KEY,
-	IT_KEY_GREEN_KEY,
+	IT_KEY_GREEN_GEAR,
 	IT_KEY_COMMANDER_HEAD,
 	IT_KEY_AIRSTRIKE,
 	IT_KEY_NUKE_CONTAINER,
 	IT_KEY_NUKE,
+	//ZAERO
+	IT_KEY_RED_GEAR,
+	IT_KEY_YELLOW_GEAR,
+	IT_KEY_BLUE_GEAR,
+	IT_KEY_ENERGY,
+	IT_KEY_LAVA,
+	IT_KEY_SLIME,
+	//PSX
+	IT_KEY_GREEN_KEY,
+	//Q1
+	IT_KEY_SILVER_KEY,
+	IT_KEY_GOLD_KEY,
 
 	IT_HEALTH_SMALL,
 	IT_HEALTH_MEDIUM,
@@ -1075,7 +1091,15 @@
 	// ROGUE
 	//========
 	MOD_GRAPPLE,
-	MOD_BLUEBLASTER
+	MOD_BLUEBLASTER,
+	//ZAERO
+	MOD_A2K,
+	MOD_AUTOCANNON,
+	MOD_FLARE,
+	MOD_GL_POLYBLEND,
+	MOD_SONICCANNON,
+	MOD_SNIPERRIFLE,
+	MOD_TRIPBOMB
 };
 
 struct mod_t
@@ -1091,10 +1115,6 @@
 	{
 	}
 };
-
-// the total number of levels we'll track for the
-// end of unit screen.
-constexpr size_t MAX_LEVELS_PER_UNIT = 8;
 
 struct level_entry_t
 {
@@ -1154,8 +1174,9 @@
 //
 struct level_locals_t
 {
-	bool in_frame;
-	gtime_t time;
+	bool in_frame = false;
+	bool is_spawning = false; // whether we're still doing SpawnEntities
+	gtime_t time = {};
 
 	char level_name[MAX_QPATH]; // the descriptive name (Outer Base, etc)
 	char mapname[MAX_QPATH];	// the server name (base1, etc)
@@ -1201,7 +1222,7 @@
 	// ROGUE
 	
 	int32_t shadow_light_count; // [Sam-KEX]
-	bool is_n64;
+	bool is_n64, is_psx;
 	gtime_t coop_level_restart_time; // restart the level after this time
 	bool instantitems; // instantitems 1 set in worldspawn
 
@@ -1250,6 +1271,12 @@
 	bool story_active;
 	gtime_t next_auto_save;
 	gtime_t next_match_report;
+
+	const char *primary_objective_string;
+	const char *secondary_objective_string;
+
+	const char *primary_objective_title;
+	const char *secondary_objective_title;
 };
 
 struct shadow_light_temp_t
@@ -1275,9 +1302,9 @@
 	int32_t skyautorotate = 1;
 	const char	 *nextmap;
 
-	int32_t		lip;
-	int32_t		distance;
-	int32_t		height;
+	float		lip;
+	float		distance;
+	float		height;
 	const char	*noise;
 	float		pausetime;
 	const char	*item;
@@ -1306,6 +1333,7 @@
 	const char *start_items;
 	int no_grapple = 0;
 	float health_multiplier = 1.0f;
+	int physics_flags_sp = 0, physics_flags_dm = 0;
 
 	const char *reinforcements; // [Paril-KEX]
 	const char *noise_start, *noise_middle, *noise_end; // [Paril-KEX]
@@ -1313,10 +1341,18 @@
 
 	std::unordered_set<const char *> keys_specified;
 
+	const char *primary_objective_string;
+	const char *secondary_objective_string;
+
+	const char *primary_objective_title;
+	const char *secondary_objective_title;
+
 	inline bool was_key_specified(const char *key) const
 	{
 		return keys_specified.find(key) != keys_specified.end();
 	}
+
+	static const spawn_temp_t empty;
 };
 
 enum move_state_t
@@ -1468,14 +1504,6 @@
 	int32_t lerp_frame = -1;
 };
 
-// this check only works on windows, and is only
-// of importance to developers anyways
-#if defined(_WIN32) && defined(_MSC_VER)
-#if _MSC_VER >= 1934
-#define COMPILE_TIME_MOVE_CHECK
-#endif
-#endif
-
 struct mmove_t
 {
 	int32_t	  firstframe;
@@ -1484,33 +1512,29 @@
 	void (*endfunc)(edict_t *self);
 	float sidestep_scale;
 
-#ifdef COMPILE_TIME_MOVE_CHECK
+#ifdef _DEBUG
+	size_t framecount;
+#endif
+
 	template<size_t N>
-	constexpr mmove_t(int32_t firstframe, int32_t lastframe, const mframe_t (&frames)[N], void (*endfunc)(edict_t *self) = nullptr, float sidestep_scale = 0.0f) :
+	inline mmove_t(int32_t firstframe, int32_t lastframe, const mframe_t (&frames)[N], void (*endfunc)(edict_t *self) = nullptr, float sidestep_scale = 0.0f) :
 		firstframe(firstframe),
 		lastframe(lastframe),
 		frame(frames),
 		endfunc(endfunc),
 		sidestep_scale(sidestep_scale)
-	{
-		if ((lastframe - firstframe + 1) != N)
-			throw std::exception("bad animation frames; check your numbers!");
-	}
+#ifdef _DEBUG
+		, framecount(N)
 #endif
+	{
+	}
 };
 
 using save_mmove_t = save_data_t<mmove_t, SAVE_DATA_MMOVE>;
-#ifdef COMPILE_TIME_MOVE_CHECK
-#define MMOVE_T(n) \
-	extern const mmove_t n; \
-	static const save_data_list_t save__##n(#n, SAVE_DATA_MMOVE, &n); \
-	constexpr mmove_t n
-#else
 #define MMOVE_T(n) \
 	extern const mmove_t n; \
 	static const save_data_list_t save__##n(#n, SAVE_DATA_MMOVE, &n); \
 	const mmove_t n
-#endif
 
 DEFINE_DATA_FUNC(monsterinfo_stand, MONSTERINFO_STAND, void, edict_t *self);
 #define MONSTERINFO_STAND(n) \
@@ -1599,6 +1623,9 @@
 };
 
 constexpr size_t MAX_REINFORCEMENTS = 5; // max number of spawns we can do at once.
+
+void M_SetupReinforcements(const char *reinforcements, reinforcement_list_t &list);
+std::array<uint8_t, MAX_REINFORCEMENTS> M_PickReinforcements(edict_t *self, int32_t &num_chosen, int32_t max_slots = 0);
 
 constexpr gtime_t HOLD_FOREVER = gtime_t::from_ms(std::numeric_limits<int64_t>::max());
 
@@ -1669,8 +1696,9 @@
 	gtime_t blind_fire_delay;
 	vec3_t	blind_fire_target;
 	// used by the spawners to not spawn too much and keep track of #s of monsters spawned
-	int32_t	 monster_slots; // nb: for spawned monsters, this is how many slots we took from our commander
-	int32_t	 monster_used;
+	int32_t  slots_from_commander; // for spawned monsters, this is how many slots we took from our commander
+	int32_t	 monster_slots; // for commanders, total slots we can occupy
+	int32_t	 monster_used; // for commanders, total slots currently used
 	edict_t *commander;
 	// powerup timers, used by widow, our friend
 	gtime_t quad_time;
@@ -1729,6 +1757,14 @@
 
 	// NOTE: if adding new elements, make sure to add them
 	// in g_save.cpp too!
+
+	//ZAERO
+	float flashTime;
+	float flashBase;
+	float reducedDamageAmount;
+	float attack_angle_yaw; //created because old version used attack_state which got changed
+
+	vec3_t shottarget;
 };
 
 // non-monsterinfo save stuff
@@ -1777,7 +1813,6 @@
 extern game_locals_t  game;
 extern level_locals_t level;
 extern game_export_t  globals;
-extern spawn_temp_t	  st;
 
 extern edict_t *g_edicts;
 
@@ -1878,6 +1913,7 @@
 	return irandom(2) == 0;
 }
 
+extern cvar_t *developer;
 extern cvar_t *deathmatch;
 extern cvar_t *coop;
 extern cvar_t *skill;
@@ -1912,6 +1948,7 @@
 extern cvar_t *sv_cheats;
 extern cvar_t *g_debug_monster_paths;
 extern cvar_t *g_debug_monster_kills;
+extern cvar_t *g_debug_poi;
 extern cvar_t *maxspectators;
 
 extern cvar_t *bot_debug_follow_actor;
@@ -1994,7 +2031,8 @@
 constexpr spawnflags_t SPAWNFLAG_ITEM_TRIGGER_SPAWN = 0x00000001_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_ITEM_NO_TOUCH = 0x00000002_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_ITEM_TOSS_SPAWN = 0x00000004_spawnflag;
-constexpr spawnflags_t SPAWNFLAG_ITEM_MAX = 0x00000008_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_ITEM_NO_DROP = 0x00000008_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_ITEM_MAX = 0x00000016_spawnflag;
 // 8 bits reserved for editor flags & power cube bits
 // (see SPAWNFLAG_NOT_EASY above)
 constexpr spawnflags_t SPAWNFLAG_ITEM_DROPPED = 0x00010000_spawnflag;
@@ -2021,7 +2059,7 @@
 edict_t	*Drop_Item(edict_t *ent, gitem_t *item);
 void	  SetRespawn(edict_t *ent, gtime_t delay, bool hide_self = true);
 void	  ChangeWeapon(edict_t *ent);
-void	  SpawnItem(edict_t *ent, gitem_t *item);
+void	  SpawnItem(edict_t *ent, gitem_t *item, const spawn_temp_t &st);
 void	  Think_Weapon(edict_t *ent);
 item_id_t ArmorIndex(edict_t *ent);
 item_id_t PowerArmorType(edict_t *ent);
@@ -2039,7 +2077,7 @@
 //
 // g_utils.c
 //
-bool KillBox(edict_t *ent, bool from_spawning, mod_id_t mod = MOD_TELEFRAG, bool bsp_clipping = true);
+bool KillBox(edict_t *ent, bool from_spawning, mod_id_t mod = MOD_TELEFRAG, bool bsp_clipping = true, bool allow_safety = false);
 edict_t *G_Find(edict_t *from, std::function<bool(edict_t *e)> matcher);
 
 // utility template for getting the type of a field
@@ -2085,6 +2123,9 @@
 //
 // g_spawn.c
 //
+const spawn_temp_t &ED_GetSpawnTemp();
+void  ED_ParseField(const char *key, const char *value, edict_t *ent, spawn_temp_t &st);
+void  ED_CallSpawn(edict_t *ent, const spawn_temp_t &spawntemp);
 void  ED_CallSpawn(edict_t *ent);
 char *ED_NewString(char *string);
 
@@ -2103,6 +2144,8 @@
 constexpr spawnflags_t SPAWNFLAG_LASER_FAT = 0x0040_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_LASER_ZAP = 0x80000000_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_LASER_LIGHTNING = 0x10000_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_LASER_REACTOR = 0x20000_spawnflag; // PSX reactor effect instead of beam
+constexpr spawnflags_t SPAWNFLAG_LASER_NO_PROTECTION = 0x40000_spawnflag; // no protection
 
 constexpr spawnflags_t SPAWNFLAG_HEALTHBAR_PVS_ONLY = 1_spawnflag;
 
@@ -2177,7 +2220,7 @@
 						 int vspread, monster_muzzleflash_id_t flashtype);
 void monster_fire_shotgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick, int hspread,
 						  int vspread, int count, monster_muzzleflash_id_t flashtype);
-void monster_fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
+edict_t *monster_fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 						  monster_muzzleflash_id_t flashtype, effects_t effect);
 void monster_fire_flechette(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 						    monster_muzzleflash_id_t flashtype);
@@ -2185,7 +2228,7 @@
 						  monster_muzzleflash_id_t flashtype, float right_adjust, float up_adjust);
 void monster_fire_rocket(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 						 monster_muzzleflash_id_t flashtype);
-void monster_fire_railgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick,
+bool monster_fire_railgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick,
 						  monster_muzzleflash_id_t flashtype);
 void monster_fire_bfg(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, int kick,
 					  float damage_radius, monster_muzzleflash_id_t flashtype);
@@ -2217,13 +2260,15 @@
 // used in N64, appears to change their behavior for the end scene.
 constexpr size_t HACKFLAG_END_CUTSCENE = 4;
 
-bool monster_start(edict_t *self);
+bool monster_start(edict_t *self, const spawn_temp_t &st);
 void monster_start_go(edict_t *self);
 // RAFAEL
 void monster_fire_ionripper(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 							monster_muzzleflash_id_t flashtype, effects_t effect);
 void monster_fire_heat(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 					   monster_muzzleflash_id_t flashtype, float lerp_factor);
+constexpr spawnflags_t SPAWNFLAG_DABEAM_SECONDARY = 1_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_DABEAM_SPAWNED = 2_spawnflag;
 void monster_fire_dabeam(edict_t *self, int damage, bool secondary, void(*update_func)(edict_t *self));
 void dabeam_update(edict_t *self, bool damage);
 void monster_fire_blueblaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
@@ -2237,7 +2282,7 @@
 						  monster_muzzleflash_id_t flashtype);
 void monster_fire_heatbeam(edict_t *self, const vec3_t &start, const vec3_t &dir, const vec3_t &offset, int damage,
 						   int kick, monster_muzzleflash_id_t flashtype);
-void stationarymonster_start(edict_t *self);
+void stationarymonster_start(edict_t *self, const spawn_temp_t &st);
 void monster_done_dodge(edict_t *self);
 // ROGUE
 
@@ -2253,6 +2298,7 @@
 constexpr spawnflags_t SPAWNFLAG_MONSTER_SUPER_STEP = 17_spawnflag_bit;
 constexpr spawnflags_t SPAWNFLAG_MONSTER_NO_DROP = 18_spawnflag_bit;
 constexpr spawnflags_t SPAWNFLAG_MONSTER_SCENIC = 19_spawnflag_bit;
+constexpr spawnflags_t SPAWNFLAG_MONSTER_NO_IDLE_DOORS = 20_spawnflag_bit;
 
 // fixbot spawnflags
 constexpr spawnflags_t SPAWNFLAG_FIXBOT_FIXIT = 4_spawnflag;
@@ -2303,6 +2349,7 @@
 
 void FoundTarget(edict_t *self);
 void HuntTarget(edict_t *self, bool animate_state = true);
+bool infront_cone(edict_t *self, edict_t *other, float cone);
 bool infront(edict_t *self, edict_t *other);
 bool visible(edict_t *self, edict_t *other, bool through_glass = true);
 bool FacingIdeal(edict_t *self);
@@ -2318,7 +2365,7 @@
 void fire_shotgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick, int hspread,
 				  int vspread, int count, mod_t mod);
 void blaster_touch(edict_t *self, edict_t *other, const trace_t &tr, bool other_touching_self);
-void fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, effects_t effect,
+edict_t *fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, effects_t effect,
 				  mod_t mod);
 void Grenade_Explode(edict_t *ent);
 void fire_grenade(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, gtime_t timer,
@@ -2328,7 +2375,7 @@
 void rocket_touch(edict_t *ent, edict_t *other, const trace_t &tr, bool other_touching_self);
 edict_t *fire_rocket(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed, float damage_radius,
 				 int radius_damage);
-void fire_rail(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick);
+bool fire_rail(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick);
 void fire_bfg(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed, float damage_radius);
 // RAFAEL
 void fire_ionripper(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, effects_t effect);
@@ -2340,7 +2387,7 @@
 				 int radius_damage);
 void fire_trap(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int speed);
 // RAFAEL
-void fire_disintegrator(edict_t *self, const vec3_t &start, const vec3_t &dir, int speed);
+//void fire_disintegrator(edict_t *self, const vec3_t &start, const vec3_t &dir, int speed);
 vec3_t P_CurrentKickAngles(edict_t *ent);
 vec3_t P_CurrentKickOrigin(edict_t *ent);
 void P_AddWeaponKick(edict_t *ent, const vec3_t &origin, const vec3_t &angles);
@@ -2431,6 +2478,15 @@
 //
 // p_view.c
 //
+struct step_parameters_t
+{
+	float			xyspeed;
+	float			bobmove;
+	int				bobcycle, bobcycle_run;	  // odd cycles are right foot going forward
+	float			bobfracsin; // sinf(bobfrac*M_PI)
+};
+
+void G_SetClientFrame(edict_t *ent, const step_parameters_t &step);
 void ClientEndServerFrame(edict_t *ent);
 void G_LagCompensate(edict_t *from_player, const vec3_t &start, const vec3_t &dir);
 void G_UnLagCompensate();
@@ -3006,6 +3062,21 @@
 	gtime_t	 last_attacker_time;
 	// saved - for coop; last time we were in a firing state
 	gtime_t	 last_firing_time;
+
+	//ZAERO
+	float flashTime;
+	float flashBase;
+
+	gtime_t sniper_ready_time;
+	gtime_t scannon_sound_time;
+	gtime_t scannon_start_fire_time;
+	gtime_t scannon_ready_time;
+	gtime_t a2k_time;
+
+	edict_t* zaero_camera_tracking;
+	edict_t* zaero_camera_local_entity;
+	vec3_t zaero_camera_offset;
+	gtime_t zaero_camera_static_effect_time;
 };
 
 // ==========================================
@@ -3233,8 +3304,29 @@
 	mod_t	lastMOD;
 	const char	*style_on, *style_off;
 	uint32_t crosslevel_flags;
+	gtime_t no_gravity_time;
+	float vision_cone; // TODO: migrate vision_cone on old loads to -2.0f
 	// NOTE: if adding new elements, make sure to add them
 	// in g_save.cpp too!
+
+	//
+	// ZAERO
+	//
+
+	gtime_t timeout;
+
+	int active;
+	int seq;
+
+	edict_t* rideWith[2];
+	vec3_t rideWithOffset[2];
+	vec3_t mangle;
+	int visorFrames;
+
+	int onFloor;
+	gtime_t bossFireTimeout;
+	int bossFireCount;
+	gtime_t visor_time;
 };
 
 //=============
@@ -3534,17 +3626,16 @@
 struct fmt::formatter<edict_t>
 {
 	template<typename ParseContext>
-	constexpr auto parse(ParseContext& ctx)
+	constexpr auto parse(ParseContext &ctx)
 	{
 		return ctx.begin();
 	}
 
     template<typename FormatContext>
-    auto format(const edict_t &p, FormatContext &ctx) -> decltype(ctx.out())
+    auto format(const edict_t &p, FormatContext &ctx) const
     {
-		if (p.linked)
-			return fmt::format_to(ctx.out(), FMT_STRING("{} @ {}"), p.classname, (p.absmax + p.absmin) * 0.5f);
-		return fmt::format_to(ctx.out(), FMT_STRING("{} @ {}"), p.classname, p.s.origin);
+		vec3_t pos = p.linked ? ((p.absmax + p.absmin) * 0.5f) : p.s.origin;
+		return fmt::format_to(ctx.out(), FMT_STRING("{} @ {}"), p.classname, pos);
     }
 };
 
@@ -3647,3 +3738,73 @@
 
 extern cached_modelindex sm_meat_index;
 extern cached_soundindex snd_fry;
+
+/* KONIG - IONIZED*/
+//g_ionized_items.cpp
+
+//g_ionized_monster.cpp
+void fire_acid(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed);
+void fire_guardian_heat(edict_t* self, const vec3_t& start, const vec3_t& dir, const vec3_t& rest_dir, int damage, int speed,
+	float damage_radius, int radius_damage, float turn_fraction);
+void fire_dropper(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int speed);
+
+void monster_fire_lightning(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed,
+	monster_muzzleflash_id_t flashtype, effects_t effect);
+void monster_fire_plasma(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed,
+	float damage_radius, int radius_damage, monster_muzzleflash_id_t flashtype);
+void monster_fire_flakcannon(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int hspread,
+	int vspread, int count, monster_muzzleflash_id_t flashtype);
+void monster_fire_flakblaster(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int hspread,
+	int vspread, int count, monster_muzzleflash_id_t flashtype, effects_t effect, int skin);
+void monster_fire_flakripper(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int kick, int hspread,
+	int vspread, int count, monster_muzzleflash_id_t flashtype, effects_t effect);
+
+bool IsEnergyWeapon(const mod_t& mod);
+bool IsExplosiveWeapon(const mod_t& mod);
+
+//g_ionized_weapon.cpp
+void fire_disintegrator(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, float damage_radius);
+void fire_lightning(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, effects_t effect);
+
+// ZAERO
+constexpr gtime_t TBOMB_DELAY = 1_sec;
+constexpr gtime_t TBOMB_TIMEOUT = 180_sec;
+constexpr int 	  TBOMB_DAMAGE = 150;
+constexpr int 	  TBOMB_RADIUS_DAMAGE = 384;
+constexpr int 	  TBOMB_HEALTH = 100;
+constexpr int 	  TBOMB_SHRAPNEL = 5;
+constexpr int 	  TBOMB_SHRAPNEL_DMG = 15;
+
+//g_zaero_camera.cpp
+
+//g_zaero_items.cpp
+
+//g_zaero_misc.cpp
+constexpr spawnflags_t SPAWNFLAG_CHECK_BACK_WALL = 1_spawnflag;
+
+//g_zaero_weapon.cpp
+void fire_flare(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, float damage_radius,
+	int radius_damage, float right_adjust, float up_adjust);
+bool EMPNukeCheck(edict_t* ent, vec3_t pos);
+void fire_empnuke(edict_t* ent, vec3_t center, int radius);
+
+//g_q1_ai.cpp
+bool TryRandomTeleportPosition(edict_t* self, float radius);
+void Q1BossExplode(edict_t* self);
+
+//g_q1_misc.cpp
+
+//g_q1_monster.cpp
+edict_t* fire_lavaball(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, float damage_radius,
+	int radius_damage);
+void fire_vorepod(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, float damage_radius,
+	int radius_damage, float turn_fraction, int skin);
+void fire_gib(edict_t* self, vec3_t start, vec3_t aimdir, int damage, int speed, float right_adjust, float up_adjust);
+edict_t* fire_flame(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed);
+void fire_plasmaball(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, float damage_radius);
+
+void monster_fire_multigrenade(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed,
+	monster_muzzleflash_id_t flashtype, float right_adjust, float up_adjust);
+
+//g_q1_weapon.cpp
+void fire_multigrenade(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, gtime_t timer, float damage_radius, float right_adjust, float up_adjust, bool monster);
--- a/g_main.cpp	2023-10-03 19:43:06
+++ b/g_main.cpp	2025-09-04 19:53:48
@@ -20,13 +20,13 @@
 /*static*/ std::array<const char*, MAX_LOCALIZATION_ARGS> local_game_import_t::buffer_ptrs;
 
 game_export_t  globals;
-spawn_temp_t   st;
 
 cached_modelindex		sm_meat_index;
 cached_soundindex		snd_fry;
 
 edict_t *g_edicts;
 
+cvar_t *developer;
 cvar_t *deathmatch;
 cvar_t *coop;
 cvar_t *skill;
@@ -69,6 +69,7 @@
 
 cvar_t *g_debug_monster_paths;
 cvar_t *g_debug_monster_kills;
+cvar_t *g_debug_poi;
 
 cvar_t *bot_debug_follow_actor;
 cvar_t *bot_debug_move_to_point;
@@ -168,6 +169,7 @@
 */
 void PreInitGame()
 {
+	developer = gi.cvar("developer", "0", CVAR_NOFLAGS);
 	maxclients = gi.cvar("maxclients", G_Fmt("{}", MAX_SPLIT_PLAYERS).data(), CVAR_SERVERINFO | CVAR_LATCH);
 	deathmatch = gi.cvar("deathmatch", "0", CVAR_LATCH);
 	coop = gi.cvar("coop", "0", CVAR_LATCH);
@@ -259,6 +261,7 @@
 
 	g_debug_monster_paths = gi.cvar("g_debug_monster_paths", "0", CVAR_NOFLAGS);
 	g_debug_monster_kills = gi.cvar("g_debug_monster_kills", "0", CVAR_LATCH);
+	g_debug_poi = gi.cvar("g_debug_poi", "0", CVAR_NOFLAGS);
 
 	bot_debug_follow_actor = gi.cvar("bot_debug_follow_actor", "0", CVAR_NOFLAGS);
 	bot_debug_move_to_point = gi.cvar("bot_debug_move_to_point", "0", CVAR_NOFLAGS);
--- a/g_misc.cpp	2023-10-03 19:43:06
+++ b/g_misc.cpp	2025-09-04 19:53:48
@@ -624,6 +624,8 @@
 
 static void setup_dynamic_light(edict_t* self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	// [Sam-KEX] Shadow stuff
 	if (st.sl.data.radius > 0)
 	{
@@ -661,6 +663,8 @@
 
 void SP_light(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	// no targeted lights in deathmatch, because they cause global messages
 	if((!self->targetname || (deathmatch->integer && !(self->spawnflags.has(SPAWNFLAG_LIGHT_ALLOW_IN_DM)))) && st.sl.data.radius == 0) // [Sam-KEX]
 	{
@@ -709,6 +713,7 @@
 constexpr spawnflags_t SPAWNFLAG_WALL_START_ON = 4_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_WALL_ANIMATED = 8_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_WALL_ANIMATED_FAST = 16_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_SAFE_APPEAR = 32_spawnflag;
 
 USE(func_wall_use) (edict_t *self, edict_t *other, edict_t *activator) -> void
 {
@@ -717,7 +722,7 @@
 		self->solid = SOLID_BSP;
 		self->svflags &= ~SVF_NOCLIENT;
 		gi.linkentity(self);
-		KillBox(self, false);
+		KillBox(self, false, MOD_TELEFRAG, true, self->spawnflags.has(SPAWNFLAG_SAFE_APPEAR));
 	}
 	else
 	{
@@ -1188,6 +1193,8 @@
 // PGM
 //=========
 
+constexpr spawnflags_t SPAWNFLAG_EXPLOBOX_NO_MOVE = 1_spawnflag;
+
 void SP_misc_explobox(edict_t *self)
 {
 	if (deathmatch->integer)
@@ -1220,7 +1227,10 @@
 	self->takedamage = true;
 	self->flags |= FL_TRAP;
 
-	self->touch = barrel_touch;
+	if (!self->spawnflags.has(SPAWNFLAG_EXPLOBOX_NO_MOVE))
+		self->touch = barrel_touch;
+	else
+		self->flags |= FL_NO_KNOCKBACK;
 
 	// PGM - change so barrels will think and hence, blow up
 	self->think = barrel_start;
@@ -2133,6 +2143,8 @@
 
 void SP_misc_flare(edict_t* ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	ent->s.modelindex = 1;
 	ent->s.renderfx = RF_FLARE;
 	ent->solid = SOLID_NOT;
@@ -2352,6 +2364,8 @@
 		return;
 	} // not much point without something to print...
 
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->think = info_world_text_think;
 	self->use = info_world_text_use;
 	self->size[ 2 ] = st.radius ? st.radius : 0.2f;
@@ -2492,6 +2506,8 @@
  "radius"		- How much to scale the model in-game
 */
 void SP_misc_player_mannequin( edict_t * self ) {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->movetype = MOVETYPE_NONE;
 	self->solid = SOLID_BBOX;
 	if (!st.was_key_specified("effects"))
@@ -2528,10 +2544,28 @@
 	gi.linkentity( self );
 }
 
+constexpr spawnflags_t SPAWNFLAG_MODEL_TOGGLE = 1_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_MODEL_START_ON = 2_spawnflag;
+
+USE(misc_model_use) (edict_t *self, edict_t *other, edict_t *activator) -> void
+{
+	self->svflags ^= SVF_NOCLIENT;
+}
+
 /*QUAKED misc_model (1 0 0) (-8 -8 -8) (8 8 8)
 */
 void SP_misc_model(edict_t *ent)
 {
-	gi.setmodel(ent, ent->model);
+	if (ent->model && ent->model[0])
+		gi.setmodel(ent, ent->model);
+
+	if (ent->spawnflags.has(SPAWNFLAG_MODEL_TOGGLE))
+	{
+		ent->use = misc_model_use;
+
+		if (!ent->spawnflags.has(SPAWNFLAG_MODEL_START_ON))
+			ent->svflags |= SVF_NOCLIENT;
+	}
+
 	gi.linkentity(ent);
 }
--- a/g_monster.cpp	2023-10-03 19:43:06
+++ b/g_monster.cpp	2025-09-04 19:53:48
@@ -37,11 +37,12 @@
 	monster_muzzleflash(self, start, flashtype);
 }
 
-void monster_fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
+edict_t *monster_fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
 						  monster_muzzleflash_id_t flashtype, effects_t effect)
 {
-	fire_blaster(self, start, dir, damage, speed, effect, MOD_BLASTER);
+	edict_t *e = fire_blaster(self, start, dir, damage, speed, effect, MOD_BLASTER);
 	monster_muzzleflash(self, start, flashtype);
+	return e;
 }
 
 void monster_fire_flechette(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed,
@@ -65,15 +66,17 @@
 	monster_muzzleflash(self, start, flashtype);
 }
 
-void monster_fire_railgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick,
+bool monster_fire_railgun(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick,
 						  monster_muzzleflash_id_t flashtype)
 {
 	if (gi.pointcontents(start) & MASK_SOLID)
-		return;
-
-	fire_rail(self, start, aimdir, damage, kick);
+		return false;
+
+	bool hit = fire_rail(self, start, aimdir, damage, kick);
 
 	monster_muzzleflash(self, start, flashtype);
+
+	return hit;
 }
 
 void monster_fire_bfg(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int speed, int kick,
@@ -141,6 +144,10 @@
 {
 	vec3_t	point;
 	trace_t trace;
+
+	// [Paril-KEX]
+	if (ent->no_gravity_time > level.time)
+		return;
 
 	if (ent->flags & (FL_SWIM | FL_FLY))
 		return;
@@ -238,43 +245,31 @@
 
 	if (ent->health > 0)
 	{
+		bool take_drown_damage = false;
+
 		if (!(ent->flags & FL_SWIM))
 		{
 			if (ent->waterlevel < WATER_UNDER)
-			{
 				ent->air_finished = level.time + 12_sec;
-			}
 			else if (ent->air_finished < level.time)
-			{ // drown!
-				if (ent->pain_debounce_time < level.time)
-				{
-					dmg = 2 + (int) (2 * floorf((level.time - ent->air_finished).seconds()));
-					if (dmg > 15)
-						dmg = 15;
-					T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, dmg, 0, DAMAGE_NO_ARMOR,
-							 MOD_WATER);
-					ent->pain_debounce_time = level.time + 1_sec;
-				}
-			}
+				take_drown_damage = true;
 		}
 		else
 		{
 			if (ent->waterlevel > WATER_NONE)
-			{
 				ent->air_finished = level.time + 9_sec;
-			}
 			else if (ent->air_finished < level.time)
-			{ // suffocate!
-				if (ent->pain_debounce_time < level.time)
-				{
-					dmg = 2 + (int) (2 * floorf((level.time - ent->air_finished).seconds()));
-					if (dmg > 15)
-						dmg = 15;
-					T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, dmg, 0, DAMAGE_NO_ARMOR,
-							 MOD_WATER);
-					ent->pain_debounce_time = level.time + 1_sec;
-				}
-			}
+				take_drown_damage = true;
+		}
+
+		if (take_drown_damage && ent->pain_debounce_time < level.time)
+		{
+			dmg = 2 + (int) (2 * floorf((level.time - ent->air_finished).seconds()));
+			if (dmg > 15)
+				dmg = 15;
+			T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, dmg, 0, DAMAGE_NO_ARMOR,
+						MOD_WATER);
+			ent->pain_debounce_time = level.time + 1_sec;
 		}
 	}
 
@@ -666,30 +661,16 @@
 		}
 		// ROGUE
 
+		bool dead_commander_check = false;
+
 		if (!e->deadflag)
 		{
 			e->enemy = e->monsterinfo.damage_attacker;
 
 			// ROGUE
 			// ROGUE - free up slot for spawned monster if it's spawned
-			if (e->monsterinfo.aiflags & AI_SPAWNED_CARRIER)
-			{
-				if (e->monsterinfo.commander && e->monsterinfo.commander->inuse &&
-					!strcmp(e->monsterinfo.commander->classname, "monster_carrier"))
-					e->monsterinfo.commander->monsterinfo.monster_slots++;
-				e->monsterinfo.commander = nullptr;
-			}
-			if (e->monsterinfo.aiflags & AI_SPAWNED_WIDOW)
-			{
-				// need to check this because we can have variable numbers of coop players
-				if (e->monsterinfo.commander && e->monsterinfo.commander->inuse &&
-					!strncmp(e->monsterinfo.commander->classname, "monster_widow", 13))
-				{
-					if (e->monsterinfo.commander->monsterinfo.monster_used > 0)
-						e->monsterinfo.commander->monsterinfo.monster_used--;
-					e->monsterinfo.commander = nullptr;
-				}
-			}
+			if ((e->monsterinfo.aiflags & AI_SPAWNED_COMMANDER) && !(e->monsterinfo.aiflags & AI_SPAWNED_NEEDS_GIB))
+				dead_commander_check = true;
 
 			if (!(e->monsterinfo.aiflags & AI_DO_NOT_COUNT) && !(e->spawnflags & SPAWNFLAG_MONSTER_DEAD))
 				G_MonsterKilled(e);
@@ -703,13 +684,18 @@
 		// [Paril-KEX] medic commander only gets his slots back after the monster is gibbed, since we can revive them
 		if (e->health <= e->gib_health)
 		{
-			if (e->monsterinfo.aiflags & AI_SPAWNED_MEDIC_C)
-			{
-				if (e->monsterinfo.commander && e->monsterinfo.commander->inuse && !strcmp(e->monsterinfo.commander->classname, "monster_medic_commander"))
-					e->monsterinfo.commander->monsterinfo.monster_used -= e->monsterinfo.monster_slots;
-
-				e->monsterinfo.commander = nullptr;
-			}
+			if ((e->monsterinfo.aiflags & AI_SPAWNED_COMMANDER) && (e->monsterinfo.aiflags & AI_SPAWNED_NEEDS_GIB))
+				dead_commander_check = true;
+		}
+
+		if (dead_commander_check)
+		{
+			edict_t *&commander = e->monsterinfo.commander;
+
+			if (commander && commander->inuse)
+				commander->monsterinfo.monster_used = max(0, commander->monsterinfo.monster_used - e->monsterinfo.slots_from_commander);
+
+			commander = nullptr;
 		}
 
 		if (e->inuse && e->health > e->gib_health && e->s.frame == e->monsterinfo.active_move->lastframe)
@@ -1152,7 +1138,7 @@
 void monster_death_use(edict_t *self)
 {
 	self->flags &= ~(FL_FLY | FL_SWIM);
-	self->monsterinfo.aiflags &= (AI_DOUBLE_TROUBLE | AI_GOOD_GUY | AI_STINKY | AI_SPAWNED_MASK);
+	self->monsterinfo.aiflags &= AI_DEATH_MASK;
 
 	if (self->item)
 	{
@@ -1176,8 +1162,10 @@
 	// [Paril-KEX] fire health target
 	if (self->healthtarget)
 	{
+		const char *target = self->target;
 		self->target = self->healthtarget;
 		G_UseTargets(self, self->enemy);
+		self->target = target;
 	}
 }
 
@@ -1221,7 +1209,7 @@
 //============================================================================
 constexpr spawnflags_t SPAWNFLAG_MONSTER_FUBAR = 4_spawnflag;
 
-bool monster_start(edict_t *self)
+bool monster_start(edict_t *self, const spawn_temp_t &st)
 {
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
@@ -1284,6 +1272,9 @@
 		self->mass *= self->s.scale;
 	}
 
+	if (level.is_psx)
+		self->s.origin[2] -= self->mins[2] - (self->mins[2] * PSX_PHYSICS_SCALAR);
+
 	// set combat style if unset
 	if (self->monsterinfo.combat_style == COMBAT_UNKNOWN)
 	{
@@ -1326,6 +1317,12 @@
 	// [Paril-KEX] co-op health scale
 	G_Monster_ScaleCoopHealth(self);
 
+	// set vision cone
+	if (!st.was_key_specified("vision_cone"))
+	{
+		self->vision_cone = -2.0f; // special value to use old algorithm
+	}
+
 	return true;
 }
 
@@ -1341,7 +1338,7 @@
 
 	self->s.origin = check;
 
-	if (result == stuck_result_t::FIXED)
+	if (result == stuck_result_t::FIXED && developer->integer)
 		gi.Com_PrintFmt("fixed stuck {}\n", *self);
 
 	return result;
@@ -1569,7 +1566,7 @@
 void walkmonster_start(edict_t *self)
 {
 	self->think = walkmonster_start_go;
-	monster_start(self);
+	monster_start(self, ED_GetSpawnTemp());
 }
 
 THINK(flymonster_start_go) (edict_t *self) -> void
@@ -1587,7 +1584,7 @@
 {
 	self->flags |= FL_FLY;
 	self->think = flymonster_start_go;
-	monster_start(self);
+	monster_start(self, ED_GetSpawnTemp());
 }
 
 THINK(swimmonster_start_go) (edict_t *self) -> void
@@ -1605,7 +1602,7 @@
 {
 	self->flags |= FL_SWIM;
 	self->think = swimmonster_start_go;
-	monster_start(self);
+	monster_start(self, ED_GetSpawnTemp());
 }
 
 USE(trigger_health_relay_use) (edict_t *self, edict_t *other, edict_t *activator) -> void
--- a/g_phys.cpp	2023-10-03 19:43:06
+++ b/g_phys.cpp	2025-09-04 19:53:48
@@ -24,6 +24,8 @@
 */
 
 void SV_Physics_NewToss(edict_t *ent); // PGM
+void SV_Physics_FallFloat(edict_t* ent); //ZAERO
+void SV_Physics_Ride(edict_t* ent); //ZAERO
 
 // [Paril-KEX] fetch the clipmask for this entity; certain modifiers
 // affect the clipping behavior of objects.
@@ -52,6 +54,9 @@
 	if ((ent->svflags & (SVF_MONSTER | SVF_PLAYER)) && (ent->svflags & SVF_DEADMONSTER))
 		mask &= ~(CONTENTS_MONSTER | CONTENTS_PLAYER);
 
+	// remove special mask value
+	mask &= ~CONTENTS_AREAPORTAL;
+
 	return mask;
 }
 
@@ -179,6 +184,9 @@
 */
 void SV_AddGravity(edict_t *ent)
 {
+	if (ent->no_gravity_time > level.time)
+		return;
+
 	ent->velocity += ent->gravityVector * (ent->gravity * level.gravity * gi.frame_time_s);
 }
 
@@ -281,6 +289,10 @@
 	pusher->s.origin += move;
 	pusher->s.angles += amove;
 	gi.linkentity(pusher);
+
+	// no clip mask, so it won't move anything
+	if (!G_GetClipMask(pusher))
+		return true;
 
 	// see if any solid entities are inside the final position
 	check = g_edicts + 1;
@@ -415,7 +427,7 @@
 void SV_Physics_Pusher(edict_t *ent)
 {
 	vec3_t	 move, amove;
-	edict_t *part, *mv;
+	edict_t *part;
 
 	// if not a team captain, so movement will be handled elsewhere
 	if (ent->flags & FL_TEAMSLAVE)
@@ -741,8 +753,11 @@
 	edict_t	*groundentity;
 	contents_t mask = G_GetClipMask(ent);
 
+	// [Paril-KEX]
+	if (ent->no_gravity_time > level.time)
+		ent->groundentity = nullptr;
 	// airborne monsters should always check for ground
-	if (!ent->groundentity)
+	else if (!ent->groundentity)
 		M_CheckGround(ent, mask);
 
 	groundentity = ent->groundentity;
@@ -799,7 +814,7 @@
 		ent->velocity[2] *= newspeed;
 	}
 
-	if (ent->velocity[2] || ent->velocity[1] || ent->velocity[0])
+	if (ent->velocity[2] || ent->velocity[1] || ent->velocity[0] || ent->no_gravity_time > level.time)
 	{
 		// apply friction
 		if ((wasonground || (ent->flags & (FL_SWIM | FL_FLY))) && !(ent->monsterinfo.aiflags & AI_ALTERNATE_FLY))
@@ -994,7 +1009,13 @@
 	case MOVETYPE_NEWTOSS:
 		SV_Physics_NewToss(ent);
 		break;
-	// ROGUE
+		// ZAERO
+	case MOVETYPE_FALLFLOAT:
+		SV_Physics_FallFloat(ent);
+		break;
+	case MOVETYPE_RIDE:
+		SV_Physics_Ride(ent);
+		break;
 	default:
 		gi.Com_ErrorFmt("SV_Physics: bad movetype {}", (int32_t) ent->movetype);
 	}
--- a/g_save.cpp	2023-10-03 19:43:06
+++ b/g_save.cpp	2025-09-04 19:53:48
@@ -22,7 +22,6 @@
 // - backwards & forwards compatible with this same format
 // - I wrote this initially when the codebase was in C, so it
 //   does have some C-isms in here.
-constexpr size_t SAVE_FORMAT_VERSION = 1;
 
 #include <unordered_map>
 
@@ -105,6 +104,26 @@
 		list_str_hash.emplace(link->name, link);
 		list_from_ptr_hash.emplace(std::make_tuple(link->ptr, link->tag), link);
 	}
+
+#ifdef _DEBUG
+	// verify integrity of mmove_t's; ideally this would be done
+	// at compile time but it complicates the code a bit
+	for (const save_data_list_t *link = list_head; link; link = link->next)
+	{
+		if (link->tag == SAVE_DATA_MMOVE)
+		{
+			// mmove_t integrity check
+			const mmove_t *move = reinterpret_cast<const mmove_t *>(link->ptr);
+			size_t defined_frames = (move->lastframe - move->firstframe + 1);
+
+			if (defined_frames != move->framecount)
+			{
+				gi.Com_ErrorFmt("monster move {} has mismatched frame counts (defined as {} frames, but array has {} elements)",
+					link->name, defined_frames, move->framecount);
+			}
+		}
+	}
+#endif
 
 	save_data_initialized = true;
 }
@@ -223,6 +242,12 @@
 
 	void (*read)(void *data, const Json::Value &json, const char *field) = nullptr; // for custom reading
 	bool (*write)(const void *data, bool null_for_empty, Json::Value &output) = nullptr; // for custom writing
+};
+
+constexpr size_t SAVE_FORMAT_VERSION = 2;
+
+constexpr save_type_t save_version_type = {
+	ST_UINT32
 };
 
 struct save_field_t
@@ -738,7 +763,11 @@
 	FIELD_AUTO(health_bar_entities),
 	FIELD_AUTO(intermission_server_frame),
 	FIELD_AUTO(story_active),
-	FIELD_AUTO(next_auto_save)
+	FIELD_AUTO(next_auto_save),
+	FIELD_LEVEL_STRING(primary_objective_string),
+	FIELD_LEVEL_STRING(secondary_objective_string),
+	FIELD_LEVEL_STRING(primary_objective_title),
+	FIELD_LEVEL_STRING(secondary_objective_title)
 SAVE_STRUCT_END
 #undef DECLARE_SAVE_STRUCT
 
@@ -929,6 +958,19 @@
 	FIELD_AUTO(sound2_entity_time),
 
 	FIELD_AUTO(last_firing_time),
+
+		//ZAERO
+		FIELD_AUTO(flashTime),
+		FIELD_AUTO(flashBase),
+		FIELD_AUTO(sniper_ready_time),
+		FIELD_AUTO(scannon_sound_time),
+		FIELD_AUTO(scannon_start_fire_time),
+		FIELD_AUTO(scannon_ready_time),
+		FIELD_AUTO(a2k_time),
+		FIELD_AUTO(zaero_camera_tracking),
+		FIELD_AUTO(zaero_camera_local_entity),
+		FIELD_AUTO(zaero_camera_offset),
+		FIELD_AUTO(zaero_camera_static_effect_time),
 SAVE_STRUCT_END
 #undef DECLARE_SAVE_STRUCT
 // clang-format on
@@ -966,6 +1008,8 @@
 	FIELD_AUTO(s.alpha),
 	FIELD_AUTO(s.scale),
 	FIELD_AUTO(s.instance_bits),
+	FIELD_AUTO(s.loop_volume),
+	FIELD_AUTO(s.loop_attenuation),
 
 	// server stuff
 	// client is auto-set
@@ -1095,6 +1139,7 @@
 
 	FIELD_AUTO(item),
 	FIELD_AUTO(crosslevel_flags),
+	FIELD_AUTO(no_gravity_time),
 
 	// moveinfo_t
 	FIELD_AUTO(moveinfo.start_origin),
@@ -1193,6 +1238,7 @@
 	FIELD_AUTO(monsterinfo.jump_height),
 	FIELD_AUTO(monsterinfo.blind_fire_delay),
 	FIELD_AUTO(monsterinfo.blind_fire_target),
+	FIELD_AUTO(monsterinfo.slots_from_commander),
 	FIELD_AUTO(monsterinfo.monster_slots),
 	FIELD_AUTO(monsterinfo.monster_used),
 	FIELD_AUTO(monsterinfo.commander),
@@ -1236,6 +1282,11 @@
 	FIELD_AUTO( monsterinfo.move_block_change_time ),
 	FIELD_AUTO( monsterinfo.react_to_damage_time ),
 	FIELD_AUTO(monsterinfo.jump_time),
+	// ZAERO
+		FIELD_AUTO(monsterinfo.flashTime),
+		FIELD_AUTO(monsterinfo.flashBase),
+		FIELD_AUTO(monsterinfo.reducedDamageAmount),
+		FIELD_AUTO(monsterinfo.shottarget),
 
 	FIELD_SIMPLE( monsterinfo.reinforcements, ST_REINFORCEMENTS ),
 	FIELD_AUTO( monsterinfo.chosen_reinforcements ),
@@ -1302,6 +1353,16 @@
 	
 	FIELD_AUTO( lastMOD.id ),
 	FIELD_AUTO( lastMOD.friendly_fire ),
+
+	FIELD_AUTO(vision_cone),
+
+	//ZAERO
+		FIELD_AUTO(timeout),
+		FIELD_AUTO(active),
+		FIELD_AUTO(seq),
+		FIELD_AUTO(onFloor),
+		FIELD_AUTO(bossFireTimeout),
+		FIELD_AUTO(visor_time),
 
 SAVE_STRUCT_END
 #undef DECLARE_SAVE_STRUCT
@@ -2420,6 +2481,10 @@
 
 void G_PrecacheInventoryItems();
 
+static void upgrade_client(gclient_t *client, const Json::Value &json, const uint32_t &save_version)
+{
+}
+
 // new entry point for ReadGame.
 // takes in pointer to JSON data. does
 // not store or modify it.
@@ -2431,6 +2496,10 @@
 
 	uint32_t max_entities = game.maxentities;
 	uint32_t max_clients = game.maxclients;
+
+	// pull version
+	uint32_t save_version;
+	read_save_type_json(json["save_version"], &save_version, &save_version_type, "save_version");
 	
 	game = {};
 	g_edicts = (edict_t *) gi.TagMalloc(max_entities * sizeof(g_edicts[0]), TAG_GAME);
@@ -2455,8 +2524,10 @@
 	for (auto &v : clients)
 	{
 		json_push_stack(fmt::format("clients[{}]", i));
-		read_save_struct_json(v, &game.clients[i++], &gclient_t_savestruct);
+		read_save_struct_json(v, &game.clients[i], &gclient_t_savestruct);
+		upgrade_client(&game.clients[i], v, save_version);
 		json_pop_stack();
+		i++;
 	}
 
 	G_PrecacheInventoryItems();
@@ -2506,6 +2577,24 @@
 	return saveJson(json, out_size);
 }
 
+static void upgrade_edict(edict_t *ent, const Json::Value &json, const uint32_t &save_version)
+{
+	// 1 -> 2
+	if (save_version <= 1)
+	{
+		// func_plat2 gained "wait" key.
+		// used to be hardcoded to 2.0f
+		if (ent->classname && !strcmp(ent->classname, "func_plat2"))
+		{
+			ent->wait = 2.0f;
+		}
+	}
+}
+
+static void upgrade_level(const Json::Value &json, const uint32_t &save_version)
+{
+}
+
 // new entry point for ReadLevel.
 // takes in pointer to JSON data. does
 // not store or modify it.
@@ -2521,9 +2610,14 @@
 	memset(g_edicts, 0, game.maxentities * sizeof(g_edicts[0]));
 	globals.num_edicts = game.maxclients + 1;
 
+	// pull version
+	uint32_t save_version;
+	read_save_type_json(json["save_version"], &save_version, &save_version_type, "save_version");
+
 	// read level
 	json_push_stack("level");
 	read_save_struct_json(json["level"], &level, &level_locals_t_savestruct);
+	upgrade_level(json["level"], save_version);
 	json_pop_stack();
 
 	// read entities
@@ -2532,13 +2626,11 @@
 	if (!entities.isObject())
 		gi.Com_Error("expected \"entities\" to be object");
 
-	//for (auto key : json.getMemberNames())
 	for (auto it = entities.begin(); it != entities.end(); it++)
 	{
-		//const char		   *classname = key.c_str();
 		const char *dummy;
 		const char *id = it.memberName(&dummy);
-		const Json::Value  &value = *it;//json[key];
+		const Json::Value  &value = *it;
 		uint32_t		   number = strtoul(id, nullptr, 10);
 
 		if (number >= globals.num_edicts)
@@ -2548,6 +2640,7 @@
 		G_InitEdict(ent);
 		json_push_stack(fmt::format("entities[{}]", number));
 		read_save_struct_json(value, ent, &edict_t_savestruct);
+		upgrade_edict(ent, value, save_version);
 		json_pop_stack();
 		gi.linkentity(ent);
 	}
--- a/g_spawn.cpp	2023-10-03 19:43:06
+++ b/g_spawn.cpp	2025-09-04 19:53:48
@@ -49,6 +49,7 @@
 void SP_trigger_fog(edict_t *self); // [Paril-KEX]
 void SP_trigger_coop_relay(edict_t *self); // [Paril-KEX]
 void SP_trigger_health_relay(edict_t *self); // [Paril-KEX]
+void SP_trigger_safe_fall(edict_t *ent); // [Paril-KEX]
 
 void SP_target_temp_entity(edict_t *ent);
 void SP_target_speaker(edict_t *ent);
@@ -217,6 +218,176 @@
 
 void SP_monster_shambler(edict_t* self);
 
+/* KONIG - IONIZED ADDITIONS*/
+void SP_item_foodcube(edict_t* self);
+//ZAERO
+void SP_misc_lasertripbomb(edict_t* self);
+void SP_monster_autocannon(edict_t* self);
+void SP_monster_autocannon_floor(edict_t* self);
+void SP_monster_sentien(edict_t* self);
+void SP_misc_securitycamera(edict_t* self);
+void SP_monster_hound(edict_t* self);
+void SP_monster_handler(edict_t* self);
+void SP_misc_commdish(edict_t* self);
+void SP_misc_crate(edict_t* self);
+void SP_misc_crate_medium(edict_t* self);
+void SP_misc_crate_small(edict_t* self);
+void SP_monster_zboss(edict_t* self);
+void SP_target_zboss(edict_t* self);
+void SP_func_barrier(edict_t* self);
+void SP_misc_seat(edict_t* self);
+//ZAERO COMPATIBILITY
+void SP_key_landingarea(edict_t* self);
+void SP_key_lab(edict_t* self);
+void SP_key_clearancepass(edict_t* self);
+//ZAERO INSPIRED
+void SP_misc_bulldog_s(edict_t* self);
+void SP_misc_bulldog_m(edict_t* self);
+void SP_misc_bulldog_l(edict_t* self);
+//OBLIVION
+//void SP_misc_camera(edict_t* self);
+//void SP_misc_camera_target(edict_t* self);
+//void SP_misc_screenfade(edict_t* self);
+//void SP_func_rotate_train(edict_t* self);
+//void SP_trigger_misc_camera(edict_t* self);
+//void SP_monster_kigrax(edict_t* self);
+//void SP_monster_sentinel(edict_t* self);
+//void SP_monster_tick(edict_t* self);
+void SP_monster_soldier_deatom(edict_t* self);
+//void SP_monster_cyborg(edict_t* self);
+//UNSEEN
+void SP_monster_psoldier(edict_t* self);
+void SP_monster_psoldier_light(edict_t* self);
+void SP_monster_psoldier_ss(edict_t* self);
+void SP_monster_psoldier_special(edict_t* self);
+void SP_monster_psoldier_elite(edict_t* self);
+void SP_monster_psoldier_death(edict_t* self);
+void SP_monster_psoldier_captain(edict_t* self);
+void SP_monster_heavy(edict_t* self);
+void SP_monster_sauron(edict_t* self);
+void SP_monster_droid(edict_t* self);
+void SP_monster_assassin(edict_t* self);
+//Q1 - base
+void SP_monster_army(edict_t* self);
+void SP_monster_chthon(edict_t* self);
+void SP_monster_dog(edict_t* self);
+void SP_monster_enforcer(edict_t* self);
+void SP_monster_fiend(edict_t* self);
+void SP_monster_hknight(edict_t* self);
+void SP_monster_knight(edict_t* self);
+void SP_monster_ogre(edict_t* self);
+void SP_monster_oldone(edict_t* self);
+void SP_monster_rotfish(edict_t* self);
+void SP_monster_scrag(edict_t* self);
+void SP_monster_tarbaby(edict_t* self);
+void SP_monster_vore(edict_t* self);
+void SP_monster_zombie(edict_t* self);
+void SP_light_torch_small_walltorch(edict_t* ent);
+void SP_light_flame_large_yellow(edict_t* ent);
+void SP_light_flame_small_yellow(edict_t* ent);
+void SP_light_flouro(edict_t* ent);
+void SP_light_fluorospark(edict_t* ent);
+void SP_light_sphere(edict_t* ent);
+void SP_item_silver_key(edict_t* self);
+void SP_item_gold_key(edict_t* self);
+void SP_item_sigil(edict_t* self);
+//Q1 - expansions
+void SP_monster_armagon(edict_t* self);
+void SP_monster_dragon(edict_t* self);
+void SP_monster_centroid(edict_t* self);
+void SP_monster_eel(edict_t* self);
+void SP_monster_highpriest(edict_t* self);
+void SP_monster_hstatue(edict_t* self);
+void SP_monster_lavaman(edict_t* self);
+void SP_monster_spike(edict_t* self);
+void SP_monster_mummy(edict_t* self);
+void SP_monster_ogre_multigrenade(edict_t* self);
+void SP_monster_overlord(edict_t* self);
+void SP_monster_priest(edict_t* self);
+void SP_monster_statue(edict_t* self);
+void SP_monster_sword(edict_t* self);
+void SP_monster_tarbaby_hell(edict_t* self);
+void SP_monster_wrath(edict_t* self);
+// Q1 - Qtest and mods
+// void SP_monster_freddie(edict_t* self);
+void SP_monster_ogre_marksman(edict_t* self);
+void SP_monster_serpent(edict_t* self);
+void SP_monster_shalrath(edict_t* self);
+void SP_monster_vomitus(edict_t* self);
+void SP_monster_wyvern(edict_t* self);
+// CITADEL
+void SP_monster_soldier_cobalt(edict_t* self);
+void SP_monster_boss5_gamma(edict_t* self);
+void SP_monster_boss2_titan(edict_t* self);
+// Q25
+void SP_monster_bfgladiator(edict_t* self);
+void SP_monster_soldier_dist(edict_t* self);
+//IONIZED
+void SP_target_shooter_blaster(edict_t* ent);
+void SP_target_shooter_rockets(edict_t* ent);
+void SP_target_shooter_magic(edict_t* ent);
+void SP_item_foodcube(edict_t* self);
+void SP_ammo_shells_small(edict_t* self);
+void SP_ammo_bullets_small(edict_t* self);
+void SP_ammo_rockets_small(edict_t* self);
+void SP_ammo_cells_small(edict_t* self);
+void SP_ammo_slugs_small(edict_t* self);
+void SP_ammo_flechettes_small(edict_t* self);
+void SP_ammo_prox_small(edict_t* self);
+void SP_ammo_magslugs_small(edict_t* self);
+void SP_ammo_rounds_small(edict_t* self);
+void SP_misc_gib_head2(edict_t* self);
+void SP_misc_gib_chest(edict_t* self);
+void SP_misc_gib_gekk(edict_t* self);
+void SP_misc_gib_mutant(edict_t* self);
+void SP_misc_gib_berserk(edict_t* self);
+void SP_misc_gib_chick(edict_t* self);
+void SP_misc_gib_brain(edict_t* self);
+void SP_misc_gib_glad(edict_t* self);
+void SP_misc_gib_gunner(edict_t* self);
+void SP_misc_gib_hover(edict_t* self);
+void SP_misc_gib_infantry(edict_t* self);
+void SP_misc_gib_medic(edict_t* self);
+void SP_misc_gib_parasite(edict_t* self);
+void SP_misc_gib_soldier(edict_t* self);
+void SP_misc_gib_stalker(edict_t* self);
+void SP_misc_gib_tank(edict_t* self);
+void SP_misc_gib_boss1(edict_t* self);
+void SP_misc_gib_boss2(edict_t* self);
+void SP_misc_gib_boss3(edict_t* self);
+void SP_misc_gib_carrier(edict_t* self);
+void SP_misc_gib_strider(edict_t* self);
+void SP_misc_gib_shambler(edict_t* self);
+//cut monsters restored
+void SP_monster_shocker(edict_t* self);
+void SP_monster_gnorta(edict_t* self);
+void SP_monster_dropship(edict_t* self);
+void SP_misc_fighter(edict_t* self);
+void SP_monster_flamer(edict_t* self);
+void SP_monster_blitz(edict_t* self);
+//Q4 DEMAKES
+void SP_monster_tactical_male(edict_t* self);
+void SP_monster_tactical_female(edict_t* self);
+void SP_monster_tactical_cyborg(edict_t* self);
+void SP_monster_berserk2(edict_t* self);
+void SP_monster_dropper(edict_t* self);
+void SP_monster_protector(edict_t* self);
+void SP_monster_fixbot2(edict_t* self);
+void SP_monster_voss(edict_t* self);
+void SP_monster_reject(edict_t* self);
+// QW DEMAKES
+void SP_monster_oppressor(edict_t* self);
+void SP_monster_aggressor(edict_t* self);
+void SP_monster_constructor(edict_t* self);
+void SP_monster_infiltrator(edict_t* self);
+// IONIZED Originals
+void SP_monster_soldier_discharger(edict_t* self);
+void SP_monster_infantry_handler(edict_t* self);
+void SP_monster_mimic(edict_t* self);
+void SP_monster_shark(edict_t* self);
+void SP_monster_cutter(edict_t* self);
+void SP_monster_gladiator_flak(edict_t* self);
+
 // clang-format off
 static const std::initializer_list<spawn_t> spawns = {
 	{ "info_player_start", SP_info_player_start },
@@ -259,6 +430,7 @@
 	{ "trigger_fog", SP_trigger_fog }, // [Paril-KEX]
 	{ "trigger_coop_relay", SP_trigger_coop_relay }, // [Paril-KEX]
 	{ "trigger_health_relay", SP_trigger_health_relay }, // [Paril-KEX]
+	{ "trigger_safe_fall", SP_trigger_safe_fall }, // [Paril-KEX]
 
 	{ "target_temp_entity", SP_target_temp_entity },
 	{ "target_speaker", SP_target_speaker },
@@ -433,9 +605,205 @@
 	{ "info_player_team2", SP_info_player_team2 },
 	// ZOID
 
-	{ "monster_shambler", SP_monster_shambler }
+	{ "monster_shambler", SP_monster_shambler },
+
+	/* KONIG - IONIZED ADDITIONS*/
+	//ZAERO
+	//{ "misc_ired", SP_misc_lasertripbomb },
+	{ "monster_autocannon", SP_monster_autocannon },
+	{ "monster_autocannon_floor", SP_monster_autocannon_floor },
+	{ "monster_sentien", SP_monster_sentien },
+	//{ "misc_securitycamera", SP_misc_securitycamera },
+	{ "monster_hound", SP_monster_hound },
+	{ "monster_handler", SP_monster_handler },
+	{ "monster_zboss", SP_monster_zboss },
+	{ "misc_crate", SP_misc_crate },
+	{ "misc_crate_medium", SP_misc_crate_medium },
+	{ "misc_crate_small", SP_misc_crate_small },
+	{ "misc_seat", SP_misc_seat },
+	{ "misc_commdish", SP_misc_commdish },
+	{ "func_barrier", SP_func_barrier },
+	{ "target_zboss", SP_target_zboss },
+	//ZAERO COMPATIBILITY
+	{ "target_zboss_target", SP_target_zboss },
+	{ "key_landingarea", SP_key_landingarea },
+	{ "key_lab", SP_key_lab },
+	{ "key_clearancepass", SP_key_clearancepass },
+	// ZAERO INSPIRED
+	{ "misc_bulldog_s", SP_misc_bulldog_s },
+	{ "misc_bulldog_m", SP_misc_bulldog_m },
+	{ "misc_bulldog_l", SP_misc_bulldog_l },
+	//OBLIVION
+	//{ "misc_camera", SP_misc_camera },
+	//{ "misc_camera_target", SP_misc_camera_target },
+	//{ "misc_screenfade", SP_misc_screenfade },
+	//{ "func_rotate_train", SP_func_rotate_train },
+	//{ "trigger_misc_camera", SP_trigger_misc_camera },
+	//{ "monster_kigrax", SP_monster_kigrax },
+	//{ "monster_sentinel", SP_monster_sentinel },
+	//{ "monster_badass", SP_monster_sentinel }, //old compatibility
+	//{ "monster_tick", SP_monster_tick },
+	//{ "monster_spider", SP_monster_tick }, //old compatibility
+	//{ "monster_soldier_deatom", SP_monster_soldier_deatom },
+	//{ "monster_cyborg", SP_monster_cyborg },
+	//UNSEEN
+	{ "monster_psoldier_light", SP_monster_psoldier_light },
+	{ "monster_psoldier", SP_monster_psoldier },
+	{ "monster_psoldier_ss", SP_monster_psoldier_ss },
+	{ "monster_psoldier_elite", SP_monster_psoldier_elite },
+	{ "monster_psoldier_special", SP_monster_psoldier_special },
+	{ "monster_psoldier_death", SP_monster_psoldier_death },
+	{ "monster_psoldier_captain", SP_monster_psoldier_captain },
+	{ "monster_heavy", SP_monster_heavy },
+	{ "monster_gunner2", SP_monster_guncmdr },
+	//{ "monster_sauron", SP_monster_sauron },
+	//{ "monster_droid", SP_monster_droid },
+	//{ "monster_assassin", SP_monster_assassin },
+	//{ "monster_dathran", SP_monster_dathran },
+	//PSX
+	//{ "monster_flamer", SP_monster_flamer },
+	//{ "monster_blitz", SP_monster_blitz },
+	//Q1 - base
+	{ "monster_army", SP_monster_army },
+	{ "monster_chthon", SP_monster_chthon },
+	{ "monster_dog", SP_monster_dog },
+	{ "monster_enforcer", SP_monster_enforcer },
+	{ "monster_fiend", SP_monster_fiend },
+	{ "monster_hknight", SP_monster_hknight },
+	{ "monster_knight", SP_monster_knight },
+	{ "monster_ogre", SP_monster_ogre },
+	{ "monster_oldone", SP_monster_oldone },
+	{ "monster_rotfish", SP_monster_rotfish },
+	{ "monster_scrag", SP_monster_scrag },
+	{ "monster_tarbaby", SP_monster_tarbaby },
+	{ "monster_vore", SP_monster_vore },
+	{ "monster_zombie", SP_monster_zombie },
+	//{ "light_flame_small_walltorch", SP_light_torch_small_walltorch },
+	//{ "light_flame_large_yellow", SP_light_flame_large_yellow },
+	//{ "light_flame_small_yellow", SP_light_flame_small_yellow },
+	//{ "light_flame_small_white", SP_light_flame_small_yellow },
+	//{ "light_flouro", SP_light_flouro },
+	//{ "light_flourospark", SP_light_fluorospark },
+	//{ "light_sphere", SP_light_sphere },
+	{ "key_silver_key", SP_item_silver_key },
+	{ "key_gold_key", SP_item_gold_key },
+	{ "item_sigil", SP_item_silver_key },
+	{ "item_key1", SP_item_silver_key }, //backwards compatibility
+	{ "item_key2", SP_item_gold_key }, //backwards compatibility
+	{ "monster_wizard", SP_monster_scrag }, //backwards compatibility
+	{ "monster_demon1", SP_monster_fiend }, //backwards compatibility
+	{ "monster_boss", SP_monster_chthon }, //backwards compatibility
+	//Q1 - expansions
+	// { "monster_armagon", SP_monster_armagon },
+	{ "monster_dragon", SP_monster_dragon },
+	{ "monster_centroid", SP_monster_centroid },
+	{ "monster_eel", SP_monster_eel },
+	// { "monster_highpriest", SP_monster_highpriest},
+	{ "monster_hstatue", SP_monster_hstatue },
+	{ "monster_lavaman", SP_monster_lavaman },
+	{ "monster_mummy", SP_monster_mummy },
+	// { "monster_priest", SP_monster_priest},
+	// { "monster_ogre_multigrenade", SP_monster_ogre_multigrenade },
+	{ "monster_overlord", SP_monster_overlord },
+	{ "monster_mine", SP_monster_spike },
+	{ "monster_statue", SP_monster_statue },
+	{ "monster_sword", SP_monster_sword },
+	{ "monster_tarbaby_hell", SP_monster_tarbaby_hell },
+	{ "monster_wrath", SP_monster_wrath },
+	// Q1 - Qtest and mods
+	// { "monster_freddie", SP_monster_freddie },
+	{ "monster_ogre_marksman", SP_monster_ogre_marksman },
+	//{ "monster_serpent", SP_monster_serpent },
+	{ "monster_shalrath", SP_monster_shalrath },
+	//{ "monster_vomitus", SP_monster_vomitus },
+	{ "monster_wyvern", SP_monster_wyvern },
+	//CITADEL
+	{ "monster_soldier_cobalt", SP_monster_soldier_cobalt },
+	{ "monster_gunner_elite", SP_monster_guncmdr }, //Citadel compatibility
+	{ "monster_chick_beta", SP_monster_chick_heat }, //Citadel compatibility
+	{ "monster_gladiator_beta", SP_monster_gladb }, //Citadel compatibility
+	{ "monster_boss5_gamma", SP_monster_boss5_gamma },
+	{ "monster_boss2_titan", SP_monster_boss2_titan },
+	//Q25
+	{ "monster_bfgladiator", SP_monster_bfgladiator },
+	{ "monster_soldier_dist", SP_monster_soldier_dist },
+	//IONIZED
+	{ "item_foodcube", SP_item_foodcube },
+	{ "ammo_shells_small", SP_ammo_shells_small },
+	{ "ammo_bullets_small", SP_ammo_bullets_small },
+	{ "ammo_rockets_small", SP_ammo_rockets_small },
+	{ "ammo_cells_small", SP_ammo_cells_small },
+	{ "ammo_slugs_small", SP_ammo_slugs_small },
+	//{ "ammo_flechettes_small", SP_ammo_flechettes_small },
+	//{ "ammo_prox_small", SP_ammo_prox_small },
+	//{ "ammo_magslugs_small", SP_ammo_magslugs_small },
+	//{ "ammo_rounds_small", SP_ammo_rounds_small },
+	{ "misc_gib_head2", SP_misc_gib_head2 },
+	{ "misc_gib_chest", SP_misc_gib_chest },
+	{ "misc_gib_gekk", SP_misc_gib_gekk },
+	{ "misc_gib_mutant", SP_misc_gib_mutant },
+	{ "misc_gib_berserk", SP_misc_gib_berserk },
+	{ "misc_gib_chick", SP_misc_gib_chick },
+	{ "misc_gib_brain", SP_misc_gib_brain },
+	{ "misc_gib_glad", SP_misc_gib_glad },
+	{ "misc_gib_gunner", SP_misc_gib_gunner },
+	{ "misc_gib_hover", SP_misc_gib_hover },
+	{ "misc_gib_infantry", SP_misc_gib_infantry },
+	{ "misc_gib_medic", SP_misc_gib_medic },
+	{ "misc_gib_parasite", SP_misc_gib_parasite },
+	{ "misc_gib_soldier", SP_misc_gib_soldier },
+	{ "misc_gib_stalker", SP_misc_gib_stalker },
+	{ "misc_gib_strider", SP_misc_gib_strider },
+	{ "misc_gib_tank", SP_misc_gib_tank },
+	{ "misc_gib_boss1", SP_misc_gib_boss1 },
+	{ "misc_gib_boss2", SP_misc_gib_boss2 },
+	{ "misc_gib_boss3", SP_misc_gib_boss3 },
+	{ "misc_gib_carrier", SP_misc_gib_carrier },
+	{ "misc_gib_shambler", SP_misc_gib_shambler },
+	{ "target_shooter_blaster", SP_target_shooter_blaster },
+	{ "target_shooter_rockets", SP_target_shooter_rockets },
+	{ "target_shooter_magic", SP_target_shooter_magic },
+	//Cut Content restored
+	//{ "monster_gnorta", SP_monster_gnorta },
+	//{ "monster_shocker", SP_monster_shocker },
+	//{ "misc_dropship", SP_misc_dropship },
+	//{ "misc_fighter", SP_misc_fighter },
+	//{ "monster_dropship", SP_monster_dropship },
+	//{ "monster_fighter", SP_monster_fighter },
+	//Q4 demake enemies
+	{ "monster_tactical_male", SP_monster_tactical_male },
+	{ "monster_tactical_female", SP_monster_tactical_female },
+	{ "monster_tactical_cyborg", SP_monster_tactical_cyborg },
+	{ "monster_berserk2", SP_monster_berserk2 },
+	{ "monster_dropper", SP_monster_dropper },
+	{ "monster_protector", SP_monster_protector },
+	{ "monster_fixbot2", SP_monster_fixbot2 },
+	//{ "monster_voss", SP_monster_voss },
+	//{ "monster_reject", SP_monster_reject },
+	//Ionized Originals
+	{ "monster_alphamutant", SP_monster_mutant },
+	{ "monster_infantry_handler", SP_monster_infantry_handler },
+	{ "monster_mimic", SP_monster_mimic },
+	{ "monster_soldier_discharger", SP_monster_soldier_discharger },
+	{ "monster_shark", SP_monster_shark },
+	{ "monster_gladiator_flak", SP_monster_gladiator_flak },
+	{ "monster_cutter", SP_monster_cutter }
 };
 // clang-format on
+
+static const spawn_temp_t *current_st;
+/*static*/ const spawn_temp_t spawn_temp_t::empty = {};
+
+const spawn_temp_t &ED_GetSpawnTemp()
+{
+	if (!current_st)
+	{
+		gi.Com_Print("WARNING: empty spawntemp accessed; this is probably a code bug.\n");
+		return spawn_temp_t::empty;
+	}
+
+	return *current_st;
+}
 
 /*
 ===============
@@ -444,7 +812,7 @@
 Finds the spawn function for the entity and calls it
 ===============
 */
-void ED_CallSpawn(edict_t *ent)
+void ED_CallSpawn(edict_t *ent, const spawn_temp_t &spawntemp)
 {
 	gitem_t *item;
 	int		 i;
@@ -455,6 +823,8 @@
 		G_FreeEdict(ent);
 		return;
 	}
+
+	current_st = &spawntemp;
 
 	// PGM - do this before calling the spawn function so it can be overridden.
 	ent->gravityVector[0] = 0.0;
@@ -494,7 +864,12 @@
 				}
 			}
 
-			SpawnItem(ent, item);
+			SpawnItem(ent, item, spawntemp);
+
+			if (level.is_psx)
+				ent->s.origin[2] += 15.f - (15.f * PSX_PHYSICS_SCALAR);
+
+			current_st = nullptr;
 			return;
 		}
 	}
@@ -509,12 +884,21 @@
 			// Paril: swap classname with stored constant if we didn't change it
 			if (strcmp(ent->classname, s.name) == 0)
 				ent->classname = s.name;
+
+			current_st = nullptr;
 			return;
 		}
 	}
 
 	gi.Com_PrintFmt("{} doesn't have a spawn function\n", *ent);
 	G_FreeEdict(ent);
+	current_st = nullptr;
+}
+
+// Quick redirect to use empty spawntemp
+void  ED_CallSpawn(edict_t *ent)
+{
+	ED_CallSpawn(ent, spawn_temp_t::empty);
 }
 
 /*
@@ -745,7 +1129,7 @@
 
 	// [Paril-KEX] func_eye stuff
 	FIELD_AUTO_NAMED("eye_position", move_origin),
-	FIELD_AUTO_NAMED("vision_cone", yaw_speed),
+	FIELD_AUTO(vision_cone),
 
 	// [Paril-KEX] for trigger_coop_relay
 	FIELD_AUTO_NAMED("message2", map),
@@ -777,6 +1161,23 @@
 				s->monsterinfo.power_armor_type = IT_ITEM_POWER_SCREEN;
 			else
 				s->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+		}
+	},
+
+	/* KONIG - customizable armor stuff*/
+	FIELD_AUTO_NAMED("armor_power", monsterinfo.armor_power),
+	{ "armor_type", [](edict_t* s, const char* v)
+		{
+			int32_t type = atoi(v);
+
+			if (type == 0)
+				s->monsterinfo.armor_type = IT_NULL;
+			else if (type == 1)
+				s->monsterinfo.armor_type = IT_ARMOR_JACKET;
+			else if (type == 2)
+				s->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+			else
+				s->monsterinfo.armor_type = IT_ARMOR_BODY;
 		}
 	},
 
@@ -840,13 +1241,21 @@
 	FIELD_AUTO(start_items),
 	FIELD_AUTO(no_grapple),
 	FIELD_AUTO(health_multiplier),
+	FIELD_AUTO(physics_flags_sp),
+	FIELD_AUTO(physics_flags_dm),
 
 	FIELD_AUTO(reinforcements),
 	FIELD_AUTO(noise_start),
 	FIELD_AUTO(noise_middle),
 	FIELD_AUTO(noise_end),
 
-	FIELD_AUTO(loop_count)
+	FIELD_AUTO(loop_count),
+
+	FIELD_AUTO(primary_objective_string),
+	FIELD_AUTO(secondary_objective_string),
+
+	FIELD_AUTO(primary_objective_title),
+	FIELD_AUTO(secondary_objective_title)
 };
 // clang-format on
 
@@ -858,7 +1267,7 @@
 in an edict
 ===============
 */
-void ED_ParseField(const char *key, const char *value, edict_t *ent)
+void ED_ParseField(const char *key, const char *value, edict_t *ent, spawn_temp_t &st)
 {
 	// check st first
 	for (auto &f : temp_fields)
@@ -905,14 +1314,13 @@
 ed should be a properly initialized empty edict.
 ====================
 */
-const char *ED_ParseEdict(const char *data, edict_t *ent)
+const char *ED_ParseEdict(const char *data, edict_t *ent, spawn_temp_t &st)
 {
 	bool  init;
 	char  keyname[256];
 	const char *com_token;
 
 	init = false;
-	st = {};
 	
 	// go through all the dictionary pairs
 	while (1)
@@ -947,7 +1355,7 @@
 			continue;
 		}
 
-		ED_ParseField(keyname, com_token, ent);
+		ED_ParseField(keyname, com_token, ent, st);
 	}
 
 	if (!init)
@@ -1134,6 +1542,8 @@
 	}
 }
 
+#include <map>
+
 /*
 ==============
 SpawnEntities
@@ -1144,6 +1554,8 @@
 */
 void SpawnEntities(const char *mapname, const char *entities, const char *spawnpoint)
 {
+	level.is_spawning = true;
+
 	// clear cached indices
 	cached_soundindex::clear_all();
 	cached_modelindex::clear_all();
@@ -1175,6 +1587,7 @@
 		Q_strlcpy(game.spawnpoint, spawnpoint, sizeof(game.spawnpoint));
 
 	level.is_n64 = strncmp(level.mapname, "q64/", 4) == 0;
+	level.is_psx = strncmp(level.mapname, "psx/", 4) == 0;
 
 	level.coop_scale_players = 0;
 	level.coop_health_scaling = clamp(g_coop_health_scaling->value, 0.f, 1.f);
@@ -1209,7 +1622,10 @@
 			ent = g_edicts;
 		else
 			ent = G_Spawn();
-		entities = ED_ParseEdict(entities, ent);
+
+		spawn_temp_t st {};
+
+		entities = ED_ParseEdict(entities, ent, st);
 
 		// remove things (except the world) from different skill levels or deathmatch
 		if (ent != g_edicts)
@@ -1232,7 +1648,8 @@
 		ent->gravityVector[1] = 0.0;
 		ent->gravityVector[2] = -1.0;
 		// PGM
-		ED_CallSpawn(ent);
+
+		ED_CallSpawn(ent, st);
 
 		ent->s.renderfx |= RF_IR_VISIBLE; // PGM
 	}
@@ -1272,6 +1689,61 @@
 	// ROGUE
 
 	setup_shadow_lights();
+
+	if (gi.cvar("g_print_spawned_entities", "0", CVAR_NOFLAGS)->integer)
+	{
+		std::map<std::string, int> entities;
+		int total_monster_health = 0;
+
+		for (size_t i = 0; i < globals.num_edicts; i++)
+		{
+			edict_t *e = &globals.edicts[i];
+
+			if (!e->inuse)
+				continue;
+			else if (!e->item && !e->monsterinfo.stand)
+				continue;
+
+			const char *cn = e->classname ? e->classname : "noclass";
+
+			if (auto f = entities.find(cn); f != entities.end())
+			{
+				f->second++;
+			}
+			else
+			{
+				entities.insert({ cn, 1 });
+			}
+
+			if (e->monsterinfo.stand)
+			{
+				total_monster_health += e->health;
+			}
+
+			if (e->item && strcmp(e->classname, e->item->classname))
+			{
+				cn = e->item->classname ? e->item->classname : "noclass";
+
+				if (auto f = entities.find(cn); f != entities.end())
+				{
+					f->second++;
+				}
+				else
+				{
+					entities.insert({ cn, 1 });
+				}
+			}
+		}
+
+		gi.Com_PrintFmt("total monster health: {}\n", total_monster_health);
+		
+		for (auto &e : entities)
+		{
+			gi.Com_PrintFmt("{}: {}\n", e.first, e.second);
+		}
+	}
+
+	level.is_spawning = false;
 }
 
 //===================================================================
@@ -1425,6 +1897,8 @@
 	ent->s.modelindex = MODELINDEX_WORLD;
 	ent->gravity = 1.0f;
 
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (st.hub_map)
 	{
 		level.hub_map = true;
@@ -1514,11 +1988,47 @@
 
 	gi.configstring(CS_MAXCLIENTS, G_Fmt("{}", game.maxclients).data());
 
-	if (level.is_n64 && !deathmatch->integer)
-	{
-		gi.configstring(CONFIG_N64_PHYSICS, "1");
-		pm_config.n64_physics = true;
-	}
+	int override_physics = gi.cvar("g_override_physics_flags", "-1", CVAR_NOFLAGS)->integer;
+
+	if (override_physics == -1)
+	{
+		if (deathmatch->integer && st.was_key_specified("physics_flags_dm"))
+			override_physics = st.physics_flags_dm;
+		else if (!deathmatch->integer && st.was_key_specified("physics_flags_sp"))
+			override_physics = st.physics_flags_sp;
+	}
+
+	if (override_physics >= 0)
+		pm_config.physics_flags = (physics_flags_t) override_physics;
+	else
+	{
+		if (level.is_n64)
+			pm_config.physics_flags |= PHYSICS_N64_MOVEMENT;
+
+		if (level.is_psx)
+			pm_config.physics_flags |= PHYSICS_PSX_MOVEMENT | PHYSICS_PSX_SCALE;
+
+		if (deathmatch->integer)
+			pm_config.physics_flags |= PHYSICS_DEATHMATCH;
+	}
+
+	gi.configstring(CONFIG_PHYSICS_FLAGS, G_Fmt("{}", (int) pm_config.physics_flags).data());
+	
+	level.primary_objective_string = "$g_primary_mission_objective";
+	level.secondary_objective_string = "$g_secondary_mission_objective";
+
+	if (st.primary_objective_string && st.primary_objective_string[0])
+		level.primary_objective_string = st.primary_objective_string;
+	if (st.secondary_objective_string && st.secondary_objective_string[0])
+		level.secondary_objective_string = st.secondary_objective_string;
+	
+	level.primary_objective_title = "$g_pc_primary_objective";
+	level.secondary_objective_title = "$g_pc_secondary_objective";
+
+	if (st.primary_objective_title && st.primary_objective_title[0])
+		level.primary_objective_title = st.primary_objective_title;
+	if (st.secondary_objective_title && st.secondary_objective_title[0])
+		level.secondary_objective_title = st.secondary_objective_title;
 
 	// statusbar prog
 	G_InitStatusbar();
@@ -1634,6 +2144,10 @@
 	gi.soundindex("player/wade2.wav");
 	gi.soundindex("player/wade3.wav");
 
+	gi.soundindex("player/breathout1.wav");
+	gi.soundindex("player/breathout2.wav");
+	gi.soundindex("player/breathout3.wav");
+
 	gi.soundindex("items/pkup.wav");   // bonus item pickup
 	gi.soundindex("world/land.wav");   // landing thud
 	gi.soundindex("misc/h2ohit1.wav"); // landing splash
--- a/g_target.cpp	2023-10-03 19:43:06
+++ b/g_target.cpp	2025-09-04 19:53:48
@@ -70,6 +70,8 @@
 
 void SP_target_speaker(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!st.noise)
 	{
 		gi.Com_PrintFmt("{}: no noise set\n", *ent);
@@ -154,6 +156,8 @@
 */
 void SP_target_help(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{ // auto-remove for deathmatch
 		G_FreeEdict(ent);
@@ -204,6 +208,8 @@
 
 void SP_target_secret(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{ // auto-remove for deathmatch
 		G_FreeEdict(ent);
@@ -215,8 +221,9 @@
 
 	ent->use = use_target_secret;
 	if (!st.noise)
-		st.noise = "misc/secret.wav";
-	ent->noise_index = gi.soundindex(st.noise);
+		ent->noise_index = gi.soundindex("misc/secret.wav");
+	else
+		ent->noise_index = gi.soundindex(st.noise);
 	ent->svflags = SVF_NOCLIENT;
 	level.total_secrets++;
 }
@@ -285,7 +292,7 @@
 
 		if (*game.helpmessage1)
 			// [Sam-KEX] Print objective to screen
-			gi.LocClient_Print(player, PRINT_TYPEWRITER, "$g_primary_mission_objective", game.helpmessage1);
+			gi.LocClient_Print(player, PRINT_TYPEWRITER, level.primary_objective_string, game.helpmessage1);
 	}
 	
 	if (player->client->pers.game_help2changed != game.help2changed)
@@ -296,7 +303,7 @@
 
 		if (*game.helpmessage2)
 			// [Sam-KEX] Print objective to screen
-			gi.LocClient_Print(player, PRINT_TYPEWRITER, "$g_secondary_mission_objective", game.helpmessage2);
+			gi.LocClient_Print(player, PRINT_TYPEWRITER, level.secondary_objective_string, game.helpmessage2);
 	}
 }
 
@@ -336,6 +343,8 @@
 
 void SP_target_goal(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{ // auto-remove for deathmatch
 		G_FreeEdict(ent);
@@ -344,8 +353,9 @@
 
 	ent->use = use_target_goal;
 	if (!st.noise)
-		st.noise = "misc/secret.wav";
-	ent->noise_index = gi.soundindex(st.noise);
+		ent->noise_index = gi.soundindex("misc/secret.wav");
+	else
+		ent->noise_index = gi.soundindex(st.noise);
 	ent->svflags = SVF_NOCLIENT;
 	level.total_goals++;
 }
@@ -537,20 +547,16 @@
 	speed how fast it should be moving otherwise it
 	will just be dropped
 */
-void ED_CallSpawn(edict_t *ent);
 
 USE(use_target_spawner) (edict_t *self, edict_t *other, edict_t *activator) -> void
 {
-	edict_t *ent;
-
-	ent = G_Spawn();
+	edict_t *ent = G_Spawn();
 	ent->classname = self->target;
 	// RAFAEL
 	ent->flags = self->flags;
 	// RAFAEL
 	ent->s.origin = self->s.origin;
 	ent->s.angles = self->s.angles;
-	st = {};
 
 	// [Paril-KEX] although I fixed these in our maps, this is just
 	// in case anybody else does this by accident. Don't count these monsters
@@ -560,7 +566,9 @@
 	ED_CallSpawn(ent);
 	gi.linkentity(ent);
 
-	KillBox(ent, false);
+	if (ent->solid == SOLID_BBOX || (G_GetClipMask(ent) & (CONTENTS_PLAYER)))
+		KillBox(ent, false);
+
 	if (self->speed)
 		ent->velocity = self->movedir;
 
@@ -697,7 +705,12 @@
 		if (self->dmg > 0 && (tr.ent->takedamage) && !(tr.ent->flags & FL_IMMUNE_LASER) && self->damage_debounce_time <= level.time)
 		{
 			damaged_thing = true;
-			T_Damage(tr.ent, self, self->activator, self->movedir, tr.endpos, vec3_origin, self->dmg, 1, DAMAGE_ENERGY, MOD_TARGET_LASER);
+			damageflags_t dmg = DAMAGE_ENERGY;
+
+			if (self->spawnflags.has(SPAWNFLAG_LASER_NO_PROTECTION))
+				dmg |= DAMAGE_NO_PROTECTION;
+
+			T_Damage(tr.ent, self, self->activator, self->movedir, tr.endpos, vec3_origin, self->dmg, 1, dmg, MOD_TARGET_LASER);
 		}
 
 		// if we hit something that's not a monster or player or is immune to lasers, we're done
@@ -756,6 +769,9 @@
 
 	contents_t mask = self->spawnflags.has(SPAWNFLAG_LASER_STOPWINDOW) ? MASK_SHOT : (CONTENTS_SOLID | CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_DEADMONSTER);
 
+	if (!self->dmg)
+		mask &= ~(CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_DEADMONSTER);
+
 	pierce_trace(start, end, self, args, mask);
 
 	self->s.old_origin = args.tr.endpos;
@@ -814,22 +830,9 @@
 		}
 	}
 
-	if (self->spawnflags.has(SPAWNFLAG_LASER_LIGHTNING))
-	{
-		self->s.renderfx |= RF_BEAM_LIGHTNING; // tell renderer it is lightning
-
-		if (!self->s.skinnum)
-			self->s.skinnum = 0xf3f3f1f1; // default lightning color
-	}
-
-	// set the beam diameter
-	// [Paril-KEX] lab has this set prob before lightning was implemented
-	if (!level.is_n64 && self->spawnflags.has(SPAWNFLAG_LASER_FAT))
-		self->s.frame = 16;
-	else
-		self->s.frame = 4;
-
 	// set the color
+	// [Paril-KEX] moved it here so that color takes place
+	// before lightning/reactor check
 	if (!self->s.skinnum)
 	{
 		if (self->spawnflags.has(SPAWNFLAG_LASER_RED))
@@ -844,6 +847,26 @@
 			self->s.skinnum = 0xe0e1e2e3;
 	}
 
+	if (self->spawnflags.has(SPAWNFLAG_LASER_REACTOR))
+		self->spawnflags |= SPAWNFLAG_LASER_LIGHTNING;
+
+	if (self->spawnflags.has(SPAWNFLAG_LASER_LIGHTNING))
+	{
+		self->s.renderfx |= RF_BEAM_LIGHTNING; // tell renderer it is lightning
+
+		if (!self->s.skinnum)
+			self->s.skinnum = 0xf3f3f1f1; // default lightning color
+	}
+	/*
+	else if (self->spawnflags.has(SPAWNFLAG_LASER_REACTOR))
+	{
+		self->s.renderfx |= RF_BEAM_REACTOR;
+
+		if (!self->s.skinnum)
+			self->s.skinnum = 0xf3f3f1f1; // default reactor color
+	}
+	*/
+
 	if (!self->enemy)
 	{
 		if (self->target)
@@ -869,9 +892,6 @@
 	self->use = target_laser_use;
 	self->think = target_laser_think;
 
-	if (!self->dmg)
-		self->dmg = 1;
-
 	self->mins = { -8, -8, -8 };
 	self->maxs = { 8, 8, 8 };
 	gi.linkentity(self);
@@ -884,6 +904,33 @@
 
 void SP_target_laser(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
+	// set the beam diameter
+	// [Paril-KEX] lab has this set prob before lightning was implemented
+	// [Paril-KEX] moved this here because st
+	if (!st.was_key_specified("frame"))
+	{
+		if (!level.is_n64 && self->spawnflags.has(SPAWNFLAG_LASER_FAT))
+			self->s.frame = 16;
+		else
+			self->s.frame = 4;
+	}
+
+	// [Paril-KEX] upper 2 bytes of reactor laser are count
+	/*
+	if (self->spawnflags.has(SPAWNFLAG_LASER_REACTOR))
+	{
+		self->s.frame &= 0xFFFF;
+
+		self->s.frame |= (self->count << 16) & 0xFFFF0000;
+	}
+	*/
+
+	// [Paril-KEX] moved this here because st
+	if (!st.was_key_specified("dmg"))
+		self->dmg = 1;
+
 	// let everything else get spawned before we start firing
 	self->think = target_laser_start;
 	self->flags |= FL_TRAP_LASER_FIELD;
@@ -1249,17 +1296,16 @@
     self->nextthink = level.time + FRAME_TIME_S;
 }
 
-void G_SetClientFrame(edict_t *ent);
-
-extern float xyspeed;
-
 THINK(target_camera_dummy_think) (edict_t *self) -> void
 {
 	// bit of a hack, but this will let the dummy
 	// move like a player
 	self->client = self->owner->client;
-	xyspeed = sqrtf(self->velocity[0] * self->velocity[0] + self->velocity[1] * self->velocity[1]);
-	G_SetClientFrame(self);
+
+	step_parameters_t step {};
+	step.xyspeed = sqrtf(self->velocity[0] * self->velocity[0] + self->velocity[1] * self->velocity[1]);
+	G_SetClientFrame(self, step);
+
 	self->client = nullptr;
 
 	// alpha fade out for voops
@@ -1376,6 +1422,8 @@
 
 void SP_target_gravity(edict_t* self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->use = use_target_gravity;
 	self->gravity = atof(st.gravity);
 }
@@ -1397,6 +1445,8 @@
 
 void SP_target_soundfx(edict_t* self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!self->volume)
 		self->volume = 1.0;
 
@@ -1529,6 +1579,8 @@
 
 void SP_target_light(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->s.modelindex = 1;
 	self->s.renderfx = RF_CUSTOM_LIGHT;
 	self->s.frame = st.radius ? st.radius : 150;
@@ -1622,19 +1674,35 @@
 
 USE(target_poi_use) (edict_t *ent, edict_t *other, edict_t *activator) -> void
 {
+	bool debug = !!g_debug_poi->integer;
+
+	if (debug)
+		gi.Com_PrintFmt("POI {} used by {}\n", *ent, *other);
+
 	// we were disabled, so remove the disable check
 	if (ent->spawnflags.has(SPAWNFLAG_POI_DISABLED))
+	{
 		ent->spawnflags &= ~SPAWNFLAG_POI_DISABLED;
+		if (debug)
+			gi.Com_Print(" - POI was disabled, made re-enabled\n");
+	}
 
 	// early stage check
 	if (ent->count && level.current_poi_stage > ent->count)
-		return;
+	{
+		if (debug)
+			gi.Com_PrintFmt(" - POI count is {}, current stage {}, early exit\n", ent->count, level.current_poi_stage);
+		return;
+	}
 
 	// teamed POIs work a bit differently
 	if (ent->team)
 	{
 		edict_t *poi_master = ent->teammaster;
 
+		if (debug)
+			gi.Com_PrintFmt(" - teamed POI \"{}\"; master is {}\n", ent->team, *poi_master);
+
 		// unset ent, since we need to find one that matches
 		ent = nullptr;
 
@@ -1645,42 +1713,79 @@
 
 		for (edict_t *poi = poi_master; poi; poi = poi->teamchain)
 		{
+			if (debug)
+				gi.Com_PrintFmt("  - checking team member {}\n", *poi);
+
 			// currently disabled
 			if (poi->spawnflags.has(SPAWNFLAG_POI_DISABLED))
+			{
+				if (debug)
+					gi.Com_Print("  - disabled, skipping\n");
+
 				continue;
+			}
 
 			// ignore dummy POI
 			if (poi->spawnflags.has(SPAWNFLAG_POI_DUMMY))
 			{
+				if (debug)
+					gi.Com_Print("  - dummy, skipping (but storing as fallback)\n");
+
 				dummy_fallback = poi;
 				continue;
 			}
 			// POI is not part of current stage
 			else if (poi->count && level.current_poi_stage > poi->count)
+			{
+				if (debug)
+					gi.Com_PrintFmt("  - staged POI; level stage {} = POI count {}, skipping\n", level.current_poi_stage, poi->count);
+
 				continue;
 			// POI isn't the right style
+			}
 			else if (poi->style > best_style)
+			{
+				if (debug)
+					gi.Com_PrintFmt("  - style {} > current best style {}, skipping\n", poi->style, best_style);
+
 				continue;
+			}
 
 			float dist = distance_to_poi(activator->s.origin, poi->s.origin);
+
+			if (debug)
+				gi.Com_PrintFmt("  - resolved distance as {} (used for nearest)\n", dist);
 
 			// we have one already and it's farther away, don't bother
 			if (poi_master->spawnflags.has(SPAWNFLAG_POI_NEAREST) &&
 				ent &&
 				dist > best_distance)
+			{
+				if (debug)
+					gi.Com_PrintFmt("  - nearest used; distance > best distance of {}, skipping\n", best_distance);
 				continue;
+			}
 
 			// found a better style; overwrite dist
 			if (poi->style < best_style)
 			{
+				if (debug)
+					gi.Com_PrintFmt("  - style {} < current best style {} - potentially better pick\n", poi->style, best_style);
+
 				// unless we weren't reachable...
 				if (poi_master->spawnflags.has(SPAWNFLAG_POI_NEAREST) && std::isinf(dist))
+				{
+					if (debug)
+						gi.Com_Print("  - not reachable; skipped\n");
 					continue;
+				}
 
 				best_style = poi->style;
 				if (poi_master->spawnflags.has(SPAWNFLAG_POI_NEAREST))
 					best_distance = dist;
 				ent = poi;
+				if (debug)
+					gi.Com_Print("  - marked as current best due to style\n");
 				continue;
 			}
 
@@ -1691,6 +1796,8 @@
 				{
 					best_distance = dist;
 					ent = poi;
+					if (debug)
+						gi.Com_Print("  - marked as current best due to distance\n");
 					continue;
 				}
 			}
@@ -1698,6 +1805,8 @@
 			{
 				// not picking by distance, so it's order of appearance
 				ent = poi;
+				if (debug)
+					gi.Com_Print("  - marked as current best due to order of appearance\n");
 			}
 		}
 
@@ -1706,36 +1815,66 @@
 		if (!ent)
 		{
 			if (dummy_fallback && dummy_fallback->spawnflags.has(SPAWNFLAG_POI_DYNAMIC))
+			{
+				if (debug)
+					gi.Com_Print(" - no valid POI found, but we had a dummy fallback\n");
 				ent = dummy_fallback;
+			}
 			else
+			{
+				if (debug)
+					gi.Com_Print(" - no valid POI found, skipping\n");
 				return;
+			}
 		}
 
 		// copy over POI stage value
 		if (ent->count)
 		{
 			if (level.current_poi_stage <= ent->count)
+			{
 				level.current_poi_stage = ent->count;
+				if (debug)
+					gi.Com_PrintFmt(" - current POI stage set to {}\n", ent->count);
+			}
 		}
 	}
 	else
 	{
+		if (debug)
+			gi.Com_Print(" - non-teamed POI\n");
+
 		if (ent->count)
 		{
 			if (level.current_poi_stage <= ent->count)
+			{
 				level.current_poi_stage = ent->count;
+				if (debug)
+					gi.Com_PrintFmt(" - level stage {} <= POI count {}, using new stage value\n", level.current_poi_stage, ent->count);
+			}
 			else
+			{
+				if (debug)
+					gi.Com_PrintFmt(" - level stage {} <= POI count {}, not part of current stage, skipping\n", level.current_poi_stage, ent->count);
 				return; // this POI is not part of our current stage
+			}
 		}
 	}
 
 	// dummy POI; not valid
 	if (!strcmp(ent->classname, "target_poi") && ent->spawnflags.has(SPAWNFLAG_POI_DUMMY) && !ent->spawnflags.has(SPAWNFLAG_POI_DYNAMIC))
-		return;
+	{
+		if (debug)
+			gi.Com_Print(" - POI is target_poi, dummy & not dynamic; not a valid POI\n");
+		return;
+	}
 
 	level.valid_poi = true;
 	level.current_poi = ent->s.origin;
 	level.current_poi_image = ent->noise_index;
+	
+	if (debug)
+		gi.Com_Print(" - got valid POI!\n");
 
 	if (!strcmp(ent->classname, "target_poi") && ent->spawnflags.has(SPAWNFLAG_POI_DYNAMIC))
 	{
@@ -1748,11 +1887,13 @@
 			if (m->spawnflags.has(SPAWNFLAG_POI_DUMMY))
 			{
 				level.current_dynamic_poi = m;
+				if (debug)
+					gi.Com_Print(" - setting dynamic POI\n");
 				break;
 			}
 
 		if (!level.current_dynamic_poi)
-			gi.Com_PrintFmt("can't activate poi for {}; need DUMMY in chain\n", *ent);
+			gi.Com_PrintFmt("can't activate dynamic poi for {}; need DUMMY in chain\n", *ent);
 	}
 	else
 		level.current_dynamic_poi = nullptr;
@@ -1777,6 +1918,8 @@
 
 void SP_target_poi(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{ // auto-remove for deathmatch
 		G_FreeEdict(self);
@@ -1957,6 +2100,8 @@
 
 void SP_target_sky(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->use = use_target_sky;
 	if (st.was_key_specified("sky"))
 		self->map = st.sky;
@@ -2045,6 +2190,8 @@
 
 void SP_target_achievement(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{
 		G_FreeEdict(self);
--- a/g_trigger.cpp	2023-10-03 19:43:06
+++ b/g_trigger.cpp	2025-09-04 19:53:48
@@ -13,6 +13,8 @@
 
 void InitTrigger(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (st.was_key_specified("angle") || st.was_key_specified("angles") || self->s.angles)
 		G_SetMovedir(self->s.angles, self->movedir);
 
@@ -176,7 +178,12 @@
 
 void SP_trigger_multiple(edict_t *ent)
 {
-	if (ent->sounds == 1)
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
+	// [Paril-KEX] PSX
+	if (st.noise && *st.noise)
+		ent->noise_index = gi.soundindex(st.noise);
+	else if (ent->sounds == 1)
 		ent->noise_index = gi.soundindex("misc/secret.wav");
 	else if (ent->sounds == 2)
 		ent->noise_index = gi.soundindex("misc/talk.wav");
@@ -198,7 +205,7 @@
 		ent->use = Use_Multi;
 		return;
 	}
-	else
+	else if (ent->model || ent->mins || ent->maxs)
 		ent->touch = Touch_Multi;
 
 	// PGM
@@ -278,6 +285,8 @@
 
 ==============================================================================
 */
+
+constexpr spawnflags_t SPAWNFLAGS_TRIGGER_KEY_BECOME_RELAY = 1_spawnflag;
 
 /*QUAKED trigger_key (.5 .5 .5) (-8 -8 -8) (8 8 8)
 A relay trigger that only fires it's targets if player has the proper key.
@@ -362,11 +371,16 @@
 
 	G_UseTargets(self, activator);
 
-	self->use = nullptr;
+	if (self->spawnflags.has(SPAWNFLAGS_TRIGGER_KEY_BECOME_RELAY))
+		self->use = trigger_relay_use;
+	else
+		self->use = nullptr;
 }
 
 void SP_trigger_key(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!st.item)
 	{
 		gi.Com_PrintFmt("{}: no key item\n", *self);
@@ -478,6 +492,7 @@
 constexpr spawnflags_t SPAWNFLAG_PUSH_SILENT = 0x04_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_PUSH_START_OFF = 0x08_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_PUSH_CLIP = 0x10_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_PUSH_ADDITIVE = 0x20_spawnflag;
 // PGM
 
 static cached_soundindex windsound;
@@ -492,13 +507,23 @@
 			return;
 	}
 
-	if (strcmp(other->classname, "grenade") == 0)
-	{
-		other->velocity = self->movedir * (self->speed * 10);
-	}
-	else if (other->health > 0)
-	{
-		other->velocity = self->movedir * (self->speed * 10);
+	if (strcmp(other->classname, "grenade") == 0 || other->health > 0)
+	{
+		// [Paril-KEX]
+		if (self->spawnflags.has(SPAWNFLAG_PUSH_ADDITIVE))
+		{
+			vec3_t velocity_in_dir = other->velocity.scaled(self->movedir);
+			float max_speed = (self->speed * 10);
+
+			if (velocity_in_dir.normalized().dot(self->movedir) < 0 || velocity_in_dir.length() < max_speed)
+			{
+				float speed_adjust = (max_speed * gi.frame_time_s) * 2;
+				other->velocity += self->movedir * speed_adjust;
+				other->no_gravity_time = level.time + 100_ms;
+			}
+		}
+		else
+			other->velocity = self->movedir * (self->speed * 10);
 
 		if (other->client)
 		{
@@ -650,7 +675,7 @@
 ==============================================================================
 */
 
-/*QUAKED trigger_hurt (.5 .5 .5) ? START_OFF TOGGLE SILENT NO_PROTECTION SLOW NO_PLAYERS NO_MONSTERS
+/*QUAKED trigger_hurt (.5 .5 .5) ? START_OFF TOGGLE SILENT NO_PROTECTION SLOW NO_PLAYERS NO_MONSTERS PASSIVE
 Any entity that touches this will be hurt.
 
 It does dmg points of damage each server frame
@@ -671,6 +696,7 @@
 constexpr spawnflags_t SPAWNFLAG_HURT_NO_PLAYERS = 32_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_HURT_NO_MONSTERS = 64_spawnflag;
 constexpr spawnflags_t SPAWNFLAG_HURT_CLIPPED = 128_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_HURT_PASSIVE = 16_spawnflag_bit;
 
 USE(hurt_use) (edict_t *self, edict_t *other, edict_t *activator) -> void
 {
@@ -682,12 +708,87 @@
 
 	if (!(self->spawnflags & SPAWNFLAG_HURT_TOGGLE))
 		self->use = nullptr;
+
+	if (self->spawnflags.has(SPAWNFLAG_HURT_PASSIVE))
+	{
+		if (self->solid == SOLID_TRIGGER)
+		{
+			if (self->spawnflags.has(SPAWNFLAG_HURT_SLOW))
+				self->nextthink = level.time + 1_sec;
+			else
+				self->nextthink = level.time + 10_hz;
+		}
+		else
+			self->nextthink = 0_ms;
+	}
+}
+
+struct hurt_filter_data_t
+{
+	edict_t *self;
+	std::vector<edict_t *> hurt;
+};
+
+static BoxEdictsResult_t hurt_filter(edict_t *other, void *self_ptr)
+{
+	hurt_filter_data_t *data = (hurt_filter_data_t *) self_ptr;
+	edict_t *self = data->self;
+
+	if (!other->takedamage)
+		return BoxEdictsResult_t::Skip;
+	else if (!(other->svflags & SVF_MONSTER) && !(other->flags & FL_DAMAGEABLE) && (!other->client) && (strcmp(other->classname, "misc_explobox") != 0))
+		return BoxEdictsResult_t::Skip;
+	else if (self->spawnflags.has(SPAWNFLAG_HURT_NO_MONSTERS) && (other->svflags & SVF_MONSTER))
+		return BoxEdictsResult_t::Skip;
+	else if (self->spawnflags.has(SPAWNFLAG_HURT_NO_PLAYERS) && (other->client))
+		return BoxEdictsResult_t::Skip;
+
+	if (self->spawnflags.has(SPAWNFLAG_HURT_CLIPPED))
+	{
+		trace_t clip = gi.clip(self, other->s.origin, other->mins, other->maxs, other->s.origin, G_GetClipMask(other));
+
+		if (clip.fraction == 1.0f)
+			return BoxEdictsResult_t::Skip;
+	}
+
+	data->hurt.push_back(other);
+	return BoxEdictsResult_t::Skip;
+}
+
+THINK(hurt_think) (edict_t *self) -> void
+{
+	hurt_filter_data_t data { self };
+	gi.BoxEdicts(self->absmin, self->absmax, nullptr, 0, AREA_SOLID, hurt_filter, &data);
+	
+	damageflags_t dflags;
+
+	if (self->spawnflags.has(SPAWNFLAG_HURT_NO_PROTECTION))
+		dflags = DAMAGE_NO_PROTECTION;
+	else
+		dflags = DAMAGE_NONE;
+
+	for (auto &other : data.hurt)
+	{
+		if (!(self->spawnflags & SPAWNFLAG_HURT_SILENT))
+		{
+			if (self->fly_sound_debounce_time < level.time)
+			{
+				gi.sound(other, CHAN_AUTO, self->noise_index, 1, ATTN_NORM, 0);
+				self->fly_sound_debounce_time = level.time + 1_sec;
+			}
+		}
+
+		T_Damage(other, self, self, vec3_origin, other->s.origin, vec3_origin, self->dmg, self->dmg, dflags, MOD_TRIGGER_HURT);
+	}
+
+	if (self->spawnflags.has(SPAWNFLAG_HURT_SLOW))
+		self->nextthink = level.time + 1_sec;
+	else
+		self->nextthink = level.time + 10_hz;
 }
 
 TOUCH(hurt_touch) (edict_t *self, edict_t *other, const trace_t &tr, bool other_touching_self) -> void
 {
-	damageflags_t dflags;
-
 	if (!other->takedamage)
 		return;
 	else if (!(other->svflags & SVF_MONSTER) && !(other->flags & FL_DAMAGEABLE) && (!other->client) && (strcmp(other->classname, "misc_explobox") != 0))
@@ -722,6 +823,8 @@
 		}
 	}
 
+	damageflags_t dflags;
+
 	if (self->spawnflags.has(SPAWNFLAG_HURT_NO_PROTECTION))
 		dflags = DAMAGE_NO_PROTECTION;
 	else
@@ -735,7 +838,21 @@
 	InitTrigger(self);
 
 	self->noise_index = gi.soundindex("world/electro.wav");
-	self->touch = hurt_touch;
+
+	if (self->spawnflags.has(SPAWNFLAG_HURT_PASSIVE))
+	{
+		self->think = hurt_think;
+
+		if (!self->spawnflags.has(SPAWNFLAG_HURT_START_OFF))
+		{
+			if (self->spawnflags.has(SPAWNFLAG_HURT_SLOW))
+				self->nextthink = level.time + 1_sec;
+			else
+				self->nextthink = level.time + 10_hz;
+		}
+	}
+	else
+		self->touch = hurt_touch;
 
 	if (!self->dmg)
 		self->dmg = 5;
@@ -800,6 +917,8 @@
 
 void SP_trigger_gravity(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!st.gravity || !*st.gravity)
 	{
 		gi.Com_PrintFmt("{}: no gravity set\n", *self);
@@ -890,15 +1009,18 @@
 
 void SP_trigger_monsterjump(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!self->speed)
 		self->speed = 200;
-	if (!st.height)
-		st.height = 200;
+	float height = st.height;
+	if (!height)
+		height = 200;
 	if (self->s.angles[YAW] == 0)
 		self->s.angles[YAW] = 360;
 	InitTrigger(self);
 	self->touch = trigger_monsterjump_touch;
-	self->movedir[2] = (float) st.height;
+	self->movedir[2] = height;
 
 	if (self->spawnflags.has(SPAWNFLAG_MONSTERJUMP_TOGGLE))
 		self->use = trigger_monsterjump_use;
@@ -961,11 +1083,13 @@
 
 void SP_trigger_flashlight(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (self->s.angles[YAW] == 0)
 		self->s.angles[YAW] = 360;
 	InitTrigger(self);
 	self->touch = trigger_flashlight_touch;
-	self->movedir[2] = (float) st.height;
+	self->movedir[2] = st.height;
 
 	if (self->spawnflags.has(SPAWNFLAG_FLASHLIGHT_CLIPPED))
 		self->svflags |= SVF_HULL;
@@ -1331,3 +1455,25 @@
 	self->svflags |= SVF_NOCLIENT;
 	gi.linkentity(self);
 }
+
+/*QUAKED trigger_safe_fall (.5 .5 .5) ?
+Players that touch this trigger are granted one (1)
+free safe fall damage exemption.
+
+They must already be in the air to get this ability.
+*/
+
+TOUCH(trigger_safe_fall_touch) (edict_t *self, edict_t *other, const trace_t &tr, bool other_touching_self) -> void
+{
+	if (other->client && !other->groundentity)
+		other->client->landmark_free_fall = true;
+}
+
+void SP_trigger_safe_fall(edict_t *self)
+{
+	InitTrigger(self);
+	self->touch = trigger_safe_fall_touch;
+	self->svflags |= SVF_NOCLIENT;
+	self->solid = SOLID_TRIGGER;
+	gi.linkentity(self);
+}
--- a/g_turret.cpp	2023-10-03 19:43:06
+++ b/g_turret.cpp	2025-09-04 19:53:48
@@ -217,6 +217,8 @@
 
 void SP_turret_breach(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->solid = SOLID_BSP;
 	self->movetype = MOVETYPE_PUSH;
 
@@ -230,17 +232,21 @@
 	if (!self->dmg)
 		self->dmg = 10;
 
-	if (!st.minpitch)
-		st.minpitch = -30;
-	if (!st.maxpitch)
-		st.maxpitch = 30;
-	if (!st.maxyaw)
-		st.maxyaw = 360;
-
-	self->pos1[PITCH] = -1 * st.minpitch;
+	float minpitch = st.minpitch;
+	float maxpitch = st.maxpitch;
+	float maxyaw = st.maxyaw;
+
+	if (!minpitch)
+		minpitch = -30;
+	if (!maxpitch)
+		maxpitch = 30;
+	if (!maxyaw)
+		maxyaw = 360;
+
+	self->pos1[PITCH] = -1 * minpitch;
 	self->pos1[YAW] = st.minyaw;
-	self->pos2[PITCH] = -1 * st.maxpitch;
-	self->pos2[YAW] = st.maxyaw;
+	self->pos2[PITCH] = -1 * maxpitch;
+	self->pos2[YAW] = maxyaw;
 
 	// scale used for rocket scale
 	self->dmg_radius = self->s.scale;
@@ -263,6 +269,8 @@
 
 void SP_turret_base(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	self->solid = SOLID_BSP;
 	self->movetype = MOVETYPE_PUSH;
 
@@ -310,6 +318,7 @@
 		self->movetype = MOVETYPE_STEP;
 
 		self->think = monster_think;
+		self->classname = "monster_infantry"; // [Paril-KEX] fix revive
 	}
 
 	infantry_die(self, inflictor, attacker, damage, point, mod);
@@ -412,6 +421,8 @@
 
 void SP_turret_driver(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (deathmatch->integer)
 	{
 		G_FreeEdict(self);
--- a/g_utils.cpp	2023-10-03 19:43:06
+++ b/g_utils.cpp	2025-09-04 19:53:48
@@ -508,7 +508,7 @@
 	return BoxEdictsResult_t::Keep;
 }
 
-bool KillBox(edict_t *ent, bool from_spawning, mod_id_t mod, bool bsp_clipping)
+bool KillBox(edict_t *ent, bool from_spawning, mod_id_t mod, bool bsp_clipping, bool allow_safety)
 {
 	// don't telefrag as spectator...
 	if (ent->movetype == MOVETYPE_NOCLIP)
@@ -555,6 +555,9 @@
 			continue;
 		}
 
+		if (allow_safety && G_FixStuckObject(hit, hit->s.origin) != stuck_result_t::NO_GOOD_POSITION)
+			continue;
+
 		T_Damage(hit, ent, ent, vec3_origin, ent->s.origin, vec3_origin, 100000, 0, DAMAGE_NO_PROTECTION, mod);
 	}
 
--- a/g_weapon.cpp	2023-10-03 19:43:06
+++ b/g_weapon.cpp	2025-09-04 19:53:48
@@ -379,7 +379,7 @@
 	G_FreeEdict(self);
 }
 
-void fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed, effects_t effect, mod_t mod)
+edict_t *fire_blaster(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed, effects_t effect, mod_t mod)
 {
 	edict_t *bolt;
 	trace_t	 tr;
@@ -415,6 +415,8 @@
 		bolt->s.origin = tr.endpos + (tr.plane.normal * 1.f);
 		bolt->touch(bolt, tr.ent, tr, false);
 	}
+
+	return bolt;
 }
 
 constexpr spawnflags_t SPAWNFLAG_GRENADE_HAND = 1_spawnflag;
@@ -425,7 +427,7 @@
 fire_grenade
 =================
 */
-THINK(Grenade_Explode) (edict_t *ent) -> void
+static void Grenade_ExplodeReal(edict_t *ent, edict_t *other, vec3_t normal)
 {
 	vec3_t origin;
 	mod_t  mod;
@@ -434,22 +436,14 @@
 		PlayerNoise(ent->owner, ent->s.origin, PNOISE_IMPACT);
 
 	// FIXME: if we are onground then raise our Z just a bit since we are a point?
-	if (ent->enemy)
-	{
-		float  points;
-		vec3_t v;
-		vec3_t dir;
-
-		v = ent->enemy->mins + ent->enemy->maxs;
-		v = ent->enemy->s.origin + (v * 0.5f);
-		v = ent->s.origin - v;
-		points = ent->dmg - 0.5f * v.length();
-		dir = ent->enemy->s.origin - ent->s.origin;
+	if (other)
+	{
+		vec3_t dir = other->s.origin - ent->s.origin;
 		if (ent->spawnflags.has(SPAWNFLAG_GRENADE_HAND))
 			mod = MOD_HANDGRENADE;
 		else
 			mod = MOD_GRENADE;
-		T_Damage(ent->enemy, ent, ent->owner, dir, ent->s.origin, vec3_origin, (int) points, (int) points, DAMAGE_RADIUS, mod);
+		T_Damage(other, ent, ent->owner, dir, ent->s.origin, normal, ent->dmg, ent->dmg, mod.id == MOD_HANDGRENADE ? DAMAGE_RADIUS : DAMAGE_NONE, mod);
 	}
 
 	if (ent->spawnflags.has(SPAWNFLAG_GRENADE_HELD))
@@ -458,9 +452,9 @@
 		mod = MOD_HG_SPLASH;
 	else
 		mod = MOD_G_SPLASH;
-	T_RadiusDamage(ent, ent->owner, (float) ent->dmg, ent->enemy, ent->dmg_radius, DAMAGE_NONE, mod);
-
-	origin = ent->s.origin + (ent->velocity * -0.02f);
+	T_RadiusDamage(ent, ent->owner, (float) ent->dmg, other, ent->dmg_radius, DAMAGE_NONE, mod);
+
+	origin = ent->s.origin + normal;
 	gi.WriteByte(svc_temp_entity);
 	if (ent->waterlevel)
 	{
@@ -480,6 +474,11 @@
 	gi.multicast(ent->s.origin, MULTICAST_PHS, false);
 
 	G_FreeEdict(ent);
+}
+
+THINK(Grenade_Explode) (edict_t *ent) -> void
+{
+	Grenade_ExplodeReal(ent, nullptr, ent->velocity * -0.02f);
 }
 
 TOUCH(Grenade_Touch) (edict_t *ent, edict_t *other, const trace_t &tr, bool other_touching_self) -> void
@@ -509,8 +508,7 @@
 		return;
 	}
 
-	ent->enemy = other;
-	Grenade_Explode(ent);
+	Grenade_ExplodeReal(ent, other, tr.plane.normal);
 }
 
 THINK(Grenade4_Think) (edict_t *self) -> void
@@ -669,7 +667,7 @@
 
 	if (other->takedamage)
 	{
-		T_Damage(other, ent, ent->owner, ent->velocity, ent->s.origin, tr.plane.normal, ent->dmg, 0, DAMAGE_NONE, MOD_ROCKET);
+		T_Damage(other, ent, ent->owner, ent->velocity, ent->s.origin, tr.plane.normal, ent->dmg, ent->dmg, DAMAGE_NONE, MOD_ROCKET);
 	}
 	else
 	{
@@ -832,7 +830,7 @@
 fire_rail
 =================
 */
-void fire_rail(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick)
+bool fire_rail(edict_t *self, const vec3_t &start, const vec3_t &aimdir, int damage, int kick)
 {
 	fire_rail_pierce_t args = {
 		self,
@@ -872,6 +870,8 @@
 
 	if (self->client)
 		PlayerNoise(self, args.tr.endpos, PNOISE_IMPACT);
+
+	return args.num_pierced;
 }
 
 static vec3_t bfg_laser_pos(vec3_t p, float dist)
@@ -904,7 +904,7 @@
 static void bfg_spawn_laser(edict_t *self)
 {
 	vec3_t end = bfg_laser_pos(self->s.origin, 256);
-	trace_t tr = gi.traceline(self->s.origin, end, self, MASK_OPAQUE);
+	trace_t tr = gi.traceline(self->s.origin, end, self, MASK_OPAQUE | CONTENTS_PROJECTILECLIP);
 
 	if (tr.fraction == 1.0f)
 		return;
@@ -1053,10 +1053,10 @@
 			gi.WriteByte(svc_temp_entity);
 			gi.WriteByte(TE_LASER_SPARKS);
 			gi.WriteByte(4);
-			gi.WritePosition(tr.endpos);
+			gi.WritePosition(tr.endpos + tr.plane.normal);
 			gi.WriteDir(tr.plane.normal);
-			gi.WriteByte(self->s.skinnum);
-			gi.multicast(tr.endpos, MULTICAST_PVS, false);
+			gi.WriteByte(208);
+			gi.multicast(tr.endpos + tr.plane.normal, MULTICAST_PVS, false);
 			return false;
 		}
 
@@ -1114,10 +1114,12 @@
 		end = start + (dir * 2048);
 
 		// [Paril-KEX] don't fire a laser if we're blocked by the world
-		tr = gi.traceline(start, point, nullptr, MASK_SOLID);
+		tr = gi.traceline(start, point, nullptr, CONTENTS_SOLID | CONTENTS_PROJECTILECLIP);
 
 		if (tr.fraction < 1.0f)
 			continue;
+
+		tr = gi.traceline(start, end, nullptr, CONTENTS_SOLID | CONTENTS_PROJECTILECLIP);
 
 		bfg_laser_pierce_t args {
 			self,
@@ -1125,7 +1127,7 @@
 			dmg
 		};
 		
-		pierce_trace(start, end, self, args, CONTENTS_SOLID | CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_DEADMONSTER);
+		pierce_trace(start, end, self, args, CONTENTS_SOLID | CONTENTS_MONSTER | CONTENTS_PLAYER | CONTENTS_DEADMONSTER | CONTENTS_PROJECTILECLIP);
 
 		gi.WriteByte(svc_temp_entity);
 		gi.WriteByte(TE_BFG_LASER);
@@ -1170,48 +1172,3 @@
 
 	gi.linkentity(bfg);
 }
-
-TOUCH(disintegrator_touch) (edict_t *self, edict_t *other, const trace_t &tr, bool other_touching_self) -> void
-{
-	gi.WriteByte(svc_temp_entity);
-	gi.WriteByte(TE_WIDOWSPLASH);
-	gi.WritePosition(self->s.origin - (self->velocity * 0.01f));
-	gi.multicast(self->s.origin, MULTICAST_PHS, false);
-
-	G_FreeEdict(self);
-
-	if (other->svflags & (SVF_MONSTER | SVF_PLAYER))
-	{
-		other->disintegrator_time += 50_sec;
-		other->disintegrator = self->owner;
-	}
-}
-
-void fire_disintegrator(edict_t *self, const vec3_t &start, const vec3_t &forward, int speed)
-{
-	edict_t *bfg;
-
-	bfg = G_Spawn();
-	bfg->s.origin = start;
-	bfg->s.angles = vectoangles(forward);
-	bfg->velocity = forward * speed;
-	bfg->movetype = MOVETYPE_FLYMISSILE;
-	bfg->clipmask = MASK_PROJECTILE;
-	// [Paril-KEX]
-	if (self->client && !G_ShouldPlayersCollide(true))
-		bfg->clipmask &= ~CONTENTS_PLAYER;
-	bfg->solid = SOLID_BBOX;
-	bfg->s.effects |= EF_TAGTRAIL | EF_ANIM_ALL;
-	bfg->s.renderfx |= RF_TRANSLUCENT;
-	bfg->svflags |= SVF_PROJECTILE;
-	bfg->flags |= FL_DODGE;
-	bfg->s.modelindex = gi.modelindex("sprites/s_bfg1.sp2");
-	bfg->owner = self;
-	bfg->touch = disintegrator_touch;
-	bfg->nextthink = level.time + gtime_t::from_sec(8000.f / speed);
-	bfg->think = G_FreeEdict;
-	bfg->classname = "disint ball";
-	bfg->s.sound = gi.soundindex("weapons/bfg__l1a.wav");
-
-	gi.linkentity(bfg);
-}
--- a/game.h	2023-10-03 19:43:06
+++ b/game.h	2025-09-04 19:53:48
@@ -19,8 +19,12 @@
     using gvec3_t = float[3];
     using gvec3_ptr_t = gvec3_t;
     using gvec3_ref_t = gvec3_t;
-    using gvec3_cref_t = const gvec3_t;
-    using gvec3_cptr_t = const gvec3_t;
+    // FIXME: MSVC bug
+    //using gvec3_cref_t = const gvec3_t;
+    typedef const gvec3_t gvec3_cref_t;
+    // FIXME: MSVC bug
+    //using gvec3_cptr_t = const gvec3_t;
+    typedef const gvec3_t gvec3_cptr_t;
     using gvec4_t = float[4];
 #endif
     
@@ -388,6 +392,7 @@
     PMF_NO_ANGULAR_PREDICTION = bit_v<8>, // temporary disables angular prediction
     PMF_IGNORE_PLAYER_COLLISION = bit_v<9>, // don't collide with other players
     PMF_TIME_TRICK = bit_v<10>, // pm_time is trick jump time
+    PMF_NO_GROUND_SEEK = bit_v<11>, // temporarily disable ground seeking
 };
 
 MAKE_ENUM_BITFLAGS(pmflags_t);
@@ -612,6 +617,7 @@
 MAKE_ENUM_BITFLAGS(renderfx_t);
 
 constexpr renderfx_t RF_BEAM_LIGHTNING = RF_BEAM | RF_GLOW; // [Paril-KEX] make a lightning bolt instead of a laser
+//constexpr renderfx_t RF_BEAM_REACTOR = RF_BEAM | RF_USE_DISGUISE; // [Paril-KEX] make reactor FX, like PSX version
 
 MAKE_ENUM_BITFLAGS(refdef_flags_t);
 
--- a/game.vcxproj	2023-10-03 19:43:06
+++ /dev/null
@@ -1,246 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <VCProjectVersion>16.0</VCProjectVersion>
-    <Keyword>Win32Proj</Keyword>
-    <ProjectGuid>{c994b5ea-3058-403c-953d-3673c2c4d64e}</ProjectGuid>
-    <RootNamespace>game</RootNamespace>
-    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v143</PlatformToolset>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <UseDebugLibraries>false</UseDebugLibraries>
-    <PlatformToolset>v143</PlatformToolset>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <CharacterSet>Unicode</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Label="Shared">
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <OutDir>../</OutDir>
-    <TargetName>$(ProjectName)_x64</TargetName>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <OutDir>../</OutDir>
-    <TargetName>$(ProjectName)_x64</TargetName>
-  </PropertyGroup>
-  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <VcpkgUseStatic>true</VcpkgUseStatic>
-  </PropertyGroup>
-  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <VcpkgUseStatic>true</VcpkgUseStatic>
-  </PropertyGroup>
-  <PropertyGroup Label="Vcpkg">
-    <VcpkgEnableManifest>true</VcpkgEnableManifest>
-  </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <SDLCheck>true</SDLCheck>
-      <PreprocessorDefinitions>KEX_Q2_GAME;KEX_Q2GAME_EXPORTS;NO_FMT_SOURCE;KEX_Q2GAME_DYNAMIC;_CRT_SECURE_NO_WARNINGS;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <ConformanceMode>true</ConformanceMode>
-      <LanguageStandard>stdcpp17</LanguageStandard>
-      <DisableSpecificWarnings>4267;4244</DisableSpecificWarnings>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
-    </ClCompile>
-    <Link>
-      <SubSystem>NotSet</SubSystem>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <SDLCheck>true</SDLCheck>
-      <PreprocessorDefinitions>KEX_Q2_GAME;KEX_Q2GAME_EXPORTS;NO_FMT_SOURCE;KEX_Q2GAME_DYNAMIC;_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <ConformanceMode>true</ConformanceMode>
-      <LanguageStandard>stdcpp17</LanguageStandard>
-      <DisableSpecificWarnings>4267;4244</DisableSpecificWarnings>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
-    </ClCompile>
-    <Link>
-      <SubSystem>NotSet</SubSystem>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <OptimizeReferences>true</OptimizeReferences>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <ClInclude Include="bg_local.h" />
-    <ClInclude Include="bots\bot_debug.h" />
-    <ClInclude Include="bots\bot_exports.h" />
-    <ClInclude Include="bots\bot_includes.h" />
-    <ClInclude Include="bots\bot_think.h" />
-    <ClInclude Include="bots\bot_utils.h" />
-    <ClInclude Include="cg_local.h" />
-    <ClInclude Include="ctf\g_ctf.h" />
-    <ClInclude Include="ctf\p_ctf_menu.h" />
-    <ClInclude Include="game.h" />
-    <ClInclude Include="g_local.h" />
-    <ClInclude Include="g_statusbar.h" />
-    <ClInclude Include="m_actor.h" />
-    <ClInclude Include="m_arachnid.h" />
-    <ClInclude Include="m_berserk.h" />
-    <ClInclude Include="m_boss2.h" />
-    <ClInclude Include="m_boss31.h" />
-    <ClInclude Include="m_boss32.h" />
-    <ClInclude Include="m_brain.h" />
-    <ClInclude Include="m_chick.h" />
-    <ClInclude Include="m_flash.h" />
-    <ClInclude Include="m_flipper.h" />
-    <ClInclude Include="m_float.h" />
-    <ClInclude Include="m_flyer.h" />
-    <ClInclude Include="m_gladiator.h" />
-    <ClInclude Include="m_guardian.h" />
-    <ClInclude Include="m_gunner.h" />
-    <ClInclude Include="m_hover.h" />
-    <ClInclude Include="m_infantry.h" />
-    <ClInclude Include="m_insane.h" />
-    <ClInclude Include="m_medic.h" />
-    <ClInclude Include="m_mutant.h" />
-    <ClInclude Include="m_parasite.h" />
-    <ClInclude Include="m_player.h" />
-    <ClInclude Include="m_rider.h" />
-    <ClInclude Include="m_shambler.h" />
-    <ClInclude Include="m_soldier.h" />
-    <ClInclude Include="m_supertank.h" />
-    <ClInclude Include="m_tank.h" />
-    <ClInclude Include="q_std.h" />
-    <ClInclude Include="q_vec3.h" />
-    <ClInclude Include="rogue\m_rogue_carrier.h" />
-    <ClInclude Include="rogue\m_rogue_stalker.h" />
-    <ClInclude Include="rogue\m_rogue_turret.h" />
-    <ClInclude Include="rogue\m_rogue_widow.h" />
-    <ClInclude Include="rogue\m_rogue_widow2.h" />
-    <ClInclude Include="xatrix\m_xatrix_fixbot.h" />
-    <ClInclude Include="xatrix\m_xatrix_gekk.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="bots\bot_debug.cpp" />
-    <ClCompile Include="bots\bot_exports.cpp" />
-    <ClCompile Include="bots\bot_think.cpp" />
-    <ClCompile Include="bots\bot_utils.cpp" />
-    <ClCompile Include="cg_main.cpp" />
-    <ClCompile Include="cg_screen.cpp" />
-    <ClCompile Include="ctf\g_ctf.cpp" />
-    <ClCompile Include="ctf\p_ctf_menu.cpp" />
-    <ClCompile Include="g_ai.cpp" />
-    <ClCompile Include="g_chase.cpp" />
-    <ClCompile Include="g_cmds.cpp" />
-    <ClCompile Include="g_combat.cpp" />
-    <ClCompile Include="g_func.cpp" />
-    <ClCompile Include="g_items.cpp" />
-    <ClCompile Include="g_main.cpp" />
-    <ClCompile Include="g_misc.cpp" />
-    <ClCompile Include="g_monster.cpp" />
-    <ClCompile Include="g_phys.cpp" />
-    <ClCompile Include="g_save.cpp" />
-    <ClCompile Include="g_spawn.cpp" />
-    <ClCompile Include="g_svcmds.cpp" />
-    <ClCompile Include="g_target.cpp" />
-    <ClCompile Include="g_trigger.cpp" />
-    <ClCompile Include="g_turret.cpp" />
-    <ClCompile Include="g_utils.cpp" />
-    <ClCompile Include="g_weapon.cpp" />
-    <ClCompile Include="m_actor.cpp" />
-    <ClCompile Include="m_arachnid.cpp" />
-    <ClCompile Include="m_berserk.cpp" />
-    <ClCompile Include="m_boss2.cpp" />
-    <ClCompile Include="m_boss3.cpp" />
-    <ClCompile Include="m_boss31.cpp" />
-    <ClCompile Include="m_boss32.cpp" />
-    <ClCompile Include="m_brain.cpp" />
-    <ClCompile Include="m_chick.cpp" />
-    <ClCompile Include="m_flipper.cpp" />
-    <ClCompile Include="m_float.cpp" />
-    <ClCompile Include="m_flyer.cpp" />
-    <ClCompile Include="m_gladiator.cpp" />
-    <ClCompile Include="m_guardian.cpp" />
-    <ClCompile Include="m_guncmdr.cpp" />
-    <ClCompile Include="m_gunner.cpp" />
-    <ClCompile Include="m_hover.cpp" />
-    <ClCompile Include="m_infantry.cpp" />
-    <ClCompile Include="m_insane.cpp" />
-    <ClCompile Include="m_medic.cpp" />
-    <ClCompile Include="m_move.cpp" />
-    <ClCompile Include="m_mutant.cpp" />
-    <ClCompile Include="m_parasite.cpp" />
-    <ClCompile Include="m_shambler.cpp" />
-    <ClCompile Include="m_soldier.cpp" />
-    <ClCompile Include="m_supertank.cpp" />
-    <ClCompile Include="m_tank.cpp" />
-    <ClCompile Include="p_client.cpp" />
-    <ClCompile Include="p_hud.cpp" />
-    <ClCompile Include="p_move.cpp" />
-    <ClCompile Include="p_trail.cpp" />
-    <ClCompile Include="p_view.cpp" />
-    <ClCompile Include="p_weapon.cpp" />
-    <ClCompile Include="q_std.cpp" />
-    <ClCompile Include="rogue\g_rogue_combat.cpp" />
-    <ClCompile Include="rogue\g_rogue_func.cpp" />
-    <ClCompile Include="rogue\g_rogue_items.cpp" />
-    <ClCompile Include="rogue\g_rogue_misc.cpp" />
-    <ClCompile Include="rogue\g_rogue_monster.cpp" />
-    <ClCompile Include="rogue\g_rogue_newai.cpp" />
-    <ClCompile Include="rogue\g_rogue_newdm.cpp" />
-    <ClCompile Include="rogue\g_rogue_newfnc.cpp" />
-    <ClCompile Include="rogue\g_rogue_newtarg.cpp" />
-    <ClCompile Include="rogue\g_rogue_newtrig.cpp" />
-    <ClCompile Include="rogue\g_rogue_newweap.cpp" />
-    <ClCompile Include="rogue\g_rogue_phys.cpp" />
-    <ClCompile Include="rogue\g_rogue_spawn.cpp" />
-    <ClCompile Include="rogue\g_rogue_sphere.cpp" />
-    <ClCompile Include="rogue\g_rogue_utils.cpp" />
-    <ClCompile Include="rogue\m_rogue_carrier.cpp" />
-    <ClCompile Include="rogue\m_rogue_stalker.cpp" />
-    <ClCompile Include="rogue\m_rogue_turret.cpp" />
-    <ClCompile Include="rogue\m_rogue_widow.cpp" />
-    <ClCompile Include="rogue\m_rogue_widow2.cpp" />
-    <ClCompile Include="rogue\p_rogue_weapon.cpp" />
-    <ClCompile Include="rogue\rogue_dm_ball.cpp" />
-    <ClCompile Include="rogue\rogue_dm_tag.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_func.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_items.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_misc.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_monster.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_target.cpp" />
-    <ClCompile Include="xatrix\g_xatrix_weapon.cpp" />
-    <ClCompile Include="xatrix\m_xatrix_fixbot.cpp" />
-    <ClCompile Include="xatrix\m_xatrix_gekk.cpp" />
-    <ClCompile Include="xatrix\p_xatrix_weapon.cpp" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-</Project>
--- a/game.vcxproj.filters	2023-10-03 19:43:06
+++ /dev/null
@@ -1,265 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <ClInclude Include="bg_local.h" />
-    <ClInclude Include="cg_local.h" />
-    <ClInclude Include="g_local.h" />
-    <ClInclude Include="g_statusbar.h" />
-    <ClInclude Include="game.h" />
-    <ClInclude Include="m_actor.h" />
-    <ClInclude Include="m_arachnid.h" />
-    <ClInclude Include="m_berserk.h" />
-    <ClInclude Include="m_boss2.h" />
-    <ClInclude Include="m_boss31.h" />
-    <ClInclude Include="m_boss32.h" />
-    <ClInclude Include="m_brain.h" />
-    <ClInclude Include="m_chick.h" />
-    <ClInclude Include="m_flash.h" />
-    <ClInclude Include="m_flipper.h" />
-    <ClInclude Include="m_float.h" />
-    <ClInclude Include="m_flyer.h" />
-    <ClInclude Include="m_gladiator.h" />
-    <ClInclude Include="m_guardian.h" />
-    <ClInclude Include="m_gunner.h" />
-    <ClInclude Include="m_hover.h" />
-    <ClInclude Include="m_infantry.h" />
-    <ClInclude Include="m_insane.h" />
-    <ClInclude Include="m_medic.h" />
-    <ClInclude Include="m_mutant.h" />
-    <ClInclude Include="m_parasite.h" />
-    <ClInclude Include="m_player.h" />
-    <ClInclude Include="m_rider.h" />
-    <ClInclude Include="m_shambler.h" />
-    <ClInclude Include="m_soldier.h" />
-    <ClInclude Include="m_supertank.h" />
-    <ClInclude Include="m_tank.h" />
-    <ClInclude Include="q_std.h" />
-    <ClInclude Include="q_vec3.h" />
-    <ClInclude Include="bots\bot_debug.h">
-      <Filter>bots</Filter>
-    </ClInclude>
-    <ClInclude Include="bots\bot_exports.h">
-      <Filter>bots</Filter>
-    </ClInclude>
-    <ClInclude Include="bots\bot_includes.h">
-      <Filter>bots</Filter>
-    </ClInclude>
-    <ClInclude Include="bots\bot_think.h">
-      <Filter>bots</Filter>
-    </ClInclude>
-    <ClInclude Include="bots\bot_utils.h">
-      <Filter>bots</Filter>
-    </ClInclude>
-    <ClInclude Include="ctf\g_ctf.h">
-      <Filter>ctf</Filter>
-    </ClInclude>
-    <ClInclude Include="ctf\p_ctf_menu.h">
-      <Filter>ctf</Filter>
-    </ClInclude>
-    <ClInclude Include="rogue\m_rogue_carrier.h">
-      <Filter>rogue</Filter>
-    </ClInclude>
-    <ClInclude Include="rogue\m_rogue_stalker.h">
-      <Filter>rogue</Filter>
-    </ClInclude>
-    <ClInclude Include="rogue\m_rogue_turret.h">
-      <Filter>rogue</Filter>
-    </ClInclude>
-    <ClInclude Include="rogue\m_rogue_widow.h">
-      <Filter>rogue</Filter>
-    </ClInclude>
-    <ClInclude Include="rogue\m_rogue_widow2.h">
-      <Filter>rogue</Filter>
-    </ClInclude>
-    <ClInclude Include="xatrix\m_xatrix_fixbot.h">
-      <Filter>xatrix</Filter>
-    </ClInclude>
-    <ClInclude Include="xatrix\m_xatrix_gekk.h">
-      <Filter>xatrix</Filter>
-    </ClInclude>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="cg_main.cpp" />
-    <ClCompile Include="cg_screen.cpp" />
-    <ClCompile Include="g_ai.cpp" />
-    <ClCompile Include="g_chase.cpp" />
-    <ClCompile Include="g_cmds.cpp" />
-    <ClCompile Include="g_combat.cpp" />
-    <ClCompile Include="g_func.cpp" />
-    <ClCompile Include="g_items.cpp" />
-    <ClCompile Include="g_main.cpp" />
-    <ClCompile Include="g_misc.cpp" />
-    <ClCompile Include="g_monster.cpp" />
-    <ClCompile Include="g_phys.cpp" />
-    <ClCompile Include="g_save.cpp" />
-    <ClCompile Include="g_spawn.cpp" />
-    <ClCompile Include="g_svcmds.cpp" />
-    <ClCompile Include="g_target.cpp" />
-    <ClCompile Include="g_trigger.cpp" />
-    <ClCompile Include="g_turret.cpp" />
-    <ClCompile Include="g_utils.cpp" />
-    <ClCompile Include="g_weapon.cpp" />
-    <ClCompile Include="m_actor.cpp" />
-    <ClCompile Include="m_arachnid.cpp" />
-    <ClCompile Include="m_berserk.cpp" />
-    <ClCompile Include="m_boss2.cpp" />
-    <ClCompile Include="m_boss3.cpp" />
-    <ClCompile Include="m_boss31.cpp" />
-    <ClCompile Include="m_boss32.cpp" />
-    <ClCompile Include="m_brain.cpp" />
-    <ClCompile Include="m_chick.cpp" />
-    <ClCompile Include="m_flipper.cpp" />
-    <ClCompile Include="m_float.cpp" />
-    <ClCompile Include="m_flyer.cpp" />
-    <ClCompile Include="m_gladiator.cpp" />
-    <ClCompile Include="m_guardian.cpp" />
-    <ClCompile Include="m_guncmdr.cpp" />
-    <ClCompile Include="m_gunner.cpp" />
-    <ClCompile Include="m_hover.cpp" />
-    <ClCompile Include="m_infantry.cpp" />
-    <ClCompile Include="m_insane.cpp" />
-    <ClCompile Include="m_medic.cpp" />
-    <ClCompile Include="m_move.cpp" />
-    <ClCompile Include="m_mutant.cpp" />
-    <ClCompile Include="m_parasite.cpp" />
-    <ClCompile Include="m_shambler.cpp" />
-    <ClCompile Include="m_soldier.cpp" />
-    <ClCompile Include="m_supertank.cpp" />
-    <ClCompile Include="m_tank.cpp" />
-    <ClCompile Include="p_client.cpp" />
-    <ClCompile Include="p_hud.cpp" />
-    <ClCompile Include="p_move.cpp" />
-    <ClCompile Include="p_trail.cpp" />
-    <ClCompile Include="p_view.cpp" />
-    <ClCompile Include="p_weapon.cpp" />
-    <ClCompile Include="q_std.cpp" />
-    <ClCompile Include="bots\bot_debug.cpp">
-      <Filter>bots</Filter>
-    </ClCompile>
-    <ClCompile Include="bots\bot_exports.cpp">
-      <Filter>bots</Filter>
-    </ClCompile>
-    <ClCompile Include="bots\bot_think.cpp">
-      <Filter>bots</Filter>
-    </ClCompile>
-    <ClCompile Include="bots\bot_utils.cpp">
-      <Filter>bots</Filter>
-    </ClCompile>
-    <ClCompile Include="ctf\g_ctf.cpp">
-      <Filter>ctf</Filter>
-    </ClCompile>
-    <ClCompile Include="ctf\p_ctf_menu.cpp">
-      <Filter>ctf</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_combat.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_func.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_items.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_misc.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_monster.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newai.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newdm.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newfnc.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newtarg.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newtrig.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_newweap.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_phys.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_spawn.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_sphere.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\g_rogue_utils.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\m_rogue_carrier.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\m_rogue_stalker.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\m_rogue_turret.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\m_rogue_widow.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\m_rogue_widow2.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\p_rogue_weapon.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\rogue_dm_ball.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="rogue\rogue_dm_tag.cpp">
-      <Filter>rogue</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_func.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_items.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_misc.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_monster.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_target.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\g_xatrix_weapon.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\m_xatrix_fixbot.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\m_xatrix_gekk.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-    <ClCompile Include="xatrix\p_xatrix_weapon.cpp">
-      <Filter>xatrix</Filter>
-    </ClCompile>
-  </ItemGroup>
-  <ItemGroup>
-    <Filter Include="bots">
-      <UniqueIdentifier>{185665ce-b604-4d9a-b22b-02a83797d112}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="ctf">
-      <UniqueIdentifier>{2b0fdaa0-3de9-4bbd-9bc6-3cadf798c291}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="rogue">
-      <UniqueIdentifier>{76ef0be8-1c1d-472a-ada1-3aa1b354e022}</UniqueIdentifier>
-    </Filter>
-    <Filter Include="xatrix">
-      <UniqueIdentifier>{6565427e-a805-4dc7-ba57-3ce0b62e4336}</UniqueIdentifier>
-    </Filter>
-  </ItemGroup>
-</Project>
--- /dev/null
+++ b/ionized/g_ionized_items.cpp	2025-09-04 19:53:48
@@ -0,0 +1,138 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+
+/* KONIG - small ammos*/
+void SP_ammo_shells_small(edict_t* self)
+{
+	self->model = "models/vault/items/ammo/shells/small/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_SHELLS), ED_GetSpawnTemp());
+	self->count = 5;
+}
+
+void SP_ammo_bullets_small(edict_t* self)
+{
+	self->model = "models/vault/items/ammo/bullets/small/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_BULLETS), ED_GetSpawnTemp());
+	self->count = 25;
+}
+
+void SP_ammo_rockets_small(edict_t* self)
+{
+	self->model = "models/vault/items/ammo/rockets/small/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_ROCKETS), ED_GetSpawnTemp());
+	self->count = 2;
+}
+
+void SP_ammo_cells_small(edict_t* self)
+{
+	self->model = "models/vault/items/ammo/cells/small/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_CELLS), ED_GetSpawnTemp());
+	self->count = 25;
+}
+
+void SP_ammo_slugs_small(edict_t* self)
+{
+	self->model = "models/vault/items/ammo/slugs/small/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_SLUGS), ED_GetSpawnTemp());
+	self->count = 3;
+}
+
+void SP_ammo_flechettes_small(edict_t* self)
+{
+	self->model = "models/items/ammo/flechette/small/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_FLECHETTES), ED_GetSpawnTemp());
+	self->count = 3;
+}
+
+void SP_ammo_prox_small(edict_t* self)
+{
+	self->model = "models/items/ammo/prox/small/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_PROX), ED_GetSpawnTemp());
+	self->count = 3;
+}
+
+void SP_ammo_magslugs_small(edict_t* self)
+{
+	self->model = "models/items/ammo/magslugs/small/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_MAGSLUG), ED_GetSpawnTemp());
+	self->count = 3;
+}
+
+void SP_ammo_rounds_small(edict_t* self)
+{
+	self->model = "models/items/ammo/rounds/small/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_ROUNDS), ED_GetSpawnTemp());
+	self->count = 3;
+}
+
+//ZAERO KEY COMPATIBILITY
+void SP_key_landingarea(edict_t* self)
+{
+	self->model = "models/items/keys/blue_gearkey/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_KEY_BLUE_GEAR), ED_GetSpawnTemp());
+	self->count = 1;
+}
+
+void SP_key_lab(edict_t* self)
+{
+	self->model = "models/items/keys/yellow_gearkey/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_KEY_YELLOW_GEAR), ED_GetSpawnTemp());
+	self->count = 1;
+}
+
+void SP_key_clearancepass(edict_t* self)
+{
+	self->model = "models/items/keys/red_gearkey/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_KEY_RED_GEAR), ED_GetSpawnTemp());
+	self->count = 1;
+}
+
+void SP_item_silver_key(edict_t* self)
+{
+	if (self->spawnflags.has(16_spawnflag))
+		self->model = "models/items/keys/b_s_key/tris.md2";
+	else if (self->spawnflags.has(32_spawnflag))
+		self->model = "models/items/keys/m_s_key/tris.md2";
+	else
+		self->model = "models/items/keys/w_s_key/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_KEY_SILVER_KEY), ED_GetSpawnTemp());
+	self->count = 1;
+}
+
+void SP_item_gold_key(edict_t* self)
+{
+	if (self->spawnflags.has(16_spawnflag))
+		self->model = "models/items/keys/b_g_key/tris.md2";
+	else if (self->spawnflags.has(32_spawnflag))
+		self->model = "models/items/keys/m_g_key/tris.md2";
+	else
+		self->model = "models/items/keys/w_g_key/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_KEY_GOLD_KEY), ED_GetSpawnTemp());
+	self->count = 1;
+}
+
+void SP_item_sigil(edict_t* self)
+{
+	if (self->spawnflags.has(16_spawnflag))
+	{
+		self->model = "models/items/keys/sigil2/tris.md2";
+		SpawnItem(self, GetItemByIndex(IT_TECH_STRENGTH), ED_GetSpawnTemp());
+	}
+	else if (self->spawnflags.has(32_spawnflag))
+	{
+		self->model = "models/items/keys/sigil3/tris.md2";
+		SpawnItem(self, GetItemByIndex(IT_TECH_HASTE), ED_GetSpawnTemp());
+	}
+	else if (self->spawnflags.has(64_spawnflag))
+	{
+		self->model = "models/items/keys/sigil4/tris.md2";
+		SpawnItem(self, GetItemByIndex(IT_TECH_REGENERATION), ED_GetSpawnTemp());
+	}
+	else
+	{
+		self->model = "models/items/keys/sigil1/tris.md2";
+		SpawnItem(self, GetItemByIndex(IT_TECH_RESISTANCE), ED_GetSpawnTemp());
+	}
+	self->count = 1;
+}
--- /dev/null
+++ b/ionized/g_ionized_misc.cpp	2025-09-04 19:53:48
@@ -0,0 +1,680 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+
+/*QUAKED misc_gib_head2 (1 0 0) (-8 -8 -8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_head2(edict_t* ent)
+{
+	gi.setmodel(ent, "models/objects/gibs/head2/tris.md2");
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+}
+
+/*QUAKED misc_gib_chest (1 0 0) (-8 -8 -8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_chest(edict_t* ent)
+{
+	gi.setmodel(ent, "models/objects/gibs/chest/tris.md2");
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+}
+
+/*QUAKED misc_gib_gekk(1 0 0) (-8 - 8 - 8) (8 8 8)
+*/
+void SP_misc_gib_gekk(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GREENGIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(6);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/objects/gekkgibs/arm/tris.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/objects/gekkgibs/claw/tris.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/objects/gekkgibs/head/tris.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/objects/gekkgibs/torso/tris.md2");
+	else if (r == 4)
+		gi.setmodel(ent, "models/objects/gekkgibs/pelvis/tris.md2");
+	else if (r == 5)
+		gi.setmodel(ent, "models/objects/gekkgibs/leg/tris.md2");
+}
+
+/*QUAKED misc_gib_berserk(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_berserk(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/berserk/gibs/hammer.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/berserk/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/berserk/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/berserk/gibs/thigh.md2");
+}
+
+/*QUAKED misc_gib_chick(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_chick(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/bitch/gibs/arm.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/bitch/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/bitch/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/bitch/gibs/foot.md2");
+}
+
+/*QUAKED misc_gib_brain(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_brain(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/brain/gibs/arm.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/brain/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/brain/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/brain/gibs/boot.md2");
+}
+
+/*QUAKED misc_gib_glad(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_glad(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/gladiatr/gibs/larm.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/gladiatr/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/gladiatr/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/gladiatr/gibs/thigh.md2");
+}
+
+/*QUAKED misc_gib_gunner(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_gunner(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/gunner/gibs/garm.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/gunner/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/gunner/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/gunner/gibs/foot.md2");
+}
+
+/*QUAKED misc_gib_hover(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_hover(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/hover/gibs/ring.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/hover/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/hover/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/hover/gibs/foot.md2");
+}
+
+/*QUAKED misc_gib_infantry(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_infantry(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/infantry/gibs/arm.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/infantry/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/infantry/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/infantry/gibs/foot.md2");
+}
+
+/*QUAKED misc_gib_medic(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_medic(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/medic/gibs/hook.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/medic/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/medic/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/medic/gibs/leg.md2");
+}
+
+/*QUAKED misc_gib_parasite(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_parasite(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/parasite/gibs/fleg.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/parasite/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/parasite/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/parasite/gibs/bleg.md2");
+}
+
+/*QUAKED misc_gib_soldier(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_soldier(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/soldier/gibs/arm.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/soldier/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/soldier/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/soldier/gibs/gun.md2");
+}
+
+/*QUAKED misc_gib_stalker(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_stalker(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/stalker/gibs/claw.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/stalker/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/stalker/gibs/bodya.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/stalker/gibs/leg.md2");
+}
+
+/*QUAKED misc_gib_tank(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_tank(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/tank/gibs/barm.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/tank/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/tank/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/tank/gibs/thigh.md2");
+}
+
+/*QUAKED misc_gib_mutant(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_mutant(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/mutant/gibs/hand.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/mutant/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/mutant/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/mutant/gibs/foot.md2");
+}
+
+/*QUAKED misc_gib_boss1(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+Boss gibs
+*/
+void SP_misc_gib_boss1(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/boss1/gibs/cgun.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/boss1/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/boss1/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/boss1/gibs/ltread.md2");
+}
+
+/*QUAKED misc_gib_boss2(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+Boss gibs
+*/
+void SP_misc_gib_boss2(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/boss2/gibs/larm.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/boss2/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/boss2/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/boss2/gibs/wing.md2");
+}
+
+/*QUAKED misc_gib_boss3(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+Boss gibs
+*/
+void SP_misc_gib_boss3(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/boss3/jorg/gibs/gun.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/boss3/jorg/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/boss3/jorg/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/boss3/jorg/gibs/thigh.md2");
+}
+
+/*QUAKED misc_gib_carrier(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+Boss gibs
+*/
+void SP_misc_gib_carrier(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/carrier/gibs/rwing.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/carrier/gibs/head.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/carrier/gibs/chest.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/carrier/gibs/thigh.md2");
+}
+
+/*QUAKED misc_gib_strider(1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_strider(edict_t* ent)
+{
+	int r;
+
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	r = irandom(4);
+
+	if (r == 0)
+		gi.setmodel(ent, "models/monsters/guardian/gib5.md2");
+	else if (r == 1)
+		gi.setmodel(ent, "models/monsters/guardian/gib3.md2");
+	else if (r == 2)
+		gi.setmodel(ent, "models/monsters/guardian/gib4.md2");
+	else if (r == 3)
+		gi.setmodel(ent, "models/monsters/guardian/gib6.md2");
+}
+
+/* KONIG - TO DO; other Quake 1 gibs */
+/*QUAKED misc_gib_shambler (1 0 0) (-8 - 8 - 8) (8 8 8)
+Intended for use with the target_spawner
+*/
+void SP_misc_gib_shambler(edict_t* ent)
+{
+	ent->solid = SOLID_NOT;
+	ent->s.effects |= EF_GIB;
+	ent->takedamage = true;
+	ent->die = gib_die;
+	ent->movetype = MOVETYPE_TOSS;
+	ent->deadflag = true;
+	ent->avelocity[0] = frandom(200);
+	ent->avelocity[1] = frandom(200);
+	ent->avelocity[2] = frandom(200);
+	ent->think = G_FreeEdict;
+	ent->nextthink = level.time + 10_sec;
+	gi.linkentity(ent);
+
+	gi.setmodel(ent, "models/monsters/shambler/gibs/head.md2");
+}
--- /dev/null
+++ b/ionized/g_ionized_monster.cpp	2025-09-04 19:53:48
@@ -0,0 +1,848 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+
+
+/*
+=================
+BossPowerups
+
+universal boss response powerups
+=================
+*/
+
+void BossPowerArmor(edict_t* self)
+{
+	self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+	if (self->monsterinfo.power_armor_power <= 0)
+		self->monsterinfo.power_armor_power += 200 * (skill->integer - 1);
+	if (coop->integer)
+		self->monsterinfo.power_armor_power += ((25 * skill->integer) + (25 * (CountPlayers() - 1)));
+}
+
+void BossRespondPowerup(edict_t* self, edict_t* other)
+{
+	if (other->s.effects & (EF_QUAD | EF_DOUBLE | EF_DUALFIRE | EF_PENT))
+	{
+		BossPowerArmor(self);
+	}
+}
+
+void BossPowerups(edict_t* self)
+{
+	edict_t* ent;
+
+	if (!coop->integer)
+	{
+		BossRespondPowerup(self, self->enemy);
+	}
+	else
+	{
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			BossRespondPowerup(self, ent);
+		}
+	}
+}
+
+/* KONIG - old attacks made universal*/
+
+/*
+=================
+fire_acid
+
+Fires a single acid bolt. Taken from gekk's loogie. Used by natural monsters.
+=================
+*/
+
+TOUCH(acid_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (other == self->owner)
+		return;
+
+	if (tr.surface && (tr.surface->flags & SURF_SKY))
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	if (self->owner->client)
+		PlayerNoise(self->owner, self->s.origin, PNOISE_IMPACT);
+
+	if (other->takedamage)
+		T_Damage(other, self, self->owner, self->velocity, self->s.origin, tr.plane.normal, self->dmg, 1, DAMAGE_ENERGY, MOD_GEKK);
+
+	gi.sound(self, CHAN_AUTO, gi.soundindex("gek/loogie_hit.wav"), 1.0f, ATTN_NORM, 0);
+
+	G_FreeEdict(self);
+};
+
+void fire_acid(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed)
+{
+	edict_t* acid;
+	trace_t	 tr;
+
+	acid = G_Spawn();
+	acid->s.origin = start;
+	acid->s.old_origin = start;
+	acid->s.angles = vectoangles(dir);
+	acid->velocity = dir * speed;
+	acid->movetype = MOVETYPE_FLYMISSILE;
+	acid->clipmask = MASK_PROJECTILE;
+	acid->solid = SOLID_BBOX;
+	// Paril: this was originally the wrong effect,
+	// but it makes it look more acid-y.
+	acid->s.effects |= EF_GREENGIB;
+	acid->s.renderfx |= RF_FULLBRIGHT;
+	acid->s.modelindex = gi.modelindex("models/objects/loogy/tris.md2");
+	acid->owner = self;
+	acid->touch = acid_touch;
+	acid->nextthink = level.time + 2_sec;
+	acid->think = G_FreeEdict;
+	acid->dmg = damage;
+	acid->svflags |= SVF_PROJECTILE;
+	gi.linkentity(acid);
+
+	tr = gi.traceline(self->s.origin, acid->s.origin, acid, MASK_PROJECTILE);
+	if (tr.fraction < 1.0f)
+	{
+		acid->s.origin = tr.endpos + (tr.plane.normal * 1.f);
+		acid->touch(acid, tr.ent, tr, false);
+	}
+}
+
+/*
+=================
+monster_fire_plasma
+
+Fires a phalanx explosive.
+=================
+*/
+
+void monster_fire_plasma(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, float damage_radius, int radius_damage, monster_muzzleflash_id_t flashtype)
+{
+	if (EMPNukeCheck(self, self->s.origin))
+	{
+		gi.sound(self, CHAN_AUTO, gi.soundindex("items/empnuke/emp_missfire.wav"), 1, ATTN_NORM, 0);
+		return;
+	}
+	fire_plasma(self, start, dir, damage, speed, damage_radius, radius_damage);
+	monster_muzzleflash(self, start, flashtype);
+}
+
+/*
+=================
+fire_guardian_heat
+
+Destructible heat-seeking rockets
+=================
+*/
+
+static inline vec3_t heat_guardian_get_dist_vec(edict_t* heat, edict_t* target, float dist_to_target)
+{
+	return (((target->s.origin + vec3_t{ 0.f, 0.f, target->mins.z }) + (target->velocity * (clamp(dist_to_target / 500.f, 0.f, 1.f)) * 0.5f)) - heat->s.origin).normalized();
+}
+
+THINK(heat_guardian_think) (edict_t* self) -> void
+{
+	edict_t* acquire = nullptr;
+	float	 oldlen = 0;
+	float	 olddot = 1;
+
+	if (self->timestamp < level.time)
+	{
+		vec3_t fwd = AngleVectors(self->s.angles).forward;
+
+		if (self->oldenemy)
+		{
+			self->enemy = self->oldenemy;
+			self->oldenemy = nullptr;
+		}
+
+		if (self->enemy)
+		{
+			acquire = self->enemy;
+
+			if (acquire->health <= 0 ||
+				!visible(self, acquire))
+			{
+				self->enemy = acquire = nullptr;
+			}
+			else
+			{
+				float dist_to_target = (self->s.origin - acquire->s.origin).normalize();
+				self->pos1 = heat_guardian_get_dist_vec(self, acquire, dist_to_target);
+			}
+		}
+
+		if (!acquire)
+		{
+			// acquire new target
+			edict_t* target = nullptr;
+
+			while ((target = findradius(target, self->s.origin, 1024)) != nullptr)
+			{
+				if (self->owner == target)
+					continue;
+				if (!target->client)
+					continue;
+				if (target->health <= 0)
+					continue;
+				if (!visible(self, target))
+					continue;
+
+				float dist_to_target = (self->s.origin - target->s.origin).normalize();
+				vec3_t vec = heat_guardian_get_dist_vec(self, target, dist_to_target);
+
+				float len = vec.normalize();
+				float dot = vec.dot(fwd);
+
+				// targets that require us to turn less are preferred
+				if (dot >= olddot)
+					continue;
+
+				if (acquire == nullptr || dot < olddot || len < oldlen)
+				{
+					acquire = target;
+					oldlen = len;
+					olddot = dot;
+					self->pos1 = vec;
+				}
+			}
+		}
+	}
+
+	vec3_t preferred_dir = self->pos1;
+
+	if (acquire != nullptr)
+	{
+		if (self->enemy != acquire)
+		{
+			gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/railgr1a.wav"), 1.f, 0.25f, 0);
+			self->enemy = acquire;
+		}
+	}
+	else
+		self->enemy = nullptr;
+
+	float t = self->accel;
+
+	if (self->enemy)
+		t *= 0.85f;
+
+	float d = self->movedir.dot(preferred_dir);
+
+	self->movedir = slerp(self->movedir, preferred_dir, t).normalized();
+	self->s.angles = vectoangles(self->movedir);
+
+	if (self->speed < self->yaw_speed)
+	{
+		self->speed += self->yaw_speed * gi.frame_time_s;
+	}
+
+	self->velocity = self->movedir * self->speed;
+	self->nextthink = level.time + FRAME_TIME_MS;
+}
+
+DIE(guardian_heat_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	BecomeExplosion1(self);
+}
+
+void fire_guardian_heat(edict_t* self, const vec3_t& start, const vec3_t& dir, const vec3_t& rest_dir, int damage, int speed, float damage_radius, int radius_damage, float turn_fraction)
+{
+	edict_t* heat;
+
+	heat = G_Spawn();
+	heat->s.origin = start;
+	heat->movedir = dir;
+	heat->s.angles = vectoangles(dir);
+	heat->velocity = dir * speed;
+	heat->movetype = MOVETYPE_FLYMISSILE;
+	heat->clipmask = MASK_PROJECTILE;
+	heat->flags |= FL_DAMAGEABLE;
+	heat->solid = SOLID_BBOX;
+	heat->s.effects |= EF_ROCKET;
+	heat->s.modelindex = gi.modelindex("models/objects/rocket/tris.md2");
+	heat->s.scale = 1.5f;
+	heat->owner = self;
+	heat->touch = rocket_touch;
+	heat->speed = speed / 2;
+	heat->yaw_speed = speed * 2;
+	heat->accel = turn_fraction;
+	heat->pos1 = rest_dir;
+	heat->mins = { -5, -5, -5 };
+	heat->maxs = { 5, 5, 5 };
+	heat->health = 15;
+	heat->takedamage = true;
+	heat->die = guardian_heat_die;
+
+	heat->nextthink = level.time + 0.20_sec;
+	heat->think = heat_guardian_think;
+
+	heat->dmg = damage;
+	heat->radius_dmg = radius_damage;
+	heat->dmg_radius = damage_radius;
+	heat->s.sound = gi.soundindex("weapons/rockfly.wav");
+
+	if (visible(heat, self->enemy))
+	{
+		heat->oldenemy = self->enemy;
+		heat->timestamp = level.time + 0.6_sec;
+		gi.sound(heat, CHAN_WEAPON, gi.soundindex("weapons/railgr1a.wav"), 1.f, 0.25f, 0);
+	}
+
+	gi.linkentity(heat);
+}
+
+/* KONIG - new attacks*/
+
+/*
+========================
+monster_fire_lightning
+
+fires lightning bolts as projectiles
+========================
+*/
+
+void monster_fire_lightning(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, monster_muzzleflash_id_t flashtype, effects_t effect)
+{
+	if (EMPNukeCheck(self, self->s.origin))
+	{
+		gi.sound(self, CHAN_AUTO, gi.soundindex("items/empnuke/emp_missfire.wav"), 1, ATTN_NORM, 0);
+		return;
+	}
+	fire_lightning(self, start, dir, damage, speed, effect);
+	monster_muzzleflash(self, start, flashtype);
+}
+
+/*
+========================
+
+monster_fire_flakcannon
+
+Fires multiple nails.
+
+========================
+*/
+void flechette_touch(edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self);
+
+void fire_flakshot(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int hspread, int vspread, int kick)
+{
+	edict_t* flak;
+
+	vec3_t end, dir, forward, right, up;
+	dir = vectoangles(aimdir);
+	AngleVectors(dir, forward, right, up);
+
+	float r = crandom() * hspread;
+	float u = crandom() * vspread;
+	end = forward * 8192; //start + (forward * 8192);
+	end += (right * r);
+	end += (up * u);
+
+	flak = G_Spawn();
+	flak->s.origin = start;
+	flak->s.old_origin = start;
+	flak->s.angles = dir;
+	flak->velocity = end * speed / 8192;
+	flak->svflags |= SVF_PROJECTILE;
+	flak->movetype = MOVETYPE_FLYMISSILE;
+	flak->clipmask = MASK_PROJECTILE;
+	flak->flags |= FL_DODGE;
+
+	// [Paril-KEX]
+	if (self->client && !G_ShouldPlayersCollide(true))
+		flak->clipmask &= ~CONTENTS_PLAYER;
+
+	flak->solid = SOLID_BBOX;
+	flak->s.renderfx = RF_FULLBRIGHT;
+	flak->s.modelindex = gi.modelindex("models/proj/flechette/tris.md2");
+
+	flak->owner = self;
+	flak->touch = flechette_touch;
+	flak->nextthink = level.time + gtime_t::from_sec(8000.f / speed);
+	flak->think = G_FreeEdict;
+	flak->dmg = damage;
+	flak->dmg_radius = (float)kick;
+
+	gi.linkentity(flak);
+
+	trace_t tr = gi.traceline(self->s.origin, flak->s.origin, flak, flak->clipmask);
+	if (tr.fraction < 1.0f)
+	{
+		flak->s.origin = tr.endpos + (tr.plane.normal * 1.f);
+		flak->touch(flak, tr.ent, tr, false);
+	}
+}
+
+void fire_flakcannon(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int hspread, int vspread, int kick, int count)
+{
+	for (int i = 0; i < count; i++)
+		fire_flakshot(self, start, aimdir, damage, speed, hspread, vspread, kick);
+}
+
+void monster_fire_flakcannon(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int hspread, int vspread, int count, monster_muzzleflash_id_t flashtype)
+{
+	if (EMPNukeCheck(self, self->s.origin))
+	{
+		gi.sound(self, CHAN_AUTO, gi.soundindex("items/empnuke/emp_missfire.wav"), 1, ATTN_NORM, 0);
+		fire_flechette(self, start, aimdir, damage, speed, damage / 2);
+		monster_muzzleflash(self, start, flashtype);
+		return;
+	}
+	fire_flakcannon(self, start, aimdir, damage, speed, hspread, vspread, damage, count);
+	monster_muzzleflash(self, start, flashtype);
+}
+
+/*
+========================
+
+monster_fire_flakblaster
+
+Fires multiple blaster shots.
+
+========================
+*/
+edict_t* fire_flakshot_blaster(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int hspread, int vspread, effects_t effect, int skin)
+{
+	edict_t* bolt;
+	trace_t	 tr;
+
+	vec3_t end, dir, forward, right, up;
+	dir = vectoangles(aimdir);
+	AngleVectors(dir, forward, right, up);
+
+	float r = crandom() * hspread;
+	float u = crandom() * vspread;
+	end = forward * 8192; //start + (forward * 8192);
+	end += (right * r);
+	end += (up * u);
+
+	bolt = G_Spawn();
+	bolt->svflags = SVF_PROJECTILE;
+	bolt->s.origin = start;
+	bolt->s.old_origin = start;
+	bolt->s.angles = dir;
+	bolt->velocity = end * speed / 8192;
+	bolt->movetype = MOVETYPE_FLYMISSILE;
+	bolt->clipmask = MASK_PROJECTILE;
+	// [Paril-KEX]
+	if (self->client && !G_ShouldPlayersCollide(true))
+		bolt->clipmask &= ~CONTENTS_PLAYER;
+	bolt->flags |= FL_DODGE;
+	bolt->solid = SOLID_BBOX;
+	bolt->s.effects |= effect;
+	if (skin == 2 && effect)
+		bolt->s.effects |= EF_TRACKER;
+	bolt->s.modelindex = gi.modelindex("models/objects/laser/tris.md2");
+	bolt->s.skinnum |= skin; //0=yellow, 1=blue, 2=green
+	bolt->s.sound = gi.soundindex("misc/lasfly.wav");
+	bolt->owner = self;
+	bolt->touch = blaster_touch;
+	bolt->nextthink = level.time + 2_sec;
+	bolt->think = G_FreeEdict;
+	bolt->dmg = damage;
+	bolt->classname = "bolt";
+	bolt->style = MOD_BLASTER;
+	gi.linkentity(bolt);
+
+	tr = gi.traceline(self->s.origin, bolt->s.origin, bolt, bolt->clipmask);
+	if (tr.fraction < 1.0f)
+	{
+		bolt->s.origin = tr.endpos + (tr.plane.normal * 1.f);
+		bolt->touch(bolt, tr.ent, tr, false);
+	}
+
+	return bolt;
+}
+
+void fire_flakblaster(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int hspread, int vspread, int count, effects_t effect, int skin)
+{
+	for (int i = 0; i < count; i++)
+		fire_flakshot_blaster(self, start, aimdir, damage, speed, hspread, vspread, effect, skin);
+}
+
+void monster_fire_flakblaster(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int hspread,
+	int vspread, int count, monster_muzzleflash_id_t flashtype, effects_t effect, int skin)
+{
+	if (EMPNukeCheck(self, self->s.origin))
+	{
+		gi.sound(self, CHAN_AUTO, gi.soundindex("items/empnuke/emp_missfire.wav"), 1, ATTN_NORM, 0);
+		fire_blaster(self, start, aimdir, damage, speed, effect, MOD_BLASTER);
+		monster_muzzleflash(self, start, flashtype);
+		return;
+	}
+	fire_flakblaster(self, start, aimdir, damage, speed, hspread, vspread, count, effect, skin);
+	monster_muzzleflash(self, start, flashtype);
+}
+
+/*
+========================
+
+monster_fire_flakripper
+
+Fires multiple ion ripper shots.
+
+========================
+*/
+void ionripper_touch(edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self);
+void ionripper_sparks(edict_t* self);
+
+void fire_flakshot_ripper(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int hspread, int vspread, int kick, effects_t effect)
+{
+	edict_t* ion;
+	trace_t	 tr;
+
+	vec3_t end, dir, forward, right, up;
+	dir = vectoangles(aimdir);
+	AngleVectors(dir, forward, right, up);
+
+	float r = crandom() * hspread;
+	float u = crandom() * vspread;
+	end = forward * 8192; //start + (forward * 8192);
+	end += (right * r);
+	end += (up * u);
+
+	ion = G_Spawn();
+	ion->s.origin = start;
+	ion->s.old_origin = start;
+	ion->s.angles = dir;
+	ion->velocity = end * speed / 8192;
+	ion->movetype = MOVETYPE_WALLBOUNCE;
+	ion->clipmask = MASK_PROJECTILE;
+
+	// [Paril-KEX]
+	if (self->client && !G_ShouldPlayersCollide(true))
+		ion->clipmask &= ~CONTENTS_PLAYER;
+
+	ion->solid = SOLID_BBOX;
+	ion->s.effects |= effect;
+	ion->svflags |= SVF_PROJECTILE;
+	ion->flags |= FL_DODGE;
+	ion->s.renderfx |= RF_FULLBRIGHT;
+	ion->s.modelindex = gi.modelindex("models/objects/boomrang/tris.md2");
+	ion->s.sound = gi.soundindex("misc/lasfly.wav");
+	ion->owner = self;
+	ion->touch = ionripper_touch;
+	ion->nextthink = level.time + 3_sec;
+	ion->think = ionripper_sparks;
+	ion->dmg = damage;
+	ion->dmg_radius = 100;
+	gi.linkentity(ion);
+
+	tr = gi.traceline(self->s.origin, ion->s.origin, ion, ion->clipmask);
+	if (tr.fraction < 1.0f)
+	{
+		ion->s.origin = tr.endpos + (tr.plane.normal * 1.f);
+		ion->touch(ion, tr.ent, tr, false);
+	}
+}
+
+void fire_flakripper(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int hspread, int vspread, int kick, int count, effects_t effect)
+{
+	for (int i = 0; i < count; i++)
+		fire_flakshot_ripper(self, start, aimdir, damage, speed, hspread, vspread, kick, effect);
+}
+
+void monster_fire_flakripper(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, int kick, int hspread,
+	int vspread, int count, monster_muzzleflash_id_t flashtype, effects_t effect)
+{
+	if (EMPNukeCheck(self, self->s.origin))
+	{
+		gi.sound(self, CHAN_AUTO, gi.soundindex("items/empnuke/emp_missfire.wav"), 1, ATTN_NORM, 0);
+		fire_ionripper(self, start, aimdir, damage, speed, effect);
+		monster_muzzleflash(self, start, flashtype);
+		return;
+	}
+	fire_flakripper(self, start, aimdir, damage, speed, kick, hspread, vspread, count, effect);
+	monster_muzzleflash(self, start, flashtype);
+}
+
+/*
+=================
+fire_dropper
+=================
+*/
+
+constexpr gtime_t DROPPER_TIME_TO_LIVE = 30_sec;
+constexpr float	  DROPPER_DAMAGE_RADIUS = 128;
+constexpr int32_t DROPPER_DAMAGE = 3;
+constexpr int32_t DROPPER_KNOCKBACK = 8;
+
+constexpr gtime_t DROPPER_ACTIVATE_TIME = 2_sec;
+constexpr int32_t DROPPER_EXPLOSION_DAMAGE_MULT = 50; // this is the amount the damage is multiplied by for underwater explosions
+constexpr float	  DROPPER_EXPLOSION_RADIUS = 200;
+
+void dropper_remove(edict_t* self)
+{
+	edict_t* cur, * next;
+
+	self->takedamage = false;
+	if (self->teamchain)
+	{
+		cur = self->teamchain;
+		while (cur)
+		{
+			next = cur->teamchain;
+			G_FreeEdict(cur);
+			cur = next;
+		}
+	}
+	else if (self->air_finished)
+		gi.Com_Print("dropper_mine without a field!\n");
+
+	self->owner = self->teammaster;
+	self->enemy = nullptr;
+
+	if ((self->dmg_radius) && (self->dmg > (DROPPER_DAMAGE * DROPPER_EXPLOSION_DAMAGE_MULT)))
+		gi.sound(self, CHAN_ITEM, gi.soundindex("items/damage3.wav"), 1, ATTN_NORM, 0);
+
+	Grenade_Explode(self);
+}
+
+DIE(dropper_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	dropper_remove(self);
+}
+
+void dropper_blow(edict_t* self)
+{
+	self->dmg *= DROPPER_EXPLOSION_DAMAGE_MULT;
+	self->dmg_radius = DROPPER_EXPLOSION_RADIUS;
+	dropper_remove(self);
+}
+
+TOUCH(dropper_lava) (edict_t* ent, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (tr.contents & (CONTENTS_SLIME | CONTENTS_LAVA))
+	{
+		dropper_blow(ent);
+		return;
+	}
+
+	if (frandom() > 0.5f)
+		gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/hgrenb1a.wav"), 1, ATTN_NORM, 0);
+	else
+		gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/hgrenb2a.wav"), 1, ATTN_NORM, 0);
+}
+
+THINK(dropper_think)(edict_t* self) -> void
+{
+	vec3_t f, r, offset, startpoint, spawnpoint;
+
+	// Hardcoded offset
+	offset = { -24.f, -124.f, 0.f };
+
+	AngleVectors(self->s.angles, f, r, nullptr);
+	if (self->s.scale != 0.0f)
+		offset = offset * self->s.scale;
+
+	startpoint = M_ProjectFlashSource(self, offset, f, r);
+	startpoint[2] += 10 * (self->s.scale != 0.0f ? self->s.scale : 1.0f);
+
+	vec3_t mins = { -16, -16, -24 };
+	vec3_t maxs = { 16,  16,  32 };
+
+	static const char* skill0_monsters[] = {
+		"monster_soldier_light",
+		"monster_psoldier_light"
+	};
+
+	static const char* skill1_monsters[] = {
+		"monster_soldier_light",
+		"monster_psoldier_light",
+		"monster_soldier_cobalt"
+	};
+
+	static const char* skill2_monsters[] = {
+		"monster_soldier_cobalt",
+		"monster_soldier_hypergun",
+		"monster_soldier_ripper"
+	};
+
+	static const char* skill3_monsters[] = {
+		"monster_soldier_hypergun",
+		"monster_soldier_ripper",
+		"monster_soldier_elite",
+		"monster_soldier_special"
+	};
+
+	const char** monster_types = nullptr;
+	int monster_count = 0;
+
+	switch (skill->integer)
+	{
+	case 0:
+		monster_types = skill0_monsters;
+		monster_count = sizeof(skill0_monsters) / sizeof(skill0_monsters[0]);
+		break;
+	case 1:
+		monster_types = skill1_monsters;
+		monster_count = sizeof(skill1_monsters) / sizeof(skill1_monsters[0]);
+		break;
+	case 2:
+		monster_types = skill2_monsters;
+		monster_count = sizeof(skill2_monsters) / sizeof(skill2_monsters[0]);
+		break;
+	default:
+		monster_types = skill3_monsters;
+		monster_count = sizeof(skill3_monsters) / sizeof(skill3_monsters[0]);
+		break;
+	}
+
+	const char* chosen_monster = monster_types[rand() % monster_count];
+
+	if (FindSpawnPoint(startpoint, mins, maxs, spawnpoint, 32))
+	{
+		if (CheckGroundSpawnPoint(spawnpoint, mins, maxs, 256, -1))
+		{
+			edict_t* ent = CreateGroundMonster(spawnpoint, self->s.angles, mins, maxs, chosen_monster, 256);
+
+			if (!ent)
+			{
+				return;
+			}
+
+			ent->nextthink = level.time;
+			ent->think(ent);
+
+			gi.sound(ent, CHAN_AUTO, gi.soundindex("medic_commander/monsterspawn1.wav"), 1.0f, ATTN_NORM, 0.0f);
+
+			if (self->enemy && self->enemy->inuse && self->enemy->health > 0)
+			{
+				ent->enemy = self->enemy;
+				FoundTarget(ent);
+			}
+
+			vec3_t center;
+			center = mins + maxs;
+			center = spawnpoint + (center * 1.0f);
+			float radius = maxs.length() * 0.5f;
+			SpawnGrow_Spawn(center, radius, radius * 2.0f);
+		}
+	}
+
+	dropper_remove(self);
+}
+
+void fire_dropper(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int speed)
+{
+	edict_t* dropper;
+	vec3_t	 dir;
+	vec3_t	 forward, right, up;
+
+	dir = vectoangles(aimdir);
+	AngleVectors(dir, forward, right, up);
+
+	dropper = G_Spawn();
+	dropper->s.origin = start;
+	dropper->velocity = aimdir * speed;
+
+	float gravityAdjustment = level.gravity / 800.f;
+
+	dropper->velocity += up * (200 + crandom() * 10.0f) * gravityAdjustment;
+	dropper->velocity += right * (crandom() * 10.0f);
+
+	dropper->s.angles = {};
+	dropper->movetype = MOVETYPE_BOUNCE;
+	dropper->solid = SOLID_BBOX;
+	dropper->s.effects |= EF_GRENADE;
+	dropper->s.renderfx |= RF_IR_VISIBLE;
+	dropper->mins = { -16, -16, -24 };
+	dropper->maxs = { 16, 16, 32 };
+	dropper->s.modelindex = gi.modelindex("models/objects/dopplebase/tris.md2");
+	dropper->owner = self;
+	dropper->teammaster = self;
+
+	dropper->enemy = self->enemy; // Needed later for targeting
+
+	dropper->wait = (level.time + DROPPER_TIME_TO_LIVE).seconds();
+	dropper->think = dropper_think;
+	dropper->nextthink = level.time + DROPPER_ACTIVATE_TIME;
+
+	// blow up on contact with lava & slime code
+	dropper->touch = dropper_lava;
+
+	if (deathmatch->integer)
+		// PMM - lowered from 50 - 7/29/1998
+		dropper->health = 20;
+	else
+		dropper->health = 50; // FIXME - change depending on skill?
+
+	dropper->takedamage = true;
+	dropper->die = dropper_die;
+	dropper->classname = "teleport_dropper";
+	dropper->flags |= (FL_DAMAGEABLE | FL_TRAP);
+	dropper->clipmask = (MASK_PROJECTILE | CONTENTS_SLIME | CONTENTS_LAVA) & ~CONTENTS_DEADMONSTER;
+
+	// [Paril-KEX]
+	if (self->client && !G_ShouldPlayersCollide(true))
+		dropper->clipmask &= ~CONTENTS_PLAYER;
+
+	dropper->flags |= FL_MECHANICAL;
+
+	gi.linkentity(dropper);
+}
+
+
+//For enemies weak/strong only to energy weapons
+bool IsEnergyWeapon(const mod_t& mod)
+{
+	switch (mod.id)
+	{
+	case MOD_BLASTER:
+	case MOD_TESLA:
+	case MOD_HYPERBLASTER:
+	case MOD_RIPPER:
+	case MOD_HEATBEAM:
+	case MOD_PHALANX:
+	case MOD_BFG_LASER:
+	case MOD_BFG_BLAST:
+	case MOD_BFG_EFFECT:
+//	case MOD_SONICCANNON:
+//	case MOD_DISCHARGER:
+	case MOD_DEFENDER_SPHERE:
+	case MOD_TARGET_LASER:
+	case MOD_TARGET_BLASTER:
+	case MOD_BLASTER2:
+	case MOD_BLUEBLASTER:
+		return true;
+	default:
+		return false;
+	}
+}
+
+//For enemies weak/strong only to energy weapons
+bool IsExplosiveWeapon(const mod_t& mod)
+{
+	switch (mod.id)
+	{
+	case MOD_GRENADE:
+	case MOD_G_SPLASH:
+	case MOD_ROCKET:
+	case MOD_R_SPLASH:
+	case MOD_HANDGRENADE:
+	case MOD_HG_SPLASH:
+	case MOD_HELD_GRENADE:
+	case MOD_EXPLOSIVE:
+	case MOD_BARREL:
+	case MOD_BOMB:
+	case MOD_PHALANX:
+//	case MOD_SONICCANNON:
+	case MOD_PROX:
+	case MOD_NUKE:
+	case MOD_DOPPLE_EXPLODE:
+//	case MOD_A2K:
+//	case MOD_TRIPBOMB:
+	case MOD_HUNTER_SPHERE:
+		return true;
+	default:
+		return false;
+	}
+}
--- /dev/null
+++ b/ionized/g_ionized_target.cpp	2025-09-04 19:53:48
@@ -0,0 +1,244 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+/*QUAKED target_shooter_blaster (1 0 0) (-8 -8 -8) (8 8 8) NOTRAIL NOEFFECTS BLUEBLASTER GREENBLASTER NAILS RIPPER
+Fires a projectile attack in the set direction when triggered.
+
+dmg		default is 15
+speed	default is 1000
+volume	default is 0.75
+*/
+/* KONIG - spawnflags for alternative projectiles; sound variable by volume entity key; default to 0.75*/
+constexpr spawnflags_t SPAWNFLAG_BLASTER_NOTRAIL = 1_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_BLASTER_NOEFFECTS = 2_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_BLASTER_BLUEBLASTER = 4_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_BLASTER_GREENBLASTER = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_BLASTER_NAILS = 16_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_BLASTER_RIPPER = 32_spawnflag;
+
+USE(use_target_shooter_blaster) (edict_t* self, edict_t* other, edict_t* activator) -> void
+{
+	effects_t effect;
+
+	if (self->spawnflags.has(SPAWNFLAG_BLASTER_NOEFFECTS))
+		effect = EF_NONE;
+	else if (self->spawnflags.has(SPAWNFLAG_BLASTER_NOTRAIL))
+		effect = EF_HYPERBLASTER;
+	else
+		effect = EF_BLASTER;
+
+	if (self->spawnflags.has(SPAWNFLAG_BLASTER_NAILS))
+	{
+		self->spawnflags |= SPAWNFLAG_BLASTER_NOEFFECTS;
+		fire_flechette(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, effect);
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_BLASTER_RIPPER))
+	{
+		self->spawnflags |= SPAWNFLAG_BLASTER_NOEFFECTS;
+		fire_ionripper(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, EF_IONRIPPER);
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_BLASTER_BLUEBLASTER))
+	{
+		fire_blueblaster(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, EF_BLUEHYPERBLASTER);
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_BLASTER_GREENBLASTER))
+	{
+		fire_blaster2(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, effect, MOD_TARGET_BLASTER);
+	}
+	else
+	{
+		fire_blaster(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, effect, MOD_TARGET_BLASTER);
+	}
+
+	gi.sound(self, CHAN_VOICE, self->noise_index, self->volume, ATTN_NORM, 0);
+}
+
+void SP_target_shooter_blaster(edict_t* self)
+{
+	self->use = use_target_shooter_blaster;
+	G_SetMovedir(self->s.angles, self->movedir);
+	if (self->spawnflags.has(SPAWNFLAG_BLASTER_NAILS))
+	{
+		self->noise_index = gi.soundindex("weapons/nail1.wav");
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_BLASTER_RIPPER))
+	{
+		self->noise_index = gi.soundindex("weapons/rippfire.wav");
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_BLASTER_BLUEBLASTER))
+	{
+		self->noise_index = gi.soundindex("weapons/laser2.wav");
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_BLASTER_GREENBLASTER))
+	{
+		self->noise_index = gi.soundindex("weapons/laser2.wav");
+	}
+	else
+	{
+		self->noise_index = gi.soundindex("weapons/laser2.wav");
+	}
+
+	if (!self->dmg)
+		self->dmg = 15;
+	if (!self->speed)
+		self->speed = 1000;
+	if (!self->volume)
+		self->volume = 0.75;
+
+	self->svflags = SVF_NOCLIENT;
+}
+
+//==========================================================
+
+/*QUAKED target_shooter_rockets (1 0 0) (-8 -8 -8) (8 8 8) GRENADE PHALANX BFG
+Fires an explosive projectile in the set direction when triggered.
+
+dmg		default is 15
+speed	default is 1000
+volume  default is 0.75
+*/
+constexpr spawnflags_t SPAWNFLAG_GRENADE = 1_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_PHALANX = 2_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_BFG = 4_spawnflag;
+
+USE(use_target_shooter_rockets) (edict_t* self, edict_t* other, edict_t* activator) -> void
+{
+	if (self->spawnflags.has(SPAWNFLAG_GRENADE))
+	{
+		fire_grenade(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, 2.5_sec, self->dmg, (crandom_open() * 10.0f), (200 + crandom_open() * 10.0f), true);
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_PHALANX))
+	{
+		fire_plasma(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, 120, 30);
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_BFG))
+	{
+		fire_bfg(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, 1000);
+	}
+	else
+	{
+		fire_rocket(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, self->dmg, self->dmg);
+	}
+
+	gi.sound(self, CHAN_VOICE, self->noise_index, self->volume, ATTN_NORM, 0);
+}
+
+void SP_target_shooter_rockets(edict_t* self)
+{
+	self->use = use_target_shooter_rockets;
+	G_SetMovedir(self->s.angles, self->movedir);
+
+	if (self->spawnflags.has(SPAWNFLAG_GRENADE))
+	{
+		self->noise_index = gi.soundindex("weapons/grenlf1a.wav");
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_PHALANX))
+	{
+		self->noise_index = gi.soundindex("weapons/plasshot.wav");
+		if (!self->dmg)
+			self->dmg = 80;
+		if (!self->speed)
+			self->speed = 725;
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_BFG))
+	{
+		self->noise_index = gi.soundindex("makron/bfg_fire.wav");
+		if (!self->dmg)
+			self->dmg = deathmatch->integer ? 200 : 500;;
+		if (!self->speed)
+			self->speed = 400;
+	}
+	else
+	{
+		self->noise_index = gi.soundindex("weapons/rocklf1a.wav");
+		if (!self->dmg)
+			self->dmg = 120;
+		if (!self->speed)
+			self->speed = 600;
+	}
+
+	if (!self->volume)
+		self->volume = 0.75;
+
+	self->svflags = SVF_NOCLIENT;
+}
+
+//==========================================================
+
+/*QUAKED target_shooter_magic (1 0 0) (-8 -8 -8) (8 8 8) GRENADE PHALANX BFG
+Fires an explosive projectile in the set direction when triggered.
+
+dmg		default is 15
+speed	default is 1000
+volume  default is 0.75
+*/
+constexpr spawnflags_t SPAWNFLAG_FLAME = 1_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_VOREPOD = 2_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_WRATHPOD = 4_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_PLASMABALL = 8_spawnflag;
+
+USE(use_target_shooter_magic) (edict_t* self, edict_t* other, edict_t* activator) -> void
+{
+	if (self->spawnflags.has(SPAWNFLAG_FLAME))
+	{
+		fire_flame(self, self->s.origin, self->movedir, self->dmg, (int)self->speed);
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_VOREPOD))
+	{
+		fire_vorepod(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, 120, 30, 0, 0);
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_WRATHPOD))
+	{
+		fire_vorepod(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, 120, 30, 0, 1);
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_PLASMABALL))
+	{
+		fire_plasmaball(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, 1000);
+	}
+	else
+	{
+		fire_rocket(self, self->s.origin, self->movedir, self->dmg, (int)self->speed, self->dmg, self->dmg);
+	}
+
+	gi.sound(self, CHAN_VOICE, self->noise_index, self->volume, ATTN_NORM, 0);
+}
+
+void SP_target_shooter_magic(edict_t* self)
+{
+	self->use = use_target_shooter_magic;
+	G_SetMovedir(self->s.angles, self->movedir);
+
+	if (self->spawnflags.has(SPAWNFLAG_GRENADE))
+	{
+		self->noise_index = gi.soundindex("weapons/grenlf1a.wav");
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_PHALANX))
+	{
+		self->noise_index = gi.soundindex("weapons/plasshot.wav");
+		if (!self->dmg)
+			self->dmg = 80;
+		if (!self->speed)
+			self->speed = 725;
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_BFG))
+	{
+		self->noise_index = gi.soundindex("makron/bfg_fire.wav");
+		if (!self->dmg)
+			self->dmg = deathmatch->integer ? 200 : 500;;
+		if (!self->speed)
+			self->speed = 400;
+	}
+	else
+	{
+		self->noise_index = gi.soundindex("weapons/rocklf1a.wav");
+		if (!self->dmg)
+			self->dmg = 120;
+		if (!self->speed)
+			self->speed = 600;
+	}
+
+	if (!self->volume)
+		self->volume = 0.75;
+
+	self->svflags = SVF_NOCLIENT;
+}
--- /dev/null
+++ b/ionized/g_ionized_weapon.cpp	2025-09-04 19:53:48
@@ -0,0 +1,334 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+
+/*
+=================
+fire_disintegrator
+=================
+*/
+
+THINK(Dist_Gib_Think) (edict_t* ent) -> void
+{
+	if (ent->owner->s.frame != 5)
+	{
+		G_FreeEdict(ent);
+		return;
+	}
+
+	vec3_t forward, right, up;
+	vec3_t vec;
+
+	AngleVectors(ent->owner->s.angles, forward, right, up);
+
+	// rotate us around the center
+	float degrees = (720.f * gi.frame_time_s) + ent->owner->delay;
+	vec3_t diff = ent->owner->s.origin - ent->s.origin;
+
+	float max_radius = 64.f;
+	float current_radius = diff.length();
+
+	if (current_radius > max_radius)
+	{
+		diff.normalize();
+		diff *= max_radius;
+	}
+
+	vec = RotatePointAroundVector(up, diff, degrees);
+	ent->s.angles[1] += degrees;
+	vec3_t new_origin = ent->owner->s.origin - vec;
+
+	trace_t tr = gi.traceline(ent->s.origin, new_origin, ent, MASK_SOLID);
+	ent->s.origin = tr.endpos;
+
+	// pull us towards the trap's center
+//	diff.normalize();
+	//ent->s.origin += diff * (15.0f * gi.frame_time_s);
+
+	ent->watertype = gi.pointcontents(ent->s.origin);
+	if (ent->watertype & MASK_WATER)
+		ent->waterlevel = WATER_FEET;
+
+	ent->nextthink = level.time + FRAME_TIME_S;
+	gi.linkentity(ent);
+}
+
+TOUCH(dist_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (other == self->owner)
+		return;
+
+	if (other->svflags & SVF_MONSTER || other->client) {
+		return;
+	}
+
+	if (tr.surface && (tr.surface->flags & SURF_SKY))
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	if (self->owner->client)
+		PlayerNoise(self->owner, self->s.origin, PNOISE_IMPACT);
+
+	// core explosion - prevents firing it into the wall/floor
+	if (other->takedamage)
+		T_Damage(other, self, self->owner, self->velocity, self->s.origin, tr.plane.normal, 200, 0, DAMAGE_ENERGY, MOD_BFG_BLAST);
+	T_RadiusDamage(self, self->owner, 200, other, 100, DAMAGE_ENERGY, MOD_BFG_BLAST);
+
+	gi.sound(self, CHAN_VOICE, gi.soundindex("weapons/dist/energy_burst.wav"), 1, ATTN_NORM, 0);
+	self->solid = SOLID_NOT;
+	self->touch = nullptr;
+	self->s.origin += self->velocity * (-1 * gi.frame_time_s);
+	self->velocity = {};
+	self->enemy = other;
+
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_TRACKER_EXPLOSION);
+	gi.WritePosition(self->s.origin);
+	gi.multicast(self->s.origin, MULTICAST_PHS, false);
+
+	self->nextthink = level.time;
+	self->think = G_FreeEdict;
+}
+
+THINK(dist_think) (edict_t* ent) -> void
+{
+	edict_t* target = nullptr;
+	edict_t* best = nullptr;
+	vec3_t	 vec;
+	float	 len;
+	float	 oldlen = 8000;
+
+	while ((target = findradius(target, ent->s.origin, 256)) != nullptr)
+	{
+		if (target == ent)
+			continue;
+
+		if (!(target->svflags & SVF_MONSTER) && !target->client)
+			continue;
+		if (target != ent->teammaster && CheckTeamDamage(target, ent->teammaster))
+			continue;
+		// [Paril-KEX]
+		if (!deathmatch->integer && target->client)
+			continue;
+		if (target->health <= 0)
+			continue;
+		if (!visible(ent, target))
+			continue;
+		vec = ent->s.origin - target->s.origin;
+		len = vec.length();
+		if (!best)
+		{
+			best = target;
+			oldlen = len;
+			continue;
+		}
+		if (len < oldlen)
+		{
+			oldlen = len;
+			best = target;
+		}
+	}
+
+	// pull the enemy in
+	if (best)
+	{
+		if (best->groundentity)
+		{
+			best->s.origin[2] += 1;
+			best->groundentity = nullptr;
+		}
+		vec = ent->s.origin - best->s.origin;
+		len = vec.normalize();
+
+		float max_speed = best->client ? 290.f : 150.f;
+		float distance = (ent->s.origin - best->s.origin).length();
+		float pull_strength = clamp((512.f - distance) / 512.f, 0.2f, 1.f); // scale down with distance
+		float pull_speed = (best->client ? 300.f : 200.f) * pull_strength;
+		if (best->mass <= 400)
+		{
+			float mass_factor = clamp(1.0f / (best->mass * 0.0005f), 0.3f, 2.0f);
+			best->velocity = vec * (pull_speed * mass_factor);
+		}
+		else
+		{
+			float mass_factor = clamp(1.0f / (best->mass * 0.005f), 0.2f, 1.0f);
+			best->velocity = vec * (pull_speed * mass_factor);
+		}
+
+		//	best->velocity += (vec * clamp(max_speed - len, 64.f, max_speed));
+
+		ent->s.sound = gi.soundindex("weapons/trapsuck.wav");
+
+		if (len < 48)
+		{
+			if (best->mass <= 400)
+			{
+				ent->takedamage = false;
+				ent->die = nullptr;
+
+				T_Damage(best, ent, ent->teammaster, vec3_origin, best->s.origin, vec3_origin, 100000, 1, DAMAGE_NONE, MOD_TRAP);
+
+				if (best->svflags & SVF_MONSTER)
+					M_ProcessPain(best);
+
+				ent->enemy = best;
+				ent->wait = 64;
+				ent->s.old_origin = ent->s.origin;
+				ent->timestamp = level.time + 30_sec;
+				ent->accel = best->mass;
+				if (deathmatch->integer)
+					ent->mass = best->mass / 4;
+				else
+					ent->mass = best->mass / 10;
+				// ok spawn the food cube
+				ent->s.frame = 5;
+
+				// link up any gibs that this monster may have spawned
+				for (uint32_t i = 0; i < globals.num_edicts; i++)
+				{
+					edict_t* e = &g_edicts[i];
+
+					if (!e->inuse)
+						continue;
+					else if (strcmp(e->classname, "gib"))
+						continue;
+					else if ((e->s.origin - ent->s.origin).length() > 128.f)
+						continue;
+
+					e->movetype = MOVETYPE_NONE;
+					e->nextthink = level.time + FRAME_TIME_S;
+					e->think = Dist_Gib_Think;
+					e->owner = ent;
+					Dist_Gib_Think(e);
+				}
+			}
+			else
+			{
+				ent->takedamage = false;
+				ent->die = nullptr;
+
+				T_Damage(best, ent, ent->teammaster, vec3_origin, best->s.origin, vec3_origin, 10, 1, DAMAGE_NONE, MOD_TRAP);
+
+				if (best->svflags & SVF_MONSTER)
+					M_ProcessPain(best);
+
+				ent->enemy = best;
+				ent->wait = 64;
+				ent->s.old_origin = ent->s.origin;
+				ent->timestamp = level.time + 30_sec;
+				ent->accel = best->mass;
+				if (deathmatch->integer)
+					ent->mass = best->mass / 4;
+				else
+					ent->mass = best->mass / 10;
+				// ok spawn the food cube
+				ent->s.frame = 5;
+
+				// link up any gibs that this monster may have spawned
+				for (uint32_t i = 0; i < globals.num_edicts; i++)
+				{
+					edict_t* e = &g_edicts[i];
+
+					if (!e->inuse)
+						continue;
+					else if (strcmp(e->classname, "gib"))
+						continue;
+					else if ((e->s.origin - ent->s.origin).length() > 128.f)
+						continue;
+
+					e->movetype = MOVETYPE_NONE;
+					e->nextthink = level.time + FRAME_TIME_S;
+					e->think = Dist_Gib_Think;
+					e->owner = ent;
+					Dist_Gib_Think(e);
+				}
+			}
+		}
+	}
+
+	ent->nextthink = level.time + FRAME_TIME_S;
+}
+
+void fire_disintegrator(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, float damage_radius)
+{
+	edict_t* dist;
+
+	dist = G_Spawn();
+	dist->s.origin = start;
+	dist->s.angles = vectoangles(dir);
+	dist->velocity = dir * speed;
+	dist->movetype = MOVETYPE_FLYMISSILE;
+	dist->clipmask = MASK_SOLID;
+	dist->svflags = SVF_PROJECTILE;
+	// [Paril-KEX]
+	if (self->client && !G_ShouldPlayersCollide(true))
+		dist->clipmask &= ~CONTENTS_PLAYER;
+	dist->solid = SOLID_BBOX;
+	dist->s.effects |= EF_TRACKER | EF_ROTATE;
+	dist->s.modelindex = gi.modelindex("models/items/spawngro3/tris.md2");
+	dist->s.alpha = 0.75;
+	dist->s.skinnum = 1;
+	dist->s.frame = 2;
+	dist->owner = self;
+	dist->touch = dist_touch;
+	dist->nextthink = level.time + gtime_t::from_sec(8000.f / speed);
+	dist->think = G_FreeEdict;
+	dist->radius_dmg = damage;
+	dist->dmg_radius = damage_radius;
+	dist->classname = "dist blast";
+	dist->s.sound = gi.soundindex("weapons/dist/energy_loop.wav");
+
+	dist->nextthink = level.time + FRAME_TIME_S;
+	dist->think = dist_think;
+	dist->teammaster = dist;
+	dist->teamchain = nullptr;
+
+	gi.linkentity(dist);
+}
+
+/*
+=================
+fire_lightning
+
+Fires a single lightning  bolt. Used by the discharger.
+=================
+*/
+
+void fire_lightning(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, effects_t effect)
+{
+	edict_t* bolt;
+	trace_t	 tr;
+
+	bolt = G_Spawn();
+	bolt->s.origin = start;
+	bolt->s.old_origin = start;
+	bolt->s.angles = vectoangles(dir);
+	bolt->velocity = dir * speed;
+	bolt->svflags |= SVF_PROJECTILE;
+	bolt->movetype = MOVETYPE_FLYMISSILE;
+	bolt->flags |= FL_DODGE;
+	bolt->clipmask = MASK_PROJECTILE;
+	bolt->solid = SOLID_BBOX;
+	bolt->s.effects |= effect;
+	bolt->s.modelindex = gi.modelindex("models/proj/lightning/tris.md2");
+	bolt->s.skinnum = 1;
+	bolt->s.sound = gi.soundindex("weapons/tesla.wav");
+	bolt->owner = self;
+	bolt->touch = blaster_touch;
+	bolt->nextthink = level.time + 2_sec;
+	bolt->think = G_FreeEdict;
+	bolt->dmg = damage;
+	bolt->classname = "bolt";
+	bolt->style = MOD_BLUEBLASTER;
+	gi.linkentity(bolt);
+
+	tr = gi.traceline(self->s.origin, bolt->s.origin, bolt, bolt->clipmask);
+
+	if (tr.fraction < 1.0f)
+	{
+		bolt->s.origin = tr.endpos + (tr.plane.normal * 1.f);
+		bolt->touch(bolt, tr.ent, tr, false);
+	}
+}
--- /dev/null
+++ b/ionized/m_gnorta.cpp	2025-09-04 19:53:48
@@ -0,0 +1,1040 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+gnorta
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_gnorta.h"
+#include <float.h>
+
+constexpr spawnflags_t SPAWNFLAG_GNORTA_ONROOF = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_GNORTA_NOJUMPING = 16_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_GNORTA_NOSWIM = 32_spawnflag;
+
+static cached_soundindex sound_pain;
+static cached_soundindex sound_die;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_punch_hit1;
+static cached_soundindex sound_punch_hit2;
+static cached_soundindex sound_idle;
+
+bool gnorta_do_pounce(edict_t* self, const vec3_t& dest);
+void gnorta_walk(edict_t* self);
+void gnorta_dodge_jump(edict_t* self);
+void gnorta_swing_attack(edict_t* self);
+void gnorta_jump_straightup(edict_t* self);
+void gnorta_jump_wait_land(edict_t* self);
+void gnorta_false_death(edict_t* self);
+void gnorta_false_death_start(edict_t* self);
+bool gnorta_ok_to_transition(edict_t* self);
+void gnorta_stand(edict_t* self);
+
+inline bool GNORTA_ON_CEILING(edict_t* ent)
+{
+	return (ent->gravityVector[2] > 0);
+}
+
+//=========================
+//=========================
+bool gnorta_ok_to_transition(edict_t* self)
+{
+	trace_t trace;
+	vec3_t	pt, start;
+	float	max_dist;
+	float	margin;
+	float	end_height;
+
+	if (GNORTA_ON_CEILING(self))
+	{
+		// [Paril-KEX] if we get knocked off the ceiling, always
+		// fall downwards
+		if (!self->groundentity)
+			return true;
+
+		max_dist = -384;
+		margin = self->mins[2] - 8;
+	}
+	else
+	{
+		max_dist = 180;
+		margin = self->maxs[2] + 8;
+	}
+
+	pt = self->s.origin;
+	pt[2] += max_dist;
+	trace = gi.trace(self->s.origin, self->mins, self->maxs, pt, self, MASK_MONSTERSOLID);
+
+	if (trace.fraction == 1.0f ||
+		!(trace.contents & CONTENTS_SOLID) ||
+		(trace.ent != world))
+	{
+		if (GNORTA_ON_CEILING(self))
+		{
+			if (trace.plane.normal[2] < 0.9f)
+				return false;
+		}
+		else
+		{
+			if (trace.plane.normal[2] > -0.9f)
+				return false;
+		}
+	}
+
+	end_height = trace.endpos[2];
+
+	// check the four corners, tracing only to the endpoint of the center trace (vertically).
+	pt[0] = self->absmin[0];
+	pt[1] = self->absmin[1];
+	pt[2] = trace.endpos[2] + margin; // give a little margin of error to allow slight inclines
+	start = pt;
+	start[2] = self->s.origin[2];
+	trace = gi.traceline(start, pt, self, MASK_MONSTERSOLID);
+	if (trace.fraction == 1.0f || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
+		return false;
+	if (fabsf(end_height + margin - trace.endpos[2]) > 8)
+		return false;
+
+	pt[0] = self->absmax[0];
+	pt[1] = self->absmin[1];
+	start = pt;
+	start[2] = self->s.origin[2];
+	trace = gi.traceline(start, pt, self, MASK_MONSTERSOLID);
+	if (trace.fraction == 1.0f || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
+		return false;
+	if (fabsf(end_height + margin - trace.endpos[2]) > 8)
+		return false;
+
+	pt[0] = self->absmax[0];
+	pt[1] = self->absmax[1];
+	start = pt;
+	start[2] = self->s.origin[2];
+	trace = gi.traceline(start, pt, self, MASK_MONSTERSOLID);
+	if (trace.fraction == 1.0f || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
+		return false;
+	if (fabsf(end_height + margin - trace.endpos[2]) > 8)
+		return false;
+
+	pt[0] = self->absmin[0];
+	pt[1] = self->absmax[1];
+	start = pt;
+	start[2] = self->s.origin[2];
+	trace = gi.traceline(start, pt, self, MASK_MONSTERSOLID);
+	if (trace.fraction == 1.0f || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
+		return false;
+	if (fabsf(end_height + margin - trace.endpos[2]) > 8)
+		return false;
+
+	return true;
+}
+
+//=========================
+//=========================
+MONSTERINFO_SIGHT(gnorta_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+// ******************
+// IDLE
+// ******************
+
+void gnorta_idle_noise(edict_t* self)
+{
+	gi.sound(self, CHAN_VOICE, sound_idle, 0.5, ATTN_IDLE, 0);
+}
+
+mframe_t gnorta_frames_idle[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand, 0, gnorta_idle_noise },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand }
+};
+MMOVE_T(gnorta_move_idle) = { FRAME_idle01, FRAME_idle21, gnorta_frames_idle, gnorta_stand };
+
+mframe_t gnorta_frames_idle2[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(gnorta_move_idle2) = { FRAME_idle201, FRAME_idle213, gnorta_frames_idle2, gnorta_stand };
+
+MONSTERINFO_IDLE(gnorta_idle) (edict_t* self) -> void
+{
+	if (frandom() < 0.35f)
+		M_SetAnimation(self, &gnorta_move_idle);
+	else
+		M_SetAnimation(self, &gnorta_move_idle2);
+}
+
+// ******************
+// STAND
+// ******************
+
+mframe_t gnorta_frames_stand[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand, 0, gnorta_idle_noise },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand }
+};
+MMOVE_T(gnorta_move_stand) = { FRAME_idle01, FRAME_idle21, gnorta_frames_stand, gnorta_stand };
+
+MONSTERINFO_STAND(gnorta_stand) (edict_t* self) -> void
+{
+	if (frandom() < 0.25f)
+		M_SetAnimation(self, &gnorta_move_stand);
+	else
+		M_SetAnimation(self, &gnorta_move_idle2);
+}
+
+// ******************
+// RUN
+// ******************
+
+mframe_t gnorta_frames_run[] = {
+	{ ai_run, 13, monster_footstep },
+	{ ai_run, 17 },
+	{ ai_run, 21, monster_footstep },
+	{ ai_run, 18 }
+};
+MMOVE_T(gnorta_move_run) = { FRAME_run01, FRAME_run04, gnorta_frames_run, nullptr };
+
+MONSTERINFO_RUN(gnorta_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &gnorta_move_stand);
+	else
+		M_SetAnimation(self, &gnorta_move_run);
+}
+
+// ******************
+// WALK
+// ******************
+
+mframe_t gnorta_frames_walk[] = {
+	{ ai_walk, 4, monster_footstep },
+	{ ai_walk, 6 },
+	{ ai_walk, 8 },
+	{ ai_walk, 5 },
+
+	{ ai_walk, 4, monster_footstep },
+	{ ai_walk, 6 },
+	{ ai_walk, 8 },
+	{ ai_walk, 4 }
+};
+MMOVE_T(gnorta_move_walk) = { FRAME_walk01, FRAME_walk08, gnorta_frames_walk, gnorta_walk };
+
+MONSTERINFO_WALK(gnorta_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &gnorta_move_walk);
+}
+
+// ******************
+// false death
+// ******************
+mframe_t gnorta_frames_reactivate[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, monster_footstep }
+};
+MMOVE_T(gnorta_move_false_death_end) = { FRAME_reactive01, FRAME_reactive04, gnorta_frames_reactivate, gnorta_run };
+
+void gnorta_reactivate(edict_t* self)
+{
+	self->monsterinfo.aiflags &= ~AI_STAND_GROUND;
+	M_SetAnimation(self, &gnorta_move_false_death_end);
+}
+
+void gnorta_heal(edict_t* self)
+{
+	if (skill->integer == 2)
+		self->health += 2;
+	else if (skill->integer == 3)
+		self->health += 3;
+	else
+		self->health++;
+
+	self->monsterinfo.setskin(self);
+
+	if (self->health >= self->max_health)
+	{
+		self->health = self->max_health;
+		gnorta_reactivate(self);
+	}
+}
+
+mframe_t gnorta_frames_false_death[] = {
+	{ ai_move, 0, gnorta_heal },
+	{ ai_move, 0, gnorta_heal },
+	{ ai_move, 0, gnorta_heal },
+	{ ai_move, 0, gnorta_heal },
+	{ ai_move, 0, gnorta_heal },
+
+	{ ai_move, 0, gnorta_heal },
+	{ ai_move, 0, gnorta_heal },
+	{ ai_move, 0, gnorta_heal },
+	{ ai_move, 0, gnorta_heal },
+	{ ai_move, 0, gnorta_heal }
+};
+MMOVE_T(gnorta_move_false_death) = { FRAME_twitch01, FRAME_twitch10, gnorta_frames_false_death, gnorta_false_death };
+
+void gnorta_false_death(edict_t* self)
+{
+	M_SetAnimation(self, &gnorta_move_false_death);
+}
+
+mframe_t gnorta_frames_false_death_start[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+};
+MMOVE_T(gnorta_move_false_death_start) = { FRAME_death01, FRAME_death09, gnorta_frames_false_death_start, gnorta_false_death };
+
+void gnorta_false_death_start(edict_t* self)
+{
+	self->s.angles[2] = 0;
+	self->gravityVector = { 0, 0, -1 };
+
+	self->monsterinfo.aiflags |= AI_STAND_GROUND;
+	M_SetAnimation(self, &gnorta_move_false_death_start);
+}
+
+// ******************
+// PAIN
+// ******************
+
+mframe_t gnorta_frames_pain[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(gnorta_move_pain) = { FRAME_pain01, FRAME_pain04, gnorta_frames_pain, gnorta_run };
+
+PAIN(gnorta_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (self->deadflag)
+		return;
+
+	if (self->groundentity == nullptr)
+		return;
+
+	// if we're reactivating or false dying, ignore the pain.
+	if (self->monsterinfo.active_move == &gnorta_move_false_death_end ||
+		self->monsterinfo.active_move == &gnorta_move_false_death_start)
+		return;
+
+	if (self->monsterinfo.active_move == &gnorta_move_false_death)
+	{
+		gnorta_reactivate(self);
+		return;
+	}
+
+	if ((self->health > 0) && (self->health < (self->max_health / 4)))
+	{
+		if (frandom() < 0.30f)
+		{
+			if (!GNORTA_ON_CEILING(self) || gnorta_ok_to_transition(self))
+			{
+				gnorta_false_death_start(self);
+				return;
+			}
+		}
+	}
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	if (mod.id == MOD_CHAINFIST || damage > 10) // don't react unless the damage was significant
+	{
+		// gnorta should dodge jump periodically to help avoid damage.
+		if (self->groundentity && (frandom() < 0.5f))
+			gnorta_dodge_jump(self);
+		else if (M_ShouldReactToPain(self, mod)) // no pain anims in nightmare
+			M_SetAnimation(self, &gnorta_move_pain);
+	}
+}
+
+MONSTERINFO_SETSKIN(gnorta_setskin) (edict_t* self) -> void
+{
+	/* KONIG - allow multiple skins */
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+// ******************
+// GNORTA ATTACK
+// ******************
+
+void gnorta_shoot_attack(edict_t* self)
+{
+	vec3_t	offset, start, f, r, dir;
+	vec3_t	end;
+	float	dist;
+	trace_t trace;
+
+	if (!has_valid_enemy(self))
+		return;
+
+	if (self->groundentity && frandom() < 0.33f)
+	{
+		dir = self->enemy->s.origin - self->s.origin;
+		dist = dir.length();
+
+		if ((dist > 256) || (frandom() < 0.5f))
+			gnorta_do_pounce(self, self->enemy->s.origin);
+		else
+			gnorta_jump_straightup(self);
+	}
+
+	AngleVectors(self->s.angles, f, r, nullptr);
+	offset = { 24, 0, 6 };
+	start = M_ProjectFlashSource(self, offset, f, r);
+
+	dir = self->enemy->s.origin - start;
+	if (frandom() < 0.3f)
+		PredictAim(self, self->enemy, start, 1000, true, 0, &dir, &end);
+	else
+		end = self->enemy->s.origin;
+
+	trace = gi.traceline(start, end, self, MASK_PROJECTILE);
+	if (trace.ent == self->enemy || trace.ent == world)
+	{
+		dir.normalize();
+		//fire_acid(self, start, dir, 5, 550);
+	}
+}
+
+void gnorta_shoot_attack2(edict_t* self)
+{
+	if (frandom() < 0.5)
+		gnorta_shoot_attack(self);
+}
+
+mframe_t gnorta_frames_shoot[] = {
+	{ ai_charge, 13 },
+	{ ai_charge, 17, gnorta_shoot_attack },
+	{ ai_charge, 21 },
+	{ ai_charge, 18, gnorta_shoot_attack2 }
+};
+MMOVE_T(gnorta_move_shoot) = { FRAME_run01, FRAME_run04, gnorta_frames_shoot, gnorta_run };
+
+MONSTERINFO_ATTACK(gnorta_attack_ranged) (edict_t* self) -> void
+{
+	if (!has_valid_enemy(self))
+		return;
+
+	// PMM - circle strafe stuff
+	if (frandom() > 0.5f)
+	{
+		self->monsterinfo.attack_state = AS_STRAIGHT;
+	}
+	else
+	{
+		if (frandom() <= 0.5f) // switch directions
+			self->monsterinfo.lefty = !self->monsterinfo.lefty;
+		self->monsterinfo.attack_state = AS_SLIDING;
+	}
+	M_SetAnimation(self, &gnorta_move_shoot);
+}
+
+// ******************
+// close combat
+// ******************
+
+void gnorta_swing_attack(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, 0, 0 };
+	if (fire_hit(self, aim, irandom(5, 10), 50))
+	{
+		if (self->s.frame < FRAME_attack08)
+			gi.sound(self, CHAN_WEAPON, sound_punch_hit2, 1, ATTN_NORM, 0);
+		else
+			gi.sound(self, CHAN_WEAPON, sound_punch_hit1, 1, ATTN_NORM, 0);
+	}
+	else
+		self->monsterinfo.melee_debounce_time = level.time + 0.8_sec;
+}
+
+mframe_t gnorta_frames_swing_l[] = {
+	{ ai_charge, 2 },
+	{ ai_charge, 4 },
+	{ ai_charge, 6 },
+	{ ai_charge, 10, monster_footstep },
+
+	{ ai_charge, 5, gnorta_swing_attack },
+	{ ai_charge, 5 },
+	{ ai_charge, 5 },
+	{ ai_charge, 5, monster_footstep } // gnorta_swing_check_l
+};
+MMOVE_T(gnorta_move_swing_l) = { FRAME_attack01, FRAME_attack08, gnorta_frames_swing_l, gnorta_run };
+
+mframe_t gnorta_frames_swing_r[] = {
+	{ ai_charge, 4 },
+	{ ai_charge, 6, monster_footstep },
+	{ ai_charge, 6, gnorta_swing_attack },
+	{ ai_charge, 10 },
+	{ ai_charge, 5, monster_footstep } // gnorta_swing_check_r
+};
+MMOVE_T(gnorta_move_swing_r) = { FRAME_attack11, FRAME_attack15, gnorta_frames_swing_r, gnorta_run };
+
+MONSTERINFO_MELEE(gnorta_attack_melee) (edict_t* self) -> void
+{
+	if (!has_valid_enemy(self))
+		return;
+
+	if (frandom() < 0.5f)
+		M_SetAnimation(self, &gnorta_move_swing_l);
+	else
+		M_SetAnimation(self, &gnorta_move_swing_r);
+}
+
+// ******************
+// POUNCE
+// ******************
+
+// ====================
+// ====================
+bool gnorta_check_lz(edict_t* self, edict_t* target, const vec3_t& dest)
+{
+	if ((gi.pointcontents(dest) & MASK_WATER) || (target->waterlevel))
+		return false;
+
+	if (!target->groundentity)
+		return false;
+
+	vec3_t jumpLZ;
+
+	// check under the player's four corners
+	// if they're not solid, bail.
+	jumpLZ[0] = self->enemy->mins[0];
+	jumpLZ[1] = self->enemy->mins[1];
+	jumpLZ[2] = self->enemy->mins[2] - 0.25f;
+	if (!(gi.pointcontents(jumpLZ) & MASK_SOLID))
+		return false;
+
+	jumpLZ[0] = self->enemy->maxs[0];
+	jumpLZ[1] = self->enemy->mins[1];
+	if (!(gi.pointcontents(jumpLZ) & MASK_SOLID))
+		return false;
+
+	jumpLZ[0] = self->enemy->maxs[0];
+	jumpLZ[1] = self->enemy->maxs[1];
+	if (!(gi.pointcontents(jumpLZ) & MASK_SOLID))
+		return false;
+
+	jumpLZ[0] = self->enemy->mins[0];
+	jumpLZ[1] = self->enemy->maxs[1];
+	if (!(gi.pointcontents(jumpLZ) & MASK_SOLID))
+		return false;
+
+	return true;
+}
+
+// ====================
+// ====================
+bool gnorta_do_pounce(edict_t* self, const vec3_t& dest)
+{
+	vec3_t	dist;
+	float	length;
+	vec3_t	jumpAngles;
+	vec3_t	jumpLZ;
+	float	velocity = 400.1f;
+
+	// don't pounce when we're on the ceiling
+	if (GNORTA_ON_CEILING(self))
+		return false;
+
+	if (!gnorta_check_lz(self, self->enemy, dest))
+		return false;
+
+	dist = dest - self->s.origin;
+
+	// make sure we're pointing in that direction 15deg margin of error.
+	jumpAngles = vectoangles(dist);
+	if (fabsf(jumpAngles[YAW] - self->s.angles[YAW]) > 45)
+		return false; // not facing the player...
+
+	if (isnan(jumpAngles[YAW]))
+		return false; // Switch why
+
+	self->ideal_yaw = jumpAngles[YAW];
+	M_ChangeYaw(self);
+
+	length = dist.length();
+	if (length > 450)
+		return false; // can't jump that far...
+
+	jumpLZ = dest;
+	vec3_t dir = dist.normalized();
+
+	// find a valid angle/velocity combination
+	while (velocity <= 800)
+	{
+		if (M_CalculatePitchToFire(self, jumpLZ, self->s.origin, dir, velocity, 3, false, true))
+			break;
+
+		velocity += 200;
+	}
+
+	// nothing found
+	if (velocity > 800)
+		return false;
+
+	self->velocity = dir * velocity;
+	return true;
+}
+
+// ******************
+// DODGE
+// ******************
+
+//===================
+// gnorta_jump_straightup
+//===================
+void gnorta_jump_straightup(edict_t* self)
+{
+	if (self->deadflag)
+		return;
+
+	if (GNORTA_ON_CEILING(self))
+	{
+		if (gnorta_ok_to_transition(self))
+		{
+			self->gravityVector[2] = -1;
+			self->s.angles[2] += 180.0f;
+			if (self->s.angles[2] > 360.0f)
+				self->s.angles[2] -= 360.0f;
+			self->groundentity = nullptr;
+		}
+	}
+	else if (self->groundentity) // make sure we're standing on SOMETHING...
+	{
+		self->velocity[0] += crandom() * 5;
+		self->velocity[1] += crandom() * 5;
+		self->velocity[2] += -400 * self->gravityVector[2];
+		if (gnorta_ok_to_transition(self))
+		{
+			self->gravityVector[2] = 1;
+			self->s.angles[2] = 180.0;
+			self->groundentity = nullptr;
+		}
+	}
+}
+
+mframe_t gnorta_frames_jump_straightup[] = {
+	{ ai_move, 1, gnorta_jump_straightup },
+	{ ai_move, 1, gnorta_jump_wait_land },
+	{ ai_move, -1, monster_footstep },
+	{ ai_move, -1 }
+};
+
+MMOVE_T(gnorta_move_jump_straightup) = { FRAME_jump04, FRAME_jump07, gnorta_frames_jump_straightup, gnorta_run };
+
+//===================
+// gnorta_dodge_jump - abstraction so pain function can trigger a dodge jump too without
+//		faking the inputs to gnorta_dodge
+//===================
+void gnorta_dodge_jump(edict_t* self)
+{
+	M_SetAnimation(self, &gnorta_move_jump_straightup);
+}
+
+#if 0
+mframe_t gnorta_frames_dodge_run[] = {
+	{ ai_run, 13 },
+	{ ai_run, 17 },
+	{ ai_run, 21 },
+	{ ai_run, 18, monster_done_dodge }
+};
+MMOVE_T(gnorta_move_dodge_run) = { FRAME_run01, FRAME_run04, gnorta_frames_dodge_run, nullptr };
+#endif
+
+MONSTERINFO_DODGE(gnorta_dodge) (edict_t* self, edict_t* attacker, gtime_t eta, trace_t* tr, bool gravity) -> void
+{
+	if (!self->groundentity || self->health <= 0)
+		return;
+
+	if (!self->enemy)
+	{
+		self->enemy = attacker;
+		FoundTarget(self);
+		return;
+	}
+
+	// PMM - don't bother if it's going to hit anyway; fix for weird in-your-face etas (I was
+	// seeing numbers like 13 and 14)
+	if ((eta < FRAME_TIME_MS) || (eta > 5_sec))
+		return;
+
+	if (self->timestamp > level.time)
+		return;
+
+	self->timestamp = level.time + random_time(1_sec, 5_sec);
+	// this will override the foundtarget call of gnorta_run
+	gnorta_dodge_jump(self);
+}
+
+// ******************
+// Jump onto / off of things
+// ******************
+
+//===================
+//===================
+void gnorta_jump_down(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 100);
+	self->velocity += (up * 300);
+}
+
+//===================
+//===================
+void gnorta_jump_up(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 200);
+	self->velocity += (up * 450);
+}
+
+//===================
+//===================
+void gnorta_jump_wait_land(edict_t* self)
+{
+	if ((frandom() < 0.4f) && (level.time >= self->monsterinfo.attack_finished))
+	{
+		self->monsterinfo.attack_finished = level.time + 300_ms;
+		gnorta_shoot_attack(self);
+	}
+
+	if (self->groundentity == nullptr)
+	{
+		self->gravity = 1.3f;
+		self->monsterinfo.nextframe = self->s.frame;
+
+		if (monster_jump_finished(self))
+		{
+			self->gravity = 1;
+			self->monsterinfo.nextframe = self->s.frame + 1;
+		}
+	}
+	else
+	{
+		self->gravity = 1;
+		self->monsterinfo.nextframe = self->s.frame + 1;
+	}
+}
+
+mframe_t gnorta_frames_jump_up[] = {
+	{ ai_move, -8 },
+	{ ai_move, -8 },
+	{ ai_move, -8 },
+	{ ai_move, -8 },
+
+	{ ai_move, 0, gnorta_jump_up },
+	{ ai_move, 0, gnorta_jump_wait_land },
+	{ ai_move, 0, monster_footstep }
+};
+MMOVE_T(gnorta_move_jump_up) = { FRAME_jump01, FRAME_jump07, gnorta_frames_jump_up, gnorta_run };
+
+mframe_t gnorta_frames_jump_down[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move, 0, gnorta_jump_down },
+	{ ai_move, 0, gnorta_jump_wait_land },
+	{ ai_move, 0, monster_footstep }
+};
+MMOVE_T(gnorta_move_jump_down) = { FRAME_jump01, FRAME_jump07, gnorta_frames_jump_down, gnorta_run };
+
+//============
+// gnorta_jump - this is only used for jumping onto or off of things. for dodge jumping,
+//		use gnorta_dodge_jump
+//============
+void gnorta_jump(edict_t* self, blocked_jump_result_t result)
+{
+	if (!self->enemy)
+		return;
+
+	if (result == blocked_jump_result_t::JUMP_JUMP_UP)
+		M_SetAnimation(self, &gnorta_move_jump_up);
+	else
+		M_SetAnimation(self, &gnorta_move_jump_down);
+}
+
+// ******************
+// Blocked
+// ******************
+MONSTERINFO_BLOCKED(gnorta_blocked) (edict_t* self, float dist) -> bool
+{
+	if (!has_valid_enemy(self))
+		return false;
+
+	bool onCeiling = GNORTA_ON_CEILING(self);
+
+	if (!onCeiling)
+	{
+		if (auto result = blocked_checkjump(self, dist); result != blocked_jump_result_t::NO_JUMP)
+		{
+			if (result != blocked_jump_result_t::JUMP_TURN)
+				gnorta_jump(self, result);
+			return true;
+		}
+
+		if (blocked_checkplat(self, dist))
+			return true;
+
+		if (visible(self, self->enemy) && frandom() < 0.1f)
+		{
+			gnorta_do_pounce(self, self->enemy->s.origin);
+			return true;
+		}
+	}
+	else
+	{
+		if (gnorta_ok_to_transition(self))
+		{
+			self->gravityVector[2] = -1;
+			self->s.angles[2] += 180.0f;
+			if (self->s.angles[2] > 360.0f)
+				self->s.angles[2] -= 360.0f;
+			self->groundentity = nullptr;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+// [Paril-KEX] quick patch-job to fix gnortas endlessly floating up into the sky
+MONSTERINFO_PHYSCHANGED(gnorta_physics_change) (edict_t* self) -> void
+{
+	if (GNORTA_ON_CEILING(self) && !self->groundentity)
+	{
+		self->gravityVector[2] = -1;
+		self->s.angles[2] += 180.0f;
+		if (self->s.angles[2] > 360.0f)
+			self->s.angles[2] -= 360.0f;
+	}
+}
+
+// ******************
+// Death
+// ******************
+
+void gnorta_dead(edict_t* self)
+{
+	self->mins = { -28, -28, -18 };
+	self->maxs = { 28, 28, -4 };
+	monster_dead(self);
+}
+
+mframe_t gnorta_frames_death[] = {
+	{ ai_move },
+	{ ai_move, -5 },
+	{ ai_move, -10 },
+	{ ai_move, -20 },
+
+	{ ai_move, -10 },
+	{ ai_move, -10 },
+	{ ai_move, -5 },
+	{ ai_move, -5 },
+
+	{ ai_move, 0, monster_footstep }
+};
+MMOVE_T(gnorta_move_death) = { FRAME_death01, FRAME_death09, gnorta_frames_death, gnorta_dead };
+
+DIE(gnorta_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	// dude bit it, make him fall!
+	self->movetype = MOVETYPE_TOSS;
+	self->s.angles[2] = 0;
+	self->gravityVector = { 0, 0, -1 };
+
+	// check for gib
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/sm_meat/tris.md2" },
+			{"models/monsters/gnorta/gibs/bodya.md2", GIB_SKINNED},
+			{ "models/monsters/gnorta/gibs/bodyb.md2", GIB_SKINNED },
+			{ 2, "models/monsters/gnorta/gibs/claw.md2", GIB_SKINNED | GIB_UPRIGHT },
+			{ 2, "models/monsters/gnorta/gibs/leg.md2", GIB_SKINNED | GIB_UPRIGHT },
+			{ 2, "models/monsters/gnorta/gibs/foot.md2", GIB_SKINNED },
+			{ "models/monsters/gnorta/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			});
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	// regular death
+	gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+	M_SetAnimation(self, &gnorta_move_death);
+}
+
+// ******************
+// SPAWN
+// ******************
+
+/*QUAKED monster_gnorta (1 .5 0) (-28 -28 -18) (28 28 18) Ambush Trigger_Spawn Sight OnRoof NoJumping
+Turtle Monster
+
+  ONROOF - Monster starts sticking to the roof.
+*/
+
+void SP_monster_gnorta(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_pain.assign("gnorta/pain.wav");
+	sound_die.assign("gnorta/death.wav");
+	sound_sight.assign("gnorta/sight.wav");
+	sound_punch_hit1.assign("gnorta/melee1.wav");
+	sound_punch_hit2.assign("gnorta/melee2.wav");
+	sound_idle.assign("gnorta/idle.wav");
+
+	// PMM - precache bolt2
+	gi.modelindex("models/objects/laser/tris.md2");
+
+	self->s.modelindex = gi.modelindex("models/monsters/gnorta/tris.md2");
+
+	gi.modelindex("models/monsters/gnorta/gibs/bodya.md2");
+	gi.modelindex("models/monsters/gnorta/gibs/bodyb.md2");
+	gi.modelindex("models/monsters/gnorta/gibs/claw.md2");
+	gi.modelindex("models/monsters/gnorta/gibs/foot.md2");
+	gi.modelindex("models/monsters/gnorta/gibs/head.md2");
+	gi.modelindex("models/monsters/gnorta/gibs/leg.md2");
+
+	self->mins = { -28, -28, -18 };
+	self->maxs = { 28, 28, 18 };
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->health = 250 * st.health_multiplier;
+	self->gib_health = -50;
+	self->mass = 250;
+
+	self->pain = gnorta_pain;
+	self->die = gnorta_die;
+
+	self->monsterinfo.stand = gnorta_stand;
+	self->monsterinfo.walk = gnorta_walk;
+	self->monsterinfo.run = gnorta_run;
+	self->monsterinfo.attack = gnorta_attack_ranged;
+	self->monsterinfo.sight = gnorta_sight;
+	self->monsterinfo.idle = gnorta_idle;
+	self->monsterinfo.dodge = gnorta_dodge;
+	self->monsterinfo.blocked = gnorta_blocked;
+	self->monsterinfo.melee = gnorta_attack_melee;
+	self->monsterinfo.setskin = gnorta_setskin;
+	self->monsterinfo.physics_change = gnorta_physics_change;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &gnorta_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	if (self->spawnflags.has(SPAWNFLAG_GNORTA_ONROOF))
+	{
+		self->s.angles[2] = 180;
+		self->gravityVector[2] = 1;
+	}
+
+	self->monsterinfo.can_jump = !self->spawnflags.has(SPAWNFLAG_GNORTA_NOJUMPING);
+	self->monsterinfo.drop_height = 256;
+	self->monsterinfo.jump_height = 68;
+
+	walkmonster_start(self);
+}
--- /dev/null
+++ b/ionized/m_gnorta.h	2025-09-04 19:53:48
@@ -0,0 +1,181 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+// /expanse/quake2/xpack/models/monsters/gnorta
+
+// This file generated by qdata - Do NOT Modify
+
+enum
+{
+	FRAME_idle01,
+	FRAME_idle02,
+	FRAME_idle03,
+	FRAME_idle04,
+	FRAME_idle05,
+	FRAME_idle06,
+	FRAME_idle07,
+	FRAME_idle08,
+	FRAME_idle09,
+	FRAME_idle10,
+	FRAME_idle11,
+	FRAME_idle12,
+	FRAME_idle13,
+	FRAME_idle14,
+	FRAME_idle15,
+	FRAME_idle16,
+	FRAME_idle17,
+	FRAME_idle18,
+	FRAME_idle19,
+	FRAME_idle20,
+	FRAME_idle21,
+	FRAME_idle201,
+	FRAME_idle202,
+	FRAME_idle203,
+	FRAME_idle204,
+	FRAME_idle205,
+	FRAME_idle206,
+	FRAME_idle207,
+	FRAME_idle208,
+	FRAME_idle209,
+	FRAME_idle210,
+	FRAME_idle211,
+	FRAME_idle212,
+	FRAME_idle213,
+	FRAME_walk01,
+	FRAME_walk02,
+	FRAME_walk03,
+	FRAME_walk04,
+	FRAME_walk05,
+	FRAME_walk06,
+	FRAME_walk07,
+	FRAME_walk08,
+	FRAME_jump01,
+	FRAME_jump02,
+	FRAME_jump03,
+	FRAME_jump04,
+	FRAME_jump05,
+	FRAME_jump06,
+	FRAME_jump07,
+	FRAME_run01,
+	FRAME_run02,
+	FRAME_run03,
+	FRAME_run04,
+	FRAME_attack01,
+	FRAME_attack02,
+	FRAME_attack03,
+	FRAME_attack04,
+	FRAME_attack05,
+	FRAME_attack06,
+	FRAME_attack07,
+	FRAME_attack08,
+	FRAME_attack11,
+	FRAME_attack12,
+	FRAME_attack13,
+	FRAME_attack14,
+	FRAME_attack15,
+	FRAME_pain01,
+	FRAME_pain02,
+	FRAME_pain03,
+	FRAME_pain04,
+	FRAME_death01,
+	FRAME_death02,
+	FRAME_death03,
+	FRAME_death04,
+	FRAME_death05,
+	FRAME_death06,
+	FRAME_death07,
+	FRAME_death08,
+	FRAME_death09,
+	FRAME_twitch01,
+	FRAME_twitch02,
+	FRAME_twitch03,
+	FRAME_twitch04,
+	FRAME_twitch05,
+	FRAME_twitch06,
+	FRAME_twitch07,
+	FRAME_twitch08,
+	FRAME_twitch09,
+	FRAME_twitch10,
+	FRAME_reactive01,
+	FRAME_reactive02,
+	FRAME_reactive03,
+	FRAME_reactive04,
+	FRAME_wdeath01,
+	FRAME_wdeath02,
+	FRAME_wdeath03,
+	FRAME_wdeath04,
+	FRAME_wdeath05,
+	FRAME_wdeath06,
+	FRAME_wdeath07,
+	FRAME_wdeath08,
+	FRAME_wdeath09,
+	FRAME_wdeath10,
+	FRAME_wdeath11,
+	FRAME_wdeath12,
+	FRAME_wdeath13,
+	FRAME_wdeath14,
+	FRAME_wdeath15,
+	FRAME_wdeath16,
+	FRAME_wdeath17,
+	FRAME_wdeath18,
+	FRAME_wdeath19,
+	FRAME_wdeath20,
+	FRAME_wdeath21,
+	FRAME_wdeath22,
+	FRAME_wdeath23,
+	FRAME_wdeath24,
+	FRAME_wdeath25,
+	FRAME_wdeath26,
+	FRAME_wdeath27,
+	FRAME_wdeath28,
+	FRAME_wdeath29,
+	FRAME_wdeath30,
+	FRAME_wdeath31,
+	FRAME_wdeath32,
+	FRAME_wdeath33,
+	FRAME_wdeath34,
+	FRAME_wdeath35,
+	FRAME_wdeath36,
+	FRAME_wdeath37,
+	FRAME_wdeath38,
+	FRAME_wdeath39,
+	FRAME_wdeath40,
+	FRAME_wdeath41,
+	FRAME_wdeath42,
+	FRAME_wdeath43,
+	FRAME_wdeath44,
+	FRAME_wdeath45,
+	FRAME_swim01,
+	FRAME_swim02,
+	FRAME_swim03,
+	FRAME_swim04,
+	FRAME_swim05,
+	FRAME_swim06,
+	FRAME_swim07,
+	FRAME_swim08,
+	FRAME_swim09,
+	FRAME_swim10,
+	FRAME_swim11,
+	FRAME_swim12,
+	FRAME_swim13,
+	FRAME_swim14,
+	FRAME_swim15,
+	FRAME_swim16,
+	FRAME_swim17,
+	FRAME_swim18,
+	FRAME_swim19,
+	FRAME_swim20,
+	FRAME_swim21,
+	FRAME_swim22,
+	FRAME_swim23,
+	FRAME_swim24,
+	FRAME_swim25,
+	FRAME_swim26,
+	FRAME_swim27,
+	FRAME_swim28,
+	FRAME_swim29,
+	FRAME_swim30,
+	FRAME_swim31,
+	FRAME_swim32
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/ionized/m_shark.cpp	2025-09-04 19:53:48
@@ -0,0 +1,430 @@
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+SHARK
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_shark.h"
+
+static cached_soundindex sound_chomp;
+static cached_soundindex sound_attack;
+static cached_soundindex sound_pain1;
+static cached_soundindex sound_pain2;
+static cached_soundindex sound_death;
+static cached_soundindex sound_idle;
+static cached_soundindex sound_search;
+static cached_soundindex sound_sight;
+
+mframe_t shark_frames_stand[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand }
+};
+
+MMOVE_T(shark_move_stand) = { FRAME_amba001, FRAME_amba020, shark_frames_stand, nullptr };
+
+MONSTERINFO_STAND(shark_stand) (edict_t *self) -> void
+{
+	M_SetAnimation(self, &shark_move_stand);
+}
+
+mframe_t shark_frames_run[] = {
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 }, // 10
+
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 }, // 20
+
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 } // 30
+};
+MMOVE_T(shark_move_run) = { FRAME_swima001, FRAME_swima030, shark_frames_run, nullptr };
+
+MONSTERINFO_RUN(shark_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &shark_move_run);
+}
+
+/* Standard Swimming */
+mframe_t shark_frames_walk[] = {
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 },
+	{ ai_walk, 4 }
+};
+MMOVE_T(shark_move_walk) = { FRAME_swima001, FRAME_swima030, shark_frames_walk, nullptr };
+
+MONSTERINFO_WALK(shark_walk) (edict_t *self) -> void
+{
+	M_SetAnimation(self, &shark_move_walk);
+}
+
+mframe_t shark_frames_pain[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(shark_move_pain) = { FRAME_hita001, FRAME_hita015, shark_frames_pain, shark_run };
+
+void shark_bite(edict_t *self)
+{
+	vec3_t aim = { MELEE_DISTANCE, 0, 0 };
+	fire_hit(self, aim, 25, 0);
+}
+
+void shark_preattack(edict_t *self)
+{
+	gi.sound(self, CHAN_WEAPON, sound_chomp, 1, ATTN_NORM, 0);
+}
+
+mframe_t shark_frames_attack1[] = {
+	{ ai_charge, 0, shark_preattack },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, shark_bite },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, shark_bite },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(shark_move_attack1) = { FRAME_ataka001, FRAME_ataka021, shark_frames_attack1, shark_run };
+
+mframe_t shark_frames_attack2[] = {
+	{ ai_charge, 0, shark_preattack },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, shark_bite },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, shark_bite },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(shark_move_attack2) = { FRAME_atakb001, FRAME_atakb021, shark_frames_attack2, shark_run };
+
+mframe_t shark_frames_attack3[] = {
+	{ ai_charge, 0, shark_preattack },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, shark_bite },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, shark_bite },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(shark_move_attack3) = { FRAME_atakc001, FRAME_atakc025, shark_frames_attack3, shark_run };
+
+MONSTERINFO_MELEE(shark_melee) (edict_t *self) -> void
+{
+	M_SetAnimation(self, &shark_move_attack1);
+}
+
+PAIN(shark_pain) (edict_t *self, edict_t *other, float kick, int damage, const mod_t &mod) -> void
+{
+	int n;
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+	n = brandom();
+
+	if (n == 0)
+		gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	M_SetAnimation(self, &shark_move_pain);
+}
+
+MONSTERINFO_SETSKIN(shark_setskin) (edict_t *self) -> void
+{
+	/* KONIG - allow multiple skins */
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+void shark_dead(edict_t *self)
+{
+	self->mins = { -16, -16, -8 };
+	self->maxs = { 16, 16, 8 };
+	monster_dead(self);
+}
+
+mframe_t shark_frames_death1[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move }
+};
+MMOVE_T(shark_move_death1) = { FRAME_diea001, FRAME_diea021, shark_frames_death1, shark_dead };
+
+mframe_t shark_frames_death2[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(shark_move_death2) = { FRAME_dieb001, FRAME_dieb015, shark_frames_death2, shark_dead };
+
+MONSTERINFO_SIGHT(shark_sight) (edict_t *self, edict_t *other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+DIE(shark_die) (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, const vec3_t &point, const mod_t &mod) -> void
+{
+	// check for gib
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+		ThrowGibs(self, damage, {
+			{ 4, "models/objects/gibs/bone/tris.md2" },
+			{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+			{ "models/objects/gibs/head2/tris.md2", GIB_HEAD }
+		});
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	// regular death
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+	self->svflags |= SVF_DEADMONSTER;
+	if (frandom() > 0.5f)
+		M_SetAnimation(self, &shark_move_death1);
+	else
+		M_SetAnimation(self, &shark_move_death2);
+
+}
+
+static void shark_set_fly_parameters(edict_t *self)
+{
+	self->monsterinfo.fly_thrusters = false;
+	self->monsterinfo.fly_acceleration = 30.f;
+	self->monsterinfo.fly_speed = 110.f;
+	// only melee, so get in close
+	self->monsterinfo.fly_min_distance = 10.f;
+	self->monsterinfo.fly_max_distance = 10.f;
+}
+
+/*QUAKED monster_shark (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+ */
+void SP_monster_shark(edict_t *self)
+{
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
+	if ( !M_AllowSpawn( self ) ) {
+		G_FreeEdict( self );
+		return;
+	}
+
+	sound_pain1.assign("shark/flppain1.wav");
+	sound_pain2.assign("shark/flppain2.wav");
+	sound_death.assign("shark/flpdeth1.wav");
+	sound_chomp.assign("shark/flpatck1.wav");
+	sound_attack.assign("shark/flpatck2.wav");
+	sound_idle.assign("shark/flpidle1.wav");
+	sound_search.assign("shark/flpsrch1.wav");
+	sound_sight.assign("shark/flpsght1.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex("models/monsters/shark/tris.md2");
+	self->mins = { -32, -32, -8 };
+	self->maxs = { 32, 32, 20 };
+
+	self->health = 300 * st.health_multiplier;
+	self->gib_health = -200;
+	self->mass = 400;
+
+	self->pain = shark_pain;
+	self->die = shark_die;
+
+	self->monsterinfo.stand = shark_stand;
+	self->monsterinfo.walk = shark_walk;
+	self->monsterinfo.run = shark_run;
+	self->monsterinfo.melee = shark_melee;
+	self->monsterinfo.sight = shark_sight;
+	self->monsterinfo.setskin = shark_setskin;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &shark_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+	shark_set_fly_parameters(self);
+
+	swimmonster_start(self);
+}
--- /dev/null
+++ b/ionized/m_shark.h	2025-09-04 19:53:48
@@ -0,0 +1,175 @@
+//SHARK!!!
+
+enum
+{
+	FRAME_amba001,
+	FRAME_amba002,
+	FRAME_amba003,
+	FRAME_amba004,
+	FRAME_amba005,
+	FRAME_amba006,
+	FRAME_amba007,
+	FRAME_amba008,
+	FRAME_amba009,
+	FRAME_amba010,
+	FRAME_amba011,
+	FRAME_amba012,
+	FRAME_amba013,
+	FRAME_amba014,
+	FRAME_amba015,
+	FRAME_amba016,
+	FRAME_amba017,
+	FRAME_amba018,
+	FRAME_amba019,
+	FRAME_amba020,
+	FRAME_ataka001,
+	FRAME_ataka002,
+	FRAME_ataka003,
+	FRAME_ataka004,
+	FRAME_ataka005,
+	FRAME_ataka006,
+	FRAME_ataka007,
+	FRAME_ataka008,
+	FRAME_ataka009,
+	FRAME_ataka010,
+	FRAME_ataka011,
+	FRAME_ataka012,
+	FRAME_ataka013,
+	FRAME_ataka014,
+	FRAME_ataka015,
+	FRAME_ataka016,
+	FRAME_ataka017,
+	FRAME_ataka018,
+	FRAME_ataka019,
+	FRAME_ataka020,
+	FRAME_ataka021,
+	FRAME_atakb001,
+	FRAME_atakb002,
+	FRAME_atakb003,
+	FRAME_atakb004,
+	FRAME_atakb005,
+	FRAME_atakb006,
+	FRAME_atakb007,
+	FRAME_atakb008,
+	FRAME_atakb009,
+	FRAME_atakb010,
+	FRAME_atakb011,
+	FRAME_atakb012,
+	FRAME_atakb013,
+	FRAME_atakb014,
+	FRAME_atakb015,
+	FRAME_atakb016,
+	FRAME_atakb017,
+	FRAME_atakb018,
+	FRAME_atakb019,
+	FRAME_atakb020,
+	FRAME_atakb021,
+	FRAME_atakc001,
+	FRAME_atakc002,
+	FRAME_atakc003,
+	FRAME_atakc004,
+	FRAME_atakc005,
+	FRAME_atakc006,
+	FRAME_atakc007,
+	FRAME_atakc008,
+	FRAME_atakc009,
+	FRAME_atakc010,
+	FRAME_atakc011,
+	FRAME_atakc012,
+	FRAME_atakc013,
+	FRAME_atakc014,
+	FRAME_atakc015,
+	FRAME_atakc016,
+	FRAME_atakc017,
+	FRAME_atakc018,
+	FRAME_atakc019,
+	FRAME_atakc020,
+	FRAME_atakc021,
+	FRAME_atakc022,
+	FRAME_atakc023,
+	FRAME_atakc024,
+	FRAME_atakc025,
+	FRAME_diea001,
+	FRAME_diea002,
+	FRAME_diea003,
+	FRAME_diea004,
+	FRAME_diea005,
+	FRAME_diea006,
+	FRAME_diea007,
+	FRAME_diea008,
+	FRAME_diea009,
+	FRAME_diea010,
+	FRAME_diea011,
+	FRAME_diea012,
+	FRAME_diea013,
+	FRAME_diea014,
+	FRAME_diea015,
+	FRAME_diea016,
+	FRAME_diea017,
+	FRAME_diea018,
+	FRAME_diea019,
+	FRAME_diea020,
+	FRAME_diea021,
+	FRAME_dieb001,
+	FRAME_dieb002,
+	FRAME_dieb003,
+	FRAME_dieb004,
+	FRAME_dieb005,
+	FRAME_dieb006,
+	FRAME_dieb007,
+	FRAME_dieb008,
+	FRAME_dieb009,
+	FRAME_dieb010,
+	FRAME_dieb011,
+	FRAME_dieb012,
+	FRAME_dieb013,
+	FRAME_dieb014,
+	FRAME_dieb015,
+	FRAME_hita001,
+	FRAME_hita002,
+	FRAME_hita003,
+	FRAME_hita004,
+	FRAME_hita005,
+	FRAME_hita006,
+	FRAME_hita007,
+	FRAME_hita008,
+	FRAME_hita009,
+	FRAME_hita010,
+	FRAME_hita011,
+	FRAME_hita012,
+	FRAME_hita013,
+	FRAME_hita014,
+	FRAME_hita015,
+	FRAME_swima001,
+	FRAME_swima002,
+	FRAME_swima003,
+	FRAME_swima004,
+	FRAME_swima005,
+	FRAME_swima006,
+	FRAME_swima007,
+	FRAME_swima008,
+	FRAME_swima009,
+	FRAME_swima010,
+	FRAME_swima011,
+	FRAME_swima012,
+	FRAME_swima013,
+	FRAME_swima014,
+	FRAME_swima015,
+	FRAME_swima016,
+	FRAME_swima017,
+	FRAME_swima018,
+	FRAME_swima019,
+	FRAME_swima020,
+	FRAME_swima021,
+	FRAME_swima022,
+	FRAME_swima023,
+	FRAME_swima024,
+	FRAME_swima025,
+	FRAME_swima026,
+	FRAME_swima027,
+	FRAME_swima028,
+	FRAME_swima029,
+	FRAME_swima030
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/ionized/m_shocker.cpp	2025-09-04 19:53:48
@@ -0,0 +1,1476 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+GUNNER
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_shocker.h"
+#include "../m_flash.h"
+
+constexpr spawnflags_t SPAWNFLAG_SHOCKER_NOJUMPING = 8_spawnflag;
+
+static cached_soundindex sound_pain;
+static cached_soundindex sound_pain2;
+static cached_soundindex sound_death;
+static cached_soundindex sound_idle;
+static cached_soundindex sound_open;
+static cached_soundindex sound_search;
+static cached_soundindex sound_sight;
+
+void shocker_idlesound(edict_t* self)
+{
+	gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+MONSTERINFO_SIGHT(shocker_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SEARCH(shocker_search) (edict_t* self) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
+}
+
+void ShockerGrenade(edict_t* self);
+void ShockerFire(edict_t* self);
+void shocker_fire_chain(edict_t* self);
+void shocker_refire_chain(edict_t* self);
+
+void shocker_stand(edict_t* self);
+
+mframe_t shocker_frames_fidget[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, shocker_idlesound },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand, 0, shocker_idlesound },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(shocker_move_fidget) = { FRAME_c_stand201, FRAME_c_stand254, shocker_frames_fidget, shocker_stand };
+
+void shocker_fidget(edict_t* self)
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		return;
+	else if (self->enemy)
+		return;
+	if (frandom() <= 0.05f)
+		M_SetAnimation(self, &shocker_move_fidget);
+}
+
+mframe_t shocker_frames_stand[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, shocker_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, shocker_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, shocker_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, shocker_fidget }
+};
+MMOVE_T(shocker_move_stand) = { FRAME_c_stand101, FRAME_c_stand140, shocker_frames_stand, nullptr };
+
+MONSTERINFO_STAND(shocker_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &shocker_move_stand);
+}
+
+mframe_t shocker_frames_walk[] = {
+	{ ai_walk, 1.5f, monster_footstep },
+	{ ai_walk, 2.5f },
+	{ ai_walk, 3.0f },
+	{ ai_walk, 2.5f },
+	{ ai_walk, 2.3f },
+	{ ai_walk, 3.0f },
+	{ ai_walk, 2.8f, monster_footstep },
+	{ ai_walk, 3.6f },
+	{ ai_walk, 2.8f },
+	{ ai_walk, 2.5f },
+
+	{ ai_walk, 2.3f },
+	{ ai_walk, 4.3f },
+	{ ai_walk, 3.0f, monster_footstep },
+	{ ai_walk, 1.5f },
+	{ ai_walk, 2.5f },
+	{ ai_walk, 3.3f },
+	{ ai_walk, 2.8f },
+	{ ai_walk, 3.0f },
+	{ ai_walk, 2.0f, monster_footstep },
+	{ ai_walk, 2.0f },
+
+	{ ai_walk, 3.3f },
+	{ ai_walk, 3.6f },
+	{ ai_walk, 3.4f },
+	{ ai_walk, 2.8f },
+};
+MMOVE_T(shocker_move_walk) = { FRAME_c_walk101, FRAME_c_walk124, shocker_frames_walk, nullptr };
+
+MONSTERINFO_WALK(shocker_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &shocker_move_walk);
+}
+
+mframe_t shocker_frames_run[] = {
+	{ ai_run, 15.f, monster_done_dodge },
+	{ ai_run, 16.f, monster_footstep },
+	{ ai_run, 20.f },
+	{ ai_run, 18.f },
+	{ ai_run, 24.f, monster_footstep },
+	{ ai_run, 13.5f }
+};
+
+MMOVE_T(shocker_move_run) = { FRAME_c_run101, FRAME_c_run106, shocker_frames_run, nullptr };
+
+MONSTERINFO_RUN(shocker_run) (edict_t* self) -> void
+{
+	monster_done_dodge(self);
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &shocker_move_stand);
+	else
+		M_SetAnimation(self, &shocker_move_run);
+}
+
+// standing pains
+
+mframe_t shocker_frames_pain1[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+};
+MMOVE_T(shocker_move_pain1) = { FRAME_c_pain101, FRAME_c_pain104, shocker_frames_pain1, shocker_run };
+
+mframe_t shocker_frames_pain2[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(shocker_move_pain2) = { FRAME_c_pain201, FRAME_c_pain204, shocker_frames_pain2, shocker_run };
+
+mframe_t shocker_frames_pain3[] = {
+	{ ai_move, -3.0f },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+};
+MMOVE_T(shocker_move_pain3) = { FRAME_c_pain301, FRAME_c_pain304, shocker_frames_pain3, shocker_run };
+
+mframe_t shocker_frames_pain4[] = {
+	{ ai_move, -17.1f },
+	{ ai_move, -3.2f },
+	{ ai_move, 0.9f },
+	{ ai_move, 3.6f },
+	{ ai_move, -2.6f },
+	{ ai_move, 1.0f },
+	{ ai_move, -5.1f },
+	{ ai_move, -6.7f },
+	{ ai_move, -8.8f },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move, -2.1f },
+	{ ai_move, -2.3f },
+	{ ai_move, -2.5f },
+	{ ai_move }
+};
+MMOVE_T(shocker_move_pain4) = { FRAME_c_pain401, FRAME_c_pain415, shocker_frames_pain4, shocker_run };
+
+void shocker_dead(edict_t*);
+
+mframe_t shocker_frames_death1[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 4.0f }, // scoot
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(shocker_move_death1) = { FRAME_c_death101, FRAME_c_death118, shocker_frames_death1, shocker_dead };
+
+void shocker_pain5_to_death1(edict_t* self)
+{
+	if (self->health < 0)
+		M_SetAnimation(self, &shocker_move_death1, false);
+}
+
+mframe_t shocker_frames_death2[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(shocker_move_death2) = { FRAME_c_death201, FRAME_c_death204, shocker_frames_death2, shocker_dead };
+
+void shocker_pain5_to_death2(edict_t* self)
+{
+	if (self->health < 0 && brandom())
+		M_SetAnimation(self, &shocker_move_death2, false);
+}
+
+mframe_t shocker_frames_pain5[] = {
+	{ ai_move, -29.f },
+	{ ai_move, -5.f },
+	{ ai_move, -5.f },
+	{ ai_move, -3.f },
+	{ ai_move },
+	{ ai_move, 0, shocker_pain5_to_death2 },
+	{ ai_move, 9.f },
+	{ ai_move, 3.f },
+	{ ai_move, 0, shocker_pain5_to_death1 },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move, -4.6f },
+	{ ai_move, -4.8f },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 9.5f },
+	{ ai_move, 3.4f },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move, -2.4f },
+	{ ai_move, -9.0f },
+	{ ai_move, -5.0f },
+	{ ai_move, -3.6f },
+};
+MMOVE_T(shocker_move_pain5) = { FRAME_c_pain501, FRAME_c_pain524, shocker_frames_pain5, shocker_run };
+
+void shocker_dead(edict_t* self)
+{
+	self->mins = vec3_t{ -16, -16, -24 } *self->s.scale;
+	self->maxs = vec3_t{ 16, 16, -8 } *self->s.scale;
+	monster_dead(self);
+}
+
+static void shocker_shrink(edict_t* self)
+{
+	self->maxs[2] = -4 * self->s.scale;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t shocker_frames_death6[] = {
+	{ ai_move, 0, shocker_shrink },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(shocker_move_death6) = { FRAME_c_death601, FRAME_c_death614, shocker_frames_death6, shocker_dead };
+
+static void shocker_pain6_to_death6(edict_t* self)
+{
+	if (self->health < 0)
+		M_SetAnimation(self, &shocker_move_death6, false);
+}
+
+mframe_t shocker_frames_pain6[] = {
+	{ ai_move, 16.f },
+	{ ai_move, 16.f },
+	{ ai_move, 12.f },
+	{ ai_move, 5.5f, monster_duck_down },
+	{ ai_move, 3.0f },
+	{ ai_move, -4.7f },
+	{ ai_move, -6.0f, shocker_pain6_to_death6 },
+	{ ai_move },
+	{ ai_move, 1.8f },
+	{ ai_move, 0.7f },
+
+	{ ai_move },
+	{ ai_move, -2.1f },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move, -6.1f },
+	{ ai_move, 10.5f },
+	{ ai_move, 4.3f },
+	{ ai_move, 4.7f, monster_duck_up },
+	{ ai_move, 1.4f },
+	{ ai_move },
+	{ ai_move, -3.2f },
+	{ ai_move, 2.3f },
+	{ ai_move, -4.4f },
+
+	{ ai_move, -4.4f },
+	{ ai_move, -2.4f }
+};
+MMOVE_T(shocker_move_pain6) = { FRAME_c_pain601, FRAME_c_pain632, shocker_frames_pain6, shocker_run };
+
+mframe_t shocker_frames_pain7[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(shocker_move_pain7) = { FRAME_c_pain701, FRAME_c_pain714, shocker_frames_pain7, shocker_run };
+
+extern const mmove_t shocker_move_jump;
+extern const mmove_t shocker_move_jump2;
+extern const mmove_t shocker_move_duck_attack;
+
+bool shocker_sidestep(edict_t* self);
+
+PAIN(shocker_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	monster_done_dodge(self);
+
+	if (self->monsterinfo.active_move == &shocker_move_jump ||
+		self->monsterinfo.active_move == &shocker_move_jump2 ||
+		self->monsterinfo.active_move == &shocker_move_duck_attack)
+		return;
+
+	if (level.time < self->pain_debounce_time)
+	{
+		if (frandom() < 0.3)
+			self->monsterinfo.dodge(self, other, FRAME_TIME_S, nullptr, false);
+
+		return;
+	}
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	if (brandom())
+		gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+
+	if (!M_ShouldReactToPain(self, mod))
+	{
+		if (frandom() < 0.3)
+			self->monsterinfo.dodge(self, other, FRAME_TIME_S, nullptr, false);
+
+		return; // no pain anims in nightmare
+	}
+
+	vec3_t forward;
+	AngleVectors(self->s.angles, forward, nullptr, nullptr);
+
+	vec3_t dif = (other->s.origin - self->s.origin);
+	dif.z = 0;
+	dif.normalize();
+
+	// small pain
+	if (damage < 35)
+	{
+		int r = irandom(0, 4);
+
+		if (r == 0)
+			M_SetAnimation(self, &shocker_move_pain3);
+		else if (r == 1)
+			M_SetAnimation(self, &shocker_move_pain2);
+		else if (r == 2)
+			M_SetAnimation(self, &shocker_move_pain1);
+		else
+			M_SetAnimation(self, &shocker_move_pain7);
+	}
+	// large pain from behind (aka Paril)
+	else if (dif.dot(forward) < -0.40f)
+	{
+		M_SetAnimation(self, &shocker_move_pain6);
+
+		self->pain_debounce_time += 1.5_sec;
+	}
+	else
+	{
+		if (brandom())
+			M_SetAnimation(self, &shocker_move_pain4);
+		else
+			M_SetAnimation(self, &shocker_move_pain5);
+
+		self->pain_debounce_time += 1.5_sec;
+	}
+
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+
+	// PMM - clear duck flag
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		monster_duck_up(self);
+}
+
+MONSTERINFO_SETSKIN(shocker_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+mframe_t shocker_frames_death3[] = {
+	{ ai_move, 20.f },
+	{ ai_move, 10.f },
+	{ ai_move, 10.f, [](edict_t* self) { monster_footstep(self); shocker_shrink(self); } },
+	{ ai_move, 0.f, monster_footstep },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move }
+};
+MMOVE_T(shocker_move_death3) = { FRAME_c_death301, FRAME_c_death321, shocker_frames_death3, shocker_dead };
+
+mframe_t shocker_frames_death7[] = {
+	{ ai_move, 30.f },
+	{ ai_move, 20.f },
+	{ ai_move, 16.f, [](edict_t* self) { monster_footstep(self); shocker_shrink(self); } },
+	{ ai_move, 5.f, monster_footstep },
+	{ ai_move, -6.f },
+	{ ai_move, -7.f, monster_footstep },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0.f, monster_footstep },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0.f, monster_footstep },
+	{ ai_move },
+	{ ai_move },
+};
+MMOVE_T(shocker_move_death7) = { FRAME_c_death701, FRAME_c_death730, shocker_frames_death7, shocker_dead };
+
+mframe_t shocker_frames_death4[] = {
+	{ ai_move, -20.f },
+	{ ai_move, -16.f },
+	{ ai_move, -26.f, [](edict_t* self) { monster_footstep(self); shocker_shrink(self); } },
+	{ ai_move, 0.f, monster_footstep },
+	{ ai_move, -12.f },
+	{ ai_move, 16.f },
+	{ ai_move, 9.2f },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(shocker_move_death4) = { FRAME_c_death401, FRAME_c_death436, shocker_frames_death4, shocker_dead };
+
+mframe_t shocker_frames_death5[] = {
+	{ ai_move, -14.f },
+	{ ai_move, -2.7f },
+	{ ai_move, -2.5f },
+	{ ai_move, -4.6f, monster_footstep },
+	{ ai_move, -4.0f, monster_footstep },
+	{ ai_move, -1.5f },
+	{ ai_move, 2.3f },
+	{ ai_move, 2.5f },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 3.5f },
+	{ ai_move, 12.9f, monster_footstep },
+	{ ai_move, 3.8f },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move, -2.1f },
+	{ ai_move, -1.3f },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 3.4f },
+	{ ai_move, 5.7f },
+	{ ai_move, 11.2f },
+	{ ai_move, 0, monster_footstep }
+};
+MMOVE_T(shocker_move_death5) = { FRAME_c_death501, FRAME_c_death528, shocker_frames_death5, shocker_dead };
+
+DIE(shocker_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	// check for gib
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		const char* head_gib = (self->monsterinfo.active_move != &shocker_move_death5) ? "models/objects/gibs/sm_meat/tris.md2" : "models/monsters/shocker/gibs/head.md2";
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 2, "models/objects/gibs/sm_meat/tris.md2" },
+			{ 1, "models/objects/gibs/gear/tris.md2" },
+			{ "models/monsters/shocker/gibs/chest.md2", GIB_SKINNED },
+			{ "models/monsters/shocker/gibs/garm.md2", GIB_SKINNED | GIB_UPRIGHT },
+			{ "models/monsters/shocker/gibs/gun.md2", GIB_SKINNED | GIB_UPRIGHT },
+			{ "models/monsters/shocker/gibs/foot.md2", GIB_SKINNED },
+			{ head_gib, GIB_SKINNED | GIB_HEAD }
+			});
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	// regular death
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	// these animations cleanly transitions to death, so just keep going
+	if (self->monsterinfo.active_move == &shocker_move_pain5 &&
+		self->s.frame < FRAME_c_pain508)
+		return;
+	else if (self->monsterinfo.active_move == &shocker_move_pain6 &&
+		self->s.frame < FRAME_c_pain607)
+		return;
+
+	vec3_t forward;
+	AngleVectors(self->s.angles, forward, nullptr, nullptr);
+
+	vec3_t dif = (inflictor->s.origin - self->s.origin);
+	dif.z = 0;
+	dif.normalize();
+
+	// off with da head
+	if (fabsf((self->s.origin[2] + self->viewheight) - point[2]) <= 4 &&
+		self->velocity.z < 65.f)
+	{
+		M_SetAnimation(self, &shocker_move_death5);
+
+		edict_t* head = ThrowGib(self, "models/monsters/shocker/gibs/head.md2", damage, GIB_NONE, self->s.scale);
+
+		if (head)
+		{
+			head->s.angles = self->s.angles;
+			head->s.origin = self->s.origin + vec3_t{ 0, 0, 24.f };
+			vec3_t headDir = (self->s.origin - inflictor->s.origin);
+			head->velocity = headDir / headDir.length() * 100.0f;
+			head->velocity[2] = 200.0f;
+			head->avelocity *= 0.15f;
+			gi.linkentity(head);
+		}
+	}
+	// damage came from behind; use backwards death
+	else if (dif.dot(forward) < -0.40f)
+	{
+		int r = irandom(0, self->monsterinfo.active_move == &shocker_move_pain6 ? 2 : 3);
+
+		if (r == 0)
+			M_SetAnimation(self, &shocker_move_death3);
+		else if (r == 1)
+			M_SetAnimation(self, &shocker_move_death7);
+		else if (r == 2)
+			M_SetAnimation(self, &shocker_move_pain6);
+	}
+	else
+	{
+		int r = irandom(0, self->monsterinfo.active_move == &shocker_move_pain5 ? 1 : 2);
+
+		if (r == 0)
+			M_SetAnimation(self, &shocker_move_death4);
+		else
+			M_SetAnimation(self, &shocker_move_pain5);
+	}
+}
+
+void shocker_opengun(edict_t* self)
+{
+	gi.sound(self, CHAN_VOICE, sound_open, 1, ATTN_IDLE, 0);
+}
+
+void ShockerFire(edict_t* self)
+{
+	vec3_t					 start;
+	vec3_t					 forward, right;
+	vec3_t					 aim;
+	monster_muzzleflash_id_t flash_number;
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	if (self->s.frame >= FRAME_c_attack401 && self->s.frame <= FRAME_c_attack505)
+		flash_number = MZ2_GUNCMDR_CHAINGUN_2;
+	else
+		flash_number = MZ2_GUNCMDR_CHAINGUN_1;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+	PredictAim(self, self->enemy, start, 800, false, frandom() * 0.3f, &aim, nullptr);
+	for (int i = 0; i < 3; i++)
+		aim[i] += crandom_open() * 0.025f;
+	monster_fire_flechette(self, start, aim, 4, 800, flash_number);
+}
+
+mframe_t shocker_frames_attack_chain[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, shocker_opengun },
+	{ ai_charge }
+};
+MMOVE_T(shocker_move_attack_chain) = { FRAME_c_attack101, FRAME_c_attack106, shocker_frames_attack_chain, shocker_fire_chain };
+
+mframe_t shocker_frames_fire_chain[] = {
+	{ ai_charge, 0, ShockerFire },
+	{ ai_charge, 0, ShockerFire },
+	{ ai_charge, 0, ShockerFire },
+	{ ai_charge, 0, ShockerFire },
+	{ ai_charge, 0, ShockerFire },
+	{ ai_charge, 0, ShockerFire }
+};
+MMOVE_T(shocker_move_fire_chain) = { FRAME_c_attack107, FRAME_c_attack112, shocker_frames_fire_chain, shocker_refire_chain };
+
+mframe_t shocker_frames_fire_chain_run[] = {
+	{ ai_charge, 15.f, ShockerFire },
+	{ ai_charge, 16.f, ShockerFire },
+	{ ai_charge, 20.f, ShockerFire },
+	{ ai_charge, 18.f, ShockerFire },
+	{ ai_charge, 24.f, ShockerFire },
+	{ ai_charge, 13.5f, ShockerFire }
+};
+MMOVE_T(shocker_move_fire_chain_run) = { FRAME_c_run201, FRAME_c_run206, shocker_frames_fire_chain_run, shocker_refire_chain };
+
+mframe_t shocker_frames_fire_chain_dodge_right[] = {
+	{ ai_charge, 5.1f * 2.0f, ShockerFire },
+	{ ai_charge, 9.0f * 2.0f, ShockerFire },
+	{ ai_charge, 3.5f * 2.0f, ShockerFire },
+	{ ai_charge, 3.6f * 2.0f, ShockerFire },
+	{ ai_charge, -1.0f * 2.0f, ShockerFire }
+};
+MMOVE_T(shocker_move_fire_chain_dodge_right) = { FRAME_c_attack401, FRAME_c_attack405, shocker_frames_fire_chain_dodge_right, shocker_refire_chain };
+
+mframe_t shocker_frames_fire_chain_dodge_left[] = {
+	{ ai_charge, 5.1f * 2.0f, ShockerFire },
+	{ ai_charge, 9.0f * 2.0f, ShockerFire },
+	{ ai_charge, 3.5f * 2.0f, ShockerFire },
+	{ ai_charge, 3.6f * 2.0f, ShockerFire },
+	{ ai_charge, -1.0f * 2.0f, ShockerFire }
+};
+MMOVE_T(shocker_move_fire_chain_dodge_left) = { FRAME_c_attack501, FRAME_c_attack505, shocker_frames_fire_chain_dodge_left, shocker_refire_chain };
+
+mframe_t shocker_frames_endfire_chain[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, shocker_opengun },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(shocker_move_endfire_chain) = { FRAME_c_attack118, FRAME_c_attack124, shocker_frames_endfire_chain, shocker_run };
+
+constexpr float MORTAR_SPEED = 850.f;
+constexpr float GRENADE_SPEED = 600.f;
+
+void ShockerGrenade(edict_t* self)
+{
+	vec3_t					 start;
+	vec3_t					 forward, right, up;
+	vec3_t					 aim;
+	monster_muzzleflash_id_t flash_number;
+	float					 spread;
+	float					 pitch = 0;
+	// PMM
+	vec3_t target;
+	bool   blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	// pmm
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+
+	if (self->s.frame == FRAME_c_attack205)
+	{
+		spread = -0.1f;
+		flash_number = MZ2_GUNCMDR_GRENADE_MORTAR_1;
+	}
+	else if (self->s.frame == FRAME_c_attack208)
+	{
+		spread = 0.f;
+		flash_number = MZ2_GUNCMDR_GRENADE_MORTAR_2;
+	}
+	else if (self->s.frame == FRAME_c_attack211)
+	{
+		spread = 0.1f;
+		flash_number = MZ2_GUNCMDR_GRENADE_MORTAR_3;
+	}
+	else if (self->s.frame == FRAME_c_attack304)
+	{
+		spread = -0.1f;
+		flash_number = MZ2_GUNCMDR_GRENADE_FRONT_1;
+	}
+	else if (self->s.frame == FRAME_c_attack307)
+	{
+		spread = 0.f;
+		flash_number = MZ2_GUNCMDR_GRENADE_FRONT_2;
+	}
+	else if (self->s.frame == FRAME_c_attack310)
+	{
+		spread = 0.1f;
+		flash_number = MZ2_GUNCMDR_GRENADE_FRONT_3;
+	}
+	else if (self->s.frame == FRAME_c_attack911)
+	{
+		spread = 0.25f;
+		flash_number = MZ2_GUNCMDR_GRENADE_CROUCH_1;
+	}
+	else if (self->s.frame == FRAME_c_attack912)
+	{
+		spread = 0.f;
+		flash_number = MZ2_GUNCMDR_GRENADE_CROUCH_2;
+	}
+	else if (self->s.frame == FRAME_c_attack913)
+	{
+		spread = -0.25f;
+		flash_number = MZ2_GUNCMDR_GRENADE_CROUCH_3;
+	}
+
+	//	pmm
+	// if we're shooting blind and we still can't see our enemy
+	if ((blindfire) && (!visible(self, self->enemy)))
+	{
+		// and we have a valid blind_fire_target
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		target = self->monsterinfo.blind_fire_target;
+	}
+	else
+		target = self->enemy->s.origin;
+	// pmm
+
+	AngleVectors(self->s.angles, forward, right, up); // PGM
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+
+	// PGM
+	if (self->enemy && !(flash_number >= MZ2_GUNCMDR_GRENADE_CROUCH_1 && flash_number <= MZ2_GUNCMDR_GRENADE_CROUCH_3))
+	{
+		float dist;
+
+		aim = target - self->s.origin;
+		dist = aim.length();
+
+		// aim up if they're on the same level as me and far away.
+		if ((dist > 512) && (aim[2] < 64) && (aim[2] > -64))
+		{
+			aim[2] += (dist - 512);
+		}
+
+		aim.normalize();
+		pitch = aim[2];
+		if (pitch > 0.4f)
+			pitch = 0.4f;
+		else if (pitch < -0.5f)
+			pitch = -0.5f;
+
+		if ((self->enemy->absmin.z - self->absmax.z) > 16.f && flash_number >= MZ2_GUNCMDR_GRENADE_MORTAR_1 && flash_number <= MZ2_GUNCMDR_GRENADE_MORTAR_3)
+			pitch += 0.5f;
+	}
+	// PGM
+
+	if (flash_number >= MZ2_GUNCMDR_GRENADE_FRONT_1 && flash_number <= MZ2_GUNCMDR_GRENADE_FRONT_3)
+		pitch -= 0.05f;
+
+	if (!(flash_number >= MZ2_GUNCMDR_GRENADE_CROUCH_1 && flash_number <= MZ2_GUNCMDR_GRENADE_CROUCH_3))
+	{
+		aim = forward + (right * spread);
+		aim += (up * pitch);
+		aim.normalize();
+	}
+	else
+	{
+		PredictAim(self, self->enemy, start, 800, false, 0.f, &aim, nullptr);
+		aim += right * spread;
+		aim.normalize();
+	}
+
+	if (flash_number >= MZ2_GUNCMDR_GRENADE_CROUCH_1 && flash_number <= MZ2_GUNCMDR_GRENADE_CROUCH_3)
+	{
+		constexpr float inner_spread = 0.125f;
+
+		for (int32_t i = 0; i < 3; i++)
+			fire_ionripper(self, start, aim + (right * (-(inner_spread * 2) + (inner_spread * (i + 1)))), 15, 800, EF_IONRIPPER);
+
+		monster_muzzleflash(self, start, flash_number);
+	}
+	else
+	{
+		// mortar fires farther
+		float speed;
+
+		if (flash_number >= MZ2_GUNCMDR_GRENADE_MORTAR_1 && flash_number <= MZ2_GUNCMDR_GRENADE_MORTAR_3)
+			speed = MORTAR_SPEED;
+		else
+			speed = GRENADE_SPEED;
+
+		// try search for best pitch
+		if (M_CalculatePitchToFire(self, target, start, aim, speed, 2.5f, (flash_number >= MZ2_GUNCMDR_GRENADE_MORTAR_1 && flash_number <= MZ2_GUNCMDR_GRENADE_MORTAR_3)))
+			monster_fire_grenade(self, start, aim, 50, speed, flash_number, (crandom_open() * 10.0f), frandom() * 10.f);
+		else
+			// normal shot
+			monster_fire_grenade(self, start, aim, 50, speed, flash_number, (crandom_open() * 10.0f), 200.f + (crandom_open() * 10.0f));
+	}
+}
+
+mframe_t shocker_frames_attack_mortar[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, ShockerGrenade },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, ShockerGrenade },
+	{ ai_charge },
+	{ ai_charge },
+
+	{ ai_charge, 0, ShockerGrenade },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, monster_duck_up },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(shocker_move_attack_mortar) = { FRAME_c_attack201, FRAME_c_attack221, shocker_frames_attack_mortar, shocker_run };
+
+void shocker_grenade_mortar_resume(edict_t* self)
+{
+	M_SetAnimation(self, &shocker_move_attack_mortar);
+	self->monsterinfo.attack_state = AS_STRAIGHT;
+	self->s.frame = self->count;
+}
+
+mframe_t shocker_frames_attack_mortar_dodge[] = {
+	{ ai_charge, 11.f },
+	{ ai_charge, 12.f },
+	{ ai_charge, 16.f },
+	{ ai_charge, 16.f },
+	{ ai_charge, 12.f },
+	{ ai_charge, 11.f }
+};
+MMOVE_T(shocker_move_attack_mortar_dodge) = { FRAME_c_duckstep01, FRAME_c_duckstep06, shocker_frames_attack_mortar_dodge, shocker_grenade_mortar_resume };
+
+mframe_t shocker_frames_attack_back[] = {
+	//{ ai_charge },
+	{ ai_charge, -2.f },
+	{ ai_charge, -1.5f },
+	{ ai_charge, -0.5f, ShockerGrenade },
+	{ ai_charge, -6.0f },
+	{ ai_charge, -4.f },
+	{ ai_charge, -2.5f, ShockerGrenade },
+	{ ai_charge, -7.0f },
+	{ ai_charge, -3.5f },
+	{ ai_charge, -1.1f, ShockerGrenade },
+
+	{ ai_charge, -4.6f },
+	{ ai_charge, 1.9f },
+	{ ai_charge, 1.0f },
+	{ ai_charge, -4.5f },
+	{ ai_charge, 3.2f },
+	{ ai_charge, 4.4f },
+	{ ai_charge, -6.5f },
+	{ ai_charge, -6.1f },
+	{ ai_charge, 3.0f },
+	{ ai_charge, -0.7f },
+	{ ai_charge, -1.0f }
+};
+MMOVE_T(shocker_move_attack_grenade_back) = { FRAME_c_attack302, FRAME_c_attack321, shocker_frames_attack_back, shocker_run };
+
+void shocker_grenade_back_dodge_resume(edict_t* self)
+{
+	M_SetAnimation(self, &shocker_move_attack_grenade_back);
+	self->monsterinfo.attack_state = AS_STRAIGHT;
+	self->s.frame = self->count;
+}
+
+mframe_t shocker_frames_attack_grenade_back_dodge_right[] = {
+	{ ai_charge, 5.1f * 2.0f },
+	{ ai_charge, 9.0f * 2.0f },
+	{ ai_charge, 3.5f * 2.0f },
+	{ ai_charge, 3.6f * 2.0f },
+	{ ai_charge, -1.0f * 2.0f }
+};
+MMOVE_T(shocker_move_attack_grenade_back_dodge_right) = { FRAME_c_attack601, FRAME_c_attack605, shocker_frames_attack_grenade_back_dodge_right, shocker_grenade_back_dodge_resume };
+
+mframe_t shocker_frames_attack_grenade_back_dodge_left[] = {
+	{ ai_charge, 5.1f * 2.0f },
+	{ ai_charge, 9.0f * 2.0f },
+	{ ai_charge, 3.5f * 2.0f },
+	{ ai_charge, 3.6f * 2.0f },
+	{ ai_charge, -1.0f * 2.0f }
+};
+MMOVE_T(shocker_move_attack_grenade_back_dodge_left) = { FRAME_c_attack701, FRAME_c_attack705, shocker_frames_attack_grenade_back_dodge_left, shocker_grenade_back_dodge_resume };
+
+static void shocker_kick_finished(edict_t* self)
+{
+	self->monsterinfo.melee_debounce_time = level.time + 3_sec;
+	self->monsterinfo.attack(self);
+}
+
+static void shocker_kick(edict_t* self)
+{
+	if (fire_hit(self, vec3_t{ MELEE_DISTANCE, 0.f, -32.f }, 15.f, 400.f))
+	{
+		if (self->enemy && self->enemy->client && self->enemy->velocity.z < 270.f)
+			self->enemy->velocity.z = 270.f;
+	}
+}
+
+mframe_t shocker_frames_attack_kick[] = {
+	{ ai_charge, -7.7f },
+	{ ai_charge, -4.9f },
+	{ ai_charge, 12.6f, shocker_kick },
+	{ ai_charge },
+	{ ai_charge, -3.0f },
+	{ ai_charge },
+	{ ai_charge, -4.1f },
+	{ ai_charge, 8.6f },
+	//{ ai_charge, -3.5f }
+};
+MMOVE_T(shocker_move_attack_kick) = { FRAME_c_attack801, FRAME_c_attack808, shocker_frames_attack_kick, shocker_kick_finished };
+
+// don't ever try grenades if we get this close
+constexpr float RANGE_GRENADE = 100.f;
+
+// always use mortar at this range
+constexpr float RANGE_GRENADE_MORTAR = 525.f;
+
+// at this range, run towards the enemy
+constexpr float RANGE_CHAINGUN_RUN = 400.f;
+
+MONSTERINFO_ATTACK(shocker_attack) (edict_t* self) -> void
+{
+	monster_done_dodge(self);
+
+	float d = range_to(self, self->enemy);
+
+	vec3_t forward, right, aim;
+	AngleVectors(self->s.angles, forward, right, nullptr); // PGM
+
+	// always use chaingun on tesla
+	// kick close enemies
+	if (!self->bad_area && d < RANGE_MELEE && self->monsterinfo.melee_debounce_time < level.time)
+		M_SetAnimation(self, &shocker_move_attack_kick);
+	else if (self->bad_area || ((d <= RANGE_GRENADE || brandom()) && M_CheckClearShot(self, monster_flash_offset[MZ2_GUNCMDR_CHAINGUN_1])))
+		M_SetAnimation(self, &shocker_move_attack_chain);
+	else if ((d >= RANGE_GRENADE_MORTAR ||
+		fabs(self->absmin.z - self->enemy->absmax.z) > 64.f // enemy is far below or above us, always try mortar
+		) && M_CheckClearShot(self, monster_flash_offset[MZ2_GUNCMDR_GRENADE_MORTAR_1]) &&
+		M_CalculatePitchToFire(self, self->enemy->s.origin, M_ProjectFlashSource(self, monster_flash_offset[MZ2_GUNCMDR_GRENADE_MORTAR_1], forward, right),
+			aim = (self->enemy->s.origin - self->s.origin).normalized(), MORTAR_SPEED, 2.5f, true)
+		)
+	{
+		M_SetAnimation(self, &shocker_move_attack_mortar);
+		monster_duck_down(self);
+	}
+	else if (M_CheckClearShot(self, monster_flash_offset[MZ2_GUNCMDR_GRENADE_FRONT_1]) && !(self->monsterinfo.aiflags & AI_STAND_GROUND) &&
+		M_CalculatePitchToFire(self, self->enemy->s.origin, M_ProjectFlashSource(self, monster_flash_offset[MZ2_GUNCMDR_GRENADE_FRONT_1], forward, right),
+			aim = (self->enemy->s.origin - self->s.origin).normalized(), GRENADE_SPEED, 2.5f, false))
+		M_SetAnimation(self, &shocker_move_attack_grenade_back);
+	else if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &shocker_move_attack_chain);
+}
+
+void shocker_fire_chain(edict_t* self)
+{
+	if (!(self->monsterinfo.aiflags & AI_STAND_GROUND) && self->enemy && range_to(self, self->enemy) > RANGE_CHAINGUN_RUN && ai_check_move(self, 8.0f))
+		M_SetAnimation(self, &shocker_move_fire_chain_run);
+	else
+		M_SetAnimation(self, &shocker_move_fire_chain);
+}
+
+void shocker_refire_chain(edict_t* self)
+{
+	monster_done_dodge(self);
+	self->monsterinfo.attack_state = AS_STRAIGHT;
+
+	if (self->enemy->health > 0)
+		if (visible(self, self->enemy))
+			if (frandom() <= 0.5f)
+			{
+				if (!(self->monsterinfo.aiflags & AI_STAND_GROUND) && self->enemy && range_to(self, self->enemy) > RANGE_CHAINGUN_RUN && ai_check_move(self, 8.0f))
+					M_SetAnimation(self, &shocker_move_fire_chain_run, false);
+				else
+					M_SetAnimation(self, &shocker_move_fire_chain, false);
+				return;
+			}
+	M_SetAnimation(self, &shocker_move_endfire_chain, false);
+}
+
+//===========
+// PGM
+void shocker_jump_now(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 100);
+	self->velocity += (up * 300);
+}
+
+void shocker_jump2_now(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 150);
+	self->velocity += (up * 400);
+}
+
+void shocker_jump_wait_land(edict_t* self)
+{
+	if (self->groundentity == nullptr)
+	{
+		self->monsterinfo.nextframe = self->s.frame;
+
+		if (monster_jump_finished(self))
+			self->monsterinfo.nextframe = self->s.frame + 1;
+	}
+	else
+		self->monsterinfo.nextframe = self->s.frame + 1;
+}
+
+mframe_t shocker_frames_jump[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, shocker_jump_now },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, shocker_jump_wait_land },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(shocker_move_jump) = { FRAME_c_jump01, FRAME_c_jump10, shocker_frames_jump, shocker_run };
+
+mframe_t shocker_frames_jump2[] = {
+	{ ai_move, -8 },
+	{ ai_move, -4 },
+	{ ai_move, -4 },
+	{ ai_move, 0, shocker_jump2_now },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, shocker_jump_wait_land },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(shocker_move_jump2) = { FRAME_c_jump01, FRAME_c_jump10, shocker_frames_jump2, shocker_run };
+
+void shocker_jump(edict_t* self, blocked_jump_result_t result)
+{
+	if (!self->enemy)
+		return;
+
+	monster_done_dodge(self);
+
+	if (result == blocked_jump_result_t::JUMP_JUMP_UP)
+		M_SetAnimation(self, &shocker_move_jump2);
+	else
+		M_SetAnimation(self, &shocker_move_jump);
+}
+
+void T_SlamRadiusDamage(vec3_t point, edict_t* inflictor, edict_t* attacker, float damage, float kick, edict_t* ignore, float radius, mod_t mod);
+
+static void ShockerCounter(edict_t* self)
+{
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_BERSERK_SLAM);
+	vec3_t f, r, start;
+	AngleVectors(self->s.angles, f, r, nullptr);
+	start = M_ProjectFlashSource(self, { 20.f, 0.f, 14.f }, f, r);
+	trace_t tr = gi.traceline(self->s.origin, start, self, MASK_SOLID);
+	gi.WritePosition(tr.endpos);
+	gi.WriteDir(f);
+	gi.multicast(tr.endpos, MULTICAST_PHS, false);
+
+	T_SlamRadiusDamage(tr.endpos, self, self, 15, 250.f, self, 200.f, MOD_UNKNOWN);
+}
+
+//===========
+// PGM
+mframe_t shocker_frames_duck_attack[] = {
+	{ ai_move, 3.6f },
+	{ ai_move, 5.6f, monster_duck_down },
+	{ ai_move, 8.4f },
+	{ ai_move, 2.0f, monster_duck_hold },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+
+	//{ ai_charge, 0, ShockerGrenade },
+	//{ ai_charge, 9.5f, ShockerGrenade },
+	//{ ai_charge, -1.5f, ShockerGrenade },
+
+	{ ai_charge, 0 },
+	{ ai_charge, 9.5f, ShockerCounter },
+	{ ai_charge, -1.5f },
+	{ ai_charge },
+	{ ai_charge, 0, monster_duck_up },
+	{ ai_charge },
+	{ ai_charge, 11.f },
+	{ ai_charge, 2.0f },
+	{ ai_charge, 5.6f }
+};
+MMOVE_T(shocker_move_duck_attack) = { FRAME_c_attack901, FRAME_c_attack919, shocker_frames_duck_attack, shocker_run };
+
+MONSTERINFO_DUCK(shocker_duck) (edict_t* self, gtime_t eta) -> bool
+{
+	if ((self->monsterinfo.active_move == &shocker_move_jump2) ||
+		(self->monsterinfo.active_move == &shocker_move_jump))
+	{
+		return false;
+	}
+
+	if ((self->monsterinfo.active_move == &shocker_move_fire_chain_dodge_left) ||
+		(self->monsterinfo.active_move == &shocker_move_fire_chain_dodge_right) ||
+		(self->monsterinfo.active_move == &shocker_move_attack_grenade_back_dodge_left) ||
+		(self->monsterinfo.active_move == &shocker_move_attack_grenade_back_dodge_right) ||
+		(self->monsterinfo.active_move == &shocker_move_attack_mortar_dodge))
+	{
+		// if we're dodging, don't duck
+		self->monsterinfo.unduck(self);
+		return false;
+	}
+
+	M_SetAnimation(self, &shocker_move_duck_attack);
+
+	return true;
+}
+
+MONSTERINFO_SIDESTEP(shocker_sidestep) (edict_t* self) -> bool
+{
+	// use special dodge during the main firing anim
+	if (self->monsterinfo.active_move == &shocker_move_fire_chain ||
+		self->monsterinfo.active_move == &shocker_move_fire_chain_run)
+	{
+		M_SetAnimation(self, !self->monsterinfo.lefty ? &shocker_move_fire_chain_dodge_right : &shocker_move_fire_chain_dodge_left, false);
+		return true;
+	}
+
+	// for backwards mortar, back up where we are in the animation and do a quick dodge
+	if (self->monsterinfo.active_move == &shocker_move_attack_grenade_back)
+	{
+		self->count = self->s.frame;
+		M_SetAnimation(self, !self->monsterinfo.lefty ? &shocker_move_attack_grenade_back_dodge_right : &shocker_move_attack_grenade_back_dodge_left, false);
+		return true;
+	}
+
+	// use crouch-move for mortar dodge
+	if (self->monsterinfo.active_move == &shocker_move_attack_mortar)
+	{
+		self->count = self->s.frame;
+		M_SetAnimation(self, &shocker_move_attack_mortar_dodge, false);
+		return true;
+	}
+
+	// regular sidestep during run
+	if (self->monsterinfo.active_move == &shocker_move_run)
+	{
+		M_SetAnimation(self, &shocker_move_run, true);
+		return true;
+	}
+
+	return false;
+}
+
+MONSTERINFO_BLOCKED(shocker_blocked) (edict_t* self, float dist) -> bool
+{
+	if (blocked_checkplat(self, dist))
+		return true;
+
+	if (auto result = blocked_checkjump(self, dist); result != blocked_jump_result_t::NO_JUMP)
+	{
+		if (result != blocked_jump_result_t::JUMP_TURN)
+			shocker_jump(self, result);
+
+		return true;
+	}
+
+	return false;
+}
+// PGM
+//===========
+
+/*QUAKED monster_shocker (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping
+model="models/monsters/shocker/tris.md2"
+*/
+void SP_monster_shocker(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_death.assign("shocker/gcdrdeath1.wav");
+	sound_pain.assign("shocker/gcdrpain2.wav");
+	sound_pain2.assign("shocker/gcdrpain1.wav");
+	sound_idle.assign("shocker/gcdridle1.wav");
+	sound_open.assign("shocker/gcdratck1.wav");
+	sound_search.assign("shocker/gcdrsrch1.wav");
+	sound_sight.assign("shocker/sight1.wav");
+
+	gi.soundindex("shocker/gcdratck2.wav");
+	gi.soundindex("shocker/gcdratck3.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex("models/monsters/shocker/tris.md2");
+
+	gi.modelindex("models/monsters/shocker/gibs/chest.md2");
+	gi.modelindex("models/monsters/shocker/gibs/foot.md2");
+	gi.modelindex("models/monsters/shocker/gibs/garm.md2");
+	gi.modelindex("models/monsters/shocker/gibs/gun.md2");
+	gi.modelindex("models/monsters/shocker/gibs/head.md2");
+
+	self->s.scale = 1.25f;
+	self->mins = vec3_t{ -16, -16, -24 };
+	self->maxs = vec3_t{ 16, 16, 36 };
+	self->s.skinnum = 2;
+
+	self->health = 325 * st.health_multiplier;
+	self->gib_health = -175;
+	self->mass = 255;
+
+	self->pain = shocker_pain;
+	self->die = shocker_die;
+
+	self->monsterinfo.stand = shocker_stand;
+	self->monsterinfo.walk = shocker_walk;
+	self->monsterinfo.run = shocker_run;
+	// pmm
+	self->monsterinfo.dodge = M_MonsterDodge;
+	self->monsterinfo.duck = shocker_duck;
+	self->monsterinfo.unduck = monster_duck_up;
+	self->monsterinfo.sidestep = shocker_sidestep;
+	self->monsterinfo.blocked = shocker_blocked; // PGM
+	// pmm
+	self->monsterinfo.attack = shocker_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = shocker_sight;
+	self->monsterinfo.search = shocker_search;
+	self->monsterinfo.setskin = shocker_setskin;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &shocker_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	/* KONIG - power armor -> screen */
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = 200;
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SCREEN;
+
+	// PMM
+	//self->monsterinfo.blindfire = true;
+	self->monsterinfo.can_jump = !self->spawnflags.has(SPAWNFLAG_SHOCKER_NOJUMPING);
+	self->monsterinfo.drop_height = 192;
+	self->monsterinfo.jump_height = 40;
+
+	walkmonster_start(self);
+}
--- /dev/null
+++ b/ionized/m_shocker.h	2025-09-04 19:53:48
@@ -0,0 +1,809 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+// E:\G Drive\md2f\quake2\baseq2\models/monsters/gunner
+
+// This file generated by qdata - Do NOT Modify
+
+enum {
+	FRAME_stand01,
+	FRAME_stand02,
+	FRAME_stand03,
+	FRAME_stand04,
+	FRAME_stand05,
+	FRAME_stand06,
+	FRAME_stand07,
+	FRAME_stand08,
+	FRAME_stand09,
+	FRAME_stand10,
+	FRAME_stand11,
+	FRAME_stand12,
+	FRAME_stand13,
+	FRAME_stand14,
+	FRAME_stand15,
+	FRAME_stand16,
+	FRAME_stand17,
+	FRAME_stand18,
+	FRAME_stand19,
+	FRAME_stand20,
+	FRAME_stand21,
+	FRAME_stand22,
+	FRAME_stand23,
+	FRAME_stand24,
+	FRAME_stand25,
+	FRAME_stand26,
+	FRAME_stand27,
+	FRAME_stand28,
+	FRAME_stand29,
+	FRAME_stand30,
+	FRAME_stand31,
+	FRAME_stand32,
+	FRAME_stand33,
+	FRAME_stand34,
+	FRAME_stand35,
+	FRAME_stand36,
+	FRAME_stand37,
+	FRAME_stand38,
+	FRAME_stand39,
+	FRAME_stand40,
+	FRAME_stand41,
+	FRAME_stand42,
+	FRAME_stand43,
+	FRAME_stand44,
+	FRAME_stand45,
+	FRAME_stand46,
+	FRAME_stand47,
+	FRAME_stand48,
+	FRAME_stand49,
+	FRAME_stand50,
+	FRAME_stand51,
+	FRAME_stand52,
+	FRAME_stand53,
+	FRAME_stand54,
+	FRAME_stand55,
+	FRAME_stand56,
+	FRAME_stand57,
+	FRAME_stand58,
+	FRAME_stand59,
+	FRAME_stand60,
+	FRAME_stand61,
+	FRAME_stand62,
+	FRAME_stand63,
+	FRAME_stand64,
+	FRAME_stand65,
+	FRAME_stand66,
+	FRAME_stand67,
+	FRAME_stand68,
+	FRAME_stand69,
+	FRAME_stand70,
+	FRAME_walk01,
+	FRAME_walk02,
+	FRAME_walk03,
+	FRAME_walk04,
+	FRAME_walk05,
+	FRAME_walk06,
+	FRAME_walk07,
+	FRAME_walk08,
+	FRAME_walk09,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12,
+	FRAME_walk13,
+	FRAME_walk14,
+	FRAME_walk15,
+	FRAME_walk16,
+	FRAME_walk17,
+	FRAME_walk18,
+	FRAME_walk19,
+	FRAME_walk20,
+	FRAME_walk21,
+	FRAME_walk22,
+	FRAME_walk23,
+	FRAME_walk24,
+	FRAME_run01,
+	FRAME_run02,
+	FRAME_run03,
+	FRAME_run04,
+	FRAME_run05,
+	FRAME_run06,
+	FRAME_run07,
+	FRAME_run08,
+	FRAME_runs01,
+	FRAME_runs02,
+	FRAME_runs03,
+	FRAME_runs04,
+	FRAME_runs05,
+	FRAME_runs06,
+	FRAME_attak101,
+	FRAME_attak102,
+	FRAME_attak103,
+	FRAME_attak104,
+	FRAME_attak105,
+	FRAME_attak106,
+	FRAME_attak107,
+	FRAME_attak108,
+	FRAME_attak109,
+	FRAME_attak110,
+	FRAME_attak111,
+	FRAME_attak112,
+	FRAME_attak113,
+	FRAME_attak114,
+	FRAME_attak115,
+	FRAME_attak116,
+	FRAME_attak117,
+	FRAME_attak118,
+	FRAME_attak119,
+	FRAME_attak120,
+	FRAME_attak121,
+	FRAME_attak201,
+	FRAME_attak202,
+	FRAME_attak203,
+	FRAME_attak204,
+	FRAME_attak205,
+	FRAME_attak206,
+	FRAME_attak207,
+	FRAME_attak208,
+	FRAME_attak209,
+	FRAME_attak210,
+	FRAME_attak211,
+	FRAME_attak212,
+	FRAME_attak213,
+	FRAME_attak214,
+	FRAME_attak215,
+	FRAME_attak216,
+	FRAME_attak217,
+	FRAME_attak218,
+	FRAME_attak219,
+	FRAME_attak220,
+	FRAME_attak221,
+	FRAME_attak222,
+	FRAME_attak223,
+	FRAME_attak224,
+	FRAME_attak225,
+	FRAME_attak226,
+	FRAME_attak227,
+	FRAME_attak228,
+	FRAME_attak229,
+	FRAME_attak230,
+	FRAME_pain101,
+	FRAME_pain102,
+	FRAME_pain103,
+	FRAME_pain104,
+	FRAME_pain105,
+	FRAME_pain106,
+	FRAME_pain107,
+	FRAME_pain108,
+	FRAME_pain109,
+	FRAME_pain110,
+	FRAME_pain111,
+	FRAME_pain112,
+	FRAME_pain113,
+	FRAME_pain114,
+	FRAME_pain115,
+	FRAME_pain116,
+	FRAME_pain117,
+	FRAME_pain118,
+	FRAME_pain201,
+	FRAME_pain202,
+	FRAME_pain203,
+	FRAME_pain204,
+	FRAME_pain205,
+	FRAME_pain206,
+	FRAME_pain207,
+	FRAME_pain208,
+	FRAME_pain301,
+	FRAME_pain302,
+	FRAME_pain303,
+	FRAME_pain304,
+	FRAME_pain305,
+	FRAME_death01,
+	FRAME_death02,
+	FRAME_death03,
+	FRAME_death04,
+	FRAME_death05,
+	FRAME_death06,
+	FRAME_death07,
+	FRAME_death08,
+	FRAME_death09,
+	FRAME_death10,
+	FRAME_death11,
+	FRAME_duck01,
+	FRAME_duck02,
+	FRAME_duck03,
+	FRAME_duck04,
+	FRAME_duck05,
+	FRAME_duck06,
+	FRAME_duck07,
+	FRAME_duck08,
+	FRAME_jump01,
+	FRAME_jump02,
+	FRAME_jump03,
+	FRAME_jump04,
+	FRAME_jump05,
+	FRAME_jump06,
+	FRAME_jump07,
+	FRAME_jump08,
+	FRAME_jump09,
+	FRAME_jump10,
+	FRAME_shield01,
+	FRAME_shield02,
+	FRAME_shield03,
+	FRAME_shield04,
+	FRAME_shield05,
+	FRAME_shield06,
+	FRAME_attak301,
+	FRAME_attak302,
+	FRAME_attak303,
+	FRAME_attak304,
+	FRAME_attak305,
+	FRAME_attak306,
+	FRAME_attak307,
+	FRAME_attak308,
+	FRAME_attak309,
+	FRAME_attak310,
+	FRAME_attak311,
+	FRAME_attak312,
+	FRAME_attak313,
+	FRAME_attak314,
+	FRAME_attak315,
+	FRAME_attak316,
+	FRAME_attak317,
+	FRAME_attak318,
+	FRAME_attak319,
+	FRAME_attak320,
+	FRAME_attak321,
+	FRAME_attak322,
+	FRAME_attak323,
+	FRAME_attak324,
+	FRAME_c_stand101,
+	FRAME_c_stand102,
+	FRAME_c_stand103,
+	FRAME_c_stand104,
+	FRAME_c_stand105,
+	FRAME_c_stand106,
+	FRAME_c_stand107,
+	FRAME_c_stand108,
+	FRAME_c_stand109,
+	FRAME_c_stand110,
+	FRAME_c_stand111,
+	FRAME_c_stand112,
+	FRAME_c_stand113,
+	FRAME_c_stand114,
+	FRAME_c_stand115,
+	FRAME_c_stand116,
+	FRAME_c_stand117,
+	FRAME_c_stand118,
+	FRAME_c_stand119,
+	FRAME_c_stand120,
+	FRAME_c_stand121,
+	FRAME_c_stand122,
+	FRAME_c_stand123,
+	FRAME_c_stand124,
+	FRAME_c_stand125,
+	FRAME_c_stand126,
+	FRAME_c_stand127,
+	FRAME_c_stand128,
+	FRAME_c_stand129,
+	FRAME_c_stand130,
+	FRAME_c_stand131,
+	FRAME_c_stand132,
+	FRAME_c_stand133,
+	FRAME_c_stand134,
+	FRAME_c_stand135,
+	FRAME_c_stand136,
+	FRAME_c_stand137,
+	FRAME_c_stand138,
+	FRAME_c_stand139,
+	FRAME_c_stand140,
+	FRAME_c_stand201,
+	FRAME_c_stand202,
+	FRAME_c_stand203,
+	FRAME_c_stand204,
+	FRAME_c_stand205,
+	FRAME_c_stand206,
+	FRAME_c_stand207,
+	FRAME_c_stand208,
+	FRAME_c_stand209,
+	FRAME_c_stand210,
+	FRAME_c_stand211,
+	FRAME_c_stand212,
+	FRAME_c_stand213,
+	FRAME_c_stand214,
+	FRAME_c_stand215,
+	FRAME_c_stand216,
+	FRAME_c_stand217,
+	FRAME_c_stand218,
+	FRAME_c_stand219,
+	FRAME_c_stand220,
+	FRAME_c_stand221,
+	FRAME_c_stand222,
+	FRAME_c_stand223,
+	FRAME_c_stand224,
+	FRAME_c_stand225,
+	FRAME_c_stand226,
+	FRAME_c_stand227,
+	FRAME_c_stand228,
+	FRAME_c_stand229,
+	FRAME_c_stand230,
+	FRAME_c_stand231,
+	FRAME_c_stand232,
+	FRAME_c_stand233,
+	FRAME_c_stand234,
+	FRAME_c_stand235,
+	FRAME_c_stand236,
+	FRAME_c_stand237,
+	FRAME_c_stand238,
+	FRAME_c_stand239,
+	FRAME_c_stand240,
+	FRAME_c_stand241,
+	FRAME_c_stand242,
+	FRAME_c_stand243,
+	FRAME_c_stand244,
+	FRAME_c_stand245,
+	FRAME_c_stand246,
+	FRAME_c_stand247,
+	FRAME_c_stand248,
+	FRAME_c_stand249,
+	FRAME_c_stand250,
+	FRAME_c_stand251,
+	FRAME_c_stand252,
+	FRAME_c_stand253,
+	FRAME_c_stand254,
+	FRAME_c_attack101,
+	FRAME_c_attack102,
+	FRAME_c_attack103,
+	FRAME_c_attack104,
+	FRAME_c_attack105,
+	FRAME_c_attack106,
+	FRAME_c_attack107,
+	FRAME_c_attack108,
+	FRAME_c_attack109,
+	FRAME_c_attack110,
+	FRAME_c_attack111,
+	FRAME_c_attack112,
+	FRAME_c_attack113,
+	FRAME_c_attack114,
+	FRAME_c_attack115,
+	FRAME_c_attack116,
+	FRAME_c_attack117,
+	FRAME_c_attack118,
+	FRAME_c_attack119,
+	FRAME_c_attack120,
+	FRAME_c_attack121,
+	FRAME_c_attack122,
+	FRAME_c_attack123,
+	FRAME_c_attack124,
+	FRAME_c_jump01,
+	FRAME_c_jump02,
+	FRAME_c_jump03,
+	FRAME_c_jump04,
+	FRAME_c_jump05,
+	FRAME_c_jump06,
+	FRAME_c_jump07,
+	FRAME_c_jump08,
+	FRAME_c_jump09,
+	FRAME_c_jump10,
+	FRAME_c_attack201,
+	FRAME_c_attack202,
+	FRAME_c_attack203,
+	FRAME_c_attack204,
+	FRAME_c_attack205,
+	FRAME_c_attack206,
+	FRAME_c_attack207,
+	FRAME_c_attack208,
+	FRAME_c_attack209,
+	FRAME_c_attack210,
+	FRAME_c_attack211,
+	FRAME_c_attack212,
+	FRAME_c_attack213,
+	FRAME_c_attack214,
+	FRAME_c_attack215,
+	FRAME_c_attack216,
+	FRAME_c_attack217,
+	FRAME_c_attack218,
+	FRAME_c_attack219,
+	FRAME_c_attack220,
+	FRAME_c_attack221,
+	FRAME_c_attack301,
+	FRAME_c_attack302,
+	FRAME_c_attack303,
+	FRAME_c_attack304,
+	FRAME_c_attack305,
+	FRAME_c_attack306,
+	FRAME_c_attack307,
+	FRAME_c_attack308,
+	FRAME_c_attack309,
+	FRAME_c_attack310,
+	FRAME_c_attack311,
+	FRAME_c_attack312,
+	FRAME_c_attack313,
+	FRAME_c_attack314,
+	FRAME_c_attack315,
+	FRAME_c_attack316,
+	FRAME_c_attack317,
+	FRAME_c_attack318,
+	FRAME_c_attack319,
+	FRAME_c_attack320,
+	FRAME_c_attack321,
+	FRAME_c_attack401,
+	FRAME_c_attack402,
+	FRAME_c_attack403,
+	FRAME_c_attack404,
+	FRAME_c_attack405,
+	FRAME_c_attack501,
+	FRAME_c_attack502,
+	FRAME_c_attack503,
+	FRAME_c_attack504,
+	FRAME_c_attack505,
+	FRAME_c_attack601,
+	FRAME_c_attack602,
+	FRAME_c_attack603,
+	FRAME_c_attack604,
+	FRAME_c_attack605,
+	FRAME_c_attack701,
+	FRAME_c_attack702,
+	FRAME_c_attack703,
+	FRAME_c_attack704,
+	FRAME_c_attack705,
+	FRAME_c_pain101,
+	FRAME_c_pain102,
+	FRAME_c_pain103,
+	FRAME_c_pain104,
+	FRAME_c_pain201,
+	FRAME_c_pain202,
+	FRAME_c_pain203,
+	FRAME_c_pain204,
+	FRAME_c_pain301,
+	FRAME_c_pain302,
+	FRAME_c_pain303,
+	FRAME_c_pain304,
+	FRAME_c_pain401,
+	FRAME_c_pain402,
+	FRAME_c_pain403,
+	FRAME_c_pain404,
+	FRAME_c_pain405,
+	FRAME_c_pain406,
+	FRAME_c_pain407,
+	FRAME_c_pain408,
+	FRAME_c_pain409,
+	FRAME_c_pain410,
+	FRAME_c_pain411,
+	FRAME_c_pain412,
+	FRAME_c_pain413,
+	FRAME_c_pain414,
+	FRAME_c_pain415,
+	FRAME_c_pain501,
+	FRAME_c_pain502,
+	FRAME_c_pain503,
+	FRAME_c_pain504,
+	FRAME_c_pain505,
+	FRAME_c_pain506,
+	FRAME_c_pain507,
+	FRAME_c_pain508,
+	FRAME_c_pain509,
+	FRAME_c_pain510,
+	FRAME_c_pain511,
+	FRAME_c_pain512,
+	FRAME_c_pain513,
+	FRAME_c_pain514,
+	FRAME_c_pain515,
+	FRAME_c_pain516,
+	FRAME_c_pain517,
+	FRAME_c_pain518,
+	FRAME_c_pain519,
+	FRAME_c_pain520,
+	FRAME_c_pain521,
+	FRAME_c_pain522,
+	FRAME_c_pain523,
+	FRAME_c_pain524,
+	FRAME_c_death101,
+	FRAME_c_death102,
+	FRAME_c_death103,
+	FRAME_c_death104,
+	FRAME_c_death105,
+	FRAME_c_death106,
+	FRAME_c_death107,
+	FRAME_c_death108,
+	FRAME_c_death109,
+	FRAME_c_death110,
+	FRAME_c_death111,
+	FRAME_c_death112,
+	FRAME_c_death113,
+	FRAME_c_death114,
+	FRAME_c_death115,
+	FRAME_c_death116,
+	FRAME_c_death117,
+	FRAME_c_death118,
+	FRAME_c_death201,
+	FRAME_c_death202,
+	FRAME_c_death203,
+	FRAME_c_death204,
+	FRAME_c_death301,
+	FRAME_c_death302,
+	FRAME_c_death303,
+	FRAME_c_death304,
+	FRAME_c_death305,
+	FRAME_c_death306,
+	FRAME_c_death307,
+	FRAME_c_death308,
+	FRAME_c_death309,
+	FRAME_c_death310,
+	FRAME_c_death311,
+	FRAME_c_death312,
+	FRAME_c_death313,
+	FRAME_c_death314,
+	FRAME_c_death315,
+	FRAME_c_death316,
+	FRAME_c_death317,
+	FRAME_c_death318,
+	FRAME_c_death319,
+	FRAME_c_death320,
+	FRAME_c_death321,
+	FRAME_c_death401,
+	FRAME_c_death402,
+	FRAME_c_death403,
+	FRAME_c_death404,
+	FRAME_c_death405,
+	FRAME_c_death406,
+	FRAME_c_death407,
+	FRAME_c_death408,
+	FRAME_c_death409,
+	FRAME_c_death410,
+	FRAME_c_death411,
+	FRAME_c_death412,
+	FRAME_c_death413,
+	FRAME_c_death414,
+	FRAME_c_death415,
+	FRAME_c_death416,
+	FRAME_c_death417,
+	FRAME_c_death418,
+	FRAME_c_death419,
+	FRAME_c_death420,
+	FRAME_c_death421,
+	FRAME_c_death422,
+	FRAME_c_death423,
+	FRAME_c_death424,
+	FRAME_c_death425,
+	FRAME_c_death426,
+	FRAME_c_death427,
+	FRAME_c_death428,
+	FRAME_c_death429,
+	FRAME_c_death430,
+	FRAME_c_death431,
+	FRAME_c_death432,
+	FRAME_c_death433,
+	FRAME_c_death434,
+	FRAME_c_death435,
+	FRAME_c_death436,
+	FRAME_c_death501,
+	FRAME_c_death502,
+	FRAME_c_death503,
+	FRAME_c_death504,
+	FRAME_c_death505,
+	FRAME_c_death506,
+	FRAME_c_death507,
+	FRAME_c_death508,
+	FRAME_c_death509,
+	FRAME_c_death510,
+	FRAME_c_death511,
+	FRAME_c_death512,
+	FRAME_c_death513,
+	FRAME_c_death514,
+	FRAME_c_death515,
+	FRAME_c_death516,
+	FRAME_c_death517,
+	FRAME_c_death518,
+	FRAME_c_death519,
+	FRAME_c_death520,
+	FRAME_c_death521,
+	FRAME_c_death522,
+	FRAME_c_death523,
+	FRAME_c_death524,
+	FRAME_c_death525,
+	FRAME_c_death526,
+	FRAME_c_death527,
+	FRAME_c_death528,
+	FRAME_c_run101,
+	FRAME_c_run102,
+	FRAME_c_run103,
+	FRAME_c_run104,
+	FRAME_c_run105,
+	FRAME_c_run106,
+	FRAME_c_run201,
+	FRAME_c_run202,
+	FRAME_c_run203,
+	FRAME_c_run204,
+	FRAME_c_run205,
+	FRAME_c_run206,
+	FRAME_c_run301,
+	FRAME_c_run302,
+	FRAME_c_run303,
+	FRAME_c_run304,
+	FRAME_c_run305,
+	FRAME_c_run306,
+	FRAME_c_walk101,
+	FRAME_c_walk102,
+	FRAME_c_walk103,
+	FRAME_c_walk104,
+	FRAME_c_walk105,
+	FRAME_c_walk106,
+	FRAME_c_walk107,
+	FRAME_c_walk108,
+	FRAME_c_walk109,
+	FRAME_c_walk110,
+	FRAME_c_walk111,
+	FRAME_c_walk112,
+	FRAME_c_walk113,
+	FRAME_c_walk114,
+	FRAME_c_walk115,
+	FRAME_c_walk116,
+	FRAME_c_walk117,
+	FRAME_c_walk118,
+	FRAME_c_walk119,
+	FRAME_c_walk120,
+	FRAME_c_walk121,
+	FRAME_c_walk122,
+	FRAME_c_walk123,
+	FRAME_c_walk124,
+	FRAME_c_pain601,
+	FRAME_c_pain602,
+	FRAME_c_pain603,
+	FRAME_c_pain604,
+	FRAME_c_pain605,
+	FRAME_c_pain606,
+	FRAME_c_pain607,
+	FRAME_c_pain608,
+	FRAME_c_pain609,
+	FRAME_c_pain610,
+	FRAME_c_pain611,
+	FRAME_c_pain612,
+	FRAME_c_pain613,
+	FRAME_c_pain614,
+	FRAME_c_pain615,
+	FRAME_c_pain616,
+	FRAME_c_pain617,
+	FRAME_c_pain618,
+	FRAME_c_pain619,
+	FRAME_c_pain620,
+	FRAME_c_pain621,
+	FRAME_c_pain622,
+	FRAME_c_pain623,
+	FRAME_c_pain624,
+	FRAME_c_pain625,
+	FRAME_c_pain626,
+	FRAME_c_pain627,
+	FRAME_c_pain628,
+	FRAME_c_pain629,
+	FRAME_c_pain630,
+	FRAME_c_pain631,
+	FRAME_c_pain632,
+	FRAME_c_death601,
+	FRAME_c_death602,
+	FRAME_c_death603,
+	FRAME_c_death604,
+	FRAME_c_death605,
+	FRAME_c_death606,
+	FRAME_c_death607,
+	FRAME_c_death608,
+	FRAME_c_death609,
+	FRAME_c_death610,
+	FRAME_c_death611,
+	FRAME_c_death612,
+	FRAME_c_death613,
+	FRAME_c_death614,
+	FRAME_c_death701,
+	FRAME_c_death702,
+	FRAME_c_death703,
+	FRAME_c_death704,
+	FRAME_c_death705,
+	FRAME_c_death706,
+	FRAME_c_death707,
+	FRAME_c_death708,
+	FRAME_c_death709,
+	FRAME_c_death710,
+	FRAME_c_death711,
+	FRAME_c_death712,
+	FRAME_c_death713,
+	FRAME_c_death714,
+	FRAME_c_death715,
+	FRAME_c_death716,
+	FRAME_c_death717,
+	FRAME_c_death718,
+	FRAME_c_death719,
+	FRAME_c_death720,
+	FRAME_c_death721,
+	FRAME_c_death722,
+	FRAME_c_death723,
+	FRAME_c_death724,
+	FRAME_c_death725,
+	FRAME_c_death726,
+	FRAME_c_death727,
+	FRAME_c_death728,
+	FRAME_c_death729,
+	FRAME_c_death730,
+	FRAME_c_pain701,
+	FRAME_c_pain702,
+	FRAME_c_pain703,
+	FRAME_c_pain704,
+	FRAME_c_pain705,
+	FRAME_c_pain706,
+	FRAME_c_pain707,
+	FRAME_c_pain708,
+	FRAME_c_pain709,
+	FRAME_c_pain710,
+	FRAME_c_pain711,
+	FRAME_c_pain712,
+	FRAME_c_pain713,
+	FRAME_c_pain714,
+	FRAME_c_attack801,
+	FRAME_c_attack802,
+	FRAME_c_attack803,
+	FRAME_c_attack804,
+	FRAME_c_attack805,
+	FRAME_c_attack806,
+	FRAME_c_attack807,
+	FRAME_c_attack808,
+	FRAME_c_attack809,
+	FRAME_c_attack901,
+	FRAME_c_attack902,
+	FRAME_c_attack903,
+	FRAME_c_attack904,
+	FRAME_c_attack905,
+	FRAME_c_attack906,
+	FRAME_c_attack907,
+	FRAME_c_attack908,
+	FRAME_c_attack909,
+	FRAME_c_attack910,
+	FRAME_c_attack911,
+	FRAME_c_attack912,
+	FRAME_c_attack913,
+	FRAME_c_attack914,
+	FRAME_c_attack915,
+	FRAME_c_attack916,
+	FRAME_c_attack917,
+	FRAME_c_attack918,
+	FRAME_c_attack919,
+	FRAME_c_duck01,
+	FRAME_c_duck02,
+	FRAME_c_duckstep01,
+	FRAME_c_duckstep02,
+	FRAME_c_duckstep03,
+	FRAME_c_duckstep04,
+	FRAME_c_duckstep05,
+	FRAME_c_duckstep06,
+	FRAME_c_duckpain01,
+	FRAME_c_duckpain02,
+	FRAME_c_duckpain03,
+	FRAME_c_duckpain04,
+	FRAME_c_duckpain05,
+	FRAME_c_duckdeath01,
+	FRAME_c_duckdeath02,
+	FRAME_c_duckdeath03,
+	FRAME_c_duckdeath04,
+	FRAME_c_duckdeath05,
+	FRAME_c_duckdeath06,
+	FRAME_c_duckdeath07,
+	FRAME_c_duckdeath08,
+	FRAME_c_duckdeath09,
+	FRAME_c_duckdeath10,
+	FRAME_c_duckdeath11,
+	FRAME_c_duckdeath12,
+	FRAME_c_duckdeath13,
+	FRAME_c_duckdeath14,
+	FRAME_c_duckdeath15,
+	FRAME_c_duckdeath16,
+	FRAME_c_duckdeath17,
+	FRAME_c_duckdeath18,
+	FRAME_c_duckdeath19,
+	FRAME_c_duckdeath20,
+	FRAME_c_duckdeath21,
+	FRAME_c_duckdeath22,
+	FRAME_c_duckdeath23,
+	FRAME_c_duckdeath24,
+	FRAME_c_duckdeath25,
+	FRAME_c_duckdeath26,
+	FRAME_c_duckdeath27,
+	FRAME_c_duckdeath28,
+	FRAME_c_duckdeath29
+};
+
+constexpr float MODEL_SCALE = 1.150000f;
--- /dev/null
+++ b/ionized/m_tactc.cpp	2025-09-04 19:53:48
@@ -0,0 +1,997 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+TACTICAL - CYBORG
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_tactical.h"
+#include "../m_flash.h"
+
+static cached_soundindex sound_pain;
+static cached_soundindex sound_death;
+static cached_soundindex sound_idle;
+static cached_soundindex sound_search;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_jump;
+
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_NOJUMPING = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_WEAPON1 = 16_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_WEAPON2 = 32_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_WEAPON3 = 64_spawnflag;
+
+//
+//SOUNDS
+//
+
+MONSTERINFO_IDLE(tactc_idle) (edict_t* self) -> void
+{
+	if (frandom() > 0.8f)
+		gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+MONSTERINFO_SEARCH(tactc_search) (edict_t* self) -> void
+{
+	if (frandom() > 0.8f)
+		gi.sound(self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SIGHT(tactc_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+//
+//STAND
+//
+
+void tactc_stand(edict_t* self);
+void tactc_fidget(edict_t* self);
+
+mframe_t tactc_frames_stand1[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactc_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactc_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactc_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactc_fidget }
+};
+MMOVE_T(tactc_move_stand1) = { FRAME_stand01, FRAME_stand40, tactc_frames_stand1, nullptr };
+
+mframe_t tactc_frames_stand2[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactc_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactc_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactc_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactc_fidget }
+};
+MMOVE_T(tactc_move_stand2) = { FRAME_stand01, FRAME_stand40, tactc_frames_stand2, nullptr };
+
+mframe_t tactc_frames_flip[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(tactc_move_flip) = { FRAME_flip01, FRAME_flip12, tactc_frames_flip, tactc_stand };
+
+mframe_t tactc_frames_salute[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand }
+};
+MMOVE_T(tactc_move_salute) = { FRAME_salute01, FRAME_salute11, tactc_frames_salute, tactc_stand };
+
+mframe_t tactc_frames_taunt[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(tactc_move_taunt) = { FRAME_taunt01, FRAME_taunt17, tactc_frames_taunt, tactc_stand };
+
+mframe_t tactc_frames_wave[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand }
+};
+MMOVE_T(tactc_move_wave) = { FRAME_wave01, FRAME_wave11, tactc_frames_wave, tactc_stand };
+
+mframe_t tactc_frames_point[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(tactc_move_point) = { FRAME_point01, FRAME_point12, tactc_frames_point, tactc_stand };
+
+void tactc_fidget(edict_t* self)
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		return;
+	else if (self->enemy)
+		return;
+
+	if (frandom() <= 0.01f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self); 
+		M_SetAnimation(self, &tactc_move_point);
+	}
+	else if (frandom() <= 0.02f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactc_move_wave);
+	}
+	else if (frandom() <= 0.03f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactc_move_taunt);
+	}
+	else if (frandom() <= 0.04f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactc_move_flip);
+	}
+	else if (frandom() <= 0.05f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactc_move_salute);
+	}
+}
+
+MONSTERINFO_STAND(tactc_stand) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		monster_duck_up(self);
+
+	if (frandom() < 0.8f)
+		M_SetAnimation(self, &tactc_move_stand1);
+	else
+	{
+		M_SetAnimation(self, &tactc_move_stand2);
+		monster_duck_down(self);
+	}
+}
+
+//
+//WALK
+//
+
+mframe_t tactc_frames_walk1[] = {
+	{ ai_walk, 4 },
+	{ ai_walk, 15, monster_footstep },
+	{ ai_walk, 15 },
+	{ ai_walk, 8 },
+	{ ai_walk, 20, monster_footstep },
+	{ ai_walk, 15 }
+};
+MMOVE_T(tactc_move_walk1) = { FRAME_run1, FRAME_run6, tactc_frames_walk1, nullptr };
+
+mframe_t tactc_frames_walk2[] = {
+	{ ai_walk },
+	{ ai_walk, 6, monster_footstep },
+	{ ai_walk, 10 },
+	{ ai_walk, 3 },
+	{ ai_walk, 2, monster_footstep },
+	{ ai_walk, 10 }
+};
+MMOVE_T(tactc_move_walk2) = { FRAME_crwalk1, FRAME_crwalk6, tactc_frames_walk2, nullptr };
+
+MONSTERINFO_WALK(tactc_walk) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		M_SetAnimation(self, &tactc_move_walk2);
+	else
+		M_SetAnimation(self, &tactc_move_walk1);
+}
+
+//
+//RUN
+//
+
+mframe_t tactc_frames_run[] = {
+	{ ai_run, 4 },
+	{ ai_run, 15, monster_footstep },
+	{ ai_run, 15 },
+	{ ai_run, 8 },
+	{ ai_run, 20, monster_footstep },
+	{ ai_run, 15 }
+};
+MMOVE_T(tactc_move_run) = { FRAME_run1, FRAME_run6, tactc_frames_run, nullptr };
+
+MONSTERINFO_RUN(tactc_run) (edict_t* self) -> void
+{
+	monster_done_dodge(self);
+
+	if ((frandom() >= 0.8f) && (self->monsterinfo.aiflags & AI_DUCKED))
+		monster_duck_up(self);
+
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &tactc_move_stand1);
+	else if (self->monsterinfo.aiflags & AI_DUCKED)
+	{
+		M_SetAnimation(self, &tactc_move_walk2);
+	}
+	else
+		monster_duck_up(self);
+		M_SetAnimation(self, &tactc_move_run);
+}
+
+//
+//ATTACKS
+//
+
+void tactc_fire_chainfist(edict_t* self) //chainfist
+{
+	constexpr vec3_t aim = { MELEE_DISTANCE, 0, -24 };
+
+	if (!fire_hit(self, aim, irandom(15, 25), 300))
+		self->monsterinfo.melee_debounce_time = level.time + 1.2_sec;
+}
+
+void tactc_fire_shotgun(edict_t* self) //shotgun
+{
+	vec3_t					 start;
+	vec3_t					 forward, right;
+	vec3_t					 aim;
+	monster_muzzleflash_id_t flash_number;
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	flash_number = MZ2_ACTOR_MACHINEGUN_1;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+	PredictAim(self, self->enemy, start, 800, false, frandom() * 0.3f, &aim, nullptr);
+	for (int i = 0; i < 3; i++)
+		aim[i] += crandom_open() * 0.025f;
+
+	gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/shotgf1b.wav"), 1, ATTN_NORM, 0);
+	monster_fire_shotgun(self, start, aim, 5, 1, 1500, 750, 9, flash_number);
+}
+
+void tactc_fire_phalanx(edict_t* self) //grenade
+{
+	vec3_t start;
+	vec3_t dir;
+	vec3_t forward, right;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[MZ2_GLADIATOR_RAILGUN_1], forward, right);
+
+	// calc direction to where we targeted
+	dir = self->pos1 - start;
+	dir.normalize();
+
+	int damage = 35;
+	int radius_damage = 45;
+
+	monster_fire_plasma(self, start, dir, damage, 725, radius_damage, radius_damage, MZ2_GLADIATOR_RAILGUN_1);
+
+	// save for aiming the shot
+	self->pos1 = self->enemy->s.origin;
+	self->pos1[2] += self->enemy->viewheight;
+
+	self->monsterinfo.attack_finished = level.time + 3_sec;
+}
+
+void tactc_fire_railgun(edict_t* self)
+{
+	vec3_t start;
+	vec3_t dir;
+	vec3_t forward, right;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[MZ2_ACTOR_MACHINEGUN_1], forward, right);
+
+	dir = self->pos1 - start;
+	dir.normalize();
+
+	gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/railgf1a.wav"), 1, ATTN_NORM, 0);
+	monster_fire_railgun(self, start, dir, 50, 100, MZ2_ACTOR_MACHINEGUN_1);
+
+	self->monsterinfo.attack_finished = level.time + 3_sec;
+}
+
+void tactc_fire_bfg(edict_t* self)
+{
+	vec3_t forward, right;
+	vec3_t start;
+	vec3_t dir;
+	vec3_t vec;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[MZ2_ACTOR_MACHINEGUN_1], forward, right);
+
+	vec = self->enemy->s.origin;
+	vec[2] += self->enemy->viewheight;
+	dir = vec - start;
+	dir.normalize();
+	gi.sound(self, CHAN_VOICE, gi.soundindex("makron/bfg_fire.wav"), 1, ATTN_NORM, 0);
+	monster_fire_bfg(self, start, dir, 50, 300, 100, 300, MZ2_ACTOR_MACHINEGUN_1);
+
+	self->monsterinfo.attack_finished = level.time + 5_sec;
+}
+
+void tactc_fire(edict_t* self)
+{
+	if (self->style == 1)
+		tactc_fire_chainfist(self); 
+	else if (self->style == 2)
+		tactc_fire_shotgun(self);
+	else if (self->style == 3)
+	{
+		if (level.time < self->monsterinfo.attack_finished)
+			return;
+		tactc_fire_phalanx(self);
+	}
+	else if (self->style == 4)
+	{
+		if (level.time < self->monsterinfo.attack_finished)
+			return;
+		tactc_fire_bfg(self);
+	}
+	else if (self->style == 5)
+	{
+		if (level.time < self->monsterinfo.attack_finished)
+			return;
+		tactc_fire_railgun(self);
+	}
+}
+
+void tactc_fire_check(edict_t* self)
+{
+	if (self->style == 1)
+		tactc_fire_chainfist(self);
+	else
+		return;
+}
+
+void tactc_fire_check2(edict_t* self)
+{
+	if ((self->style == 2) || (self->style == 3))
+	{
+		if ((self->s.frame == FRAME_attak3) && (frandom() > 0.6f))
+			self->monsterinfo.nextframe = FRAME_attak1;
+		if ((self->s.frame == FRAME_crattak3) && (frandom() > 0.6f))
+			self->monsterinfo.nextframe = FRAME_crattak1;
+	}
+	else if (self->style == 3)
+		tactc_fire_phalanx(self);
+	else
+		return;
+}
+
+mframe_t tactc_frames_attack1[] = {
+	{ ai_charge, -2, tactc_fire },
+	{ ai_charge, -2, tactc_fire_check },
+	{ ai_charge, 3, tactc_fire_check2 },
+	{ ai_charge, 2 },
+	{ ai_charge },
+
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(tactc_move_attack1) = { FRAME_attak1, FRAME_attak8, tactc_frames_attack1, tactc_run };
+
+mframe_t tactc_frames_attack2[] = {
+	{ ai_charge, -2, tactc_fire },
+	{ ai_charge, -2, tactc_fire_check },
+	{ ai_charge, 3, tactc_fire_check2 },
+	{ ai_charge, 2 },
+	{ ai_charge },
+
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(tactc_move_attack2) = { FRAME_crattak1, FRAME_crattak9, tactc_frames_attack2, tactc_run };
+
+MONSTERINFO_ATTACK(tactc_attack) (edict_t* self) -> void
+{
+	float r, chance;
+	
+	if (!M_CheckClearShot(self, monster_flash_offset[MZ2_ACTOR_MACHINEGUN_1]))
+		return;
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		monster_duck_up(self);
+
+	monster_done_dodge(self);
+
+	if (self->enemy->health <= 0)
+	{
+		M_SetAnimation(self, &tactc_move_taunt);
+		self->monsterinfo.aiflags &= ~AI_BRUTAL;
+		return;
+	}
+
+	if (range_to(self, self->enemy) <= MELEE_DISTANCE)
+	{
+		self->s.modelindex2 = 0;
+		self->style = 1;
+		self->s.modelindex2 = gi.modelindex("players/cyborg/w_chainfist.md2");
+	}
+	else if (range_to(self, self->enemy) <= (RANGE_NEAR /3))
+	{
+		self->s.modelindex2 = 0;
+		self->style = 2;
+		self->s.modelindex2 = gi.modelindex("players/cyborg/w_shotgun.md2");
+	}
+	else if (range_to(self, self->enemy) <= (RANGE_MID /3))
+	{
+		self->s.modelindex2 = 0;
+		self->style = 3;
+		self->s.modelindex2 = gi.modelindex("players/cyborg/w_phalanx.md2");
+	}
+	else if (range_to(self, self->enemy) <= (RANGE_MID))
+	{
+		self->s.modelindex2 = 0;
+		self->style = 4;
+		self->s.modelindex2 = gi.modelindex("players/cyborg/w_bfg.md2");
+	}
+	else if (range_to(self, self->enemy) <= RANGE_MID)
+	{
+		self->s.modelindex2 = 0;
+		self->style = 5;
+		self->s.modelindex2 = gi.modelindex("players/cyborg/w_railgun.md2");
+	}
+
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		if (self->monsterinfo.blind_fire_delay < 1.0_sec)
+			chance = 1.0;
+		else if (self->monsterinfo.blind_fire_delay < 7.5_sec)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		r = frandom();
+
+		self->monsterinfo.blind_fire_delay += random_time(3.5_sec, 6.5_sec);
+
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		if (r > chance)
+			return;
+
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+		M_SetAnimation(self, &tactc_move_attack1);
+		self->monsterinfo.attack_finished = level.time + random_time(2_sec);
+		return;
+	}
+
+	if (frandom() >= 0.4f)
+		M_SetAnimation(self, &tactc_move_attack1);
+	else
+	{
+		M_SetAnimation(self, &tactc_move_attack2);
+		monster_duck_down(self);
+	}
+}
+
+//
+//BLOCKED and JUMPING
+//
+
+void tactc_jump_now(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 100);
+	self->velocity += (up * 300);
+}
+
+void tactc_jump2_now(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 150);
+	self->velocity += (up * 400);
+}
+
+void tactc_jump_wait_land(edict_t* self)
+{
+	if (self->groundentity == nullptr)
+	{
+		self->monsterinfo.nextframe = self->s.frame;
+
+		if (monster_jump_finished(self))
+			self->monsterinfo.nextframe = self->s.frame + 1;
+	}
+	else
+		self->monsterinfo.nextframe = self->s.frame + 1;
+}
+
+mframe_t tactc_frames_jump[] = {
+	{ ai_move, 0, tactc_jump_now },
+	{ ai_move },
+	{ ai_move, 0, tactc_jump_wait_land },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactc_move_jump) = { FRAME_jump1, FRAME_jump6, tactc_frames_jump, tactc_run };
+
+mframe_t tactc_frames_jump2[] = {
+	{ ai_move, -8, tactc_jump2_now },
+	{ ai_move, -4 },
+	{ ai_move, -4, tactc_jump_wait_land },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactc_move_jump2) = { FRAME_jump1, FRAME_jump6, tactc_frames_jump2, tactc_run };
+
+void tactc_jump(edict_t* self, blocked_jump_result_t result)
+{
+	if (!self->enemy)
+		return;
+
+	monster_done_dodge(self);
+
+	gi.sound(self, CHAN_VOICE, sound_jump, 1, ATTN_NORM, 0);
+
+	if (result == blocked_jump_result_t::JUMP_JUMP_UP)
+		M_SetAnimation(self, &tactc_move_jump2);
+	else
+		M_SetAnimation(self, &tactc_move_jump);
+}
+
+MONSTERINFO_BLOCKED(tactc_blocked) (edict_t* self, float dist) -> bool
+{
+	if (blocked_checkplat(self, dist))
+		return true;
+
+	if (auto result = blocked_checkjump(self, dist); result != blocked_jump_result_t::NO_JUMP)
+	{
+		if (result != blocked_jump_result_t::JUMP_TURN)
+			tactc_jump(self, result);
+
+		return true;
+	}
+
+	return false;
+}
+
+//
+//DODGES
+//
+
+MONSTERINFO_DUCK(tactc_duck) (edict_t* self, gtime_t eta) -> bool
+{
+	if (self->monsterinfo.active_move == &tactc_move_attack1)
+	{
+		self->monsterinfo.unduck(self);
+		return false;
+	}
+
+	M_SetAnimation(self, &tactc_move_attack2);
+	monster_duck_down(self);
+
+	return true;
+}
+
+MONSTERINFO_SIDESTEP(tactc_sidestep) (edict_t* self) -> bool
+{
+	if ((self->monsterinfo.active_move == &tactc_move_attack1) ||
+		(self->monsterinfo.active_move == &tactc_move_attack2))
+	{
+		return false;
+	}
+
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		M_SetAnimation(self, &tactc_move_walk2);
+	else if (self->monsterinfo.active_move != &tactc_move_run)
+		M_SetAnimation(self, &tactc_move_run);
+	else
+		M_SetAnimation(self, &tactc_move_jump);
+
+	return true;
+}
+
+//
+//PAIN
+//
+
+mframe_t tactc_frames_pain1[] = {
+	{ ai_move, -5 },
+	{ ai_move, 4 },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactc_move_pain1) = { FRAME_pain101, FRAME_pain104, tactc_frames_pain1, tactc_run };
+
+mframe_t tactc_frames_pain2[] = {
+	{ ai_move, -4 },
+	{ ai_move, 4 },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactc_move_pain2) = { FRAME_pain201, FRAME_pain204, tactc_frames_pain2, tactc_run };
+
+mframe_t tactc_frames_pain3[] = {
+	{ ai_move, -1 },
+	{ ai_move, 1 },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactc_move_pain3) = { FRAME_pain301, FRAME_pain304, tactc_frames_pain3, tactc_run };
+
+mframe_t tactc_frames_pain4[] = {
+	{ ai_move, -5 },
+	{ ai_move, 4 },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactc_move_pain4) = { FRAME_crpain1, FRAME_crpain4, tactc_frames_pain4, tactc_run };
+
+PAIN(tactc_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (self->monsterinfo.active_move == &tactc_move_jump)
+		return;
+
+	if (!M_ShouldReactToPain(self, mod))
+	{
+		if (frandom() < 0.3)
+			self->monsterinfo.dodge(self, other, FRAME_TIME_S, nullptr, false);
+
+		return; // no pain anims in nightmare
+	}
+
+
+	gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		M_SetAnimation(self, &tactc_move_pain4);
+	else if (damage < 35)
+		M_SetAnimation(self, &tactc_move_pain1);
+	else if (damage < 50)
+		M_SetAnimation(self, &tactc_move_pain2);
+	else
+		M_SetAnimation(self, &tactc_move_pain3);
+}
+
+MONSTERINFO_SETSKIN(tactc_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+//DEATH
+//
+
+void tactc_dead(edict_t* self)
+{
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, -8 };
+	monster_dead(self);
+}
+
+static void tactc_shrink(edict_t* self)
+{
+	self->maxs[2] = -4;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t tactc_frames_death1[] = {
+	{ ai_move, -13 },
+	{ ai_move, 14 },
+	{ ai_move, 3 },
+	{ ai_move, -2, tactc_shrink },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactc_move_death1) = { FRAME_death101, FRAME_death106, tactc_frames_death1, tactc_dead };
+
+mframe_t tactc_frames_death2[] = {
+	{ ai_move, -13 },
+	{ ai_move, 14 },
+	{ ai_move, 3, tactc_shrink },
+	{ ai_move, -2 },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactc_move_death2) = { FRAME_death201, FRAME_death206, tactc_frames_death2, tactc_dead };
+
+mframe_t tactc_frames_death3[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move, 0 , tactc_shrink },
+	{ ai_move },
+	{ ai_move },
+};
+MMOVE_T(tactc_move_death3) = { FRAME_death301, FRAME_death308, tactc_frames_death3, tactc_dead };
+
+mframe_t tactc_frames_death4[] = {
+	{ ai_move, -13 },
+	{ ai_move, 14 },
+	{ ai_move, 3 },
+	{ ai_move, -2, tactc_shrink },
+	{ ai_move }
+};
+MMOVE_T(tactc_move_death4) = { FRAME_crdeath1, FRAME_crdeath5, tactc_frames_death4, tactc_dead };
+
+DIE(tactc_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	self->s.modelindex2 = 0;
+
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/arm/tris.md2" },
+			{ 2, "models/objects/gibs/leg/tris.md2" },
+			{ 2, "models/objects/gibs/sm_meat/tris.md2" },
+			{ "models/objects/gibs/sm_metal/tris.md2", GIB_METALLIC },
+			{ "models/objects/gibs/chest/tris.md2" },
+			{ "models/objects/gibs/head/tris.md2", GIB_HEAD }
+			});
+		self->deadflag = true;
+
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	self->deadflag = true;
+	self->takedamage = true;
+
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+	{
+		M_SetAnimation(self, &tactc_move_death4);
+	}
+	if (frandom() < 0.33f)
+	{
+		M_SetAnimation(self, &tactc_move_death1);
+	}
+	else if (frandom() < 0.66f)
+	{
+		M_SetAnimation(self, &tactc_move_death2);
+	}
+	else
+	{
+		M_SetAnimation(self, &tactc_move_death3);
+	}
+}
+
+/*QUAKED monster_tactical_cyborg (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping
+ */
+void SP_monster_tactical_cyborg(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self))
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_death.assign("tactical/death.wav");
+	sound_pain.assign("tactical/pain.wav");
+	sound_idle.assign("tactical/idle.wav");
+	sound_search.assign("tactical/search.wav");
+	sound_sight.assign("tactical/sight.wav");
+	sound_jump.assign("tactical/jump.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex("models/monsters/tactical/cyborg/tris.md2");
+	self->s.modelindex2 = gi.modelindex("players/cyborg/w_shotgun.md2");
+
+	self->mins = vec3_t { -16, -16, -24 };
+	self->maxs = vec3_t { 16, 16, 32 };
+
+	self->health = 850 * st.health_multiplier;
+	self->gib_health = -70;
+	self->mass = 200;
+
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 200;
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SCREEN;
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = 200;
+
+	self->pain = tactc_pain;
+	self->die = tactc_die;
+
+	self->monsterinfo.stand = tactc_stand;
+	self->monsterinfo.walk = tactc_walk;
+	self->monsterinfo.run = tactc_run;
+
+	self->monsterinfo.dodge = M_MonsterDodge;
+	self->monsterinfo.duck = tactc_duck;
+	self->monsterinfo.unduck = monster_duck_up;
+	self->monsterinfo.sidestep = tactc_sidestep;
+	self->monsterinfo.blocked = tactc_blocked;
+
+	self->monsterinfo.attack = tactc_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = tactc_sight;
+	self->monsterinfo.search = tactc_search;
+	self->monsterinfo.setskin = tactc_setskin;
+	
+	self->monsterinfo.aiflags |= ( AI_STINKY | AI_IGNORE_SHOTS );
+	self->monsterinfo.blindfire = true;
+	self->monsterinfo.can_jump = !self->spawnflags.has(SPAWNFLAG_TACTICAL_NOJUMPING);
+	self->monsterinfo.drop_height = 192;
+	self->monsterinfo.jump_height = 40;
+
+	M_SetAnimation(self, &tactc_move_stand1);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	walkmonster_start(self);
+
+}
--- /dev/null
+++ b/ionized/m_tactf.cpp	2025-09-04 19:53:48
@@ -0,0 +1,1043 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+TACTICAL - FEMALE
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_tactical.h"
+#include "../m_flash.h"
+
+static cached_soundindex sound_pain;
+static cached_soundindex sound_death;
+static cached_soundindex sound_idle;
+static cached_soundindex sound_search;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_jump;
+
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_NOJUMPING = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_WEAPON1 = 16_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_WEAPON2 = 32_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_WEAPON3 = 64_spawnflag;
+
+//
+//SOUNDS
+//
+
+MONSTERINFO_IDLE(tactf_idle) (edict_t* self) -> void
+{
+	if (frandom() > 0.8f)
+		gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+MONSTERINFO_SEARCH(tactf_search) (edict_t* self) -> void
+{
+	if (frandom() > 0.8f)
+		gi.sound(self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SIGHT(tactf_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+//
+//STAND
+//
+
+void tactf_stand(edict_t* self);
+void tactf_fidget(edict_t* self);
+
+mframe_t tactf_frames_stand1[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactf_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactf_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactf_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactf_fidget }
+};
+MMOVE_T(tactf_move_stand1) = { FRAME_stand01, FRAME_stand40, tactf_frames_stand1, nullptr };
+
+mframe_t tactf_frames_stand2[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactf_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactf_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactf_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactf_fidget }
+};
+MMOVE_T(tactf_move_stand2) = { FRAME_stand01, FRAME_stand40, tactf_frames_stand2, nullptr };
+
+mframe_t tactf_frames_flip[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(tactf_move_flip) = { FRAME_flip01, FRAME_flip12, tactf_frames_flip, tactf_stand };
+
+mframe_t tactf_frames_salute[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand }
+};
+MMOVE_T(tactf_move_salute) = { FRAME_salute01, FRAME_salute11, tactf_frames_salute, tactf_stand };
+
+mframe_t tactf_frames_taunt[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(tactf_move_taunt) = { FRAME_taunt01, FRAME_taunt17, tactf_frames_taunt, tactf_stand };
+
+mframe_t tactf_frames_wave[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand }
+};
+MMOVE_T(tactf_move_wave) = { FRAME_wave01, FRAME_wave11, tactf_frames_wave, tactf_stand };
+
+mframe_t tactf_frames_point[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(tactf_move_point) = { FRAME_point01, FRAME_point12, tactf_frames_point, tactf_stand };
+
+void tactf_fidget(edict_t* self)
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		return;
+	else if (self->enemy)
+		return;
+
+	if (frandom() <= 0.01f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self); 
+		M_SetAnimation(self, &tactf_move_point);
+	}
+	else if (frandom() <= 0.02f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactf_move_wave);
+	}
+	else if (frandom() <= 0.03f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactf_move_taunt);
+	}
+	else if (frandom() <= 0.04f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactf_move_flip);
+	}
+	else if (frandom() <= 0.05f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactf_move_salute);
+	}
+}
+
+MONSTERINFO_STAND(tactf_stand) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		monster_duck_up(self);
+
+	if (frandom() < 0.8f)
+		M_SetAnimation(self, &tactf_move_stand1);
+	else
+	{
+		M_SetAnimation(self, &tactf_move_stand2);
+		monster_duck_down(self);
+	}
+}
+
+//
+//WALK
+//
+
+mframe_t tactf_frames_walk1[] = {
+	{ ai_walk, 4 },
+	{ ai_walk, 15, monster_footstep },
+	{ ai_walk, 15 },
+	{ ai_walk, 8 },
+	{ ai_walk, 20, monster_footstep },
+	{ ai_walk, 15 }
+};
+MMOVE_T(tactf_move_walk1) = { FRAME_run1, FRAME_run6, tactf_frames_walk1, nullptr };
+
+mframe_t tactf_frames_walk2[] = {
+	{ ai_walk },
+	{ ai_walk, 6, monster_footstep },
+	{ ai_walk, 10 },
+	{ ai_walk, 3 },
+	{ ai_walk, 2, monster_footstep },
+	{ ai_walk, 10 }
+};
+MMOVE_T(tactf_move_walk2) = { FRAME_crwalk1, FRAME_crwalk6, tactf_frames_walk2, nullptr };
+
+MONSTERINFO_WALK(tactf_walk) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		M_SetAnimation(self, &tactf_move_walk2);
+	else
+		M_SetAnimation(self, &tactf_move_walk1);
+}
+
+//
+//RUN
+//
+
+mframe_t tactf_frames_run[] = {
+	{ ai_run, 4 },
+	{ ai_run, 15, monster_footstep },
+	{ ai_run, 15 },
+	{ ai_run, 8 },
+	{ ai_run, 20, monster_footstep },
+	{ ai_run, 15 }
+};
+MMOVE_T(tactf_move_run) = { FRAME_run1, FRAME_run6, tactf_frames_run, nullptr };
+
+MONSTERINFO_RUN(tactf_run) (edict_t* self) -> void
+{
+	monster_done_dodge(self);
+
+	if ((frandom() >= 0.8f) && (self->monsterinfo.aiflags & AI_DUCKED))
+		monster_duck_up(self);
+
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &tactf_move_stand1);
+	else if (self->monsterinfo.aiflags & AI_DUCKED)
+	{
+		M_SetAnimation(self, &tactf_move_walk2);
+	}
+	else
+		monster_duck_up(self);
+		M_SetAnimation(self, &tactf_move_run);
+}
+
+//
+//ATTACKS
+//
+
+void tactf_fire_chainfist(edict_t* self) //chainfist
+{
+	constexpr vec3_t aim = { MELEE_DISTANCE, 0, -24 };
+
+	if (!fire_hit(self, aim, irandom(10, 20), 150))
+		self->monsterinfo.melee_debounce_time = level.time + 1.2_sec;
+}
+
+void tactf_fire_shotgun(edict_t* self) //shotgun
+{
+	vec3_t					 start;
+	vec3_t					 forward, right;
+	vec3_t					 aim;
+	monster_muzzleflash_id_t flash_number;
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	flash_number = MZ2_ACTOR_MACHINEGUN_1;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+	PredictAim(self, self->enemy, start, 800, false, frandom() * 0.3f, &aim, nullptr);
+	for (int i = 0; i < 3; i++)
+		aim[i] += crandom_open() * 0.025f;
+
+	gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/shotgf1b.wav"), 1, ATTN_NORM, 0);
+	monster_fire_shotgun(self, start, aim, 5, 1, 1500, 750, 9, flash_number);
+}
+
+void tactf_fire_hyperblaster(edict_t* self)
+{
+	vec3_t					 start;
+	vec3_t					 forward, right;
+	vec3_t					 aim;
+	monster_muzzleflash_id_t flash_number;
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	flash_number = MZ2_ACTOR_MACHINEGUN_1;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+	PredictAim(self, self->enemy, start, 800, false, frandom() * 0.3f, &aim, nullptr);
+	for (int i = 0; i < 3; i++)
+		aim[i] += crandom_open() * 0.025f;
+
+	if (!(self->monsterinfo.aiflags & AI_HOLD_FRAME))
+		self->monsterinfo.fire_wait = level.time + random_time(300_ms, 1.1_sec);
+
+	gi.sound(self, CHAN_WEAPON, gi.soundindex("makron/blaster.wav"), 1, ATTN_NORM, 0);
+	monster_fire_blueblaster(self, start, aim, 1, 600, flash_number, EF_BLUEHYPERBLASTER);
+
+	if (level.time >= self->monsterinfo.fire_wait)
+		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+	else
+		self->monsterinfo.aiflags |= AI_HOLD_FRAME;
+}
+
+void tactf_fire_ripper(edict_t* self)
+{
+
+	vec3_t					 start;
+	vec3_t					 forward, right, up;
+	vec3_t					 aim;
+	monster_muzzleflash_id_t flash_number;
+	float					 spread;
+	float					 pitch = 0;
+	vec3_t target;
+	bool   blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse)
+		return;
+
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+
+	if (frandom() > 0.4f)
+		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+	spread = frandom(-0.10f, 0.10f);
+	flash_number = MZ2_ACTOR_MACHINEGUN_1;
+	
+	if ((blindfire) && (!visible(self, self->enemy)))
+	{
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		target = self->monsterinfo.blind_fire_target;
+	}
+	else
+		target = self->enemy->s.origin;
+
+	AngleVectors(self->s.angles, forward, right, up);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+
+	if (self->enemy)
+	{
+		float dist;
+
+		aim = target - self->s.origin;
+		dist = aim.length();
+
+		if ((dist > 512) && (aim[2] < 64) && (aim[2] > -64))
+		{
+			aim[2] += (dist - 512);
+		}
+
+		aim.normalize();
+		pitch = aim[2];
+		if (pitch > 0.4f)
+			pitch = 0.4f;
+		else if (pitch < -0.5f)
+			pitch = -0.5f;
+	}
+
+	aim = forward + (right * spread);
+	aim += (up * pitch);
+
+	if (M_CalculatePitchToFire(self, target, start, aim, 600, 2.5f, false))
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/rippfire.wav"), 1, ATTN_NORM, 0);
+		monster_fire_ionripper(self, start, aim, 15, 800, flash_number, EF_IONRIPPER);
+	}
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/rippfire.wav"), 1, ATTN_NORM, 0);
+		monster_fire_ionripper(self, start, aim, 15, 800, flash_number, EF_IONRIPPER);
+	}
+}
+
+void tactf_fire_railgun(edict_t* self)
+{
+	vec3_t start;
+	vec3_t dir;
+	vec3_t forward, right;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[MZ2_ACTOR_MACHINEGUN_1], forward, right);
+
+	dir = self->pos1 - start;
+	dir.normalize();
+
+	gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/railgf1a.wav"), 1, ATTN_NORM, 0);
+	monster_fire_railgun(self, start, dir, 50, 100, MZ2_ACTOR_MACHINEGUN_1);
+
+	self->monsterinfo.attack_finished = level.time + 3_sec;
+}
+
+void tactf_fire(edict_t* self)
+{
+	if (self->style == 1)
+		tactf_fire_chainfist(self); 
+	else if (self->style == 2)
+		tactf_fire_shotgun(self);
+	else if (self->style == 3)
+		tactf_fire_ripper(self);
+	else if (self->style == 4)
+		tactf_fire_hyperblaster(self);
+	else if (self->style == 5)
+	{
+		if (level.time < self->monsterinfo.attack_finished)
+			return;
+		tactf_fire_railgun(self);
+	}
+}
+
+void tactf_fire_check(edict_t* self)
+{
+	if (self->style == 1)
+		tactf_fire_chainfist(self);
+	else
+		return;
+}
+
+void tactf_fire_check2(edict_t* self)
+{
+	if ((self->style == 2) || (self->style == 3))
+	{
+		if ((self->s.frame == FRAME_attak3) && (frandom() > 0.6f))
+			self->monsterinfo.nextframe = FRAME_attak1;
+		if ((self->s.frame == FRAME_crattak3) && (frandom() > 0.6f))
+			self->monsterinfo.nextframe = FRAME_crattak1;
+	}
+	else
+		return;
+}
+
+mframe_t tactf_frames_attack1[] = {
+	{ ai_charge, -2, tactf_fire },
+	{ ai_charge, -2, tactf_fire_check },
+	{ ai_charge, 3, tactf_fire_check2 },
+	{ ai_charge, 2 },
+	{ ai_charge },
+
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(tactf_move_attack1) = { FRAME_attak1, FRAME_attak8, tactf_frames_attack1, tactf_run };
+
+mframe_t tactf_frames_attack2[] = {
+	{ ai_charge, -2, tactf_fire },
+	{ ai_charge, -2, tactf_fire_check },
+	{ ai_charge, 3, tactf_fire_check2 },
+	{ ai_charge, 2 },
+	{ ai_charge },
+
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(tactf_move_attack2) = { FRAME_crattak1, FRAME_crattak9, tactf_frames_attack2, tactf_run };
+
+MONSTERINFO_ATTACK(tactf_attack) (edict_t* self) -> void
+{
+	float r, chance;
+	
+	if (!M_CheckClearShot(self, monster_flash_offset[MZ2_ACTOR_MACHINEGUN_1]))
+		return;
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		monster_duck_up(self);
+
+	monster_done_dodge(self);
+
+	if (self->enemy->health <= 0)
+	{
+		M_SetAnimation(self, &tactf_move_flip);
+		self->monsterinfo.aiflags &= ~AI_BRUTAL;
+		return;
+	}
+
+	if (range_to(self, self->enemy) <= MELEE_DISTANCE)
+	{
+		self->s.modelindex2 = 0;
+		self->style = 1;
+		self->s.modelindex2 = gi.modelindex("players/female/w_chainfist.md2");
+	}
+	else if (range_to(self, self->enemy) <= (RANGE_NEAR /3))
+	{
+		self->s.modelindex2 = 0;
+		self->style = 2;
+		self->s.modelindex2 = gi.modelindex("players/female/w_shotgun.md2");
+	}
+	else if (range_to(self, self->enemy) <= (RANGE_MID /3))
+	{
+		self->s.modelindex2 = 0;
+		self->style = 3;
+		self->s.modelindex2 = gi.modelindex("players/female/w_glauncher.md2");
+	}
+	else if (range_to(self, self->enemy) <= (RANGE_MID))
+	{
+		self->s.modelindex2 = 0;
+		self->style = 4;
+		self->s.modelindex2 = gi.modelindex("players/female/w_etfrifle.md2");
+	}
+	else if (range_to(self, self->enemy) <= RANGE_MID)
+	{
+		self->s.modelindex2 = 0;
+		self->style = 5;
+		self->s.modelindex2 = gi.modelindex("players/female/w_railgun.md2");
+	}
+
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		if (self->monsterinfo.blind_fire_delay < 1.0_sec)
+			chance = 1.0;
+		else if (self->monsterinfo.blind_fire_delay < 7.5_sec)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		r = frandom();
+
+		self->monsterinfo.blind_fire_delay += random_time(3.5_sec, 6.5_sec);
+
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		if (r > chance)
+			return;
+
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+		M_SetAnimation(self, &tactf_move_attack1);
+		self->monsterinfo.attack_finished = level.time + random_time(2_sec);
+		return;
+	}
+
+	if (frandom() >= 0.4f)
+		M_SetAnimation(self, &tactf_move_attack1);
+	else
+	{
+		M_SetAnimation(self, &tactf_move_attack2);
+		monster_duck_down(self);
+	}
+}
+
+//
+//BLOCKED and JUMPING
+//
+
+void tactf_jump_now(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 100);
+	self->velocity += (up * 300);
+}
+
+void tactf_jump2_now(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 150);
+	self->velocity += (up * 400);
+}
+
+void tactf_jump_wait_land(edict_t* self)
+{
+	if (self->groundentity == nullptr)
+	{
+		self->monsterinfo.nextframe = self->s.frame;
+
+		if (monster_jump_finished(self))
+			self->monsterinfo.nextframe = self->s.frame + 1;
+	}
+	else
+		self->monsterinfo.nextframe = self->s.frame + 1;
+}
+
+mframe_t tactf_frames_jump[] = {
+	{ ai_move, 0, tactf_jump_now },
+	{ ai_move },
+	{ ai_move, 0, tactf_jump_wait_land },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactf_move_jump) = { FRAME_jump1, FRAME_jump6, tactf_frames_jump, tactf_run };
+
+mframe_t tactf_frames_jump2[] = {
+	{ ai_move, -8, tactf_jump2_now },
+	{ ai_move, -4 },
+	{ ai_move, -4, tactf_jump_wait_land },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactf_move_jump2) = { FRAME_jump1, FRAME_jump6, tactf_frames_jump2, tactf_run };
+
+void tactf_jump(edict_t* self, blocked_jump_result_t result)
+{
+	if (!self->enemy)
+		return;
+
+	monster_done_dodge(self);
+
+	gi.sound(self, CHAN_VOICE, sound_jump, 1, ATTN_NORM, 0);
+
+	if (result == blocked_jump_result_t::JUMP_JUMP_UP)
+		M_SetAnimation(self, &tactf_move_jump2);
+	else
+		M_SetAnimation(self, &tactf_move_jump);
+}
+
+MONSTERINFO_BLOCKED(tactf_blocked) (edict_t* self, float dist) -> bool
+{
+	if (blocked_checkplat(self, dist))
+		return true;
+
+	if (auto result = blocked_checkjump(self, dist); result != blocked_jump_result_t::NO_JUMP)
+	{
+		if (result != blocked_jump_result_t::JUMP_TURN)
+			tactf_jump(self, result);
+
+		return true;
+	}
+
+	return false;
+}
+
+//
+//DODGES
+//
+
+MONSTERINFO_DUCK(tactf_duck) (edict_t* self, gtime_t eta) -> bool
+{
+	if (self->monsterinfo.active_move == &tactf_move_attack1)
+	{
+		self->monsterinfo.unduck(self);
+		return false;
+	}
+
+	M_SetAnimation(self, &tactf_move_attack2);
+	monster_duck_down(self);
+
+	return true;
+}
+
+MONSTERINFO_SIDESTEP(tactf_sidestep) (edict_t* self) -> bool
+{
+	if ((self->monsterinfo.active_move == &tactf_move_attack1) ||
+		(self->monsterinfo.active_move == &tactf_move_attack2))
+	{
+		return false;
+	}
+
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		M_SetAnimation(self, &tactf_move_walk2);
+	else if (self->monsterinfo.active_move != &tactf_move_run)
+		M_SetAnimation(self, &tactf_move_run);
+	else
+		M_SetAnimation(self, &tactf_move_jump);
+
+	return true;
+}
+
+//
+//PAIN
+//
+
+mframe_t tactf_frames_pain1[] = {
+	{ ai_move, -5 },
+	{ ai_move, 4 },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactf_move_pain1) = { FRAME_pain101, FRAME_pain104, tactf_frames_pain1, tactf_run };
+
+mframe_t tactf_frames_pain2[] = {
+	{ ai_move, -4 },
+	{ ai_move, 4 },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactf_move_pain2) = { FRAME_pain201, FRAME_pain204, tactf_frames_pain2, tactf_run };
+
+mframe_t tactf_frames_pain3[] = {
+	{ ai_move, -1 },
+	{ ai_move, 1 },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactf_move_pain3) = { FRAME_pain301, FRAME_pain304, tactf_frames_pain3, tactf_run };
+
+mframe_t tactf_frames_pain4[] = {
+	{ ai_move, -5 },
+	{ ai_move, 4 },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactf_move_pain4) = { FRAME_crpain1, FRAME_crpain4, tactf_frames_pain4, tactf_run };
+
+PAIN(tactf_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (self->monsterinfo.active_move == &tactf_move_jump)
+		return;
+
+	if (!M_ShouldReactToPain(self, mod))
+	{
+		if (frandom() < 0.3)
+			self->monsterinfo.dodge(self, other, FRAME_TIME_S, nullptr, false);
+
+		return; // no pain anims in nightmare
+	}
+
+
+	gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		M_SetAnimation(self, &tactf_move_pain4);
+	else if (damage < 35)
+		M_SetAnimation(self, &tactf_move_pain1);
+	else if (damage < 50)
+		M_SetAnimation(self, &tactf_move_pain2);
+	else
+		M_SetAnimation(self, &tactf_move_pain3);
+}
+
+MONSTERINFO_SETSKIN(tactf_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+//DEATH
+//
+
+void tactf_dead(edict_t* self)
+{
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, -8 };
+	monster_dead(self);
+}
+
+static void tactf_shrink(edict_t* self)
+{
+	self->maxs[2] = -4;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t tactf_frames_death1[] = {
+	{ ai_move, -13 },
+	{ ai_move, 14 },
+	{ ai_move, 3 },
+	{ ai_move, -2, tactf_shrink },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactf_move_death1) = { FRAME_death101, FRAME_death106, tactf_frames_death1, tactf_dead };
+
+mframe_t tactf_frames_death2[] = {
+	{ ai_move, -13 },
+	{ ai_move, 14 },
+	{ ai_move, 3, tactf_shrink },
+	{ ai_move, -2 },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactf_move_death2) = { FRAME_death201, FRAME_death206, tactf_frames_death2, tactf_dead };
+
+mframe_t tactf_frames_death3[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move, 0 , tactf_shrink },
+	{ ai_move },
+	{ ai_move },
+};
+MMOVE_T(tactf_move_death3) = { FRAME_death301, FRAME_death308, tactf_frames_death3, tactf_dead };
+
+mframe_t tactf_frames_death4[] = {
+	{ ai_move, -13 },
+	{ ai_move, 14 },
+	{ ai_move, 3 },
+	{ ai_move, -2, tactf_shrink },
+	{ ai_move }
+};
+MMOVE_T(tactf_move_death4) = { FRAME_crdeath1, FRAME_crdeath5, tactf_frames_death4, tactf_dead };
+
+DIE(tactf_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	self->s.modelindex2 = 0;
+
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/arm/tris.md2" },
+			{ 2, "models/objects/gibs/leg/tris.md2" },
+			{ 2, "models/objects/gibs/sm_meat/tris.md2" },
+			{ "models/objects/gibs/sm_metal/tris.md2", GIB_METALLIC },
+			{ "models/objects/gibs/chest/tris.md2" },
+			{ "models/objects/gibs/head/tris.md2", GIB_HEAD }
+			});
+		self->deadflag = true;
+
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	self->deadflag = true;
+	self->takedamage = true;
+
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+	{
+		M_SetAnimation(self, &tactf_move_death4);
+	}
+	if (frandom() < 0.33f)
+	{
+		M_SetAnimation(self, &tactf_move_death1);
+	}
+	else if (frandom() < 0.66f)
+	{
+		M_SetAnimation(self, &tactf_move_death2);
+	}
+	else
+	{
+		M_SetAnimation(self, &tactf_move_death3);
+	}
+}
+
+/*QUAKED monster_tactical_female (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping
+ */
+void SP_monster_tactical_female(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self))
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_death.assign("chick/chkdeth2.wav");
+	sound_pain.assign("chick/chkpain2.wav");
+	sound_idle.assign("chick/chkidle2.wav");
+	sound_search.assign("chick/chksrch1.wav");
+	sound_sight.assign("chick/chksght1.wav");
+	sound_jump.assign("chick/chkfall1.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex("models/monsters/tactical/female/tris.md2");
+	self->s.modelindex2 = gi.modelindex("players/female/w_shotgun.md2");
+
+	self->mins = vec3_t { -16, -16, -24 };
+	self->maxs = vec3_t { 16, 16, 32 };
+
+	self->health = 350 * st.health_multiplier;
+	self->gib_health = -70;
+	self->mass = 200;
+
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 100;
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SCREEN;
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = 100;
+
+	self->pain = tactf_pain;
+	self->die = tactf_die;
+
+	self->monsterinfo.stand = tactf_stand;
+	self->monsterinfo.walk = tactf_walk;
+	self->monsterinfo.run = tactf_run;
+
+	self->monsterinfo.dodge = M_MonsterDodge;
+	self->monsterinfo.duck = tactf_duck;
+	self->monsterinfo.unduck = monster_duck_up;
+	self->monsterinfo.sidestep = tactf_sidestep;
+	self->monsterinfo.blocked = tactf_blocked;
+
+	self->monsterinfo.attack = tactf_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = tactf_sight;
+	self->monsterinfo.search = tactf_search;
+	self->monsterinfo.setskin = tactf_setskin;
+	
+	self->monsterinfo.aiflags |= ( AI_STINKY | AI_IGNORE_SHOTS );
+	self->monsterinfo.blindfire = true;
+	self->monsterinfo.can_jump = !self->spawnflags.has(SPAWNFLAG_TACTICAL_NOJUMPING);
+	self->monsterinfo.drop_height = 192;
+	self->monsterinfo.jump_height = 40;
+
+	M_SetAnimation(self, &tactf_move_stand1);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	walkmonster_start(self);
+
+}
--- /dev/null
+++ b/ionized/m_tactical.h	2025-09-04 19:53:48
@@ -0,0 +1,208 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+// E:\G Drive\md2f\quake2\baseq2\models/monsters/soldier
+
+// This file generated by qdata - Do NOT Modify
+
+enum {
+	FRAME_stand01,
+	FRAME_stand02,
+	FRAME_stand03,
+	FRAME_stand04,
+	FRAME_stand05,
+	FRAME_stand06,
+	FRAME_stand07,
+	FRAME_stand08,
+	FRAME_stand09,
+	FRAME_stand10,
+	FRAME_stand11,
+	FRAME_stand12,
+	FRAME_stand13,
+	FRAME_stand14,
+	FRAME_stand15,
+	FRAME_stand16,
+	FRAME_stand17,
+	FRAME_stand18,
+	FRAME_stand19,
+	FRAME_stand20,
+	FRAME_stand21,
+	FRAME_stand22,
+	FRAME_stand23,
+	FRAME_stand24,
+	FRAME_stand25,
+	FRAME_stand26,
+	FRAME_stand27,
+	FRAME_stand28,
+	FRAME_stand29,
+	FRAME_stand30,
+	FRAME_stand31,
+	FRAME_stand32,
+	FRAME_stand33,
+	FRAME_stand34,
+	FRAME_stand35,
+	FRAME_stand36,
+	FRAME_stand37,
+	FRAME_stand38,
+	FRAME_stand39,
+	FRAME_stand40,
+	FRAME_run1,
+	FRAME_run2,
+	FRAME_run3,
+	FRAME_run4,
+	FRAME_run5,
+	FRAME_run6,
+	FRAME_attak1,
+	FRAME_attak2,
+	FRAME_attak3,
+	FRAME_attak4,
+	FRAME_attak5,
+	FRAME_attak6,
+	FRAME_attak7,
+	FRAME_attak8,
+	FRAME_pain101,
+	FRAME_pain102,
+	FRAME_pain103,
+	FRAME_pain104,
+	FRAME_pain201,
+	FRAME_pain202,
+	FRAME_pain203,
+	FRAME_pain204,
+	FRAME_pain301,
+	FRAME_pain302,
+	FRAME_pain303,
+	FRAME_pain304,
+	FRAME_jump1,
+	FRAME_jump2,
+	FRAME_jump3,
+	FRAME_jump4,
+	FRAME_jump5,
+	FRAME_jump6,
+	FRAME_flip01,
+	FRAME_flip02,
+	FRAME_flip03,
+	FRAME_flip04,
+	FRAME_flip05,
+	FRAME_flip06,
+	FRAME_flip07,
+	FRAME_flip08,
+	FRAME_flip09,
+	FRAME_flip10,
+	FRAME_flip11,
+	FRAME_flip12,
+	FRAME_salute01,
+	FRAME_salute02,
+	FRAME_salute03,
+	FRAME_salute04,
+	FRAME_salute05,
+	FRAME_salute06,
+	FRAME_salute07,
+	FRAME_salute08,
+	FRAME_salute09,
+	FRAME_salute10,
+	FRAME_salute11,
+	FRAME_taunt01,
+	FRAME_taunt02,
+	FRAME_taunt03,
+	FRAME_taunt04,
+	FRAME_taunt05,
+	FRAME_taunt06,
+	FRAME_taunt07,
+	FRAME_taunt08,
+	FRAME_taunt09,
+	FRAME_taunt10,
+	FRAME_taunt11,
+	FRAME_taunt12,
+	FRAME_taunt13,
+	FRAME_taunt14,
+	FRAME_taunt15,
+	FRAME_taunt16,
+	FRAME_taunt17,
+	FRAME_wave01,
+	FRAME_wave02,
+	FRAME_wave03,
+	FRAME_wave04,
+	FRAME_wave05,
+	FRAME_wave06,
+	FRAME_wave07,
+	FRAME_wave08,
+	FRAME_wave09,
+	FRAME_wave10,
+	FRAME_wave11,
+	FRAME_point01,
+	FRAME_point02,
+	FRAME_point03,
+	FRAME_point04,
+	FRAME_point05,
+	FRAME_point06,
+	FRAME_point07,
+	FRAME_point08,
+	FRAME_point09,
+	FRAME_point10,
+	FRAME_point11,
+	FRAME_point12,
+	FRAME_crstnd01,
+	FRAME_crstnd02,
+	FRAME_crstnd03,
+	FRAME_crstnd04,
+	FRAME_crstnd05,
+	FRAME_crstnd06,
+	FRAME_crstnd07,
+	FRAME_crstnd08,
+	FRAME_crstnd09,
+	FRAME_crstnd10,
+	FRAME_crstnd11,
+	FRAME_crstnd12,
+	FRAME_crstnd13,
+	FRAME_crstnd14,
+	FRAME_crstnd15,
+	FRAME_crstnd16,
+	FRAME_crstnd17,
+	FRAME_crstnd18,
+	FRAME_crstnd19,
+	FRAME_crwalk1,
+	FRAME_crwalk2,
+	FRAME_crwalk3,
+	FRAME_crwalk4,
+	FRAME_crwalk5,
+	FRAME_crwalk6,
+	FRAME_crattak1,
+	FRAME_crattak2,
+	FRAME_crattak3,
+	FRAME_crattak4,
+	FRAME_crattak5,
+	FRAME_crattak6,
+	FRAME_crattak7,
+	FRAME_crattak8,
+	FRAME_crattak9,
+	FRAME_crpain1,
+	FRAME_crpain2,
+	FRAME_crpain3,
+	FRAME_crpain4,
+	FRAME_crdeath1,
+	FRAME_crdeath2,
+	FRAME_crdeath3,
+	FRAME_crdeath4,
+	FRAME_crdeath5,
+	FRAME_death101,
+	FRAME_death102,
+	FRAME_death103,
+	FRAME_death104,
+	FRAME_death105,
+	FRAME_death106,
+	FRAME_death201,
+	FRAME_death202,
+	FRAME_death203,
+	FRAME_death204,
+	FRAME_death205,
+	FRAME_death206,
+	FRAME_death301,
+	FRAME_death302,
+	FRAME_death303,
+	FRAME_death304,
+	FRAME_death305,
+	FRAME_death306,
+	FRAME_death307,
+	FRAME_death308
+};
+
+constexpr float MODEL_SCALE		= 1.2f;
--- /dev/null
+++ b/ionized/m_tactm.cpp	2025-09-04 19:53:48
@@ -0,0 +1,1043 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+TACTICAL - MALE
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_tactical.h"
+#include "../m_flash.h"
+
+static cached_soundindex sound_pain;
+static cached_soundindex sound_death;
+static cached_soundindex sound_idle;
+static cached_soundindex sound_search;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_jump;
+
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_NOJUMPING = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_WEAPON1 = 16_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_WEAPON2 = 32_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_TACTICAL_WEAPON3 = 64_spawnflag;
+
+//
+//SOUNDS
+//
+
+MONSTERINFO_IDLE(tactm_idle) (edict_t* self) -> void
+{
+	if (frandom() > 0.8f)
+		gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+MONSTERINFO_SEARCH(tactm_search) (edict_t* self) -> void
+{
+	if (frandom() > 0.8f)
+		gi.sound(self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SIGHT(tactm_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+//
+//STAND
+//
+
+void tactm_stand(edict_t* self);
+void tactm_fidget(edict_t* self);
+
+mframe_t tactm_frames_stand1[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactm_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactm_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactm_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactm_fidget }
+};
+MMOVE_T(tactm_move_stand1) = { FRAME_stand01, FRAME_stand40, tactm_frames_stand1, nullptr };
+
+mframe_t tactm_frames_stand2[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactm_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactm_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactm_fidget },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, tactm_fidget }
+};
+MMOVE_T(tactm_move_stand2) = { FRAME_stand01, FRAME_stand40, tactm_frames_stand2, nullptr };
+
+mframe_t tactm_frames_flip[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(tactm_move_flip) = { FRAME_flip01, FRAME_flip12, tactm_frames_flip, tactm_stand };
+
+mframe_t tactm_frames_salute[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand }
+};
+MMOVE_T(tactm_move_salute) = { FRAME_salute01, FRAME_salute11, tactm_frames_salute, tactm_stand };
+
+mframe_t tactm_frames_taunt[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(tactm_move_taunt) = { FRAME_taunt01, FRAME_taunt17, tactm_frames_taunt, tactm_stand };
+
+mframe_t tactm_frames_wave[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand }
+};
+MMOVE_T(tactm_move_wave) = { FRAME_wave01, FRAME_wave11, tactm_frames_wave, tactm_stand };
+
+mframe_t tactm_frames_point[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(tactm_move_point) = { FRAME_point01, FRAME_point12, tactm_frames_point, tactm_stand };
+
+void tactm_fidget(edict_t* self)
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		return;
+	else if (self->enemy)
+		return;
+
+	if (frandom() <= 0.01f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self); 
+		M_SetAnimation(self, &tactm_move_point);
+	}
+	else if (frandom() <= 0.02f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactm_move_wave);
+	}
+	else if (frandom() <= 0.03f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactm_move_taunt);
+	}
+	else if (frandom() <= 0.04f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactm_move_flip);
+	}
+	else if (frandom() <= 0.05f)
+	{
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &tactm_move_salute);
+	}
+}
+
+MONSTERINFO_STAND(tactm_stand) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		monster_duck_up(self);
+
+	if (frandom() < 0.8f)
+		M_SetAnimation(self, &tactm_move_stand1);
+	else
+	{
+		M_SetAnimation(self, &tactm_move_stand2);
+		monster_duck_down(self);
+	}
+}
+
+//
+//WALK
+//
+
+mframe_t tactm_frames_walk1[] = {
+	{ ai_walk, 4 },
+	{ ai_walk, 15, monster_footstep },
+	{ ai_walk, 15 },
+	{ ai_walk, 8 },
+	{ ai_walk, 20, monster_footstep },
+	{ ai_walk, 15 }
+};
+MMOVE_T(tactm_move_walk1) = { FRAME_run1, FRAME_run6, tactm_frames_walk1, nullptr };
+
+mframe_t tactm_frames_walk2[] = {
+	{ ai_walk },
+	{ ai_walk, 6, monster_footstep },
+	{ ai_walk, 10 },
+	{ ai_walk, 3 },
+	{ ai_walk, 2, monster_footstep },
+	{ ai_walk, 10 }
+};
+MMOVE_T(tactm_move_walk2) = { FRAME_crwalk1, FRAME_crwalk6, tactm_frames_walk2, nullptr };
+
+MONSTERINFO_WALK(tactm_walk) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		M_SetAnimation(self, &tactm_move_walk2);
+	else
+		M_SetAnimation(self, &tactm_move_walk1);
+}
+
+//
+//RUN
+//
+
+mframe_t tactm_frames_run[] = {
+	{ ai_run, 4 },
+	{ ai_run, 15, monster_footstep },
+	{ ai_run, 15 },
+	{ ai_run, 8 },
+	{ ai_run, 20, monster_footstep },
+	{ ai_run, 15 }
+};
+MMOVE_T(tactm_move_run) = { FRAME_run1, FRAME_run6, tactm_frames_run, nullptr };
+
+MONSTERINFO_RUN(tactm_run) (edict_t* self) -> void
+{
+	monster_done_dodge(self);
+
+	if ((frandom() >= 0.8f) && (self->monsterinfo.aiflags & AI_DUCKED))
+		monster_duck_up(self);
+
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &tactm_move_stand1);
+	else if (self->monsterinfo.aiflags & AI_DUCKED)
+	{
+		M_SetAnimation(self, &tactm_move_walk2);
+	}
+	else
+		monster_duck_up(self);
+		M_SetAnimation(self, &tactm_move_run);
+}
+
+//
+//ATTACKS
+//
+
+void tactm_fire_chainfist(edict_t* self) //chainfist
+{
+	constexpr vec3_t aim = { MELEE_DISTANCE, 0, -24 };
+
+	if (!fire_hit(self, aim, irandom(10, 20), 150))
+		self->monsterinfo.melee_debounce_time = level.time + 1.2_sec;
+}
+
+void tactm_fire_shotgun(edict_t* self) //shotgun
+{
+	vec3_t					 start;
+	vec3_t					 forward, right;
+	vec3_t					 aim;
+	monster_muzzleflash_id_t flash_number;
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	flash_number = MZ2_ACTOR_MACHINEGUN_1;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+	PredictAim(self, self->enemy, start, 800, false, frandom() * 0.3f, &aim, nullptr);
+	for (int i = 0; i < 3; i++)
+		aim[i] += crandom_open() * 0.025f;
+
+	gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/shotgf1b.wav"), 1, ATTN_NORM, 0);
+	monster_fire_shotgun(self, start, aim, 5, 1, 1500, 750, 9, flash_number);
+}
+
+void tactm_fire_nailgun(edict_t* self) //ETF Rifle
+{
+	vec3_t					 start;
+	vec3_t					 forward, right;
+	vec3_t					 aim;
+	monster_muzzleflash_id_t flash_number;
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	flash_number = MZ2_ACTOR_MACHINEGUN_1;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+	PredictAim(self, self->enemy, start, 800, false, frandom() * 0.3f, &aim, nullptr);
+	for (int i = 0; i < 3; i++)
+		aim[i] += crandom_open() * 0.025f;
+
+	if (!(self->monsterinfo.aiflags & AI_HOLD_FRAME))
+		self->monsterinfo.fire_wait = level.time + random_time(300_ms, 1.1_sec);
+
+	gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/nail1.wav"), 1, ATTN_NORM, 0);
+	monster_fire_flechette(self, start, aim, 8, 800, flash_number);
+
+	if (level.time >= self->monsterinfo.fire_wait)
+		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+	else
+		self->monsterinfo.aiflags |= AI_HOLD_FRAME;
+}
+
+void tactm_fire_glauncher(edict_t* self) //grenade
+{
+
+	vec3_t					 start;
+	vec3_t					 forward, right, up;
+	vec3_t					 aim;
+	monster_muzzleflash_id_t flash_number;
+	float					 spread;
+	float					 pitch = 0;
+	vec3_t target;
+	bool   blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse)
+		return;
+
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+
+	if (frandom() > 0.4f)
+		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+	spread = frandom(-0.10f, 0.10f);
+	flash_number = MZ2_ACTOR_MACHINEGUN_1;
+	
+	if ((blindfire) && (!visible(self, self->enemy)))
+	{
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		target = self->monsterinfo.blind_fire_target;
+	}
+	else
+		target = self->enemy->s.origin;
+
+	AngleVectors(self->s.angles, forward, right, up);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+
+	if (self->enemy)
+	{
+		float dist;
+
+		aim = target - self->s.origin;
+		dist = aim.length();
+
+		if ((dist > 512) && (aim[2] < 64) && (aim[2] > -64))
+		{
+			aim[2] += (dist - 512);
+		}
+
+		aim.normalize();
+		pitch = aim[2];
+		if (pitch > 0.4f)
+			pitch = 0.4f;
+		else if (pitch < -0.5f)
+			pitch = -0.5f;
+	}
+
+	aim = forward + (right * spread);
+	aim += (up * pitch);
+
+	if (M_CalculatePitchToFire(self, target, start, aim, 600, 2.5f, false))
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("guncmdr/gcdratck3.wav"), 1, ATTN_NORM, 0);
+		monster_fire_grenade(self, start, aim, 50, 600, flash_number, (crandom_open() * 10.0f), frandom() * 10.f);
+	}
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("guncmdr/gcdratck3.wav"), 1, ATTN_NORM, 0);
+		monster_fire_grenade(self, start, aim, 50, 600, flash_number, (crandom_open() * 10.0f), 200.f + (crandom_open() * 10.0f));
+	}
+}
+
+void tactm_fire_railgun(edict_t* self)
+{
+	vec3_t start;
+	vec3_t dir;
+	vec3_t forward, right;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[MZ2_ACTOR_MACHINEGUN_1], forward, right);
+
+	dir = self->pos1 - start;
+	dir.normalize();
+
+	gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/railgf1a.wav"), 1, ATTN_NORM, 0);
+	monster_fire_railgun(self, start, dir, 50, 100, MZ2_ACTOR_MACHINEGUN_1);
+
+	self->monsterinfo.attack_finished = level.time + 3_sec;
+}
+
+void tactm_fire(edict_t* self)
+{
+	if (self->style == 1)
+		tactm_fire_chainfist(self); 
+	else if (self->style == 2)
+		tactm_fire_shotgun(self);
+	else if (self->style == 3)
+		tactm_fire_glauncher(self);
+	else if (self->style == 4)
+		tactm_fire_nailgun(self);
+	else if (self->style == 5)
+	{
+		if (level.time < self->monsterinfo.attack_finished)
+			return;
+		tactm_fire_railgun(self);
+	}
+}
+
+void tactm_fire_check(edict_t* self)
+{
+	if (self->style == 1)
+		tactm_fire_chainfist(self);
+	else
+		return;
+}
+
+void tactm_fire_check2(edict_t* self)
+{
+	if ((self->style == 2) || (self->style == 3))
+	{
+		if ((self->s.frame == FRAME_attak3) && (frandom() > 0.6f))
+			self->monsterinfo.nextframe = FRAME_attak1;
+		if ((self->s.frame == FRAME_crattak3) && (frandom() > 0.6f))
+			self->monsterinfo.nextframe = FRAME_crattak1;
+	}
+	else
+		return;
+}
+
+mframe_t tactm_frames_attack1[] = {
+	{ ai_charge, -2, tactm_fire },
+	{ ai_charge, -2, tactm_fire_check },
+	{ ai_charge, 3, tactm_fire_check2 },
+	{ ai_charge, 2 },
+	{ ai_charge },
+
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(tactm_move_attack1) = { FRAME_attak1, FRAME_attak8, tactm_frames_attack1, tactm_run };
+
+mframe_t tactm_frames_attack2[] = {
+	{ ai_charge, -2, tactm_fire },
+	{ ai_charge, -2, tactm_fire_check },
+	{ ai_charge, 3, tactm_fire_check2 },
+	{ ai_charge, 2 },
+	{ ai_charge },
+
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(tactm_move_attack2) = { FRAME_crattak1, FRAME_crattak9, tactm_frames_attack2, tactm_run };
+
+MONSTERINFO_ATTACK(tactm_attack) (edict_t* self) -> void
+{
+	float r, chance;
+	
+	if (!M_CheckClearShot(self, monster_flash_offset[MZ2_ACTOR_MACHINEGUN_1]))
+		return;
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		monster_duck_up(self);
+
+	monster_done_dodge(self);
+
+	if (self->enemy->health <= 0)
+	{
+		M_SetAnimation(self, &tactm_move_flip);
+		self->monsterinfo.aiflags &= ~AI_BRUTAL;
+		return;
+	}
+
+	if (range_to(self, self->enemy) <= MELEE_DISTANCE)
+	{
+		self->s.modelindex2 = 0;
+		self->style = 1;
+		self->s.modelindex2 = gi.modelindex("players/male/w_chainfist.md2");
+	}
+	else if (range_to(self, self->enemy) <= (RANGE_NEAR /3))
+	{
+		self->s.modelindex2 = 0;
+		self->style = 2;
+		self->s.modelindex2 = gi.modelindex("players/male/w_shotgun.md2");
+	}
+	else if (range_to(self, self->enemy) <= (RANGE_MID /3))
+	{
+		self->s.modelindex2 = 0;
+		self->style = 3;
+		self->s.modelindex2 = gi.modelindex("players/male/w_glauncher.md2");
+	}
+	else if (range_to(self, self->enemy) <= (RANGE_MID))
+	{
+		self->s.modelindex2 = 0;
+		self->style = 4;
+		self->s.modelindex2 = gi.modelindex("players/male/w_etfrifle.md2");
+	}
+	else if (range_to(self, self->enemy) <= RANGE_MID)
+	{
+		self->s.modelindex2 = 0;
+		self->style = 5;
+		self->s.modelindex2 = gi.modelindex("players/male/w_railgun.md2");
+	}
+
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		if (self->monsterinfo.blind_fire_delay < 1.0_sec)
+			chance = 1.0;
+		else if (self->monsterinfo.blind_fire_delay < 7.5_sec)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		r = frandom();
+
+		self->monsterinfo.blind_fire_delay += random_time(3.5_sec, 6.5_sec);
+
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		if (r > chance)
+			return;
+
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+		M_SetAnimation(self, &tactm_move_attack1);
+		self->monsterinfo.attack_finished = level.time + random_time(2_sec);
+		return;
+	}
+
+	if (frandom() >= 0.4f)
+		M_SetAnimation(self, &tactm_move_attack1);
+	else
+	{
+		M_SetAnimation(self, &tactm_move_attack2);
+		monster_duck_down(self);
+	}
+}
+
+//
+//BLOCKED and JUMPING
+//
+
+void tactm_jump_now(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 100);
+	self->velocity += (up * 300);
+}
+
+void tactm_jump2_now(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 150);
+	self->velocity += (up * 400);
+}
+
+void tactm_jump_wait_land(edict_t* self)
+{
+	if (self->groundentity == nullptr)
+	{
+		self->monsterinfo.nextframe = self->s.frame;
+
+		if (monster_jump_finished(self))
+			self->monsterinfo.nextframe = self->s.frame + 1;
+	}
+	else
+		self->monsterinfo.nextframe = self->s.frame + 1;
+}
+
+mframe_t tactm_frames_jump[] = {
+	{ ai_move, 0, tactm_jump_now },
+	{ ai_move },
+	{ ai_move, 0, tactm_jump_wait_land },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactm_move_jump) = { FRAME_jump1, FRAME_jump6, tactm_frames_jump, tactm_run };
+
+mframe_t tactm_frames_jump2[] = {
+	{ ai_move, -8, tactm_jump2_now },
+	{ ai_move, -4 },
+	{ ai_move, -4, tactm_jump_wait_land },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactm_move_jump2) = { FRAME_jump1, FRAME_jump6, tactm_frames_jump2, tactm_run };
+
+void tactm_jump(edict_t* self, blocked_jump_result_t result)
+{
+	if (!self->enemy)
+		return;
+
+	monster_done_dodge(self);
+
+	gi.sound(self, CHAN_VOICE, sound_jump, 1, ATTN_NORM, 0);
+
+	if (result == blocked_jump_result_t::JUMP_JUMP_UP)
+		M_SetAnimation(self, &tactm_move_jump2);
+	else
+		M_SetAnimation(self, &tactm_move_jump);
+}
+
+MONSTERINFO_BLOCKED(tactm_blocked) (edict_t* self, float dist) -> bool
+{
+	if (blocked_checkplat(self, dist))
+		return true;
+
+	if (auto result = blocked_checkjump(self, dist); result != blocked_jump_result_t::NO_JUMP)
+	{
+		if (result != blocked_jump_result_t::JUMP_TURN)
+			tactm_jump(self, result);
+
+		return true;
+	}
+
+	return false;
+}
+
+//
+//DODGES
+//
+
+MONSTERINFO_DUCK(tactm_duck) (edict_t* self, gtime_t eta) -> bool
+{
+	if (self->monsterinfo.active_move == &tactm_move_attack1)
+	{
+		self->monsterinfo.unduck(self);
+		return false;
+	}
+
+	M_SetAnimation(self, &tactm_move_attack2);
+	monster_duck_down(self);
+
+	return true;
+}
+
+MONSTERINFO_SIDESTEP(tactm_sidestep) (edict_t* self) -> bool
+{
+	if ((self->monsterinfo.active_move == &tactm_move_attack1) ||
+		(self->monsterinfo.active_move == &tactm_move_attack2))
+	{
+		return false;
+	}
+
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		M_SetAnimation(self, &tactm_move_walk2);
+	else if (self->monsterinfo.active_move != &tactm_move_run)
+		M_SetAnimation(self, &tactm_move_run);
+	else
+		M_SetAnimation(self, &tactm_move_jump);
+
+	return true;
+}
+
+//
+//PAIN
+//
+
+mframe_t tactm_frames_pain1[] = {
+	{ ai_move, -5 },
+	{ ai_move, 4 },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactm_move_pain1) = { FRAME_pain101, FRAME_pain104, tactm_frames_pain1, tactm_run };
+
+mframe_t tactm_frames_pain2[] = {
+	{ ai_move, -4 },
+	{ ai_move, 4 },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactm_move_pain2) = { FRAME_pain201, FRAME_pain204, tactm_frames_pain2, tactm_run };
+
+mframe_t tactm_frames_pain3[] = {
+	{ ai_move, -1 },
+	{ ai_move, 1 },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(tactm_move_pain3) = { FRAME_pain301, FRAME_pain304, tactm_frames_pain3, tactm_run };
+
+mframe_t tactm_frames_pain4[] = {
+	{ ai_move, -5 },
+	{ ai_move, 4 },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactm_move_pain4) = { FRAME_crpain1, FRAME_crpain4, tactm_frames_pain4, tactm_run };
+
+PAIN(tactm_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (self->monsterinfo.active_move == &tactm_move_jump)
+		return;
+
+	if (!M_ShouldReactToPain(self, mod))
+	{
+		if (frandom() < 0.3)
+			self->monsterinfo.dodge(self, other, FRAME_TIME_S, nullptr, false);
+
+		return; // no pain anims in nightmare
+	}
+
+
+	gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		M_SetAnimation(self, &tactm_move_pain4);
+	else if (damage < 35)
+		M_SetAnimation(self, &tactm_move_pain1);
+	else if (damage < 50)
+		M_SetAnimation(self, &tactm_move_pain2);
+	else
+		M_SetAnimation(self, &tactm_move_pain3);
+}
+
+MONSTERINFO_SETSKIN(tactm_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+//DEATH
+//
+
+void tactm_dead(edict_t* self)
+{
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, -8 };
+	monster_dead(self);
+}
+
+static void tactm_shrink(edict_t* self)
+{
+	self->maxs[2] = -4;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t tactm_frames_death1[] = {
+	{ ai_move, -13 },
+	{ ai_move, 14 },
+	{ ai_move, 3 },
+	{ ai_move, -2, tactm_shrink },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactm_move_death1) = { FRAME_death101, FRAME_death106, tactm_frames_death1, tactm_dead };
+
+mframe_t tactm_frames_death2[] = {
+	{ ai_move, -13 },
+	{ ai_move, 14 },
+	{ ai_move, 3, tactm_shrink },
+	{ ai_move, -2 },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(tactm_move_death2) = { FRAME_death201, FRAME_death206, tactm_frames_death2, tactm_dead };
+
+mframe_t tactm_frames_death3[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move, 0 , tactm_shrink },
+	{ ai_move },
+	{ ai_move },
+};
+MMOVE_T(tactm_move_death3) = { FRAME_death301, FRAME_death308, tactm_frames_death3, tactm_dead };
+
+mframe_t tactm_frames_death4[] = {
+	{ ai_move, -13 },
+	{ ai_move, 14 },
+	{ ai_move, 3 },
+	{ ai_move, -2, tactm_shrink },
+	{ ai_move }
+};
+MMOVE_T(tactm_move_death4) = { FRAME_crdeath1, FRAME_crdeath5, tactm_frames_death4, tactm_dead };
+
+DIE(tactm_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	self->s.modelindex2 = 0;
+
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/arm/tris.md2" },
+			{ 2, "models/objects/gibs/leg/tris.md2" },
+			{ 2, "models/objects/gibs/sm_meat/tris.md2" },
+			{ "models/objects/gibs/sm_metal/tris.md2", GIB_METALLIC },
+			{ "models/objects/gibs/chest/tris.md2" },
+			{ "models/objects/gibs/head/tris.md2", GIB_HEAD }
+			});
+		self->deadflag = true;
+
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	self->deadflag = true;
+	self->takedamage = true;
+
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+	{
+		M_SetAnimation(self, &tactm_move_death4);
+	}
+	if (frandom() < 0.33f)
+	{
+		M_SetAnimation(self, &tactm_move_death1);
+	}
+	else if (frandom() < 0.66f)
+	{
+		M_SetAnimation(self, &tactm_move_death2);
+	}
+	else
+	{
+		M_SetAnimation(self, &tactm_move_death3);
+	}
+}
+
+/*QUAKED monster_tactical_male (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping
+ */
+void SP_monster_tactical_male(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self))
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_death.assign("tactical/death.wav");
+	sound_pain.assign("tactical/pain.wav");
+	sound_idle.assign("tactical/idle.wav");
+	sound_search.assign("tactical/search.wav");
+	sound_sight.assign("tactical/sight.wav");
+	sound_jump.assign("tactical/jump.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex("models/monsters/tactical/male/tris.md2");
+	self->s.modelindex2 = gi.modelindex("players/male/w_shotgun.md2");
+
+	self->mins = vec3_t { -16, -16, -24 };
+	self->maxs = vec3_t { 16, 16, 32 };
+
+	self->health = 350 * st.health_multiplier;
+	self->gib_health = -70;
+	self->mass = 200;
+
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 100;
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SCREEN;
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = 100;
+
+	self->pain = tactm_pain;
+	self->die = tactm_die;
+
+	self->monsterinfo.stand = tactm_stand;
+	self->monsterinfo.walk = tactm_walk;
+	self->monsterinfo.run = tactm_run;
+
+	self->monsterinfo.dodge = M_MonsterDodge;
+	self->monsterinfo.duck = tactm_duck;
+	self->monsterinfo.unduck = monster_duck_up;
+	self->monsterinfo.sidestep = tactm_sidestep;
+	self->monsterinfo.blocked = tactm_blocked;
+
+	self->monsterinfo.attack = tactm_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = tactm_sight;
+	self->monsterinfo.search = tactm_search;
+	self->monsterinfo.setskin = tactm_setskin;
+	
+	self->monsterinfo.aiflags |= ( AI_STINKY | AI_IGNORE_SHOTS );
+	self->monsterinfo.blindfire = true;
+	self->monsterinfo.can_jump = !self->spawnflags.has(SPAWNFLAG_TACTICAL_NOJUMPING);
+	self->monsterinfo.drop_height = 192;
+	self->monsterinfo.jump_height = 40;
+
+	M_SetAnimation(self, &tactm_move_stand1);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	walkmonster_start(self);
+
+}
--- /dev/null
+++ b/ionized/p_ionized_weapon.cpp	2025-09-04 19:53:48
@@ -0,0 +1,47 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+#include "../m_player.h"
+
+/*
+======================================================================
+
+DISINTEGRATOR
+
+======================================================================
+*/
+void weapon_disint_fire(edict_t* self)
+{
+	vec3_t start, dir;
+	int		damage = 750;
+	int damage_radius = 1000;
+
+	P_ProjectSource(self, self->client->v_angle, { 24, 8, -8 }, start, dir);
+
+	P_AddWeaponKick(self, self->client->v_forward * -2, { -1.f, 0.f, 0.f });
+
+	if (is_quad)
+		damage *= damage_multiplier;
+
+	gi.sound(self, CHAN_AUTO, gi.soundindex("weapons/dist/fire.wav"), 1, ATTN_IDLE, 0);
+
+	fire_disintegrator(self, start, dir, damage, 350, damage_radius);
+
+	// send muzzle flash
+	gi.WriteByte(svc_muzzleflash);
+	gi.WriteEntity(self);
+	gi.WriteByte(MZ_TRACKER | is_silenced);
+	gi.multicast(self->s.origin, MULTICAST_PVS, false);
+
+	PlayerNoise(self, start, PNOISE_WEAPON);
+
+	G_RemoveAmmo(self);
+}
+
+void Weapon_Disintegrator(edict_t* ent)
+{
+	constexpr int pause_frames[] = { 30, 37, 45, 0 };
+	constexpr int fire_frames[] = { 11, 0 };
+
+	Weapon_Generic(ent, 8, 18, 43, 49, pause_frames, fire_frames, weapon_disint_fire);
+}
--- a/m_actor.cpp	2023-10-03 19:43:06
+++ b/m_actor.cpp	2025-09-04 19:53:48
@@ -539,6 +539,8 @@
 
 void SP_target_actor(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if (!self->targetname)
 		gi.Com_PrintFmt("{}: no targetname\n", *self);
 
@@ -552,8 +554,9 @@
 	{
 		if (!self->speed)
 			self->speed = 200;
-		if (!st.height)
-			st.height = 200;
+		int height = st.height;
+		if (!height)
+			height = 200;
 		if (self->s.angles[YAW] == 0)
 			self->s.angles[YAW] = 360;
 		G_SetMovedir(self->s.angles, self->movedir);
--- a/m_arachnid.cpp	2023-10-03 19:43:06
+++ b/m_arachnid.cpp	2025-09-04 19:53:48
@@ -3,7 +3,7 @@
 /*
 ==============================================================================
 
-TANK
+ARACHNID
 
 ==============================================================================
 */
@@ -15,6 +15,9 @@
 static cached_soundindex sound_pain;
 static cached_soundindex sound_death;
 static cached_soundindex sound_sight;
+static cached_soundindex sound_spawn;
+static cached_soundindex sound_pissed;
+static cached_soundindex sound_pew;
 
 MONSTERINFO_SIGHT(arachnid_sight) (edict_t *self, edict_t *other) -> void
 {
@@ -59,16 +62,16 @@
 }
 
 mframe_t arachnid_frames_walk[] = {
+	{ ai_walk, 2, arachnid_footstep },
+	{ ai_walk, 5 },
+	{ ai_walk, 12 },
+	{ ai_walk, 16 },
+	{ ai_walk, 5 },
 	{ ai_walk, 8, arachnid_footstep },
 	{ ai_walk, 8 },
-	{ ai_walk, 8 },
-	{ ai_walk, 8 },
-	{ ai_walk, 8 },
-	{ ai_walk, 8, arachnid_footstep },
-	{ ai_walk, 8 },
-	{ ai_walk, 8 },
-	{ ai_walk, 8 },
-	{ ai_walk, 8 }
+	{ ai_walk, 12 },
+	{ ai_walk, 9 },
+	{ ai_walk, 5 }
 };
 MMOVE_T(arachnid_move_walk) = { FRAME_walk1, FRAME_walk10, arachnid_frames_walk, nullptr };
 
@@ -82,16 +85,16 @@
 //
 
 mframe_t arachnid_frames_run[] = {
+	{ ai_run, 2, arachnid_footstep },
+	{ ai_run, 5 },
+	{ ai_run, 12 },
+	{ ai_run, 16 },
+	{ ai_run, 5 },
 	{ ai_run, 8, arachnid_footstep },
 	{ ai_run, 8 },
-	{ ai_run, 8 },
-	{ ai_run, 8 },
-	{ ai_run, 8 },
-	{ ai_run, 8, arachnid_footstep },
-	{ ai_run, 8 },
-	{ ai_run, 8 },
-	{ ai_run, 8 },
-	{ ai_run, 8 }
+	{ ai_run, 12 },
+	{ ai_run, 9 },
+	{ ai_run, 5 }
 };
 MMOVE_T(arachnid_move_run) = { FRAME_walk1, FRAME_walk10, arachnid_frames_run, nullptr };
 
@@ -139,6 +142,8 @@
 
 	if (!M_ShouldReactToPain(self, mod))
 		return; // no pain anims in nightmare
+
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
 
 	float r = frandom();
 
@@ -150,21 +155,146 @@
 
 static cached_soundindex sound_charge;
 
-void arachnid_charge_rail(edict_t *self)
+static void arachnid_charge_rail(edict_t *self, monster_muzzleflash_id_t mz)
 {
 	if (!self->enemy || !self->enemy->inuse)
 		return;
 
 	gi.sound(self, CHAN_WEAPON, sound_charge, 1.f, ATTN_NORM, 0.f);
-	self->pos1 = self->enemy->s.origin;
-	self->pos1[2] += self->enemy->viewheight;
-}
-
-void arachnid_rail(edict_t *self)
+
+	vec3_t forward, right, start;
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[mz], forward, right);
+
+	PredictAim(self, self->enemy, start, 0, false, 0.0f, nullptr, &self->pos1);
+}
+
+static void arachnid_charge_rail_left(edict_t *self)
+{
+	arachnid_charge_rail(self, MZ2_ARACHNID_RAIL1);
+}
+
+static void arachnid_charge_rail_right(edict_t *self)
+{
+	arachnid_charge_rail(self, MZ2_ARACHNID_RAIL2);
+}
+
+static void arachnid_charge_rail_up_left(edict_t *self)
+{
+	arachnid_charge_rail(self, MZ2_ARACHNID_RAIL_UP1);
+}
+
+static void arachnid_charge_rail_up_right(edict_t *self)
+{
+	arachnid_charge_rail(self, MZ2_ARACHNID_RAIL_UP2);
+}
+
+/* KONIG - Protector attacks */
+static void protector_reattack_up(edict_t* self)
+{
+	if (visible(self, self->enemy))
+	{
+		if (self->timestamp >= level.time || frandom() < 0.3f)
+			self->s.frame = FRAME_rails_up1;
+		else
+			return;
+	}
+	else
+		return;
+}
+
+void protector_fire(edict_t* self, monster_muzzleflash_id_t id)
+{
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	forward, right, up;
+	int		spread;
+
+	AngleVectors(self->s.angles, forward, right, up);
+	start = M_ProjectFlashSource(self, monster_flash_offset[id], forward, right);
+
+	dir = (self->pos1 - start).normalized();
+
+	spread = 500;
+
+	monster_fire_flakblaster(self, start, dir, 8, 600, spread, spread, 3, MZ2_ARACHNID_RAIL2, EF_BLUEHYPERBLASTER, 1);
+
+	if ((skill->integer > 1) && frandom() <= (0.2 * (skill->integer)))
+		self->count++;
+}
+
+void arachnid_rail_real(edict_t *self, monster_muzzleflash_id_t id)
 {
 	vec3_t start;
 	vec3_t dir;
-	vec3_t forward, right;
+	vec3_t forward, right, up;
+
+	AngleVectors(self->s.angles, forward, right, up);
+	start = M_ProjectFlashSource(self, monster_flash_offset[id], forward, right);
+	int dmg = 50;
+
+	if (self->s.frame >= FRAME_melee_in1 && self->s.frame <= FRAME_melee_in16)
+	{
+		// scan our current direction for players
+		std::array<edict_t *, 8> players_scanned {};
+		size_t num_players = 0;
+
+		for (auto player : active_players())
+		{
+			if (!visible(self, player, false))
+				continue;
+
+			if (infront_cone(self, player, 0.5f))
+			{
+				players_scanned[num_players++] = player;
+
+				if (num_players == players_scanned.size())
+					break;
+			}
+		}
+
+		if (num_players != 0)
+		{
+			edict_t *chosen = players_scanned[irandom(num_players)];
+
+			PredictAim(self, chosen, start, 0, false, 0.0f, nullptr, &self->pos1);
+
+			dir = (chosen->s.origin - self->s.origin).normalized();
+
+			self->ideal_yaw = vectoyaw(dir);
+			self->s.angles[YAW] = self->ideal_yaw;
+
+			dir = (self->pos1 - start).normalized();
+
+			for (int i = 0; i < 3; i++)
+				dir[i] += crandom_open() * 0.018f;
+			dir = dir.normalized();
+		}
+		else
+		{
+			dir = forward;
+		}
+	}
+	else
+	{
+		// calc direction to where we targeted
+		dir = (self->pos1 - start).normalized();
+		dmg = 50;
+	}
+
+	bool hit = monster_fire_railgun(self, start, dir, dmg, dmg * 2.0f, id);
+
+	if (dmg == 50)
+	{
+		if (hit)
+			self->count = 0;
+		else
+			self->count++;
+	}
+}
+
+void arachnid_rail(edict_t *self)
+{
 	monster_muzzleflash_id_t id;
 
 	switch (self->s.frame)
@@ -184,23 +314,37 @@
 			break;
 	}
 
-	AngleVectors(self->s.angles, forward, right, nullptr);
-	start = M_ProjectFlashSource(self, monster_flash_offset[id], forward, right);
-
-	// calc direction to where we targeted
-	dir = self->pos1 - start;
-	dir.normalize();
-
-	monster_fire_railgun(self, start, dir, 35, 100, id);
+/* KONIG - Protector attacks */
+	if (strcmp(self->classname, "monster_protector") == 0)
+		protector_fire(self, id);
+	else
+		arachnid_rail_real(self, id);
+}
+
+static void protector_fire_rocket(edict_t* self, float offset)
+{
+	vec3_t forward, right, up;
+	vec3_t start;
+
+	AngleVectors(self->s.angles, forward, right, up);
+	start = self->s.origin;
+	start -= forward * 2.0f;
+	start += right * offset;
+	start += up * 32.f;
+
+	AngleVectors({ 20.0f, self->s.angles[1] - offset, 0.f }, forward, nullptr, nullptr);
+
+	fire_guardian_heat(self, start, up, forward, 50, 250, 150, 35, 0.085f);
+	gi.sound(self, CHAN_WEAPON, sound_pew, 1.f, 0.5f, 0.0f);
 }
 
 mframe_t arachnid_frames_attack1[] = {
-	{ ai_charge, 0, arachnid_charge_rail },
-	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, arachnid_charge_rail_left },
 	{ ai_charge },
 	{ ai_charge, 0, arachnid_rail },
-	{ ai_charge, 0, arachnid_charge_rail },
-	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, arachnid_charge_rail_right },
 	{ ai_charge },
 	{ ai_charge, 0, arachnid_rail },
 	{ ai_charge },
@@ -209,19 +353,35 @@
 };
 MMOVE_T(arachnid_attack1) = { FRAME_rails1, FRAME_rails11, arachnid_frames_attack1, arachnid_run };
 
+/* KONIG - Protector attacks */
+mframe_t protector_frames_attack1[] = {
+	{ ai_charge },
+	{ ai_charge, 0, [](edict_t* self) { arachnid_charge_rail_left(self);  arachnid_rail(self); } },
+	{ ai_charge },
+	{ ai_charge, 0, [](edict_t* self) { arachnid_charge_rail_left(self);  arachnid_rail(self); } },
+	{ ai_charge },
+	{ ai_charge, 0, [](edict_t* self) { arachnid_charge_rail_right(self);  arachnid_rail(self); } },
+	{ ai_charge },
+	{ ai_charge, 0, [](edict_t* self) { arachnid_charge_rail_right(self);  arachnid_rail(self); } },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(protector_attack1) = { FRAME_rails1, FRAME_rails11, protector_frames_attack1, arachnid_run };
+
 mframe_t arachnid_frames_attack_up1[] = {
 	{ ai_charge },
 	{ ai_charge },
 	{ ai_charge },
-	{ ai_charge, 0, arachnid_charge_rail },
-	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, arachnid_charge_rail_up_left },
 	{ ai_charge },
 	{ ai_charge, 0, arachnid_rail },
-	{ ai_charge, 0, arachnid_charge_rail },
-	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, arachnid_charge_rail_up_right },
 	{ ai_charge },
 	{ ai_charge, 0, arachnid_rail },
-	{ ai_charge },
+	{ ai_charge, 0, protector_reattack_up },
 	{ ai_charge },
 	{ ai_charge },
 	{ ai_charge },
@@ -239,7 +399,25 @@
 void arachnid_melee_hit(edict_t *self)
 {
 	if (!fire_hit(self, { MELEE_DISTANCE, 0, 0 }, 15, 50))
+	{
 		self->monsterinfo.melee_debounce_time = level.time + 1000_ms;
+		self->count++;
+	}
+	else if (self->s.frame == FRAME_melee_atk11 &&
+		     self->monsterinfo.melee_debounce_time < level.time)
+		self->monsterinfo.nextframe = FRAME_melee_atk2;
+}
+
+mframe_t arachnid_frames_melee_out[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(arachnid_melee_out) = { FRAME_melee_out1, FRAME_melee_out3, arachnid_frames_melee_out, arachnid_run };
+
+void arachnid_to_out_melee(edict_t *self)
+{
+	M_SetAnimation(self, &arachnid_melee_out);
 }
 
 mframe_t arachnid_frames_melee[] = {
@@ -256,7 +434,176 @@
 	{ ai_charge, 0, arachnid_melee_hit },
 	{ ai_charge }
 };
-MMOVE_T(arachnid_melee) = { FRAME_melee_atk1, FRAME_melee_atk12, arachnid_frames_melee, arachnid_run };
+MMOVE_T(arachnid_melee) = { FRAME_melee_atk1, FRAME_melee_atk12, arachnid_frames_melee, arachnid_to_out_melee };
+
+void arachnid_to_melee(edict_t *self)
+{
+	M_SetAnimation(self, &arachnid_melee);
+}
+
+mframe_t arachnid_frames_melee_in[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(arachnid_melee_in) = { FRAME_melee_in1, FRAME_melee_in3, arachnid_frames_melee_in, arachnid_to_melee };
+
+static void arachnid_stop_rails(edict_t *self)
+{
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+	arachnid_run(self);
+}
+
+static void arachnid_rail_left(edict_t *self)
+{
+	arachnid_rail_real(self, MZ2_ARACHNID_RAIL1);
+}
+
+static void arachnid_rail_right(edict_t *self)
+{
+	arachnid_rail_real(self, MZ2_ARACHNID_RAIL2);
+}
+
+static void arachnid_rail_rapid(edict_t *self)
+{
+	bool left_shot = self->s.frame == FRAME_melee_in9; //((self->s.frame - FRAME_melee_in5) / 2) % 2;
+
+	arachnid_rail_real(self, left_shot ? MZ2_ARACHNID_RAIL1 : MZ2_ARACHNID_RAIL2);
+}
+
+/* KONIG - protector attacks */
+static void protector_rocket_left(edict_t* self)
+{
+	protector_fire_rocket(self, -14.0f);
+}
+
+static void protector_rocket_right(edict_t* self)
+{
+	protector_fire_rocket(self, 14.0f);
+}
+
+mframe_t arachnid_frames_attack3[] = {
+	{ ai_charge },
+	{ ai_move, 0, arachnid_rail_rapid },
+	{ ai_move },
+	{ ai_move/*, 0, arachnid_rail_rapid*/ },
+	{ ai_move },
+	{ ai_move, 0, arachnid_rail_rapid },
+	{ ai_move },
+	{ ai_move/*, 0, arachnid_rail_rapid*/ },
+	{ ai_move },
+	{ ai_move, 0, arachnid_rail_rapid },
+	{ ai_move },
+	{ ai_move/*, 0, arachnid_rail_rapid*/ },
+	{ ai_charge }
+};
+MMOVE_T(arachnid_attack3) = { FRAME_melee_in4, FRAME_melee_in16, arachnid_frames_attack3, arachnid_to_out_melee };
+
+/* KONIG - protector attacks */
+mframe_t protector_frames_attack3[] = {
+	{ ai_charge },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, protector_rocket_left }, //protector left rocket
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, protector_rocket_right }, //protector right rocket
+	{ ai_move },
+	{ ai_move },
+	{ ai_charge }
+};
+MMOVE_T(protector_attack3) = { FRAME_melee_in4, FRAME_melee_in16, protector_frames_attack3, arachnid_to_out_melee };
+
+static void arachnid_rapid_fire(edict_t *self)
+{
+	self->count = 0;
+	if (strcmp(self->classname, "monster_protector") == 0)
+		M_SetAnimation(self, &protector_attack3);
+	else
+		M_SetAnimation(self, &arachnid_attack3);
+}
+
+static void arachnid_spawn(edict_t *self)
+{
+	if (skill->integer != 3)
+		return;
+
+	static constexpr vec3_t reinforcement_position[] = { { -24.f, 124.f, 0 }, { -24.f, -124.f, 0 } };
+	vec3_t f, r, offset, startpoint, spawnpoint;
+	int	   count;
+
+	AngleVectors(self->s.angles, f, r, nullptr);
+
+	int num_summoned;
+	self->monsterinfo.chosen_reinforcements = M_PickReinforcements(self, num_summoned, 2);
+
+	for (count = 0; count < num_summoned; count++)
+	{
+		offset = reinforcement_position[count];
+
+		if (self->s.scale)
+			offset *= self->s.scale;
+
+		startpoint = M_ProjectFlashSource(self, offset, f, r);
+		// a little off the ground
+		startpoint[2] += 10 * (self->s.scale ? self->s.scale : 1.0f);
+
+		auto &reinforcement = self->monsterinfo.reinforcements.reinforcements[self->monsterinfo.chosen_reinforcements[count]];
+
+		if (FindSpawnPoint(startpoint, reinforcement.mins, reinforcement.maxs, spawnpoint, 32))
+		{
+			if (CheckGroundSpawnPoint(spawnpoint, reinforcement.mins, reinforcement.maxs, 256, -1))
+			{
+				edict_t *ent = CreateGroundMonster(spawnpoint, self->s.angles, reinforcement.mins, reinforcement.maxs, reinforcement.classname, 256);
+
+				if (!ent)
+					return;
+
+				ent->nextthink = level.time;
+				ent->think(ent);
+
+				ent->monsterinfo.aiflags |= AI_SPAWNED_COMMANDER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
+				ent->monsterinfo.commander = self;
+				ent->monsterinfo.slots_from_commander = reinforcement.strength;
+				self->monsterinfo.monster_used += reinforcement.strength;
+
+				gi.sound(ent, CHAN_BODY, sound_spawn, 1, ATTN_NONE, 0);
+
+				if ((self->enemy->inuse) && (self->enemy->health > 0))
+				{
+					ent->enemy = self->enemy;
+					FoundTarget(ent);
+				}
+
+				float radius = (reinforcement.maxs - reinforcement.mins).length() * 0.5f;
+				SpawnGrow_Spawn(spawnpoint + (reinforcement.mins + reinforcement.maxs), radius, radius * 2.f);
+			}
+		}
+	}
+}
+
+mframe_t arachnid_frames_taunt[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, arachnid_spawn },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(arachnid_taunt) = { FRAME_melee_pain1, FRAME_melee_pain16, arachnid_frames_taunt, arachnid_rapid_fire };
 
 MONSTERINFO_ATTACK(arachnid_attack) (edict_t *self) -> void
 {
@@ -264,11 +611,31 @@
 		return;
 
 	if (self->monsterinfo.melee_debounce_time < level.time && range_to(self, self->enemy) < MELEE_DISTANCE)
-		M_SetAnimation(self, &arachnid_melee);
-	else if ((self->enemy->s.origin[2] - self->s.origin[2]) > 150.f)
+		M_SetAnimation(self, &arachnid_melee_in);
+	// annoyed rapid fire attack
+	else if (self->enemy->client &&
+		self->last_move_time <= level.time &&
+		self->count >= 4 &&
+		frandom() < (max(self->count / 2.0f, 4.0f) + 1.0f) * 0.2f &&
+		(M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL1]) || M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL2])))
+	{
+		M_SetAnimation(self, &arachnid_taunt);
+		gi.sound(self, CHAN_VOICE, sound_pissed, 1.f, 0.25f, 0.f);
+		self->count = 0;
+		self->pain_debounce_time = level.time + 4.5_sec;
+		self->last_move_time = level.time + 10_sec;
+	}
+	else if ((self->enemy->s.origin[2] - self->s.origin[2]) > 150.f &&
+		(M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL_UP1]) || M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL_UP2])))
 		M_SetAnimation(self, &arachnid_attack_up1);
-	else
-		M_SetAnimation(self, &arachnid_attack1);
+	else if (M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL1]) || M_CheckClearShot(self, monster_flash_offset[MZ2_ARACHNID_RAIL2]))
+	{
+		/* KONIG - protector attacks*/
+		if (strcmp(self->classname, "monster_protector") == 0)
+			M_SetAnimation(self, &protector_attack1);
+		else
+			M_SetAnimation(self, &arachnid_attack1);
+	}
 }
 
 //
@@ -318,6 +685,7 @@
 		ThrowGibs(self, damage, {
 			{ 2, "models/objects/gibs/bone/tris.md2" },
 			{ 4, "models/objects/gibs/sm_meat/tris.md2" },
+			{ 1, "models/objects/gibs/gear/tris.md2" },
 			{ "models/objects/gibs/head2/tris.md2", GIB_HEAD }
 		});
 		self->deadflag = true;
@@ -332,17 +700,33 @@
 	self->deadflag = true;
 	self->takedamage = true;
 
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+
 	M_SetAnimation(self, &arachnid_move_death);
 }
 
+MONSTERINFO_SETSKIN(arachnid_setskin) (edict_t *self) -> void
+{
+	/* KONIG - set for multiple skins*/
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
 //
 // monster_arachnid
 //
-
-/*QUAKED monster_arachnid (1 .5 0) (-48 -48 -20) (48 48 48) Ambush Trigger_Spawn Sight
+// 
+constexpr const char *default_reinforcements = "monster_stalker 1";
+constexpr int32_t default_monster_slots_base = 2;
+
+/*QUAKED monster_arachnid (1 .5 0) (-40 -40 -20) (40 40 48) Ambush Trigger_Spawn Sight
  */
 void SP_monster_arachnid(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -355,14 +739,47 @@
 	sound_pain.assign("arachnid/pain.wav");
 	sound_death.assign("arachnid/death.wav");
 	sound_sight.assign("arachnid/sight.wav");
+	sound_pissed.assign("arachnid/angry.wav");
+	sound_pew.assign("makron/blaster.wav");
+
+	if (skill->value >= 3)
+	{
+		sound_spawn.assign("medic_commander/monsterspawn1.wav");
+
+		const char *reinforcements = default_reinforcements;
+
+		if (!st.was_key_specified("monster_slots"))
+			self->monsterinfo.monster_slots = default_monster_slots_base;
+		if (st.was_key_specified("reinforcements"))
+			reinforcements = st.reinforcements;
+
+		if (self->monsterinfo.monster_slots && reinforcements && *reinforcements)
+			M_SetupReinforcements(reinforcements, self->monsterinfo.reinforcements);
+	}
 
 	self->s.modelindex = gi.modelindex("models/monsters/arachnid/tris.md2");
-	self->mins = { -48, -48, -20 };
-	self->maxs = { 48, 48, 48 };
+	self->mins = { -40, -40, -20 };
+	self->maxs = { 40, 40, 48 };
 	self->movetype = MOVETYPE_STEP;
 	self->solid = SOLID_BBOX;
 
-	self->health = 1000 * st.health_multiplier;
+	/* KONIG - adding combat armor; nerfed health to compensate */
+	if (strcmp(self->classname, "monster_protector") == 0)
+	{
+		self->health = 900 * st.health_multiplier;
+		if (!st.was_key_specified("power_armor_type"))
+			self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+		if (!st.was_key_specified("power_armor_power"))
+			self->monsterinfo.power_armor_power = 200;
+	}
+	else
+	{
+		self->health = 900 * st.health_multiplier;
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = 200;
+	}
 	self->gib_health = -200;
 
 	self->monsterinfo.scale = MODEL_SCALE;
@@ -376,6 +793,9 @@
 	self->monsterinfo.run = arachnid_run;
 	self->monsterinfo.attack = arachnid_attack;
 	self->monsterinfo.sight = arachnid_sight;
+	self->monsterinfo.setskin = arachnid_setskin;
+
+	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
 
 	gi.linkentity(self);
 
@@ -383,3 +803,23 @@
 
 	walkmonster_start(self);
 }
+
+/*KONIG - Stream Protector from Q4 as Arachnid Beta*/
+void SP_monster_protector(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	SP_monster_arachnid(self);
+
+	self->s.modelindex = gi.modelindex("models/monsters/protector/tris.md2");
+
+	self->style = 1;
+
+	if (!self->s.scale)
+		self->s.scale = 1.5f;
+
+	self->mins = { -48, -48, -24 };
+	self->maxs = { 48, 48, 52 };
+
+	self->mass = 600;
+}
--- a/m_berserk.cpp	2023-10-03 19:43:06
+++ b/m_berserk.cpp	2025-09-04 19:53:48
@@ -110,30 +110,6 @@
 	M_SetAnimation(self, &berserk_move_walk);
 }
 
-/*
-
-  *****************************
-  SKIPPED THIS FOR NOW!
-  *****************************
-
-   Running -> Arm raised in air
-
-void()	berserk_runb1	=[	$r_att1 ,	berserk_runb2	] {ai_run(21);};
-void()	berserk_runb2	=[	$r_att2 ,	berserk_runb3	] {ai_run(11);};
-void()	berserk_runb3	=[	$r_att3 ,	berserk_runb4	] {ai_run(21);};
-void()	berserk_runb4	=[	$r_att4 ,	berserk_runb5	] {ai_run(25);};
-void()	berserk_runb5	=[	$r_att5 ,	berserk_runb6	] {ai_run(18);};
-void()	berserk_runb6	=[	$r_att6 ,	berserk_runb7	] {ai_run(19);};
-// running with arm in air : start loop
-void()	berserk_runb7	=[	$r_att7 ,	berserk_runb8	] {ai_run(21);};
-void()	berserk_runb8	=[	$r_att8 ,	berserk_runb9	] {ai_run(11);};
-void()	berserk_runb9	=[	$r_att9 ,	berserk_runb10	] {ai_run(21);};
-void()	berserk_runb10	=[	$r_att10 ,	berserk_runb11	] {ai_run(25);};
-void()	berserk_runb11	=[	$r_att11 ,	berserk_runb12	] {ai_run(18);};
-void()	berserk_runb12	=[	$r_att12 ,	berserk_runb7	] {ai_run(19);};
-// running with arm in air : end loop
-*/
-
 mframe_t berserk_frames_run1[] = {
 	{ ai_run, 21 },
 	{ ai_run, 11, monster_footstep },
@@ -158,7 +134,7 @@
 {
 	constexpr vec3_t aim = { MELEE_DISTANCE, 0, -24 };
 	
-	if (!fire_hit(self, aim, irandom(5, 11), 80)) //	Faster attack -- upwards and backwards
+	if (!fire_hit(self, aim, irandom(5, 11), 400)) //	Faster attack -- upwards and backwards
 		self->monsterinfo.melee_debounce_time = level.time + 1.2_sec;
 }
 
@@ -183,10 +159,57 @@
 {
 	vec3_t aim = { MELEE_DISTANCE, self->mins[0], -4 };
 	
-	if (!fire_hit(self, aim, irandom(15, 21), 400)) // Slower attack
+	if (!fire_hit(self, aim, irandom(15, 21), 250)) // Slower attack
 		self->monsterinfo.melee_debounce_time = level.time + 2.5_sec;
 }
 
+/* KONIG - Berser2 attacks*/
+void berserk_lightning(edict_t* self)
+{
+	vec3_t					 start;
+	vec3_t					 forward, right;
+	vec3_t					 aim;
+	vec3_t					 offset;
+
+	if (!self->enemy || !self->enemy->inuse)
+		return;
+
+	//		offset = { 24.8f, -9.0f, 39.0f };
+
+	if (self->s.frame == FRAME_att_b8)
+		offset = { -34.0f, -27.8f, 29.0f };
+	else if (self->s.frame == FRAME_att_b10)
+		offset = { -72.0f, -15.8f, 15.0f };
+	else if (self->s.frame == FRAME_att_b11)
+		offset = { -14.0f, -44.8f, 15.7f };
+	else if (self->s.frame == FRAME_att_b12)
+		offset = { 32.0f, -37.7f, 20.9f };
+	else if (self->s.frame == FRAME_att_b13)
+		offset = { 46.9f, 14.8f, 20.7f };
+	else if (self->s.frame == FRAME_r_attb5)
+		offset = { 14.7f, -35.2f, 29.6f };
+	else if (self->s.frame == FRAME_r_attb9)
+		offset = { 20.3f, -25.6f, 43.3f };
+	else if (self->s.frame == FRAME_r_attb15)
+		offset = { 19.3f, -16.8f, 45.4f };
+	else
+		return;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+	PredictAim(self, self->enemy, start, 0, true, -0.2f, &aim, nullptr);
+	gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/lhit.wav"), 1, ATTN_NORM, 0);
+	fire_lightning(self, start, aim, 5, 300, EF_PLASMA);
+}
+
+void berserk_attack_club2(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->mins[0], -4 };
+
+	if (!fire_hit(self, aim, irandom(20, 26), 250)) // Slower attack
+		self->monsterinfo.melee_debounce_time = level.time + 2.5_sec;
+}
+
 mframe_t berserk_frames_attack_club[] = {
 	{ ai_charge },
 	{ ai_charge },
@@ -203,6 +226,57 @@
 };
 MMOVE_T(berserk_move_attack_club) = { FRAME_att_c9, FRAME_att_c20, berserk_frames_attack_club, berserk_run };
 
+/* KONIG - Berserk2 attacks*/
+mframe_t berserk_frames_attack_chargedclub[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+
+	{ ai_charge },
+	{ ai_charge, 0, monster_footstep },
+	{ ai_charge, 0, berserk_lightning },
+	{ ai_charge },
+	{ ai_charge, 0,  [](edict_t* self) { berserk_swing(self); berserk_lightning(self); } },
+
+	{ ai_charge, 0, berserk_lightning },
+	{ ai_charge, 0, berserk_lightning },
+	{ ai_charge, 0, berserk_lightning },
+	{ ai_charge, 0, berserk_attack_club2 },
+	{ ai_charge },
+
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+
+	{ ai_charge }
+};
+MMOVE_T(berserk_move_attack_chargedclub) = { FRAME_att_b1, FRAME_att_b21, berserk_frames_attack_chargedclub, berserk_run };
+
+void berserk_attack_slam(edict_t* self);
+
+mframe_t berserk_frames_attack_slam[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, monster_footstep },
+	{ ai_charge },
+
+	{ ai_charge, 0, berserk_swing },
+	{ ai_charge },
+	{ ai_charge, 0, monster_footstep },
+	{ ai_charge, 0, berserk_attack_slam },
+	{ ai_charge },
+
+	{ ai_charge },
+	{ ai_charge, 0, monster_footstep },
+	{ ai_charge },
+	{ ai_charge, 0, monster_footstep }
+};
+MMOVE_T(berserk_move_attack_slam) = { FRAME_att_c21, FRAME_att_c34, berserk_frames_attack_slam, berserk_run };
 
 /*
 ============
@@ -271,7 +345,10 @@
 	self->velocity = {};
 	self->flags |= FL_KILL_VELOCITY;
 
-	T_SlamRadiusDamage(tr.endpos, self, self, 8, 300.f, self, 165, MOD_UNKNOWN);
+	if (strcmp(self->classname, "monster_berserk2") == 0)
+		T_SlamRadiusDamage(tr.endpos, self, self, 16, 300.f, self, 165, MOD_UNKNOWN);
+	else
+		T_SlamRadiusDamage(tr.endpos, self, self, 8, 300.f, self, 165, MOD_UNKNOWN);
 }
 
 TOUCH(berserk_jump_touch) (edict_t *self, edict_t *other, const trace_t &tr, bool other_touching_self) -> void
@@ -295,10 +372,14 @@
 
 static void berserk_high_gravity(edict_t *self)
 {
+	float gravity_scale = (800.f / level.gravity);
+
 	if (self->velocity[2] < 0)
-		self->gravity = 2.25f * (800.f / level.gravity);
-	else
-		self->gravity = 5.25f * (800.f / level.gravity);
+		self->gravity = 2.25f;
+	else
+		self->gravity = 5.25f;
+
+	self->gravity *= gravity_scale;
 }
 
 void berserk_jump_takeoff(edict_t *self)
@@ -317,12 +398,18 @@
 	AngleVectors(self->s.angles, forward, nullptr, nullptr);
 	self->s.origin[2] += 1;
 	self->velocity = forward * fwd_speed;
-	self->velocity[2] = 450;
+	self->velocity[2] = 400;
 	self->groundentity = nullptr;
 	self->monsterinfo.aiflags |= AI_DUCKED;
 	self->monsterinfo.attack_finished = level.time + 3_sec;
 	self->touch = berserk_jump_touch;
 	berserk_high_gravity(self);
+
+	self->gravity = -self->gravity;
+	SV_AddGravity(self);
+	self->gravity = -self->gravity;
+
+	gi.linkentity(self);
 }
 
 void berserk_check_landing(edict_t *self)
@@ -377,6 +464,7 @@
 MMOVE_T(berserk_move_attack_strike) = { FRAME_slam1, FRAME_slam23, berserk_frames_attack_strike, berserk_run };
 
 extern const mmove_t berserk_move_run_attack1;
+extern const mmove_t berserk_move_run_attack2; //KONIG berserk2 variant
 
 MONSTERINFO_MELEE(berserk_melee) (edict_t *self) -> void
 {
@@ -390,13 +478,33 @@
 		self->monsterinfo.attack_finished = 0_ms;
 		return;
 	}
+	/* KONIG - same as above but berserk2*/
+	else if (self->monsterinfo.active_move == &berserk_move_run_attack2 && self->s.frame >= FRAME_r_att13)
+	{
+		self->monsterinfo.attack_state = AS_STRAIGHT;
+		self->monsterinfo.attack_finished = 0_ms;
+		return;
+	}
 
 	monster_done_dodge(self);
 
-	if (brandom())
-		M_SetAnimation(self, &berserk_move_attack_spike);
-	else
-		M_SetAnimation(self, &berserk_move_attack_club);
+	/* KONIG - berserk2 attacks*/
+	if (strcmp(self->classname, "monster_berserk2") == 0)
+	{
+		if (frandom() < 0.4)
+			M_SetAnimation(self, &berserk_move_attack_spike);
+		else if (frandom() < 0.6)
+			M_SetAnimation(self, &berserk_move_attack_club);
+		else
+			M_SetAnimation(self, &berserk_move_attack_slam);
+	}
+	else
+	{
+		if (brandom())
+			M_SetAnimation(self, &berserk_move_attack_spike);
+		else
+			M_SetAnimation(self, &berserk_move_attack_club);
+	}
 }
 
 static void berserk_run_attack_speed(edict_t *self)
@@ -442,13 +550,36 @@
 };
 MMOVE_T(berserk_move_run_attack1) = { FRAME_r_att1, FRAME_r_att18, berserk_frames_run_attack1, berserk_run };
 
+/* KONIG - Berserk2 attacks */
+mframe_t berserk_frames_run_attack2[] = {
+	{ ai_run, 21, berserk_run_attack_speed },
+	{ ai_run, 11, [](edict_t* self) { berserk_run_attack_speed(self); monster_footstep(self); } },
+	{ ai_run, 21, berserk_run_attack_speed },
+	{ ai_run, 25, [](edict_t* self) { berserk_run_attack_speed(self); monster_done_dodge(self); }},
+	{ ai_run, 18, [](edict_t* self) { berserk_run_attack_speed(self); monster_footstep(self); berserk_lightning(self); } },
+	{ ai_run, 19, berserk_run_attack_speed },
+	{ ai_run, 21 },
+	{ ai_run, 11, monster_footstep },
+	{ ai_run, 21, berserk_lightning },
+	{ ai_run, 25 },
+	{ ai_run, 18, monster_footstep },
+	{ ai_run, 19 },
+	{ ai_run, 21, berserk_run_swing },
+	{ ai_run, 11, monster_footstep },
+	{ ai_run, 21, berserk_lightning },
+	{ ai_run, 25 },
+	{ ai_run, 18, monster_footstep },
+	{ ai_run, 19, berserk_attack_club }
+};
+MMOVE_T(berserk_move_run_attack2) = { FRAME_r_attb1, FRAME_r_attb18, berserk_frames_run_attack2, berserk_run };
+
 MONSTERINFO_ATTACK(berserk_attack) (edict_t *self) -> void
 {
 	if (self->monsterinfo.melee_debounce_time <= level.time && (range_to(self, self->enemy) < MELEE_DISTANCE))
 		berserk_melee(self);
 	// only jump if they are far enough away for it to make sense (otherwise
 	// it gets annoying to have them keep hopping over and over again)
-	else if (!self->spawnflags.has(SPAWNFLAG_BERSERK_NOJUMPING) && (self->timestamp < level.time && brandom()) && range_to(self, self->enemy) > 150.f)
+	else if (!self->spawnflags.has(SPAWNFLAG_BERSERK_NOJUMPING) && (self->timestamp < level.time && brandom()) && range_to(self, self->enemy) > 250.f) //KONIG - increased distance for jumping
 	{
 		M_SetAnimation(self, &berserk_move_attack_strike);
 		// don't do this for a while, otherwise we just keep doing it
@@ -457,7 +588,16 @@
 	}
 	else if (self->monsterinfo.active_move == &berserk_move_run1 && (range_to(self, self->enemy) <= RANGE_NEAR))
 	{
-		M_SetAnimation(self, &berserk_move_run_attack1);
+		/* KONIG - Berser2 attacks*/
+		if (strcmp(self->classname, "monster_berserk2") == 0)
+		{
+			if (frandom() > 0.4f)
+				M_SetAnimation(self, &berserk_move_run_attack2);
+			else
+				M_SetAnimation(self, &berserk_move_attack_chargedclub);
+		}
+		else
+			M_SetAnimation(self, &berserk_move_run_attack1);
 		self->monsterinfo.nextframe = FRAME_r_att1 + (self->s.frame - FRAME_run1) + 1;
 	}
 }
@@ -525,10 +665,11 @@
 
 MONSTERINFO_SETSKIN(berserk_setskin) (edict_t *self) -> void
 {
+	/* KONIG - allow multiple skins */
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
-	else
-		self->s.skinnum = 0;
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 void berserk_dead(edict_t *self)
@@ -770,6 +911,8 @@
  */
 void SP_monster_berserk(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -834,3 +977,24 @@
 
 	walkmonster_start(self);
 }
+
+/*QUAKED monster_berserk2 (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+ */
+ /* KONIG - new berserker beta; Quake 4's Berserker*/
+void SP_monster_berserk2(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	SP_monster_berserk(self);
+	self->s.skinnum = 2;
+
+	self->health = 300 * st.health_multiplier;
+	self->monsterinfo.armor_type = IT_ARMOR_JACKET;
+	self->monsterinfo.armor_power = 100;
+
+	if (!self->s.scale)
+		self->s.scale = 1.2f;
+
+	self->mins[2] = -28;
+
+}
--- a/m_boss2.cpp	2023-10-03 19:43:06
+++ b/m_boss2.cpp	2025-09-04 19:53:48
@@ -22,6 +22,20 @@
 static cached_soundindex sound_pain3;
 static cached_soundindex sound_death;
 static cached_soundindex sound_search1;
+
+/* KONIG - universal boss powerup copy */
+void BossPowerups(edict_t* self);
+
+// he fly
+static void boss2_set_fly_parameters(edict_t *self, bool firing)
+{
+	self->monsterinfo.fly_thrusters = false;
+	self->monsterinfo.fly_acceleration = firing ? 1.5f : 3.f;
+	self->monsterinfo.fly_speed = firing ? 10.f : 80.f;
+	// BOSS2 stays far-ish away if he's in the open
+	self->monsterinfo.fly_min_distance = 400.f;
+	self->monsterinfo.fly_max_distance = 500.f;
+}
 
 MONSTERINFO_SEARCH(boss2_search) (edict_t *self) -> void
 {
@@ -157,7 +171,11 @@
 	dir = vec - start;
 	dir.normalize();
 
-	monster_fire_rocket(self, start, dir, 35, BOSS2_ROCKET_SPEED, MZ2_BOSS2_ROCKET_1);
+	/* KONIG _ Titan Hornet from Citadel*/
+	if (strcmp(self->classname, "monster_boss2_titan") == 0)
+		monster_fire_heat(self, start, dir, 50, 500, MZ2_BOSS2_ROCKET_1, 0.075f);
+	else
+		monster_fire_rocket(self, start, dir, 35, BOSS2_ROCKET_SPEED, MZ2_BOSS2_ROCKET_1);
 }
 
 void boss2_firebullet_right(edict_t *self)
@@ -295,7 +313,11 @@
 	forward = target - start;
 	forward.normalize();
 
-	monster_fire_blaster(self, start, forward, 2, 1000, id, (self->s.frame % 4) ? EF_NONE : EF_HYPERBLASTER);
+	/* KONIG - flechettes instead of blaster, increase damage from 2 to 5; titan uses bullets still*/
+	if (strcmp(self->classname, "monster_boss2_titan") == 0)
+		monster_fire_bullet(self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD * 3, DEFAULT_BULLET_VSPREAD, id);
+	else
+		monster_fire_flechette(self, start, forward, 5, 1000, id);
 }
 
 mframe_t boss2_frames_attack_hb[] = {
@@ -462,6 +484,8 @@
 
 MONSTERINFO_RUN(boss2_run) (edict_t *self) -> void
 {
+	boss2_set_fly_parameters(self, false);
+
 	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
 		M_SetAnimation(self, &boss2_move_stand);
 	else
@@ -485,6 +509,8 @@
 		M_SetAnimation(self, self->spawnflags.has(SPAWNFLAG_BOSS2_N64) ? &boss2_move_attack_hb : &boss2_move_attack_pre_mg);
 	else
 		M_SetAnimation(self, self->spawnflags.has(SPAWNFLAG_BOSS2_N64) ? &boss2_move_attack_rocket2 : &boss2_move_attack_rocket);
+
+	boss2_set_fly_parameters(self, true);
 }
 
 void boss2_attack_mg(edict_t *self)
@@ -528,10 +554,11 @@
 
 MONSTERINFO_SETSKIN(boss2_setskin) (edict_t *self) -> void
 {
+	/*KONIG - adjust for multiple skins*/
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
-	else
-		self->s.skinnum = 0;
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 static void boss2_gib(edict_t *self)
@@ -610,13 +637,77 @@
 // [Paril-KEX] use generic function
 MONSTERINFO_CHECKATTACK(Boss2_CheckAttack) (edict_t *self) -> bool
 {
+	/* KONIG - boss powerup response*/
+	BossPowerups(self);
 	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.8f, 0.8f, 0.f, 0.f);
+}
+
+//
+// DODGES AND TITAN TELEPORT
+//
+
+void TitanTeleport(edict_t* self)
+{
+	if (skill->integer <= 3 && frandom() >= 0.5f)
+		return;
+
+	if (!TryRandomTeleportPosition(self, 256.0f)) {
+		return;
+	}
+}
+
+MONSTERINFO_DODGE(titan_dodge) (edict_t* self, edict_t* attacker, gtime_t eta, trace_t* tr, bool gravity) -> void
+{
+	if (!(strcmp(self->classname, "monster_boss2_titan") == 0))
+		return;
+
+	if (self->health <= 0)
+		return;
+
+	if (!self->enemy)
+	{
+		self->enemy = attacker;
+		FoundTarget(self);
+		return;
+	}
+
+	if ((eta < FRAME_TIME_MS) || (eta > 5_sec))
+		return;
+
+	if (self->timestamp > level.time)
+		return;
+
+	self->timestamp = level.time + random_time(1_sec, 5_sec);
+
+	TitanTeleport(self);
+}
+
+MONSTERINFO_SIDESTEP(boss2_sidestep) (edict_t* self) -> bool
+{
+	if (skill->integer < 3)
+		return false;
+
+	if ((self->monsterinfo.active_move == &boss2_move_attack_hb) ||
+		(self->monsterinfo.active_move == &boss2_move_attack_pre_mg) ||
+		(self->monsterinfo.active_move == &boss2_move_attack_mg) ||
+		(self->monsterinfo.active_move == &boss2_move_attack_rocket) ||
+		(self->monsterinfo.active_move == &boss2_move_attack_rocket2))
+	{
+		return false;
+	}
+
+	if (self->monsterinfo.active_move != &boss2_move_run)
+		M_SetAnimation(self, &boss2_move_run);
+
+	return true;
 }
 
 /*QUAKED monster_boss2 (1 .5 0) (-56 -56 0) (56 56 80) Ambush Trigger_Spawn Sight Hyperblaster
  */
 void SP_monster_boss2(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -631,7 +722,8 @@
 	gi.soundindex("tank/rocket.wav");
 
 	if (self->spawnflags.has(SPAWNFLAG_BOSS2_N64))
-		gi.soundindex("flyer/flyatck3.wav");
+		/*KONIG - fletchettes for N64*/
+		gi.soundindex("guncmdr/gcdratck2.wav");
 	else
 		gi.soundindex("infantry/infatck1.wav");
 
@@ -655,7 +747,36 @@
 	self->mins = { -56, -56, 0 };
 	self->maxs = { 56, 56, 80 };
 
-	self->health = 2000 * st.health_multiplier;
+	/*KONIG - GZ scaling health; added armor; N64 skin */
+	if (self->spawnflags.has(SPAWNFLAG_BOSS2_N64))
+	{
+		self->s.skinnum = 2;
+		if (!level.is_n64)
+		{
+			if (!st.was_key_specified("power_armor_type"))
+				self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+			if (!st.was_key_specified("power_armor_power"))
+				self->monsterinfo.power_armor_power = max(350, 350 + 100 * (skill->integer - 1));
+		}
+		if (coop->integer)
+		{
+			self->health += (250 * (CountPlayers() - 1));
+			self->monsterinfo.power_armor_power += (100 * (CountPlayers() - 1));
+		}
+	}
+	else
+	{
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_BODY;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = max(350, 350 + 100 * (skill->integer - 1));
+		if (coop->integer)
+		{
+			self->health += (250 * (CountPlayers() - 1));
+			self->monsterinfo.armor_power += (100 * (CountPlayers() - 1));
+		}
+	}
+	self->health = max(2000, 2000 + 1000 * (skill->integer - 1)) * st.health_multiplier;
 	self->gib_health = -200;
 	self->mass = 1000;
 
@@ -672,6 +793,8 @@
 	self->monsterinfo.attack = boss2_attack;
 	self->monsterinfo.search = boss2_search;
 	self->monsterinfo.checkattack = Boss2_CheckAttack;
+	self->monsterinfo.dodge = titan_dodge;
+	self->monsterinfo.sidestep = boss2_sidestep;
 	self->monsterinfo.setskin = boss2_setskin;
 	gi.linkentity(self);
 
@@ -681,5 +804,45 @@
 	// [Paril-KEX]
 	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
 
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+	boss2_set_fly_parameters(self, false);
+
 	flymonster_start(self);
 }
+
+//Citadel boss
+/*QUAKED monster_boss2_titan (1 .5 0) (-64 -64 0) (64 64 72) Ambush Trigger_Spawn Sight
+ */
+void SP_monster_boss2_titan(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	SP_monster_boss2(self);
+	self->spawnflags |= SPAWNFLAG_BOSS2_N64;
+	self->s.skinnum = 4;
+
+	if (!self->s.scale)
+		self->s.scale = 1.5f;
+
+	self->mins = { -72, -72, 0 };
+	self->maxs = { 72, 72, 136 };
+
+	self->health = max(3000, 3000 + 1000 * (skill->integer - 1)) * st.health_multiplier;
+	self->gib_health = -200;
+	self->mass = 1000;
+
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_BODY;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = max(350, 350 + 100 * (skill->integer - 1));
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = max(350, 350 + 100 * (skill->integer - 1));
+	if (coop->integer)
+	{
+		self->health += (250 * (CountPlayers() - 1));
+		self->monsterinfo.armor_power += (100 * (CountPlayers() - 1));
+		self->monsterinfo.power_armor_power += (100 * (CountPlayers() - 1));
+	}
+}
--- a/m_boss31.cpp	2023-10-03 19:43:06
+++ b/m_boss31.cpp	2025-09-04 19:53:48
@@ -28,6 +28,12 @@
 static cached_soundindex sound_step_left;
 static cached_soundindex sound_step_right;
 static cached_soundindex sound_death_hit;
+
+/* KONIG - add powerup copy; makron corpse for disable makron spawn */
+constexpr spawnflags_t SPAWNFLAG_NO_MAKRON = 8_spawnflag;
+void makron_spawn_torso(edict_t* self);
+void makron_torso(edict_t* self);
+unsigned int jorg_damage_multiplier;
 
 void MakronToss(edict_t *self);
 
@@ -481,7 +487,7 @@
 	dir = vec - start;
 	dir.normalize();
 	gi.sound(self, CHAN_WEAPON, sound_bfg_fire, 1, ATTN_NORM, 0);
-	monster_fire_bfg(self, start, dir, 50, 300, 100, 200, MZ2_JORG_BFG_1);
+	monster_fire_bfg(self, start, dir, 50 * jorg_damage_multiplier, 300, 100, 200, MZ2_JORG_BFG_1); //KONIG - powerup multiplier
 }
 
 void jorg_firebullet_right(edict_t *self)
@@ -490,7 +496,7 @@
 	AngleVectors(self->s.angles, forward, right, nullptr);
 	start = M_ProjectFlashSource(self, monster_flash_offset[MZ2_JORG_MACHINEGUN_R1], forward, right);
 	PredictAim(self, self->enemy, start, 0, false, -0.2f, &forward, nullptr);
-	monster_fire_bullet(self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_JORG_MACHINEGUN_R1);
+	monster_fire_bullet(self, start, forward, 6 * jorg_damage_multiplier, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_JORG_MACHINEGUN_R1); //KONIG - powerup multiplier
 }
 
 void jorg_firebullet_left(edict_t *self)
@@ -499,7 +505,7 @@
 	AngleVectors(self->s.angles, forward, right, nullptr);
 	start = M_ProjectFlashSource(self, monster_flash_offset[MZ2_JORG_MACHINEGUN_L1], forward, right);
 	PredictAim(self, self->enemy, start, 0, false, 0.2f, &forward, nullptr);
-	monster_fire_bullet(self, start, forward, 6, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_JORG_MACHINEGUN_L1);
+	monster_fire_bullet(self, start, forward, 6 * jorg_damage_multiplier, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_JORG_MACHINEGUN_L1); //KONIG - powerup multiplier
 }
 
 void jorg_firebullet(edict_t *self)
@@ -546,7 +552,11 @@
 		{ "models/monsters/boss3/jorg/gibs/head.md2", GIB_SKINNED | GIB_METALLIC | GIB_HEAD }
 	});
 
-	MakronToss(self);
+	/* KONIG - Spawnflag to disable MakronToss */
+	if (self->spawnflags.has(SPAWNFLAG_NO_MAKRON))
+		makron_spawn_torso(self);
+	else
+		MakronToss(self);
 }
 
 DIE(jorg_die) (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, const vec3_t &point, const mod_t &mod) -> void
@@ -559,9 +569,140 @@
 	M_SetAnimation(self, &jorg_move_death);
 }
 
+void JorgQuad(edict_t* self, gtime_t time)
+{
+	self->monsterinfo.quad_time = time;
+	jorg_damage_multiplier = 4;
+}
+
+void JorgQuadnDouble(edict_t* self, gtime_t time)
+{
+	self->monsterinfo.quad_time = time;
+	self->monsterinfo.double_time = time;
+	jorg_damage_multiplier = 8;
+}
+
+void JorgDouble(edict_t* self, gtime_t time)
+{
+	self->monsterinfo.double_time = time;
+	jorg_damage_multiplier = 2;
+}
+
+void JorgPent(edict_t* self, gtime_t time)
+{
+	self->monsterinfo.invincible_time = time;
+}
+
+void JorgPowerArmor(edict_t* self)
+{
+	self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+	// I don't like this, but it works
+	if (self->monsterinfo.power_armor_power <= 0)
+		self->monsterinfo.power_armor_power += 250 * skill->integer;
+	if (coop->integer)
+		self->monsterinfo.power_armor_power += ((25 * skill->integer) + (25 * (CountPlayers() - 1)));
+}
+
+void JorgRespondPowerup(edict_t* self, edict_t* other)
+{
+	if (other->s.effects & EF_QUAD & EF_DOUBLE)
+	{
+		JorgPowerArmor(self);
+		if (skill->integer >= 1)
+		{
+			JorgQuadnDouble(self, other->client->quad_time);
+		}
+	}
+	else if (other->s.effects & EF_QUAD)
+	{
+		JorgPowerArmor(self);
+		if (skill->integer >= 1)
+			JorgQuad(self, other->client->quad_time);
+	}
+	else if (other->s.effects & EF_DOUBLE)
+	{
+		JorgPowerArmor(self);
+		if (skill->integer >= 1)
+			JorgDouble(self, other->client->double_time);
+	}
+	else if (other->s.effects & EF_DUALFIRE)
+	{
+		JorgPowerArmor(self);
+		if (skill->integer >= 3)
+			JorgDouble(self, other->client->double_time);
+	}
+	else
+		jorg_damage_multiplier = 1;
+
+	if (other->s.effects & EF_PENT)
+	{
+		if (skill->integer == 1)
+			JorgPowerArmor(self);
+		else if (skill->integer >= 2)
+			JorgPent(self, other->client->invincible_time);
+	}
+}
+
+void JorgPowerups(edict_t* self)
+{
+	edict_t* ent;
+
+	if (!coop->integer)
+	{
+		JorgRespondPowerup(self, self->enemy);
+	}
+	else
+	{
+		// in coop, check for pents, then quads, then doubles
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			if (ent->s.effects & EF_PENT)
+			{
+				JorgRespondPowerup(self, ent);
+				return;
+			}
+		}
+
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			if (ent->s.effects & EF_QUAD)
+			{
+				JorgRespondPowerup(self, ent);
+				return;
+			}
+		}
+
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			if (ent->s.effects & EF_DOUBLE)
+			{
+				JorgRespondPowerup(self, ent);
+				return;
+			}
+		}
+	}
+}
+
 // [Paril-KEX] use generic function
 MONSTERINFO_CHECKATTACK(Jorg_CheckAttack) (edict_t *self) -> bool
 {
+	/* KONIG - add powerup copy */
+	JorgPowerups(self);
 	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.4f, 0.2f, 0.0f, 0.f);
 }
 
@@ -571,6 +712,8 @@
  */
 void SP_monster_jorg(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -613,7 +756,38 @@
 	self->mins = { -80, -80, 0 };
 	self->maxs = { 80, 80, 140 };
 
-	self->health = 8000 * st.health_multiplier;
+	/* KONIG - GZ health scaling; added armor w/ scaling; rebalanced for nojorg spawnflag*/
+	if (self->spawnflags.has(SPAWNFLAG_NO_MAKRON))
+	{
+		self->health = max(10000, 10000 + 1250 * (skill->integer - 1)) * st.health_multiplier;
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_BODY;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = max(500, 500 + 150 * (skill->integer - 1));
+		if (!st.was_key_specified("power_armor_type"))
+			self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+		if (!st.was_key_specified("power_armor_power"))
+			self->monsterinfo.power_armor_power = max(500, 500 + 150 * (skill->integer - 1));
+		if (coop->integer)
+		{
+			self->health += (500 * skill->integer) + (500 * (CountPlayers() - 1));
+			self->monsterinfo.armor_power += (250 * skill->integer) + (250 * (CountPlayers() - 1));
+			self->monsterinfo.power_armor_power += (250 * skill->integer) + (250 * (CountPlayers() - 1));
+		}
+	}
+	else
+	{
+		self->health = max(8000, 8000 + 1250 * (skill->integer - 1)) * st.health_multiplier;
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_BODY;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = max(500, 500 + 150 * (skill->integer - 1));
+		if (coop->integer)
+		{
+			self->health += (500 * skill->integer) + (500 * (CountPlayers() - 1));
+			self->monsterinfo.armor_power += (250 * skill->integer) + (250 * (CountPlayers() - 1));
+		}
+	}
 	self->gib_health = -2000;
 	self->mass = 1000;
 
--- a/m_boss32.cpp	2023-10-03 19:43:06
+++ b/m_boss32.cpp	2025-09-04 19:53:48
@@ -34,6 +34,9 @@
 static cached_soundindex sound_taunt2;
 static cached_soundindex sound_taunt3;
 static cached_soundindex sound_hit;
+
+/* KONIG - universal boss powerup copy */
+unsigned int makron_damage_multiplier;
 
 void makron_taunt(edict_t *self)
 {
@@ -443,7 +446,8 @@
 	dir = vec - start;
 	dir.normalize();
 	gi.sound(self, CHAN_VOICE, sound_attack_bfg, 1, ATTN_NORM, 0);
-	monster_fire_bfg(self, start, dir, 50, 300, 100, 300, MZ2_MAKRON_BFG);
+	/* KONIG - damage multiplier */
+	monster_fire_bfg(self, start, dir, 50 * makron_damage_multiplier, 300, 100, 300, MZ2_MAKRON_BFG);
 }
 
 mframe_t makron_frames_attack3[] = {
@@ -527,7 +531,8 @@
 	dir = self->pos1 - start;
 	dir.normalize();
 
-	monster_fire_railgun(self, start, dir, 50, 100, MZ2_MAKRON_RAILGUN_1);
+	/* KONIG - damage multiplier */
+	monster_fire_railgun(self, start, dir, 50 * makron_damage_multiplier, 100, MZ2_MAKRON_RAILGUN_1);
 }
 
 void MakronHyperblaster(edict_t *self)
@@ -536,6 +541,7 @@
 	vec3_t vec;
 	vec3_t start;
 	vec3_t forward, right;
+	int spread = 500;
 
 	monster_muzzleflash_id_t flash_number = (monster_muzzleflash_id_t) (MZ2_MAKRON_BLASTER_1 + (self->s.frame - FRAME_attak405));
 
@@ -562,7 +568,16 @@
 
 	AngleVectors(dir, forward, nullptr, nullptr);
 
-	monster_fire_blaster(self, start, forward, 15, 1000, flash_number, EF_BLASTER);
+	/* KONIG - blaster -> ion ripper; flakripper in Nightmare */
+	if (skill->integer >= 3)
+	{
+		monster_fire_flakripper(self, start, forward, 15 * makron_damage_multiplier, 800, 15, spread,
+			spread, 5, flash_number, EF_IONRIPPER);
+	}
+	else
+	{
+		monster_fire_ionripper(self, start, forward, 15 * makron_damage_multiplier, 800, flash_number, EF_IONRIPPER);
+	}
 }
 
 PAIN(makron_pain) (edict_t *self, edict_t *other, float kick, int damage, const mod_t &mod) -> void
@@ -619,10 +634,11 @@
 
 MONSTERINFO_SETSKIN(makron_setskin) (edict_t *self) -> void
 {
+	/* KONIG - allow multiple skins */
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
-	else
-		self->s.skinnum = 0;
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 MONSTERINFO_SIGHT(makron_sight) (edict_t *self, edict_t *other) -> void
@@ -692,9 +708,140 @@
 	self->maxs = { 60, 60, 48 };
 }
 
+void MakronQuad(edict_t* self, gtime_t time)
+{
+	self->monsterinfo.quad_time = time;
+	makron_damage_multiplier = 4;
+}
+
+void MakronQuadnDouble(edict_t* self, gtime_t time)
+{
+	self->monsterinfo.quad_time = time;
+	self->monsterinfo.double_time = time;
+	makron_damage_multiplier = 8;
+}
+
+void MakronDouble(edict_t* self, gtime_t time)
+{
+	self->monsterinfo.double_time = time;
+	makron_damage_multiplier = 2;
+}
+
+void MakronPent(edict_t* self, gtime_t time)
+{
+	self->monsterinfo.invincible_time = time;
+}
+
+void MakronPowerArmor(edict_t* self)
+{
+	self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+	// I don't like this, but it works
+	if (self->monsterinfo.power_armor_power <= 0)
+		self->monsterinfo.power_armor_power += 250 * skill->integer;
+	if (coop->integer)
+		self->monsterinfo.power_armor_power += ((25 * skill->integer) + (25 * (CountPlayers() - 1)));
+}
+
+void MakronRespondPowerup(edict_t* self, edict_t* other)
+{
+	if (other->s.effects & EF_QUAD & EF_DOUBLE)
+	{
+		MakronPowerArmor(self);
+		if (skill->integer >= 1)
+		{
+			MakronQuadnDouble(self, other->client->quad_time);
+		}
+	}
+	else if (other->s.effects & EF_QUAD)
+	{
+		MakronPowerArmor(self);
+		if (skill->integer >= 1)
+			MakronQuad(self, other->client->quad_time);
+	}
+	else if (other->s.effects & EF_DOUBLE)
+	{
+		MakronPowerArmor(self);
+		if (skill->integer >= 1)
+			MakronDouble(self, other->client->double_time);
+	}
+	else if (other->s.effects & EF_DUALFIRE)
+	{
+		MakronPowerArmor(self);
+		if (skill->integer >= 3)
+			MakronDouble(self, other->client->double_time);
+	}
+	else
+		makron_damage_multiplier = 1;
+
+	if (other->s.effects & EF_PENT)
+	{
+		if (skill->integer == 1)
+			MakronPowerArmor(self);
+		else if (skill->integer >= 2)
+			MakronPent(self, other->client->invincible_time);
+	}
+}
+
+void MakronPowerups(edict_t* self)
+{
+	edict_t* ent;
+
+	if (!coop->integer)
+	{
+		MakronRespondPowerup(self, self->enemy);
+	}
+	else
+	{
+		// in coop, check for pents, then quads, then doubles
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			if (ent->s.effects & EF_PENT)
+			{
+				MakronRespondPowerup(self, ent);
+				return;
+			}
+		}
+
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			if (ent->s.effects & EF_QUAD)
+			{
+				MakronRespondPowerup(self, ent);
+				return;
+			}
+		}
+
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			if (ent->s.effects & EF_DOUBLE)
+			{
+				MakronRespondPowerup(self, ent);
+				return;
+			}
+		}
+	}
+}
+
 // [Paril-KEX] use generic function
 MONSTERINFO_CHECKATTACK(Makron_CheckAttack) (edict_t *self) -> bool
 {
+	/* KONIG - add powerup copy */
+	MakronPowerups(self);
 	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.4f, 0.2f, 0.0f, 0.f);
 }
 
@@ -726,6 +873,8 @@
  */
 void SP_monster_makron(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -739,7 +888,17 @@
 	self->mins = { -30, -30, 0 };
 	self->maxs = { 30, 30, 90 };
 
-	self->health = 3000 * st.health_multiplier;
+	/* KONIG - GZ health scaling; added armor w/ scaling; rebalanced for nojorg spawnflag*/
+	self->health = max(3000, 3000 + 1250 * (skill->integer - 1)) * st.health_multiplier;
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = max(500, 500 + 150 * (skill->integer - 1));
+	if (coop->integer)
+	{
+		self->health += (500 * skill->integer) + (500 * (CountPlayers() - 1));
+		self->monsterinfo.power_armor_power += (250 * skill->integer) + (250 * (CountPlayers() - 1));
+	}
 	self->gib_health = -2000;
 	self->mass = 500;
 
--- a/m_brain.cpp	2023-10-03 19:43:06
+++ b/m_brain.cpp	2025-09-04 19:53:48
@@ -650,10 +650,11 @@
 
 MONSTERINFO_SETSKIN(brain_setskin) (edict_t *self) -> void
 {
+	/* KONIG - allow multiple skins */
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
-	else
-		self->s.skinnum = 0;
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 void brain_dead(edict_t *self)
@@ -724,6 +725,8 @@
  */
 void SP_monster_brain(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_chick.cpp	2023-10-03 19:43:06
+++ b/m_chick.cpp	2025-09-04 19:53:48
@@ -790,6 +790,8 @@
  */
 void SP_monster_chick(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_flipper.cpp	2023-10-03 19:43:06
+++ b/m_flipper.cpp	2025-09-04 19:53:48
@@ -215,10 +215,11 @@
 
 MONSTERINFO_SETSKIN(flipper_setskin) (edict_t *self) -> void
 {
+	/* KONIG - allow multiple skins */
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
+		self->s.skinnum |= 1;
 	else
-		self->s.skinnum = 0;
+		self->s.skinnum &= ~1;
 }
 
 void flipper_dead(edict_t *self)
@@ -338,6 +339,8 @@
  */
 void SP_monster_flipper(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_float.cpp	2023-10-03 19:43:06
+++ b/m_float.cpp	2025-09-04 19:53:48
@@ -53,7 +53,11 @@
 	dir = end - start;
 	dir.normalize();
 
-	monster_fire_blaster(self, start, dir, 1, 1000, MZ2_FLOAT_BLASTER_1, (self->s.frame % 4) ? EF_NONE : EF_HYPERBLASTER);
+	/* KONIG - blue blasters for Mimics */
+	if (strcmp(self->classname, "monster_mimic") == 0)
+		monster_fire_blueblaster(self, start, dir, 2, 1000, MZ2_FLOAT_BLASTER_1, (self->s.frame % 4) ? EF_NONE : EF_BLUEHYPERBLASTER);
+	else
+		monster_fire_blaster(self, start, dir, 1, 1000, MZ2_FLOAT_BLASTER_1, (self->s.frame % 4) ? EF_NONE : EF_HYPERBLASTER);
 }
 
 mframe_t floater_frames_stand1[] = {
@@ -600,10 +604,11 @@
 
 MONSTERINFO_SETSKIN(floater_setskin) (edict_t *self) -> void
 {
+	/* KONIG - allows multiple skins*/
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
+		self->s.skinnum |= 1;
 	else
-		self->s.skinnum = 0;
+		self->s.skinnum &= ~1;
 }
 
 void floater_dead(edict_t *self)
@@ -653,6 +658,8 @@
  */
 void SP_monster_floater(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -714,3 +721,18 @@
 
 	flymonster_start(self);
 }
+
+/* KONIG - technician beta aka Mimic */
+/*QUAKED monster_floater (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight Disguise
+ */
+void SP_monster_mimic(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	self->spawnflags |= SPAWNFLAG_FLOATER_DISGUISE;
+	SP_monster_floater(self);
+	self->s.skinnum = 2;
+
+	self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	self->monsterinfo.armor_power = 100;
+}
--- a/m_flyer.cpp	2023-10-03 19:43:06
+++ b/m_flyer.cpp	2025-09-04 19:53:48
@@ -191,6 +191,55 @@
 };
 MMOVE_T(flyer_move_run) = { FRAME_stand01, FRAME_stand45, flyer_frames_run, nullptr };
 
+mframe_t flyer_frames_run2[] = {
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 },
+	{ ai_run, 25 }
+};
+MMOVE_T(flyer_move_run2) = { FRAME_stand01, FRAME_stand45, flyer_frames_run2, nullptr };
+
 mframe_t flyer_frames_kamizake[] = {
 	{ ai_charge, 40, flyer_kamikaze_check },
 	{ ai_charge, 40, flyer_kamikaze_check },
@@ -202,17 +251,19 @@
 
 MONSTERINFO_RUN(flyer_run) (edict_t *self) -> void
 {
-	if (self->mass > 50)
+	if (strcmp(self->classname, "monster_kamikaze") == 0)
 		M_SetAnimation(self, &flyer_move_kamikaze);
 	else if (self->monsterinfo.aiflags & AI_STAND_GROUND)
 		M_SetAnimation(self, &flyer_move_stand);
+	else if (strcmp(self->classname, "monster_cutter") == 0)
+		M_SetAnimation(self, &flyer_move_run2);
 	else
 		M_SetAnimation(self, &flyer_move_run);
 }
 
 MONSTERINFO_WALK(flyer_walk) (edict_t *self) -> void
 {
-	if (self->mass > 50)
+	if (strcmp(self->classname, "monster_kamikaze") == 0)
 		flyer_run(self);
 	else
 		M_SetAnimation(self, &flyer_move_walk);
@@ -220,7 +271,7 @@
 
 MONSTERINFO_STAND(flyer_stand) (edict_t *self) -> void
 {
-	if (self->mass > 50)
+	if (strcmp(self->classname, "monster_kamikaze") == 0)
 		flyer_run(self);
 	else
 		M_SetAnimation(self, &flyer_move_stand);
@@ -499,7 +550,7 @@
 
 static void flyer_set_fly_parameters(edict_t *self, bool melee)
 {
-	if (melee)
+	if (melee || strcmp(self->classname, "monster_cutter") == 0)
 	{
 		// engage thrusters for a slice
 		self->monsterinfo.fly_pinned = false;
@@ -522,7 +573,12 @@
 
 MONSTERINFO_ATTACK(flyer_attack) (edict_t *self) -> void
 {
-	if (self->mass > 50)
+	if (strcmp(self->classname, "monster_kamikaze") == 0)
+	{
+		flyer_run(self);
+		return;
+	}
+	else if (strcmp(self->classname, "monster_cutter") == 0)
 	{
 		flyer_run(self);
 		return;
@@ -561,7 +617,7 @@
 
 MONSTERINFO_MELEE(flyer_melee) (edict_t *self) -> void
 {
-	if (self->mass > 50)
+	if (strcmp(self->classname, "monster_kamikaze") == 0)
 		flyer_run(self);
 	else
 	{
@@ -590,7 +646,7 @@
 	int n;
 
 	//	pmm	 - kamikaze's don't feel pain
-	if (self->mass != 50)
+	if (strcmp(self->classname, "monster_kamikaze") == 0)
 		return;
 	// pmm
 
@@ -622,10 +678,11 @@
 
 MONSTERINFO_SETSKIN(flyer_setskin) (edict_t *self) -> void
 {
+	/* KONIG - allow multiple skins */
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
-	else
-		self->s.skinnum = 0;
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 DIE(flyer_die) (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, const vec3_t &point, const mod_t &mod) -> void
@@ -654,8 +711,7 @@
 // PMM - kamikaze code .. blow up if blocked
 MONSTERINFO_BLOCKED(flyer_blocked) (edict_t *self, float dist) -> bool
 {
-	// kamikaze = 100, normal = 50
-	if (self->mass == 100)
+	if (strcmp(self->classname, "monster_kamikaze") == 0)
 	{
 		flyer_kamikaze_check(self);
 
@@ -699,6 +755,8 @@
  */
 void SP_monster_flyer(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -752,20 +810,28 @@
 	M_SetAnimation(self, &flyer_move_stand);
 	self->monsterinfo.scale = MODEL_SCALE;
 
-	if (self->s.effects & EF_ROCKET)
-	{
-		// PMM - normal flyer has mass of 50
+	if (strcmp(self->classname, "monster_kamikaze") == 0)
+	{
 		self->mass = 100;
 		self->yaw_speed = 5;
+		flyer_set_fly_parameters(self, true);
 		self->touch = kamikaze_touch;
 	}
-	else
-	{
+	else if (strcmp(self->classname, "monster_cutter") == 0)
+	{
+		self->mass = 100;
 		self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
 		self->monsterinfo.fly_buzzard = true;
 		flyer_set_fly_parameters(self, false);
 		self->touch = flyer_touch;
 	}
+	else
+	{
+		self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+		self->monsterinfo.fly_buzzard = true;
+		flyer_set_fly_parameters(self, false);
+		self->touch = flyer_touch;
+	}
 
 	flymonster_start(self);
 }
@@ -782,3 +848,24 @@
 
 	SP_monster_flyer(self);
 }
+
+// KONIG - Melee only fliers
+void SP_monster_cutter(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	self->s.skinnum = 2;
+
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_JACKET;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 100;
+
+	SP_monster_flyer(self);
+
+}
--- a/m_gladiator.cpp	2023-10-03 19:43:06
+++ b/m_gladiator.cpp	2025-09-04 19:53:48
@@ -25,14 +25,31 @@
 static cached_soundindex sound_search;
 static cached_soundindex sound_sight;
 
+/* KONIG - BFGladiator sounds from 25th Anniversary pack */
+static cached_soundindex sound_attack_bfg;
+static cached_soundindex bfglad_sound_pain1;
+static cached_soundindex bfglad_sound_pain2;
+static cached_soundindex bfglad_sound_gun;
+static cached_soundindex bfglad_sound_die;
+static cached_soundindex bfglad_sound_idle;
+static cached_soundindex bfglad_sound_sight;
+
 MONSTERINFO_IDLE(gladiator_idle) (edict_t *self) -> void
 {
-	gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+	/* KONIG _ BFGladiator from 25th Anniversary*/
+	if (strcmp(self->classname, "monster_bfgladiator") == 0)
+		gi.sound(self, CHAN_VOICE, bfglad_sound_idle, 1, ATTN_IDLE, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
 }
 
 MONSTERINFO_SIGHT(gladiator_sight) (edict_t *self, edict_t *other) -> void
 {
-	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+	/* KONIG _ BFGladiator from 25th Anniversary*/
+	if (strcmp(self->classname, "monster_bfgladiator") == 0)
+		gi.sound(self, CHAN_VOICE, bfglad_sound_sight, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
 }
 
 MONSTERINFO_SEARCH(gladiator_search) (edict_t *self) -> void
@@ -152,7 +169,20 @@
 	dir = self->pos1 - start;
 	dir.normalize();
 
-	monster_fire_railgun(self, start, dir, 50, 100, MZ2_GLADIATOR_RAILGUN_1);
+	/* KONIG _ BFGladiator from 25th Anniversary*/
+	if (strcmp(self->classname, "monster_bfgladiator") == 0)
+		if (skill->integer >= 3) //TO DO: Homing BFG only in Nightmare
+		{
+			gi.sound(self, CHAN_VOICE, sound_attack_bfg, 1, ATTN_NORM, 0);
+			monster_fire_bfg(self, start, dir, 25, 300, 100, 300, MZ2_GLADIATOR_RAILGUN_1);
+		}
+		else
+		{
+			gi.sound(self, CHAN_VOICE, sound_attack_bfg, 1, ATTN_NORM, 0);
+			monster_fire_bfg(self, start, dir, 25, 300, 100, 300, MZ2_GLADIATOR_RAILGUN_1);
+		}
+	else
+		monster_fire_railgun(self, start, dir, 50, 100, MZ2_GLADIATOR_RAILGUN_1);
 }
 
 mframe_t gladiator_frames_attack_gun[] = {
@@ -184,6 +214,7 @@
 
 	int damage = 35;
 	int radius_damage = 45;
+	int spread = 800;
 
 	if (self->s.frame > FRAME_attack3)
 	{
@@ -191,7 +222,14 @@
 		radius_damage /= 2;
 	}
 
-	fire_plasma(self, start, dir, damage, 725, radius_damage, radius_damage);
+	/* KONIG - Flak Gladiator and swap fire_plasma for monster_fire_plasma for muzzle flash*/
+	if (strcmp(self->classname, "monster_gladiator_flak") == 0)
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/flakgn.wav"), 1, ATTN_NORM, 0);
+		monster_fire_flakcannon(self, start, dir, 5, 800, spread, spread, 7, MZ2_GLADIATOR_RAILGUN_1);
+	}
+	else
+		monster_fire_plasma(self, start, dir, damage, 725, radius_damage, radius_damage, MZ2_GLADIATOR_RAILGUN_1);
 
 	// save for aiming the shot
 	self->pos1 = self->enemy->s.origin;
@@ -240,6 +278,17 @@
 		gi.sound(self, CHAN_WEAPON, sound_gunb, 1, ATTN_NORM, 0);
 		M_SetAnimation(self, &gladb_move_attack_gun);
 	}
+	/* KONIG - Flak Gladiator*/
+	else if (strcmp(self->classname, "monster_gladiator_flak") == 0)
+	{
+		M_SetAnimation(self, &gladb_move_attack_gun);
+	}
+	/* KONIG _ BFGladiator from 25th Anniversary*/
+	else if (strcmp(self->classname, "monster_bfgladiator") == 0)
+	{
+		gi.sound(self, CHAN_WEAPON, bfglad_sound_gun, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &gladiator_move_attack_gun);
+	}
 	else
 	{
 		// RAFAEL
@@ -278,13 +327,24 @@
 
 	self->pain_debounce_time = level.time + 3_sec;
 
-	if (frandom() < 0.5f)
-		gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
-	else
-		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
-
 	if (!M_ShouldReactToPain(self, mod))
 		return; // no pain anims in nightmare
+
+	/* KONIG _ BFGladiator from 25th Anniversary*/
+	if (strcmp(self->classname, "monster_bfgladiator") == 0)
+	{
+		if (frandom() < 0.5f)
+			gi.sound(self, CHAN_VOICE, bfglad_sound_pain1, 1, ATTN_NORM, 0);
+		else
+			gi.sound(self, CHAN_VOICE, bfglad_sound_pain2, 1, ATTN_NORM, 0);
+	}
+	else
+	{
+		if (frandom() < 0.5f)
+			gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+		else
+			gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+	}
 
 	if (self->velocity[2] > 100)
 		M_SetAnimation(self, &gladiator_move_pain_air);
@@ -365,10 +425,17 @@
 		return;
 
 	// regular death
-	gi.sound(self, CHAN_BODY, sound_die, 1, ATTN_NORM, 0);
-
-	if (brandom())
-		gi.sound(self, CHAN_VOICE, sound_die2, 1, ATTN_NORM, 0);
+	/* KONIG _ BFGladiator from 25th Anniversary*/
+	if (strcmp(self->classname, "monster_bfgladiator") == 0) {
+		gi.sound(self, CHAN_VOICE, bfglad_sound_die, 1, ATTN_NORM, 0);
+	}
+	else
+	{
+		if (frandom() < 0.5f)
+			gi.sound(self, CHAN_BODY, sound_die, 1, ATTN_NORM, 0);
+		else
+			gi.sound(self, CHAN_VOICE, sound_die2, 1, ATTN_NORM, 0);
+	}
 
 	self->deadflag = true;
 	self->takedamage = true;
@@ -392,6 +459,8 @@
  */
 void SP_monster_gladiator(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -408,6 +477,15 @@
 	sound_search.assign("gladiator/gldsrch1.wav");
 	sound_sight.assign("gladiator/sight.wav");
 
+	/* KONIG _ BFGladiator from 25th Anniversary*/
+	bfglad_sound_pain1.assign("gladiator/bfpain1.wav");
+	bfglad_sound_pain2.assign("gladiator/bfpain2.wav");
+	bfglad_sound_die.assign("gladiator/bfdeth2.wav");
+	bfglad_sound_gun.assign("gladiator/bfattack.wav");
+	bfglad_sound_idle.assign("gladiator/bfidle1.wav");
+	bfglad_sound_sight.assign("gladiator/bfsight.wav");
+	sound_attack_bfg.assign("makron/bfg_fire.wav");
+
 	self->movetype = MOVETYPE_STEP;
 	self->solid = SOLID_BBOX;
 	self->s.modelindex = gi.modelindex("models/monsters/gladiatr/tris.md2");
@@ -423,19 +501,56 @@
 	{
 		sound_gunb.assign("weapons/plasshot.wav");
 
-		self->health = 250 * st.health_multiplier;
+		/* KONIG - half-revert to health nerf; power armor -> screene*/
+		self->health = 500 * st.health_multiplier;
 		self->mass = 350;
+
+		if (!st.was_key_specified("power_armor_type"))
+			self->monsterinfo.power_armor_type = IT_ITEM_POWER_SCREEN;
+		if (!st.was_key_specified("power_armor_power"))
+			self->monsterinfo.power_armor_power = 300;
+
+		self->s.skinnum = 2;
+
+		self->style = 1;
+
+		self->monsterinfo.weapon_sound = gi.soundindex("weapons/phaloop.wav");
+	}
+	else if (strcmp(self->classname, "monster_gladiator_flak") == 0)
+	{
+		self->health = 600 * st.health_multiplier;
+		self->mass = 400;
+
+		self->gib_health = -200;
+
+		if (!st.was_key_specified("power_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+		if (!st.was_key_specified("power_power"))
+			self->monsterinfo.armor_power = 200;
+
+		self->style = 1;
+		self->s.skinnum = 4;
+	}
+	else if (strcmp(self->classname, "monster_bfgladiator") == 0)
+	{
+		self->health = 800 * st.health_multiplier;
+		self->mass = 400;
+
+		self->gib_health = -200;
+
+		if (!self->s.scale)
+			self->s.scale = 1.25f;
 
 		if (!st.was_key_specified("power_armor_type"))
 			self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
 		if (!st.was_key_specified("power_armor_power"))
-			self->monsterinfo.power_armor_power = 250;
-
-		self->s.skinnum = 2;
-
-		self->style = 1;
-
-		self->monsterinfo.weapon_sound = gi.soundindex("weapons/phaloop.wav");
+			self->monsterinfo.power_armor_power = 200;
+		if (!st.was_key_specified("power_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+		if (!st.was_key_specified("power_power"))
+			self->monsterinfo.armor_power = 200;
+
+		self->s.skinnum = 6;
 	}
 	else
 	{
@@ -487,3 +602,19 @@
 {
 	SP_monster_gladiator(self);
 }
+
+/* KONIG - BFGladiator from 25th Anniversary*/
+/*QUAKED monster_bfgladiator (1 .5 0) (-32 - 32 - 24) (32 32 64) Ambush Trigger_Spawn Sight
+*/
+void SP_monster_bfgladiator(edict_t* self)
+{
+	SP_monster_gladiator(self);
+}
+
+/* KONIG - Flak Gladiator as requested by Coffee09 */
+/*QUAKED monster_gladiator_flak (1 .5 0) (-32 - 32 - 24) (32 32 64) Ambush Trigger_Spawn Sight
+*/
+void SP_monster_gladiator_flak(edict_t* self)
+{
+	SP_monster_gladiator(self);
+}
--- a/m_guardian.cpp	2023-10-03 19:43:06
+++ b/m_guardian.cpp	2025-09-04 19:53:48
@@ -12,6 +12,11 @@
 #include "m_guardian.h"
 #include "m_flash.h"
 
+static cached_soundindex sound_sight;
+static cached_soundindex sound_pain1;
+static cached_soundindex sound_pain2;
+static cached_soundindex sound_death;
+
 //
 // stand
 //
@@ -72,9 +77,62 @@
 };
 MMOVE_T(guardian_move_stand) = { FRAME_idle1, FRAME_idle52, guardian_frames_stand, nullptr };
 
+constexpr spawnflags_t SPAWNFLAG_GUARDIAN_SLEEPY = 8_spawnflag;
+
+/*
+=============
+ai_sleep
+
+honk shoo honk shoo
+==============
+*/
+void ai_sleep(edict_t *self, float dist)
+{
+}
+
+mframe_t guardian_frames_sleep[] = {
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep }
+};
+MMOVE_T(guardian_move_sleep) = { FRAME_sleep1, FRAME_sleep14, guardian_frames_sleep, nullptr };
+
 MONSTERINFO_STAND(guardian_stand) (edict_t *self) -> void
 {
-	M_SetAnimation(self, &guardian_move_stand);
+	if (self->spawnflags.has(SPAWNFLAG_GUARDIAN_SLEEPY))
+		M_SetAnimation(self, &guardian_move_sleep);
+	else
+		M_SetAnimation(self, &guardian_move_stand);
+}
+
+void guardian_run(edict_t *self);
+
+mframe_t guardian_frames_wake[] = {
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep },
+	{ ai_sleep }
+};
+MMOVE_T(guardian_move_wake) = { FRAME_wake1, FRAME_wake5, guardian_frames_wake, guardian_run };
+
+USE(guardian_use) (edict_t *self, edict_t *other, edict_t *activator) -> void
+{
+	self->spawnflags &= ~SPAWNFLAG_GUARDIAN_SLEEPY;
+	M_SetAnimation(self, &guardian_move_wake);
+	self->use = monster_use;
+	gi.sound(self, CHAN_BODY, sound_sight, 1.f, 0.1f, 0.0f);
 }
 
 //
@@ -85,7 +143,7 @@
 
 void guardian_footstep(edict_t *self)
 {
-	gi.sound(self, CHAN_BODY, sound_step, 1.f, ATTN_NORM, 0.0f);
+	gi.sound(self, CHAN_BODY, sound_step, 1.f, 0.1f, 0.0f);
 }
 
 mframe_t guardian_frames_walk[] = {
@@ -145,6 +203,8 @@
 
 MONSTERINFO_RUN(guardian_run) (edict_t *self) -> void
 {
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+
 	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
 	{
 		M_SetAnimation(self, &guardian_move_stand);
@@ -191,13 +251,18 @@
 		return;
 
 	self->pain_debounce_time = level.time + 3_sec;
-	//gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	if (brandom())
+		gi.sound(self, CHAN_BODY, sound_pain1, 1.f, 0.1f, 0.0f);
+	else
+		gi.sound(self, CHAN_BODY, sound_pain2, 1.f, 0.1f, 0.0f);
 
 	if (!M_ShouldReactToPain(self, mod))
 		return; // no pain anims in nightmare
 
 	M_SetAnimation(self, &guardian_move_pain1);
 	self->monsterinfo.weapon_sound = 0;
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
 }
 
 mframe_t guardian_frames_atk1_out[] = {
@@ -224,20 +289,25 @@
 
 void guardian_fire_blaster(edict_t *self)
 {
-	vec3_t forward, right, target;
+	vec3_t forward, right, up;
 	vec3_t start;
 	monster_muzzleflash_id_t id = MZ2_GUARDIAN_BLASTER;
 
-	AngleVectors(self->s.angles, forward, right, nullptr);
+	if (!self->enemy || !self->enemy->inuse)
+	{
+		self->monsterinfo.nextframe = FRAME_atk1_spin13;
+		return;
+	}
+
+	AngleVectors(self->s.angles, forward, right, up);
 	start = M_ProjectFlashSource(self, monster_flash_offset[id], forward, right);
-	target = self->enemy->s.origin;
-	target[2] += self->enemy->viewheight;
-	for (int i = 0; i < 3; i++)
-		target[i] += crandom_open() * 5.f;
-	forward = target - start;
+	PredictAim(self, self->enemy, start, 1000, false, crandom() * 0.1f, &forward, nullptr);
+	forward += right * crandom() * 0.02f;
+	forward += up * crandom() * 0.02f;
 	forward.normalize();
 
-	monster_fire_blaster(self, start, forward, 2, 1000, id, (self->s.frame % 4) ? EF_NONE : EF_HYPERBLASTER);
+	edict_t *bolt = monster_fire_blaster(self, start, forward, 3, 1100, id, (self->s.frame % 4) ? EF_NONE : EF_HYPERBLASTER);
+	bolt->s.scale = 2.0f;
 
 	if (self->enemy && self->enemy->health > 0 && 
 		self->s.frame == FRAME_atk1_spin12 && self->timestamp > level.time && visible(self, self->enemy))
@@ -293,6 +363,7 @@
 }
 
 static cached_soundindex sound_laser;
+static cached_soundindex sound_pew;
 
 constexpr vec3_t laser_positions[] = {
 	{ 125.0f, -70.f, 60.f },
@@ -301,29 +372,31 @@
 
 PRETHINK(guardian_fire_update) (edict_t *laser) -> void
 {
-	edict_t *self = laser->owner;
-
-	vec3_t forward, right, target;
-	vec3_t start;
-
-	AngleVectors(self->s.angles, forward, right, nullptr);
-	start = M_ProjectFlashSource(self, laser_positions[1 - (self->s.frame & 1)], forward, right);
-	target = self->enemy->s.origin + self->enemy->mins;
-	for (int i = 0; i < 3; i++)
-		target[i] += frandom() * self->enemy->size[i];
-	forward = target - start;
-	forward.normalize();
-
-	laser->s.origin = start;
-	laser->movedir = forward;
-	gi.linkentity(laser);
+	if (!laser->spawnflags.has(SPAWNFLAG_DABEAM_SPAWNED))
+	{
+		edict_t *self = laser->owner;
+
+		vec3_t forward, right, target;
+		vec3_t start;
+
+		AngleVectors(self->s.angles, forward, right, nullptr);
+		start = M_ProjectFlashSource(self, laser_positions[laser->spawnflags.has(SPAWNFLAG_DABEAM_SECONDARY) ? 1 : 0], forward, right);
+		PredictAim(self, self->enemy, start, 0, false, 0.3f, &forward, &target);
+
+		laser->s.origin = start;
+		forward[0] += crandom() * 0.02f;
+		forward[1] += crandom() * 0.02f;
+		forward.normalize();
+		laser->movedir = forward;
+		gi.linkentity(laser);
+	}
 	dabeam_update(laser, false);
 }
 
 void guardian_laser_fire(edict_t *self)
 {
 	gi.sound(self, CHAN_WEAPON, sound_laser, 1.f, ATTN_NORM, 0.f);
-	monster_fire_dabeam(self, 25, self->s.frame & 1, guardian_fire_update);
+	monster_fire_dabeam(self, 15, self->s.frame & 1, guardian_fire_update);
 }
 
 mframe_t guardian_frames_atk2_fire[] = {
@@ -357,40 +430,186 @@
 
 void guardian_kick(edict_t *self)
 {
-	if (!fire_hit(self, { MELEE_DISTANCE, 0, -80 }, 85, 700))
-		self->monsterinfo.melee_debounce_time = level.time + 1000_ms;
+	if (!fire_hit(self, { 160.f, 0, -80.f }, 85, 700))
+		self->monsterinfo.melee_debounce_time = level.time + 3500_ms;
 }
 
 mframe_t guardian_frames_kick[] = {
+	{ ai_charge, 12.f },
+	{ ai_charge, 18.f, guardian_footstep },
+	{ ai_charge, 11.f },
+	{ ai_charge, 9.f },
+	{ ai_charge, 8.f },
+	{ ai_charge, 0, guardian_kick },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
 	{ ai_charge },
 	{ ai_charge, 0, guardian_footstep },
 	{ ai_charge },
-	{ ai_charge },
-	{ ai_charge },
-	{ ai_charge, 0, guardian_kick },
-	{ ai_charge },
-	{ ai_charge },
-	{ ai_charge },
-	{ ai_charge },
-	{ ai_charge, 0, guardian_footstep },
-	{ ai_charge },
 	{ ai_charge }
 };
 MMOVE_T(guardian_move_kick) = { FRAME_kick_in1, FRAME_kick_in13, guardian_frames_kick, guardian_run };
 
+
+// RAFAEL
+/*
+fire_heat
+*/
+
+static void guardian_fire_rocket(edict_t *self, float offset)
+{
+	vec3_t forward, right, up;
+	vec3_t start;
+
+	AngleVectors(self->s.angles, forward, right, up);
+	start = self->s.origin;
+	start -= forward * 8.0f;
+	start += right * offset;
+	start += up * 50.f;
+
+	AngleVectors({ 20.0f, self->s.angles[1] - offset, 0.f }, forward, nullptr, nullptr);
+
+	fire_guardian_heat(self, start, up, forward, 20, 250, 150, 35, 0.085f);
+	gi.sound(self, CHAN_WEAPON, sound_pew, 1.f, 0.5f, 0.0f);
+}
+
+static void guardian_fire_rocket_l(edict_t *self)
+{
+	guardian_fire_rocket(self, -14.0f);
+}
+
+static void guardian_fire_rocket_r(edict_t *self)
+{
+	guardian_fire_rocket(self, 14.0f);
+}
+
+static void guardian_blind_fire_check(edict_t *self)
+{
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+	{
+		vec3_t aim = self->monsterinfo.blind_fire_target - self->s.origin;
+		self->ideal_yaw = vectoyaw(aim);
+	}
+}
+
+mframe_t guardian_frames_rocket[] = {
+	{ ai_charge, 0, guardian_blind_fire_check },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, guardian_fire_rocket_l },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, guardian_fire_rocket_r },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, guardian_fire_rocket_l },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, guardian_fire_rocket_r },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(guardian_move_rocket) = { FRAME_turnl_1, FRAME_turnr_11, guardian_frames_rocket, guardian_run };
+
 MONSTERINFO_ATTACK(guardian_attack) (edict_t *self) -> void
 {
 	if (!self->enemy || !self->enemy->inuse)
 		return;
 
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		float chance;
+
+		// setup shot probabilities
+		if (self->count == 0)
+			chance = 1.0;
+		else if (self->count <= 2)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		float r = frandom();
+
+		self->monsterinfo.blind_fire_delay += random_time(8.5_sec, 15.5_sec);
+
+		// don't shoot at the origin
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		// shot the rockets way too soon
+		if (self->count)
+		{
+			self->count--;
+			return;
+		}
+
+		// don't shoot if the dice say not to
+		if (r > chance)
+			return;
+
+		// turn on manual steering to signal both manual steering and blindfire
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+		M_SetAnimation(self, &guardian_move_rocket);
+		self->monsterinfo.attack_finished = level.time + random_time(3_sec);
+		return;
+	}
+	else if (self->bad_area)
+	{
+		M_SetAnimation(self, &guardian_move_atk1_in);
+		return;
+	}
+
 	float r = range_to(self, self->enemy);
-
-	if (r > RANGE_NEAR)
-		M_SetAnimation(self, &guardian_move_atk2_in);
-	else if (self->monsterinfo.melee_debounce_time < level.time && r < 120.f)
+	bool changedAttack = false;
+
+	if (self->monsterinfo.melee_debounce_time < level.time && r < 160.f)
+	{
 		M_SetAnimation(self, &guardian_move_kick);
-	else
+		changedAttack = true;
+		self->style = 0;
+	}
+	else if (r > 300.f && frandom() < (max(r, 1000.f) / 1200.f))
+	{
+		if (self->count <= 0 && frandom() * 0.25f)
+		{
+			M_SetAnimation(self, &guardian_move_rocket);
+			self->count = 6;
+			self->style = 0;
+			return;
+		}
+		else if (M_CheckClearShot(self, laser_positions[0]) && self->style != 1)
+		{
+			M_SetAnimation(self, &guardian_move_atk2_in);
+			self->style = 1;
+			changedAttack = true;
+
+			if (skill->integer >= 2)
+				self->monsterinfo.nextframe = FRAME_atk2_in8;
+		}
+		else if (M_CheckClearShot(self, monster_flash_offset[MZ2_GUARDIAN_BLASTER]))
+		{
+			M_SetAnimation(self, &guardian_move_atk1_in);
+			changedAttack = true;
+			self->style = 0;
+		}
+	}
+	else if (M_CheckClearShot(self, monster_flash_offset[MZ2_GUARDIAN_BLASTER]))
+	{
 		M_SetAnimation(self, &guardian_move_atk1_in);
+		changedAttack = true;
+		self->style = 0;
+	}
+
+	if (changedAttack && self->count)
+		self->count--;
 }
 
 //
@@ -465,23 +684,85 @@
 
 DIE(guardian_die) (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, const vec3_t &point, const mod_t &mod) -> void
 {
+	if (self->deadflag)
+		return;
+
 	// regular death
-	//gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
 	self->monsterinfo.weapon_sound = 0;
 	self->deadflag = true;
 	self->takedamage = true;
 
 	M_SetAnimation(self, &guardian_move_death);
-}
-
-//
-// monster_tank
+	gi.sound(self, CHAN_BODY, sound_death, 1.f, 0.1f, 0.0f);
+}
+
+void GuardianPowerArmor(edict_t *self)
+{
+	self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+	// I don't like this, but it works
+	if (self->monsterinfo.power_armor_power <= 0)
+		self->monsterinfo.power_armor_power += 200 * skill->integer;
+}
+
+void GuardianRespondPowerup(edict_t *self, edict_t *other)
+{
+	if (other->s.effects & (EF_QUAD | EF_DOUBLE | EF_DUALFIRE | EF_PENT))
+	{
+		GuardianPowerArmor(self);
+	}
+}
+
+static void GuardianPowerups(edict_t *self)
+{
+	edict_t *ent;
+
+	if (!coop->integer)
+	{
+		GuardianRespondPowerup(self, self->enemy);
+	}
+	else
+	{
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			GuardianRespondPowerup(self, ent);
+		}
+	}
+}
+
+MONSTERINFO_CHECKATTACK(Guardian_CheckAttack) (edict_t *self) -> bool
+{
+	if (!self->enemy)
+		return false;
+
+	GuardianPowerups(self);
+
+	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.6f, 0.7f, 0.85f, 0.f);
+}
+
+MONSTERINFO_SETSKIN(guardian_setskin) (edict_t *self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum = 1;
+	else
+		self->s.skinnum = 0;
+}
+
+
+//
+// monster_guardian
 //
 
 /*QUAKED monster_guardian (1 .5 0) (-96 -96 -66) (96 96 62) Ambush Trigger_Spawn Sight
  */
 void SP_monster_guardian(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -491,22 +772,33 @@
 	sound_charge.assign("weapons/hyprbu1a.wav");
 	sound_spin_loop.assign("weapons/hyprbl1a.wav");
 	sound_laser.assign("weapons/laser2.wav");
+	sound_pew.assign("makron/blaster.wav");
+	
+	sound_sight.assign("guardian/sight.wav");
+	sound_pain1.assign("guardian/pain1.wav");
+	sound_pain2.assign("guardian/pain2.wav");
+	sound_death.assign("guardian/death.wav");
 
 	for (auto &gib : gibs)
 		gi.modelindex(gib);
 
 	self->s.modelindex = gi.modelindex("models/monsters/guardian/tris.md2");
-	self->mins = { -96, -96, -66 };
-	self->maxs = { 96, 96, 62 };
+	self->mins = { -78, -78, -66 };
+	self->maxs = { 78, 78, 76 };
 	self->movetype = MOVETYPE_STEP;
 	self->solid = SOLID_BBOX;
 
 	self->health = 2500 * st.health_multiplier;
 	self->gib_health = -200;
 
+	if (skill->integer >= 3 || coop->integer)
+		self->health *= 2;
+	else if (skill->integer == 2)
+		self->health *= 1.5f;
+
 	self->monsterinfo.scale = MODEL_SCALE;
 
-	self->mass = 850;
+	self->mass = 1650;
 
 	self->pain = guardian_pain;
 	self->die = guardian_die;
@@ -514,10 +806,17 @@
 	self->monsterinfo.walk = guardian_walk;
 	self->monsterinfo.run = guardian_run;
 	self->monsterinfo.attack = guardian_attack;
+	self->monsterinfo.checkattack = Guardian_CheckAttack;
+	self->monsterinfo.setskin = guardian_setskin;
+
+	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
+	self->monsterinfo.blindfire = true;
 
 	gi.linkentity(self);
 
-	M_SetAnimation(self, &guardian_move_stand);
+	guardian_stand(self);
 
 	walkmonster_start(self);
-}
+
+	self->use = guardian_use;
+}
--- a/m_guncmdr.cpp	2023-10-03 19:43:06
+++ b/m_guncmdr.cpp	2025-09-04 19:53:48
@@ -1399,6 +1399,8 @@
 */
 void SP_monster_guncmdr(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_gunner.cpp	2023-10-03 19:43:06
+++ b/m_gunner.cpp	2025-09-04 19:53:48
@@ -284,10 +284,11 @@
 
 MONSTERINFO_SETSKIN(gunner_setskin) (edict_t *self) -> void
 {
+	/* KONIG - allow multiple skins */
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
+		self->s.skinnum |= 1;
 	else
-		self->s.skinnum = 0;
+		self->s.skinnum &= ~1;
 }
 
 void gunner_dead(edict_t *self)
@@ -853,6 +854,8 @@
 */
 void SP_monster_gunner(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- /dev/null
+++ b/m_hound.cpp	2025-09-04 19:53:48
@@ -0,0 +1,652 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+hound
+
+==============================================================================
+*/
+
+#include "g_local.h"
+#include "m_hound.h"
+
+constexpr spawnflags_t SPAWNFLAG_HOUND_NOJUMPING = 8_spawnflag;
+
+static cached_soundindex sound_pain1;
+static cached_soundindex sound_pain2;
+static cached_soundindex sound_die;
+static cached_soundindex sound_launch;
+static cached_soundindex sound_impact;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_search;
+static cached_soundindex sound_bite;
+static cached_soundindex sound_bitemiss;
+static cached_soundindex sound_jump;
+
+///
+/// SOUNDS
+/// 
+
+void hound_launch(edict_t* self)
+{
+	gi.sound(self, CHAN_WEAPON, sound_launch, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SIGHT(hound_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SEARCH(hound_search) (edict_t* self) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
+}
+
+//
+// STAND
+//
+
+mframe_t hound_frames_stand1[] = {
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},  // 10
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(hound_stand1) = { FRAME_idle401, FRAME_idle419, hound_frames_stand1, nullptr };
+
+mframe_t hound_frames_stand2[] = {
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, // 10
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, // 20
+
+	{ai_stand}
+};
+MMOVE_T(hound_stand2) = { FRAME_idle501, FRAME_idle521, hound_frames_stand2, nullptr };
+
+MONSTERINFO_STAND(hound_stand) (edict_t* self) -> void
+{
+	if (frandom() < 0.8f)
+	{
+		M_SetAnimation(self, &hound_stand1);
+	}
+	else
+	{
+		M_SetAnimation(self, &hound_stand2);
+	}
+}
+
+//
+// WALK
+//
+
+mframe_t hound_frames_walk[] =
+{
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7}
+};
+MMOVE_T(hound_move_walk) = { FRAME_walk01, FRAME_walk08, hound_frames_walk, nullptr };
+
+MONSTERINFO_WALK(hound_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &hound_move_walk);
+}
+
+
+//
+// RUN
+//
+
+mframe_t hound_frames_run[] =
+{
+	{ai_run, 60},
+	{ai_run, 60},
+	{ai_run, 40},
+	{ai_run, 30},
+	{ai_run, 30},
+	{ai_run, 30},
+	{ai_run, 40}
+};
+MMOVE_T(hound_move_run) = { FRAME_run01, FRAME_run07, hound_frames_run, nullptr };
+
+MONSTERINFO_RUN(hound_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		hound_stand(self);
+	else
+		M_SetAnimation(self, &hound_move_run);
+}
+
+//
+// MELEE
+//
+
+void hound_bite(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->maxs[0], 8 };
+	if (fire_hit(self, aim, irandom(1, 9), 100))
+		gi.sound(self, CHAN_WEAPON, sound_bite, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_bitemiss, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+void hound_bite2(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->maxs[0], 8 };
+	if (fire_hit(self, aim, irandom(1, 9), 100))
+		gi.sound(self, CHAN_WEAPON, sound_bite, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_bitemiss, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+mframe_t hound_frames_attack1[] =
+{
+	{ai_charge, 0,	hound_launch},
+	{ai_charge},
+	{ai_charge, 0,	hound_bite},
+	{ai_charge, 0,	hound_bite2}
+};
+MMOVE_T(hound_move_attack1) = { FRAME_attack101, FRAME_attack104, hound_frames_attack1, hound_run };
+
+mframe_t hound_frames_attack2[] =
+{
+	{ai_charge, 0,	hound_launch},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	hound_bite},
+	{ai_charge, 0,	hound_bite2},
+	{ai_charge, 0,	hound_bite2},
+	{ai_charge, 0,	hound_bite2},
+	{ai_charge},
+	{ai_charge},
+};
+MMOVE_T(hound_move_attack2) = { FRAME_attack201, FRAME_attack214, hound_frames_attack2, hound_run };
+
+MONSTERINFO_MELEE(hound_melee) (edict_t* self) -> void
+{
+	if (frandom() < 0.6f)
+	{
+		M_SetAnimation(self, &hound_move_attack1);
+	}
+	else
+	{
+		M_SetAnimation(self, &hound_move_attack2);
+	}
+}
+
+//
+// ATTACK
+//
+
+TOUCH(hound_jump_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (self->health <= 0)
+	{
+		self->touch = nullptr;
+		return;
+	}
+
+	if (self->style == 1 && other->takedamage)
+	{
+		if (self->velocity.length() > 400)
+		{
+			vec3_t	point;
+			vec3_t	normal;
+			int		damage;
+
+			normal = self->velocity;
+			normal.normalize();
+			point = self->s.origin + (normal * self->maxs[0]);
+			damage = (int)frandom(40, 50);
+			T_Damage(other, self, self, self->velocity, point, normal, damage, damage, DAMAGE_NONE, MOD_UNKNOWN);
+			self->style = 0;
+		}
+	}
+
+	if (!M_CheckBottom(self))
+	{
+		if (self->groundentity)
+		{
+			self->monsterinfo.nextframe = FRAME_leap04;
+			self->touch = nullptr;
+		}
+		return;
+	}
+
+	self->touch = nullptr;
+}
+
+void hound_jump_takeoff(edict_t* self)
+{
+	vec3_t	forward;
+
+	gi.sound(self, CHAN_VOICE, sound_jump, 1, ATTN_NORM, 0);
+	AngleVectors(self->s.angles, forward, nullptr, nullptr);
+	self->s.origin[2] += 1;
+	self->velocity = forward * 400;
+	self->velocity[2] = 200;
+	self->groundentity = nullptr;
+	self->monsterinfo.aiflags |= AI_DUCKED;
+	self->monsterinfo.attack_finished = level.time + 3_sec;
+	self->style = 1;
+	self->touch = hound_jump_touch;
+}
+
+void hound_check_landing(edict_t* self)
+{
+	monster_jump_finished(self);
+
+	if (self->groundentity)
+	{
+		gi.sound(self, CHAN_WEAPON, sound_impact, 1, ATTN_NORM, 0);
+		self->monsterinfo.attack_finished = level.time + random_time(500_ms, 1.5_sec);
+
+		if (self->monsterinfo.unduck)
+			self->monsterinfo.unduck(self);
+
+		if (range_to(self, self->enemy) <= RANGE_MELEE * 2.f)
+			self->monsterinfo.melee(self);
+
+		return;
+	}
+
+	if (level.time > self->monsterinfo.attack_finished)
+		self->monsterinfo.nextframe = FRAME_leap04;
+	else
+		self->monsterinfo.nextframe = FRAME_leap05;
+}
+
+void hound_check_landing2(edict_t* self)
+{
+	monster_jump_finished(self);
+
+	self->owner = nullptr;
+
+	if (self->groundentity)
+	{
+		gi.sound(self, CHAN_WEAPON, sound_impact, 1, ATTN_NORM, 0);
+		self->monsterinfo.attack_finished = level.time + random_time(500_ms, 1.5_sec);
+
+		if (self->monsterinfo.unduck)
+			self->monsterinfo.unduck(self);
+
+		if (range_to(self, self->enemy) <= RANGE_MELEE * 2.f)
+			self->monsterinfo.melee(self);
+
+		return;
+	}
+
+	if (level.time > self->monsterinfo.attack_finished)
+		self->monsterinfo.nextframe = FRAME_restrain14;
+	else
+		self->monsterinfo.nextframe = FRAME_restrain15;
+}
+
+mframe_t hound_frames_handlerjump[] =
+{
+	{ai_charge,  0},
+	{ai_charge,  20,	hound_jump_takeoff},
+	{ai_move,  40},
+	{ai_move,  30,	hound_check_landing2},
+	{ai_move,   0},
+	{ai_move,  0},
+	{ai_move,  0},
+};
+MMOVE_T(hound_move_handlerjump) = { FRAME_restrain12, FRAME_restrain18, hound_frames_handlerjump, hound_run };
+
+mframe_t hound_frames_jump[] =
+{
+	{ai_charge,	20},
+	{ai_charge,	20,	hound_jump_takeoff},
+	{ai_move,	40},
+	{ai_move,	30,	hound_check_landing},
+	{ai_move,	 0},
+	{ai_move,	 0},
+	{ai_move,	 0}
+};
+MMOVE_T(hound_move_jump) = { FRAME_leap01, FRAME_leap07, hound_frames_jump, hound_run };
+
+MONSTERINFO_ATTACK(hound_jump) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &hound_move_jump);
+}
+
+//
+// CHECKATTACK
+//
+
+bool hound_check_melee(edict_t* self)
+{
+	return range_to(self, self->enemy) <= RANGE_MELEE && self->monsterinfo.melee_debounce_time <= level.time;
+}
+
+bool hound_check_jump(edict_t* self)
+{
+	vec3_t	v;
+	float	distance;
+
+	if (self->absmin[2] > (self->enemy->absmin[2] + 0.75 * self->enemy->size[2]))
+		return false;
+
+	if (self->absmax[2] < (self->enemy->absmin[2] + 0.25 * self->enemy->size[2]))
+		return false;
+
+	v[0] = self->s.origin[0] - self->enemy->s.origin[0];
+	v[1] = self->s.origin[1] - self->enemy->s.origin[1];
+	v[2] = 0;
+	distance = v.length();
+
+	if (distance < 100 && self->monsterinfo.melee_debounce_time <= level.time)
+		return false;
+	if (distance > 100)
+	{
+		if (frandom() < 0.9f)
+			return false;
+	}
+
+	return true;
+}
+
+MONSTERINFO_CHECKATTACK(hound_checkattack) (edict_t* self) -> bool
+{
+	if (!self->enemy || self->enemy->health <= 0)
+		return false;
+
+	if (hound_check_melee(self))
+	{
+		self->monsterinfo.attack_state = AS_MELEE;
+		return true;
+	}
+
+	if (!self->spawnflags.has(SPAWNFLAG_HOUND_NOJUMPING) && hound_check_jump(self))
+	{
+		self->monsterinfo.attack_state = AS_MISSILE;
+		return true;
+	}
+
+	return false;
+}
+
+//
+// PAIN
+//
+
+mframe_t hound_frames_pain1[] =
+{
+	{ai_move,  6},
+	{ai_move, 16},
+	{ai_move, -6},
+	{ai_move, -7}
+};
+MMOVE_T(hound_move_pain1) = { FRAME_pain101, FRAME_pain104, hound_frames_pain1, hound_run };
+
+mframe_t hound_frames_pain2[] =
+{
+	{ai_move,  0},
+	{ai_move,  0},
+	{ai_move,  0},
+	{ai_move,  6},
+	{ai_move, 16},
+	{ai_move, -6},
+	{ai_move, -7},
+	{ai_move,  0}
+};
+MMOVE_T(hound_move_pain2) = { FRAME_pain201, FRAME_pain208, hound_frames_pain2, hound_run };
+
+PAIN(hound_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	float r;
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	r = frandom();
+	if (r < 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	if (r < 0.5f)
+		M_SetAnimation(self, &hound_move_pain1);
+	else
+		M_SetAnimation(self, &hound_move_pain2);
+}
+
+MONSTERINFO_SETSKIN(hound_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// DEATH
+//
+
+void hound_shrink(edict_t* self)
+{
+	self->maxs[2] = 0;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t hound_frames_death[] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0, hound_shrink},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(hound_move_death) = { FRAME_death01, FRAME_death11, hound_frames_death, monster_dead };
+
+DIE(hound_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 4, "models/objects/gibs/sm_meat/tris.md2" },
+			//{ "models/monsters/guard/hound/gibs/chest.md2", GIB_SKINNED },
+			{ "models/objects/gibs/chest/tris.md2" },
+			//{ "models/monsters/guard/hound/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			{ "models/monsters/gibs/sm_meat/head.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+	M_SetAnimation(self, &hound_move_death);
+}
+
+void SP_monster_hound_precache()
+{
+	sound_pain1.assign("monsters/hound/hpain1.wav");
+	sound_pain2.assign("monsters/hound/hpain2.wav");
+	sound_die.assign("monsters/hound/hdeth1.wav");
+	sound_launch.assign("monsters/hound/hlaunch.wav");
+	sound_impact.assign("monsters/hound/himpact.wav");
+	sound_sight.assign("monsters/hound/hsight1.wav");
+	sound_search.assign("monsters/hound/hsearch1.wav");
+	sound_jump.assign("monsters/hound/hjump.wav");
+	sound_bite.assign("monsters/hound/hbite1.wav");
+	sound_bitemiss.assign("monsters/hound/hbite2.wav");
+
+	gi.modelindex("models/monsters/guard/hound/tris.md2");
+}
+
+/*QUAKED monster_hound (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+*/
+void SP_monster_hound(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_hound_precache();
+
+	self->monsterinfo.aiflags |= AI_STINKY;
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex("models/monsters/guard/hound/tris.md2");
+
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 24 };
+
+	self->health = 100 * st.health_multiplier;
+	self->gib_health = -75;
+	self->mass = 250;
+
+	self->pain = hound_pain;
+	self->die = hound_die;
+
+	self->monsterinfo.stand = hound_stand;
+	self->monsterinfo.walk = hound_walk;
+	self->monsterinfo.run = hound_run;
+	self->monsterinfo.dodge = nullptr;
+	self->monsterinfo.attack = hound_jump;
+	self->monsterinfo.melee = hound_melee;
+	self->monsterinfo.sight = hound_sight;
+	self->monsterinfo.search = hound_search;
+	self->monsterinfo.checkattack = hound_checkattack;
+	self->monsterinfo.blocked = nullptr;
+	self->monsterinfo.setskin = hound_setskin;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &hound_stand1);
+
+	self->monsterinfo.combat_style = COMBAT_MELEE;
+
+	self->monsterinfo.scale = MODEL_SCALE;
+	self->monsterinfo.can_jump = !(self->spawnflags & SPAWNFLAG_HOUND_NOJUMPING);
+	self->monsterinfo.drop_height = 256;
+	self->monsterinfo.jump_height = 68;
+
+	walkmonster_start(self);
+}
+
+THINK(HoundSpawn) (edict_t* self) -> void
+{
+	vec3_t	 vec;
+	edict_t* player;
+
+	SP_monster_hound(self);
+	self->think(self);
+
+	// jump at player
+	if (self->enemy && self->enemy->inuse && self->enemy->health > 0)
+		player = self->enemy;
+	else
+		player = AI_GetSightClient(self);
+
+	if (!player)
+		return;
+
+	vec = player->s.origin - self->s.origin;
+	self->s.angles[YAW] = vectoyaw(vec);
+	vec.normalize();
+	self->velocity = vec * 200;
+	self->velocity[2] = 400;
+	self->groundentity = nullptr;
+	self->enemy = player;
+	FoundTarget(self);
+	self->monsterinfo.sight(self, self->enemy);
+	self->s.frame = self->monsterinfo.nextframe = FRAME_restrain12;
+}
+
+void hound_createHound(edict_t* self, float healthPercent)
+{
+	edict_t* ent = G_Spawn();
+	ent->classname = "monster_hound";
+	ent->target = self->target;
+	ent->s.origin = self->s.origin;
+	ent->enemy = self->enemy;
+
+	ent->health *= healthPercent;
+
+	HoundSpawn(ent);
+
+	// [Paril-KEX] set health bar over to Makron when we throw him out
+	for (size_t i = 0; i < 2; i++)
+		if (level.health_bar_entities[i] && level.health_bar_entities[i]->enemy == self)
+			level.health_bar_entities[i]->enemy = ent;
+}
--- /dev/null
+++ b/m_hound.h	2025-09-04 19:53:48
@@ -0,0 +1,242 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+// G:/quake2/baseq2/models/monsters/mutant
+
+enum
+{
+	FRAME_idle101,
+	FRAME_idle102,
+	FRAME_idle103,
+	FRAME_idle104,
+	FRAME_idle105,
+	FRAME_idle106,
+	FRAME_idle107,
+	FRAME_idle108,
+	FRAME_idle109,
+	FRAME_idle110,
+	FRAME_idle111,
+	FRAME_idle112,
+	FRAME_idle113,
+	FRAME_idle114,
+	FRAME_idle115,
+	FRAME_idle116,
+	FRAME_idle117,
+	FRAME_idle118,
+	FRAME_idle119,
+	FRAME_idle120,
+	FRAME_idle121,
+	FRAME_idle122,
+	FRAME_idle123,
+	FRAME_idle124,
+	FRAME_idle125,
+	FRAME_idle126,
+	FRAME_idle127,
+	FRAME_idle128,
+	FRAME_idle129,
+	FRAME_idle130,
+	FRAME_idle131,
+	FRAME_idle201,
+	FRAME_idle202,
+	FRAME_idle203,
+	FRAME_idle204,
+	FRAME_idle205,
+	FRAME_idle206,
+	FRAME_idle207,
+	FRAME_idle208,
+	FRAME_idle209,
+	FRAME_idle210,
+	FRAME_idle211,
+	FRAME_idle212,
+	FRAME_idle213,
+	FRAME_idle214,
+	FRAME_idle215,
+	FRAME_idle216,
+	FRAME_idle217,
+	FRAME_idle218,
+	FRAME_idle219,
+	FRAME_idle220,
+	FRAME_idle221,
+	FRAME_idle222,
+	FRAME_idle223,
+	FRAME_idle224,
+	FRAME_idle225,
+	FRAME_idle226,
+	FRAME_idle227,
+	FRAME_idle228,
+	FRAME_idle229,
+	FRAME_idle301,
+	FRAME_idle302,
+	FRAME_idle303,
+	FRAME_idle304,
+	FRAME_idle305,
+	FRAME_idle306,
+	FRAME_idle307,
+	FRAME_idle308,
+	FRAME_idle309,
+	FRAME_idle310,
+	FRAME_idle311,
+	FRAME_idle312,
+	FRAME_idle313,
+	FRAME_idle314,
+	FRAME_idle315,
+	FRAME_idle316,
+	FRAME_idle317,
+	FRAME_idle318,
+	FRAME_idle319,
+	FRAME_idle320,
+	FRAME_idle321,
+	FRAME_idle322,
+	FRAME_idle323,
+	FRAME_idle324,
+	FRAME_idle325,
+	FRAME_idle326,
+	FRAME_idle327,
+	FRAME_idle328,
+	FRAME_idle329,
+	FRAME_idle330,
+	FRAME_stand01,
+	FRAME_stand02,
+	FRAME_stand03,
+	FRAME_stand04,
+	FRAME_stand05,
+	FRAME_stand06,
+	FRAME_stand07,
+	FRAME_stand08,
+	FRAME_stand09,
+	FRAME_stand10,
+	FRAME_stand11,
+	FRAME_sit01,
+	FRAME_sit02,
+	FRAME_sit03,
+	FRAME_sit04,
+	FRAME_sit05,
+	FRAME_sit06,
+	FRAME_sit07,
+	FRAME_sit08,
+	FRAME_sit09,
+	FRAME_sit10,
+	FRAME_restrain01,
+	FRAME_restrain02,
+	FRAME_restrain03,
+	FRAME_restrain04,
+	FRAME_restrain05,
+	FRAME_restrain06,
+	FRAME_restrain07,
+	FRAME_restrain08,
+	FRAME_restrain09,
+	FRAME_restrain10,
+	FRAME_restrain11,
+	FRAME_restrain12,
+	FRAME_restrain13,
+	FRAME_restrain14,
+	FRAME_restrain15,
+	FRAME_restrain16,
+	FRAME_restrain17,
+	FRAME_restrain18,
+	FRAME_idle401,
+	FRAME_idle402,
+	FRAME_idle403,
+	FRAME_idle404,
+	FRAME_idle405,
+	FRAME_idle406,
+	FRAME_idle407,
+	FRAME_idle408,
+	FRAME_idle409,
+	FRAME_idle410,
+	FRAME_idle411,
+	FRAME_idle412,
+	FRAME_idle413,
+	FRAME_idle414,
+	FRAME_idle415,
+	FRAME_idle416,
+	FRAME_idle417,
+	FRAME_idle418,
+	FRAME_idle419,
+	FRAME_idle501,
+	FRAME_idle502,
+	FRAME_idle503,
+	FRAME_idle504,
+	FRAME_idle505,
+	FRAME_idle506,
+	FRAME_idle507,
+	FRAME_idle508,
+	FRAME_idle509,
+	FRAME_idle510,
+	FRAME_idle511,
+	FRAME_idle512,
+	FRAME_idle513,
+	FRAME_idle514,
+	FRAME_idle515,
+	FRAME_idle516,
+	FRAME_idle517,
+	FRAME_idle518,
+	FRAME_idle519,
+	FRAME_idle520,
+	FRAME_idle521,
+	FRAME_walk01,
+	FRAME_walk02,
+	FRAME_walk03,
+	FRAME_walk04,
+	FRAME_walk05,
+	FRAME_walk06,
+	FRAME_walk07,
+	FRAME_walk08,
+	FRAME_run01,
+	FRAME_run02,
+	FRAME_run03,
+	FRAME_run04,
+	FRAME_run05,
+	FRAME_run06,
+	FRAME_run07,
+	FRAME_leap01,
+	FRAME_leap02,
+	FRAME_leap03,
+	FRAME_leap04,
+	FRAME_leap05,
+	FRAME_leap06,
+	FRAME_leap07,
+	FRAME_attack101,
+	FRAME_attack102,
+	FRAME_attack103,
+	FRAME_attack104,
+	FRAME_attack201,
+	FRAME_attack202,
+	FRAME_attack203,
+	FRAME_attack204,
+	FRAME_attack205,
+	FRAME_attack206,
+	FRAME_attack207,
+	FRAME_attack208,
+	FRAME_attack209,
+	FRAME_attack210,
+	FRAME_attack211,
+	FRAME_attack212,
+	FRAME_attack213,
+	FRAME_attack214,
+	FRAME_pain101,
+	FRAME_pain102,
+	FRAME_pain103,
+	FRAME_pain104,
+	FRAME_pain201,
+	FRAME_pain202,
+	FRAME_pain203,
+	FRAME_pain204,
+	FRAME_pain205,
+	FRAME_pain206,
+	FRAME_pain207,
+	FRAME_pain208,
+	FRAME_death01,
+	FRAME_death02,
+	FRAME_death03,
+	FRAME_death04,
+	FRAME_death05,
+	FRAME_death06,
+	FRAME_death07,
+	FRAME_death08,
+	FRAME_death09,
+	FRAME_death10,
+	FRAME_death11,
+	FRAME_death12
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- a/m_hover.cpp	2023-10-03 19:43:06
+++ b/m_hover.cpp	2025-09-04 19:53:48
@@ -401,7 +401,8 @@
 	if (self->mass < 200)
 		monster_fire_blaster(self, start, dir, 1, 1000, (self->s.frame & 1) ? MZ2_HOVER_BLASTER_2 : MZ2_HOVER_BLASTER_1, (self->s.frame % 4) ? EF_NONE : EF_HYPERBLASTER);
 	else
-		monster_fire_blaster2(self, start, dir, 1, 1000, (self->s.frame & 1) ? MZ2_DAEDALUS_BLASTER_2 : MZ2_DAEDALUS_BLASTER, (self->s.frame % 4) ? EF_NONE : EF_BLASTER);
+		/* KONIG - reduced health by 25, increased damage by 3 per shot */
+		monster_fire_blaster2(self, start, dir, 3, 1000, (self->s.frame & 1) ? MZ2_DAEDALUS_BLASTER_2 : MZ2_DAEDALUS_BLASTER, (self->s.frame % 4) ? EF_NONE : EF_BLASTER);
 	// PGM
 }
 
@@ -506,9 +507,9 @@
 MONSTERINFO_SETSKIN(hover_setskin) (edict_t *self) -> void
 {
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum |= 1; // PGM support for skins 2 & 3.
-	else
-		self->s.skinnum &= ~1; // PGM support for skins 2 & 3.
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 void hover_dead(edict_t *self)
@@ -564,8 +565,8 @@
 	self->monsterinfo.fly_speed = 120.f;
 	// Icarus prefers to keep its distance, but flies slower than the flyer.
 	// he never pins because of this.
-	self->monsterinfo.fly_min_distance = 150.f;
-	self->monsterinfo.fly_max_distance = 350.f;
+	self->monsterinfo.fly_min_distance = 250.f;
+	self->monsterinfo.fly_max_distance = 450.f;
 }
 
 /*QUAKED monster_hover (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
@@ -575,6 +576,8 @@
 */
 void SP_monster_hover(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -610,7 +613,8 @@
 	// PGM
 	if (strcmp(self->classname, "monster_daedalus") == 0)
 	{
-		self->health = 450 * st.health_multiplier;
+		/* KONIG - reduced health by 25, increased damage by 3 per shot */
+		self->health = 425 * st.health_multiplier;
 		self->mass = 225;
 		self->yaw_speed = 23;
 		if (!st.was_key_specified("power_armor_type"))
--- a/m_infantry.cpp	2023-10-03 19:43:06
+++ b/m_infantry.cpp	2025-09-04 19:53:48
@@ -29,6 +29,10 @@
 
 // range at which we'll try to initiate a run-attack to close distance
 constexpr float RANGE_RUN_ATTACK = RANGE_NEAR * 0.75f;
+
+/* KONIG - new spawnflag for Handler*/
+constexpr spawnflags_t SPAWNFLAG_INFANTRY_NOJUMPING = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_INFANTRY_HANDLER = 32_spawnflag;
 
 mframe_t infantry_frames_stand[] = {
 	{ ai_stand },
@@ -248,10 +252,11 @@
 
 MONSTERINFO_SETSKIN(infantry_setskin) (edict_t *self) -> void
 {
+	/* KONIG - allow multiple skins */
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
-	else
-		self->s.skinnum = 0;
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 constexpr vec3_t aimangles[] = {
@@ -310,7 +315,21 @@
 		AngleVectors(vec, forward, nullptr, nullptr);
 	}
 
-	monster_fire_bullet(self, start, forward, 3, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
+	/* KONIG - Unseen and SMD inspired variants */
+	if (self->spawnflags.has(SPAWNFLAG_INFANTRY_HANDLER))
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("guncmdr/gcdratck2.wav"), 1, ATTN_NORM, 0);
+		monster_fire_flechette(self, start, forward, 4, 750, flash_number);
+	}
+	else if (strcmp(self->classname, "monster_heavy") == 0) /* KONIG - TO DO: swap with hellfury rockets*/
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("chick/chkatck2.wav"), 1, ATTN_NORM, 0);
+		monster_fire_rocket(self, start, forward, 5, 800, flash_number);
+	}
+	else
+	{
+		monster_fire_bullet(self, start, forward, 3, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
+	}
 }
 
 MONSTERINFO_SIGHT(infantry_sight) (edict_t *self, edict_t *other) -> void
@@ -863,12 +882,12 @@
 	sound_idle.assign("infantry/infidle1.wav");
 }
 
-constexpr spawnflags_t SPAWNFLAG_INFANTRY_NOJUMPING = 8_spawnflag;
-
 /*QUAKED monster_infantry (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping
  */
 void SP_monster_infantry(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -891,9 +910,36 @@
 	self->mins = { -16, -16, -24 };
 	self->maxs = { 16, 16, 32 };
 
-	self->health = 100 * st.health_multiplier;
-	self->gib_health = -65;
-	self->mass = 200;
+	/* KONIG - altered health/mass/armor for heavy, skin for handler*/
+	if (strcmp(self->classname, "monster_infantry_handler") == 0)
+	{
+		self->s.skinnum = 2;
+		self->health = 100 * st.health_multiplier;
+		self->gib_health = -65;
+		self->mass = 200;
+	}
+	else if (strcmp(self->classname, "monster_heavy") == 0)
+	{
+		self->s.skinnum = 4;
+		self->health = 120 * st.health_multiplier;
+		self->gib_health = -65;
+
+		if (!self->s.scale)
+			self->s.scale = 1.25f;
+		self->mass = 250;
+
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = 100;
+	}
+	else
+	{
+		self->s.skinnum = 0;
+		self->health = 100 * st.health_multiplier;
+		self->gib_health = -65;
+		self->mass = 200;
+	}
 
 	self->pain = infantry_pain;
 	self->die = infantry_die;
@@ -926,3 +972,43 @@
 
 	walkmonster_start(self);
 }
+
+
+/* KONIG - Zaero handler function change and Unseen's Heavy */
+/*QUAKED monster_infantry_handler (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping
+ */
+void SP_monster_infantry_handler(edict_t* self)
+{
+	SP_monster_infantry(self);
+
+	self->spawnflags |= SPAWNFLAG_INFANTRY_HANDLER; //Lazarus compat?
+}
+
+/*QUAKED monster_heavy (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping
+ */
+void SP_monster_heavy(edict_t* self)
+{
+	SP_monster_infantry(self);
+
+	self->s.skinnum = 4;
+	sound_gunshot.assign("chick/chkatck2.wav");
+}
+
+//ZAERO - handler to infantry
+void handler_ConvertToInfantry(edict_t* self)
+{
+	SP_monster_infantry_handler(self);
+
+	self->s.origin[0] -= 18;
+	self->s.origin[1] -= 9;
+
+	self->s.skinnum = 2;
+	self->s.frame = FRAME_run01;
+
+	infantry_run(self);
+
+	// [Paril-KEX] set health bar over to Makron when we throw him out
+	for (size_t i = 0; i < 2; i++)
+		if (level.health_bar_entities[i] && level.health_bar_entities[i]->enemy == self)
+			level.health_bar_entities[i]->enemy = self;
+}
--- a/m_insane.cpp	2023-10-03 19:43:06
+++ b/m_insane.cpp	2025-09-04 19:53:48
@@ -620,6 +620,8 @@
  */
 void SP_misc_insane(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	//	static int skin = 0;	//@@
 
 	if ( !M_AllowSpawn( self ) ) {
@@ -683,7 +685,7 @@
 	if (self->spawnflags.has(SPAWNFLAG_INSANE_CRUCIFIED)) // Crucified ?
 	{
 		self->flags |= FL_NO_KNOCKBACK | FL_STATIONARY;
-		stationarymonster_start(self);
+		stationarymonster_start(self, st);
 	}
 	else
 		walkmonster_start(self);
--- a/m_medic.cpp	2023-10-03 19:43:06
+++ b/m_medic.cpp	2025-09-04 19:53:48
@@ -27,7 +27,6 @@
 void M_SetEffects(edict_t *ent);
 bool FindTarget(edict_t *self);
 void FoundTarget(edict_t *self);
-void ED_CallSpawn(edict_t *ent);
 
 static cached_soundindex sound_idle1;
 static cached_soundindex sound_pain1;
@@ -77,7 +76,7 @@
 }
 
 // pick an array of reinforcements to use; note that this does not modify `self`
-std::array<uint8_t, MAX_REINFORCEMENTS> M_PickReinforcements(edict_t *self, int32_t &num_chosen, int32_t max_slots = 0)
+std::array<uint8_t, MAX_REINFORCEMENTS> M_PickReinforcements(edict_t *self, int32_t &num_chosen, int32_t max_slots)
 {
 	static std::vector<uint8_t> available;
 	std::array<uint8_t, MAX_REINFORCEMENTS> chosen;
@@ -134,8 +133,6 @@
 	const char *p = reinforcements;
 	reinforcement_t *r = list.reinforcements;
 
-	st = {};
-
 	while (true)
 	{
 		const char *token = COM_ParseEx(&p, "; ");
@@ -166,12 +163,8 @@
 	}
 }
 
-void cleanupHeal(edict_t *self, bool change_frame)
-{
-	// clean up target, if we have one and it's legit
-	if (self->enemy && self->enemy->inuse)
-		cleanupHealTarget(self->enemy);
-
+void fixHealerEnemy(edict_t *self)
+{
 	if (self->oldenemy && self->oldenemy->inuse && self->oldenemy->health > 0)
 	{
 		self->enemy = self->oldenemy;
@@ -185,21 +178,26 @@
 		{
 			// no valid enemy, so stop acting
 			self->monsterinfo.pausetime = HOLD_FOREVER;
-			self->monsterinfo.stand(self);
 			return;
 		}
 	}
-
-	if (change_frame)
-		self->monsterinfo.nextframe = FRAME_attack52;
-}
-
-void abortHeal(edict_t *self, bool change_frame, bool gib, bool mark)
+}
+
+void cleanupHeal(edict_t *self)
+{
+	// clean up target, if we have one and it's legit
+	if (self->enemy && self->enemy->inuse && !self->enemy->client && (self->monsterinfo.aiflags & AI_MEDIC))
+		cleanupHealTarget(self->enemy);
+
+	fixHealerEnemy(self);
+}
+
+void abortHeal(edict_t *self, bool gib, bool mark)
 {
 	int				 hurt;
 	constexpr vec3_t pain_normal = { 0, 0, 1 };
 
-	if (self->enemy && self->enemy->inuse)
+	if (self->enemy && self->enemy->inuse && !self->enemy->client && (self->monsterinfo.aiflags & AI_MEDIC))
 	{
 		cleanupHealTarget(self->enemy);
 
@@ -219,22 +217,122 @@
 
 		if (gib)
 		{
+			// [Paril-KEX] health added in case of weird edge case
+			// with fixbot "healing" the corpses
 			if (self->enemy->gib_health)
-				hurt = -self->enemy->gib_health;
+				hurt = -self->enemy->gib_health + max(0, self->enemy->health);
 			else
 				hurt = 500;
 
 			T_Damage(self->enemy, self, self, vec3_origin, self->enemy->s.origin,
 					 pain_normal, hurt, 0, DAMAGE_NONE, MOD_UNKNOWN);
 		}
-	}
-	// clean up self
-
-	// clean up target
-	cleanupHeal(self, change_frame);
+
+		cleanupHeal(self);
+	}
 
 	self->monsterinfo.aiflags &= ~AI_MEDIC;
 	self->monsterinfo.medicTries = 0;
+}
+
+bool finishHeal(edict_t *self)
+{
+	edict_t *healee = self->enemy;
+
+	healee->spawnflags = SPAWNFLAG_NONE;
+	healee->monsterinfo.aiflags &= AI_RESPAWN_MASK;
+	healee->target = nullptr;
+	healee->targetname = nullptr;
+	healee->combattarget = nullptr;
+	healee->deathtarget = nullptr;
+	healee->healthtarget = nullptr;
+	healee->itemtarget = nullptr;
+	healee->monsterinfo.healer = self;
+
+	vec3_t maxs = healee->maxs;
+	maxs[2] += 48; // compensate for change when they die
+
+	trace_t tr = gi.trace(healee->s.origin, healee->mins, maxs, healee->s.origin, healee, MASK_MONSTERSOLID);
+
+	if (tr.startsolid || tr.allsolid)
+	{
+		abortHeal(self, true, false);
+		return false;
+	}
+	else if (tr.ent != world)
+	{
+		abortHeal(self, true, false);
+		return false;
+	}
+
+	healee->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT;
+
+	// backup & restore health stuff, because of multipliers
+	int32_t old_max_health = healee->max_health;
+	item_id_t old_power_armor_type = healee->monsterinfo.initial_power_armor_type;
+	int32_t old_power_armor_power = healee->monsterinfo.max_power_armor_power;
+	int32_t old_base_health = healee->monsterinfo.base_health;
+	int32_t old_health_scaling = healee->monsterinfo.health_scaling;
+	auto reinforcements = healee->monsterinfo.reinforcements;
+	int32_t slots_from_commander = healee->monsterinfo.slots_from_commander;
+	int32_t monster_slots = healee->monsterinfo.monster_slots;
+	int32_t monster_used = healee->monsterinfo.monster_used;
+	int32_t old_gib_health = healee->gib_health;
+
+	spawn_temp_t st {};
+	st.keys_specified.emplace("reinforcements");
+	st.reinforcements = "";
+
+	ED_CallSpawn(healee, st);
+
+	healee->monsterinfo.slots_from_commander = slots_from_commander;
+	healee->monsterinfo.reinforcements = reinforcements;
+	healee->monsterinfo.monster_slots = monster_slots;
+	healee->monsterinfo.monster_used = monster_used;
+
+	healee->gib_health = old_gib_health / 2;
+	healee->health = healee->max_health = old_max_health;
+	healee->monsterinfo.power_armor_power = healee->monsterinfo.max_power_armor_power = old_power_armor_power;
+	healee->monsterinfo.power_armor_type = healee->monsterinfo.initial_power_armor_type = old_power_armor_type;
+	healee->monsterinfo.base_health = old_base_health;
+	healee->monsterinfo.health_scaling = old_health_scaling;
+
+	if (healee->monsterinfo.setskin)
+		healee->monsterinfo.setskin(healee);
+
+	if (healee->think)
+	{
+		healee->nextthink = level.time;
+		healee->think(healee);
+	}
+	healee->monsterinfo.aiflags &= ~AI_RESURRECTING;
+	healee->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT;
+	// turn off flies
+	healee->s.effects &= ~EF_FLIES;
+	healee->monsterinfo.healer = nullptr;
+
+	// switch our enemy
+	fixHealerEnemy(self);
+
+	// switch revivee's enemy
+	healee->oldenemy = nullptr;
+	healee->enemy = self->enemy;
+
+	if (healee->enemy)
+		FoundTarget(healee);
+	else
+	{
+		healee->enemy = nullptr;
+		if (!FindTarget(healee))
+		{
+			// no valid enemy, so stop acting
+			healee->monsterinfo.pausetime = HOLD_FOREVER;
+			healee->monsterinfo.stand(healee);
+		}
+	}
+
+	cleanupHeal(self);
+	return true;
 }
 
 bool canReach(edict_t *self, edict_t *other)
@@ -251,19 +349,10 @@
 	return trace.fraction == 1.0f || trace.ent == other;
 }
 
-edict_t *medic_FindDeadMonster(edict_t *self)
-{
-	float	 radius;
+edict_t *healFindMonster(edict_t *self, float radius)
+{
 	edict_t *ent = nullptr;
 	edict_t *best = nullptr;
-
-	if (self->monsterinfo.react_to_damage_time > level.time)
-		return nullptr;
-
-	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
-		radius = MEDIC_MAX_HEAL_DISTANCE;
-	else
-		radius = 1024;
 
 	while ((ent = findradius(ent, self->s.origin, radius)) != nullptr)
 	{
@@ -305,6 +394,23 @@
 		best = ent;
 	}
 
+	return best;
+}
+
+edict_t *medic_FindDeadMonster(edict_t *self)
+{
+	float	 radius;
+
+	if (self->monsterinfo.react_to_damage_time > level.time)
+		return nullptr;
+
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		radius = MEDIC_MAX_HEAL_DISTANCE;
+	else
+		radius = 1024;
+
+	edict_t *best = healFindMonster(self, radius);
+
 	if (best)
 		self->timestamp = level.time + MEDIC_TRY_TIME;
 
@@ -603,7 +709,7 @@
 	if (self->monsterinfo.aiflags & AI_DUCKED)
 		monster_duck_up(self);
 
-	abortHeal(self, false, false, false);
+	abortHeal(self, false, false);
 }
 
 MONSTERINFO_SETSKIN(medic_setskin) (edict_t *self) -> void
@@ -855,7 +961,7 @@
 
 	if ((!self->enemy) || (!self->enemy->inuse) || (self->enemy->s.effects & EF_GIB))
 	{
-		abortHeal(self, false, false, false);
+		abortHeal(self, false, false);
 		return;
 	}
 
@@ -867,7 +973,7 @@
 	// abort it .. we got switched to someone else due to damage
 	if (self->enemy->health > 0)
 	{
-		abortHeal(self, false, false, false);
+		abortHeal(self, false, false);
 		return;
 	}
 
@@ -882,7 +988,8 @@
 	distance = dir.length();
 	if (distance < MEDIC_MIN_DISTANCE)
 	{
-		abortHeal(self, true, true, false);
+		abortHeal(self, true, false);
+		self->monsterinfo.nextframe = FRAME_attack52;
 		return;
 	}
 
@@ -894,14 +1001,17 @@
 			// give up on second try
 			if (self->monsterinfo.medicTries > 1)
 			{
-				abortHeal(self, true, false, true);
+				abortHeal(self, false, true);
+				self->monsterinfo.nextframe = FRAME_attack52;
 				return;
 			}
 			self->monsterinfo.medicTries++;
-			cleanupHeal(self, 1);
+			cleanupHeal(self);
+			self->monsterinfo.nextframe = FRAME_attack52;
 			return;
 		}
-		abortHeal(self, true, false, false);
+		abortHeal(self, false, false);
+		self->monsterinfo.nextframe = FRAME_attack52;
 		return;
 	}
 
@@ -919,106 +1029,10 @@
 	}
 	else if (self->s.frame == FRAME_attack50)
 	{
-		vec3_t maxs;
-		self->enemy->spawnflags = SPAWNFLAG_NONE;
-		self->enemy->monsterinfo.aiflags &= AI_STINKY | AI_SPAWNED_MASK;
-		self->enemy->target = nullptr;
-		self->enemy->targetname = nullptr;
-		self->enemy->combattarget = nullptr;
-		self->enemy->deathtarget = nullptr;
-		self->enemy->healthtarget = nullptr;
-		self->enemy->itemtarget = nullptr;
-		self->enemy->monsterinfo.healer = self;
-
-		maxs = self->enemy->maxs;
-		maxs[2] += 48; // compensate for change when they die
-
-		tr = gi.trace(self->enemy->s.origin, self->enemy->mins, maxs, self->enemy->s.origin, self->enemy, MASK_MONSTERSOLID);
-
-		if (tr.startsolid || tr.allsolid)
-		{
-			abortHeal(self, true, true, false);
-			return;
-		}
-		else if (tr.ent != world)
-		{
-			abortHeal(self, true, true, false);
-			return;
-		}
-		else
-		{
-			self->enemy->monsterinfo.aiflags |= AI_DO_NOT_COUNT;
-
-			// backup & restore health stuff, because of multipliers
-			int32_t old_max_health = self->enemy->max_health;
-			item_id_t old_power_armor_type = self->enemy->monsterinfo.initial_power_armor_type;
-			int32_t old_power_armor_power = self->enemy->monsterinfo.max_power_armor_power;
-			int32_t old_base_health = self->enemy->monsterinfo.base_health;
-			int32_t old_health_scaling = self->enemy->monsterinfo.health_scaling;
-			auto reinforcements = self->enemy->monsterinfo.reinforcements;
-			int32_t monster_slots = self->enemy->monsterinfo.monster_slots;
-			int32_t monster_used = self->enemy->monsterinfo.monster_used;
-			int32_t old_gib_health = self->enemy->gib_health;
-
-			st = {};
-			st.keys_specified.emplace("reinforcements");
-			st.reinforcements = "";
-
-			ED_CallSpawn(self->enemy);
-
-			self->enemy->monsterinfo.reinforcements = reinforcements;
-			self->enemy->monsterinfo.monster_slots = monster_slots;
-			self->enemy->monsterinfo.monster_used = monster_used;
-
-			self->enemy->gib_health = old_gib_health / 2;
-			self->enemy->health = self->enemy->max_health = old_max_health;
-			self->enemy->monsterinfo.power_armor_power = self->enemy->monsterinfo.max_power_armor_power = old_power_armor_power;
-			self->enemy->monsterinfo.power_armor_type = self->enemy->monsterinfo.initial_power_armor_type = old_power_armor_type;
-			self->enemy->monsterinfo.base_health = old_base_health;
-			self->enemy->monsterinfo.health_scaling = old_health_scaling;
-
-			if (self->enemy->monsterinfo.setskin)
-				self->enemy->monsterinfo.setskin(self->enemy);
-
-			if (self->enemy->think)
-			{
-				self->enemy->nextthink = level.time;
-				self->enemy->think(self->enemy);
-			}
-			self->enemy->monsterinfo.aiflags &= ~AI_RESURRECTING;
-			self->enemy->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT;
-			// turn off flies
-			self->enemy->s.effects &= ~EF_FLIES;
-			self->enemy->monsterinfo.healer = nullptr;
-
-			if ((self->oldenemy) && (self->oldenemy->inuse) && (self->oldenemy->health > 0))
-			{
-				self->enemy->enemy = self->oldenemy;
-				FoundTarget(self->enemy);
-			}
-			else
-			{
-				self->enemy->enemy = nullptr;
-				if (!FindTarget(self->enemy))
-				{
-					// no valid enemy, so stop acting
-					self->enemy->monsterinfo.pausetime = HOLD_FOREVER;
-					self->enemy->monsterinfo.stand(self->enemy);
-				}
-				self->enemy = nullptr;
-				self->oldenemy = nullptr;
-				if (!FindTarget(self))
-				{
-					// no valid enemy, so stop acting
-					self->monsterinfo.pausetime = HOLD_FOREVER;
-					self->monsterinfo.stand(self);
-					return;
-				}
-			}
-
-			cleanupHeal(self, false);
-			return;
-		}
+		if (!finishHeal(self))
+			self->monsterinfo.nextframe = FRAME_attack52;
+
+		return;
 	}
 	else
 	{
@@ -1055,24 +1069,7 @@
 		gi.sound(self, CHAN_WEAPON, sound_hook_retract, 1, ATTN_NORM, 0);
 
 	self->monsterinfo.aiflags &= ~AI_MEDIC;
-
-	if (self->oldenemy && self->oldenemy->inuse && self->oldenemy->health > 0)
-	{
-		self->enemy = self->oldenemy;
-		HuntTarget(self, false);
-	}
-	else
-	{
-		self->enemy = self->goalentity = nullptr;
-		self->oldenemy = nullptr;
-		if (!FindTarget(self))
-		{
-			// no valid enemy, so stop acting
-			self->monsterinfo.pausetime = HOLD_FOREVER;
-			self->monsterinfo.stand(self);
-			return;
-		}
-	}
+	fixHealerEnemy(self);
 }
 
 mframe_t medic_frames_attackCable[] = {
@@ -1285,9 +1282,9 @@
 			ent->think(ent);
 		}
 
-		ent->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT | AI_SPAWNED_MEDIC_C;
+		ent->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT | AI_SPAWNED_COMMANDER | AI_SPAWNED_NEEDS_GIB;
 		ent->monsterinfo.commander = self;
-		ent->monsterinfo.monster_slots = reinforcement.strength;
+		ent->monsterinfo.slots_from_commander = reinforcement.strength;
 		self->monsterinfo.monster_used += reinforcement.strength;
 
 		if (self->monsterinfo.aiflags & AI_MEDIC)
@@ -1395,14 +1392,16 @@
 		// if our target went away
 		if ((!self->enemy) || (!self->enemy->inuse))
 		{
-			abortHeal(self, true, false, false);
+			abortHeal(self, false, false);
+			self->monsterinfo.nextframe = FRAME_attack52;
 			return false;
 		}
 
 		// if we ran out of time, give up
 		if (self->timestamp < level.time)
 		{
-			abortHeal(self, true, false, true);
+			abortHeal(self, false, true);
+			self->monsterinfo.nextframe = FRAME_attack52;
 			self->timestamp = 0_ms;
 			return false;
 		}
@@ -1508,6 +1507,8 @@
 */
 void SP_monster_medic(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1529,7 +1530,12 @@
 	// PMM
 	if (strcmp(self->classname, "monster_medic_commander") == 0)
 	{
-		self->health = 600 * st.health_multiplier;
+		/* KONIG - reduce health 600->500, add combat armor */
+		self->health = 550 * st.health_multiplier;
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = 200;
 		self->gib_health = -130;
 		self->mass = 600;
 		self->yaw_speed = 40; // default is 20
--- a/m_move.cpp	2023-10-03 19:43:06
+++ b/m_move.cpp	2025-09-04 19:53:48
@@ -184,7 +184,7 @@
 		phi = acos(frandom());
 	// non-buzzards pick a level around the center
 	else
-		phi = acos(crandom() * 0.06f);
+		phi = acos(frandom() * 0.7f);
 
     vec3_t d {
 		sin(phi) * cos(theta),
@@ -273,6 +273,8 @@
 	else
 		wanted_pos = (towards_origin + (towards_velocity * 0.25f)) + ent->monsterinfo.fly_ideal_position;
 
+	//gi.Draw_Point(wanted_pos, 8.0f, rgba_red, gi.frame_time_s, true);
+
 	// find a place we can fit in from here
 	trace_t tr = gi.trace(towards_origin, { -8.f, -8.f, -8.f }, { 8.f, 8.f, 8.f }, wanted_pos, ent, MASK_SOLID | CONTENTS_MONSTERCLIP);
 
@@ -337,9 +339,10 @@
 	// the closer we are to zero, the more we can change dir.
 	// if we're pushed past our max speed we shouldn't
 	// turn at all.
+	bool following_paths = ent->monsterinfo.aiflags & (AI_PATHING | AI_COMBAT_POINT | AI_LOST_SIGHT);
 	float turn_factor;
 			
-	if (((ent->monsterinfo.fly_thrusters && !ent->monsterinfo.fly_pinned) || ent->monsterinfo.aiflags & (AI_PATHING | AI_COMBAT_POINT | AI_LOST_SIGHT)) && dir.dot(wanted_dir) > 0.0f)
+	if (((ent->monsterinfo.fly_thrusters && !ent->monsterinfo.fly_pinned) || following_paths) && dir.dot(wanted_dir) > 0.0f)
 		turn_factor = 0.45f;
 	else
 		turn_factor = min(1.f, 0.84f + (0.08f * (current_speed / ent->monsterinfo.fly_speed)));
@@ -385,11 +388,18 @@
 	// the closer we are to the wanted position, we want to slow
 	// down so we don't fly past it.
 	float speed_factor;
-		
-	if (!ent->enemy || (ent->monsterinfo.fly_thrusters && !ent->monsterinfo.fly_pinned) || (ent->monsterinfo.aiflags & (AI_PATHING | AI_COMBAT_POINT | AI_LOST_SIGHT)))
-		speed_factor = 1.f;
-	else if (aim_fwd.dot(wanted_dir) < -0.25 && dir)
-		speed_factor = 0.f;
+	
+	//gi.Draw_Ray(ent->s.origin, aim_fwd, 16.0f, 8.0f, rgba_green, gi.frame_time_s, true);
+	//gi.Draw_Ray(ent->s.origin, final_dir, 16.0f, 8.0f, rgba_blue, gi.frame_time_s, true);
+	if (!ent->enemy || (ent->monsterinfo.fly_thrusters && !ent->monsterinfo.fly_pinned) || following_paths)
+	{
+		// Paril: only do this correction if we are following paths. we want to move backwards
+		// away from players.
+		if (following_paths && dir && wanted_dir.dot(dir) < -0.25)
+			speed_factor = 0.f;
+		else
+			speed_factor = 1.f;
+	}
 	else
 		speed_factor = min(1.f, dist_to_wanted / ent->monsterinfo.fly_speed);
 
@@ -1171,8 +1181,13 @@
 	vec3_t &path_to = (self->monsterinfo.nav_path.returnCode == PathReturnCode::TraversalPending) ?
 		self->monsterinfo.nav_path.secondMovePoint : self->monsterinfo.nav_path.firstMovePoint;
 
-	if ((self->monsterinfo.nav_path.returnCode != PathReturnCode::TraversalPending && (path_to - self->s.origin).length() <= (self->size.length() * 0.5f)) ||
-		self->monsterinfo.nav_path_cache_time <= level.time)
+	vec3_t ground_origin = self->s.origin + vec3_t { 0.f, 0.f, self->mins[2] } - vec3_t { 0.f, 0.f, PLAYER_MINS[2] };
+	vec3_t mon_mins = ground_origin + PLAYER_MINS;
+	vec3_t mon_maxs = ground_origin + PLAYER_MAXS;
+
+	if (self->monsterinfo.nav_path_cache_time <= level.time ||
+		(self->monsterinfo.nav_path.returnCode != PathReturnCode::TraversalPending &&
+		boxes_intersect(mon_mins, mon_maxs, path_to, path_to)))
 	{
 		PathRequest request;
 		if (self->enemy)
@@ -1184,6 +1199,15 @@
 			request.debugging.drawTime = gi.frame_time_s;
 		request.start = self->s.origin;
 		request.pathFlags = PathFlags::Walk;
+		
+		request.nodeSearch.minHeight = -(self->mins.z * 2);
+		request.nodeSearch.maxHeight = (self->maxs.z * 2);
+
+		// FIXME remove hardcoding
+		if (!strcmp(self->classname, "monster_guardian"))
+		{
+			request.nodeSearch.radius = 2048.f;
+		}
 
 		if (self->monsterinfo.can_jump || (self->flags & FL_FLY))
 		{
--- a/m_mutant.cpp	2023-10-03 19:43:06
+++ b/m_mutant.cpp	2025-09-04 19:53:48
@@ -497,10 +497,11 @@
 
 MONSTERINFO_SETSKIN(mutant_setskin) (edict_t *self) -> void
 {
+	/* KONIG - allow multiple skins */
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
-	else
-		self->s.skinnum = 0;
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 //
@@ -674,6 +675,8 @@
 */
 void SP_monster_mutant(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -707,9 +710,24 @@
 	self->mins = { -18, -18, -24 };
 	self->maxs = { 18, 18, 30 };
 
-	self->health = 300 * st.health_multiplier;
-	self->gib_health = -120;
-	self->mass = 300;
+	/* KONIG - alphamutant code */
+	if (strcmp(self->classname, "monster_alphamutant") == 0)
+	{
+		self->count = 1;
+		self->s.skinnum = 2;
+		if (!self->s.scale)
+			self->s.scale = 1.25f;
+
+		self->health = 500 * st.health_multiplier;
+		self->gib_health = -160;
+		self->mass = 400;
+	}
+	else
+	{
+		self->health = 300 * st.health_multiplier;
+		self->gib_health = -120;
+		self->mass = 300;
+	}
 
 	self->pain = mutant_pain;
 	self->die = mutant_die;
--- a/m_parasite.cpp	2023-10-03 19:43:06
+++ b/m_parasite.cpp	2025-09-04 19:53:48
@@ -659,6 +659,46 @@
 		proboscis_retract(self->proboscus);
 }
 
+static void teleport_dropper_launch(edict_t* self)
+{
+	vec3_t					 forward, right;
+	vec3_t					 start;
+	vec3_t offset;
+
+	if (self->s.frame >= FRAME_break01 && self->s.frame < FRAME_break01 + q_countof(parasite_break_offsets))
+		offset = parasite_break_offsets[self->s.frame - FRAME_break01];
+	else if (self->s.frame >= FRAME_drain01 && self->s.frame < FRAME_drain01 + q_countof(parasite_drain_offsets))
+		offset = parasite_drain_offsets[self->s.frame - FRAME_drain01];
+	else
+		offset = { 8, 0, 6 };
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+
+	vec3_t aim_point;
+	PredictAim(self, self->enemy, start, 0, false, crandom_open() * 0.1f, &forward, &aim_point);
+
+	for (float speed = 250.f; speed < 500.f; speed += 50.f)
+	{
+		if (!M_CalculatePitchToFire(self, aim_point, start, forward, speed, 2.5f, true))
+			continue;
+
+		fire_dropper(self, start, forward, speed);
+		break;
+	}
+
+	self->monsterinfo.attack_finished = level.time + 3_sec;
+}
+
+static void teleport_dropper_difficulty_check(edict_t* self)
+{
+	if (skill->integer < 3)
+		parasite_start_run(self);
+}
+
 mframe_t parasite_frames_fire_proboscis[] = {
 	{ parasite_charge_proboscis, 0, parasite_launch },
 	{ parasite_charge_proboscis },
@@ -681,6 +721,26 @@
 };
 MMOVE_T(parasite_move_fire_proboscis) = { FRAME_drain01, FRAME_drain18, parasite_frames_fire_proboscis, parasite_start_run };
 
+mframe_t parasite_frames_fire_droppers[] = {
+	{ parasite_charge_proboscis },
+	{ parasite_charge_proboscis, -3 },
+	{ parasite_charge_proboscis, 1 },
+	{ parasite_charge_proboscis, 2, teleport_dropper_launch },
+	{ parasite_charge_proboscis, -3 },
+
+	{ parasite_charge_proboscis, 1, teleport_dropper_launch },
+	{ parasite_charge_proboscis, 1 },
+	{ parasite_charge_proboscis, 3 },
+	{ parasite_charge_proboscis, 0, teleport_dropper_difficulty_check },
+	{ parasite_charge_proboscis, -18, teleport_dropper_launch },
+
+	{ parasite_charge_proboscis, 3 },
+	{ parasite_charge_proboscis, 9 },
+	{ parasite_charge_proboscis, 6 },
+	{ parasite_charge_proboscis }
+};
+MMOVE_T(parasite_move_fire_droppers) = { FRAME_break01, FRAME_break14, parasite_frames_fire_droppers, parasite_start_run };
+
 MONSTERINFO_ATTACK(parasite_attack) (edict_t *self) -> void
 {
 	if (!M_CheckClearShot(self, parasite_drain_offsets[0]))
@@ -688,8 +748,15 @@
 
 	if (self->proboscus && self->proboscus->style != 2)
 		proboscis_retract(self->proboscus);
-
-	M_SetAnimation(self, &parasite_move_fire_proboscis);
+	if (strcmp(self->classname, "monster_dropper") == 0)
+	{
+		if (level.time < self->monsterinfo.attack_finished)
+			return;
+
+		M_SetAnimation(self, &parasite_move_fire_droppers);
+	}
+	else
+		M_SetAnimation(self, &parasite_move_fire_proboscis);
 }
 
 //================
@@ -892,10 +959,11 @@
 
 MONSTERINFO_SETSKIN(parasite_setskin) (edict_t *self) -> void
 {
+	/* KONIG - allow multiple skins */
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
-	else
-		self->s.skinnum = 0;
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 constexpr spawnflags_t SPAWNFLAG_PARASITE_NOJUMPING = 8_spawnflag;
@@ -904,6 +972,8 @@
  */
 void SP_monster_parasite(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -963,3 +1033,24 @@
 
 	walkmonster_start(self);
 }
+
+/*QUAKED monster_dropper (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping
+ */
+ /* KONIG - new parasite beta; Quake 4's Portal Dropper*/
+void SP_monster_dropper(edict_t* self)
+{
+	SP_monster_parasite(self);
+	self->s.skinnum = 2;
+	self->style = 1;
+
+	self->monsterinfo.armor_type = IT_ARMOR_JACKET;
+	self->monsterinfo.armor_power = 100;
+
+	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS; //makeshift fix to avoid infighting with spawned entities
+
+	if (!self->s.scale)
+		self->s.scale = 1.25f;
+
+	self->mins[2] = -32;
+
+}
--- /dev/null
+++ b/m_sentien.cpp	2025-09-04 19:53:48
@@ -0,0 +1,971 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+SENTIEN
+
+==============================================================================
+*/
+
+#include "g_local.h"
+#include "m_sentien.h"
+#include "m_flash.h"
+
+void target_laser_think(edict_t* self);
+void target_laser_on(edict_t* self);
+void target_laser_off(edict_t* self);
+
+static cached_soundindex sound_fend;
+static cached_soundindex sound_pain1, sound_pain2, sound_pain3;
+static cached_soundindex sound_idle1, sound_idle2, sound_idle3;
+static cached_soundindex sound_die1, sound_die2;
+static cached_soundindex sound_step;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_attack1, sound_attack2, sound_attack3;
+static cached_soundindex sound_strike;
+
+//
+// misc
+//
+
+void sentien_run(edict_t* self);
+void sentien_walk(edict_t* self);
+void sentien_dead(edict_t* self);
+void sentien_machinegun(edict_t* self);
+void sentien_blast_attack(edict_t* self);
+void sentien_post_blast_attack(edict_t* self);
+void sentien_laser_attack(edict_t* self);
+void sentien_post_laser_attack(edict_t* self);
+
+MONSTERINFO_SIGHT(sentien_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+void sentien_step(edict_t* self)
+{
+	gi.sound(self, CHAN_BODY, sound_step, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_IDLE(sentien_idle) (edict_t* self) -> void
+{
+	int n = irandom(3);
+	if (n == 0)
+		gi.sound(self, CHAN_BODY, sound_idle1, 1, ATTN_NORM, 0);
+	else if (n == 1)
+		gi.sound(self, CHAN_BODY, sound_idle2, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_BODY, sound_idle3, 1, ATTN_NORM, 0);
+}
+
+void sentien_sound_attack1(edict_t* self)
+{
+	gi.sound(self, CHAN_BODY, sound_attack1, 1, ATTN_NORM, 0);
+}
+
+void sentien_sound_attack2(edict_t* self)
+{
+	gi.sound(self, CHAN_BODY, sound_attack2, 1, ATTN_NORM, 0);
+}
+
+void sentien_sound_attack3(edict_t* self)
+{
+	gi.sound(self, CHAN_BODY, sound_attack3, 1, ATTN_NORM, 0);
+}
+
+void sentien_sound_fend(edict_t* self)
+{
+	gi.sound(self, CHAN_BODY, sound_fend, 1, ATTN_NORM, 0);
+}
+
+void sentien_sound_die1(edict_t* self)
+{
+	gi.sound(self, CHAN_BODY, sound_die1, 1, ATTN_NORM, 0);
+}
+
+void sentien_sound_die2(edict_t* self)
+{
+	gi.sound(self, CHAN_BODY, sound_die2, 1, ATTN_NORM, 0);
+}
+
+//
+// stand
+//
+
+mframe_t sentien_frames_stand1[] =
+{
+   {ai_stand, 0, sentien_idle},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand}
+};
+MMOVE_T(sentien_move_stand1) = { FRAME_idle101, FRAME_idle129, sentien_frames_stand1, nullptr };
+
+mframe_t sentien_frames_stand2[] =
+{
+   {ai_stand, 0, sentien_idle},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand}
+};
+MMOVE_T(sentien_move_stand2) = { FRAME_idle201, FRAME_idle220, sentien_frames_stand2, nullptr };
+
+mframe_t sentien_frames_stand3[] =
+{
+	{ai_stand, 0, sentien_idle},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, //10
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, //20
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, //30
+
+	{ai_stand}
+};
+MMOVE_T(sentien_move_stand3) = { FRAME_idle301, FRAME_idle331, sentien_frames_stand3, nullptr };
+
+MONSTERINFO_STAND(sentien_stand) (edict_t* self) -> void
+{
+	float r;
+
+	r = frandom();
+	if (r < 0.33f)
+		M_SetAnimation(self, &sentien_move_stand1);
+	else if (r < 0.66f)
+		M_SetAnimation(self, &sentien_move_stand2);
+	else
+		M_SetAnimation(self, &sentien_move_stand3);
+}
+
+//
+// walk
+//
+
+mframe_t sentien_frames_start_walk[] =
+{
+   {ai_walk},
+   {ai_walk, 1.5},
+   {ai_walk, 2.9},
+   {ai_walk, 2.4},
+   {ai_walk, 2.1},
+   {ai_walk, 2.6},
+   {ai_walk, 2.1},
+   {ai_walk, 1.8, sentien_step}
+};
+MMOVE_T(sentien_move_start_walk) = { FRAME_walk01, FRAME_walk08, sentien_frames_start_walk, sentien_walk };
+
+mframe_t sentien_frames_walk[] =
+{
+   {ai_walk, 0.3},
+   {ai_walk, 2.4},
+   {ai_walk, 4.0},
+   {ai_walk, 3.5},
+   {ai_walk, 3.6},
+   {ai_walk, 3.7 * 1.1},
+   {ai_walk, 3.1 * 1.3},
+   {ai_walk, 4.1 * 1.2, sentien_step},
+
+   {ai_walk, 2.0},
+   {ai_walk, 2.6}, // 2.4
+   {ai_walk, 3.8}, // 3.9
+   {ai_walk, 3.6},
+   {ai_walk, 3.6},
+   {ai_walk, 4.3},
+   {ai_walk, 4.2 * 1.2},
+   {ai_walk, 5.2, sentien_step} // 4.1
+};
+MMOVE_T(sentien_move_walk) = { FRAME_walk09, FRAME_walk24, sentien_frames_walk, nullptr };
+#if 0
+mframe_t sentien_frames_end_walk[] =
+{
+   {ai_walk, 0.8},
+   {ai_walk, 1.0},
+   {ai_walk, 1.6},
+   {ai_walk, 1.4},
+   {ai_walk, 1.5},
+   {ai_walk, 1.4},
+   {ai_walk, 1.5},
+   {ai_walk, 1.8, sentien_step}
+};
+MMOVE_T(sentien_move_end_walk) = { FRAME_walk25, FRAME_walk32, sentien_frames_end_walk, sentien_stand };
+#endif
+MONSTERINFO_WALK(sentien_walk) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+	{
+		M_SetAnimation(self, &sentien_move_stand1);
+		return;
+	}
+
+	if (self->monsterinfo.active_move == &sentien_move_start_walk)
+	{
+		M_SetAnimation(self, &sentien_move_walk);
+	}
+	else
+	{
+		M_SetAnimation(self, &sentien_move_start_walk);
+	}
+}
+
+//
+// run
+//
+
+mframe_t sentien_frames_start_run[] =
+{
+   {ai_run},
+   {ai_run, 1.5},
+   {ai_run, 2.9},
+   {ai_run, 2.4},
+   {ai_run, 2.1},
+   {ai_run, 2.6},
+   {ai_run, 2.1},
+   {ai_run, 1.8, sentien_step}
+};
+MMOVE_T(sentien_move_start_run) = { FRAME_walk01, FRAME_walk08, sentien_frames_start_run, sentien_run };
+
+mframe_t sentien_frames_run[] =
+{
+   {ai_run, 0.3 * 1.2},
+   {ai_run, 2.4},
+   {ai_run, 4.0},
+   {ai_run, 3.5},
+   {ai_run, 3.6},
+   {ai_run, 3.7 * 1.1},
+   {ai_run, 3.1 * 1.3},
+   {ai_run, 4.1 * 1.2, sentien_step},
+
+   {ai_run, 2.0},
+   {ai_run, 2.6}, // 2.4
+   {ai_run, 3.8}, // 3.9
+   {ai_run, 3.6},
+   {ai_run, 3.6},
+   {ai_run, 4.3},
+   {ai_run, 4.2 * 1.2},
+   {ai_run, 5.2, sentien_step} // 4.1
+};
+MMOVE_T(sentien_move_run) = { FRAME_walk09, FRAME_walk24, sentien_frames_run, nullptr };
+#if 0
+mframe_t sentien_frames_run_end[] =
+{
+   {ai_run, 0.8},
+   {ai_run, 1.0},
+   {ai_run, 1.6},
+   {ai_run, 1.4},
+   {ai_run, 1.5},
+   {ai_run, 1.4},
+   {ai_run, 1.5},
+   {ai_run, 1.8, sentien_step}
+};
+MMOVE_T(sentien_move_run_end) = { FRAME_walk25, FRAME_walk32, sentien_frames_run_end, sentien_walk };
+#endif
+MONSTERINFO_RUN(sentien_run) (edict_t* self) -> void
+{
+	if (self->enemy && self->enemy->client)
+		self->monsterinfo.aiflags |= AI_BRUTAL;
+	else
+		self->monsterinfo.aiflags &= ~AI_BRUTAL;
+
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+	{
+		M_SetAnimation(self, &sentien_move_stand1);
+		return;
+	}
+
+	if (self->monsterinfo.active_move == &sentien_move_walk ||
+		self->monsterinfo.active_move == &sentien_move_start_run)
+	{
+		M_SetAnimation(self, &sentien_move_run);
+	}
+	else
+	{
+		M_SetAnimation(self, &sentien_move_start_run);
+	}
+}
+
+//
+// pain
+//
+
+mframe_t sentien_frames_pain1[] =
+{
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move}
+};
+MMOVE_T(sentien_move_pain1) = { FRAME_pain101, FRAME_pain104, sentien_frames_pain1, sentien_run };
+
+mframe_t sentien_frames_pain2[] =
+{
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move}
+};
+MMOVE_T(sentien_move_pain2) = { FRAME_pain201, FRAME_pain206, sentien_frames_pain2, sentien_run };
+
+mframe_t sentien_frames_pain3[] =
+{
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move}
+};
+MMOVE_T(sentien_move_pain3) = { FRAME_pain301, FRAME_pain321, sentien_frames_pain3, sentien_run };
+
+PAIN(sentien_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	float r;
+
+	if (mod.id != MOD_CHAINFIST && damage <= 10)
+		return;
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	// less than this we don't flinch
+	if (damage <= 10)
+		return;
+
+	if (mod.id != MOD_CHAINFIST)
+	{
+		if (damage <= 30)
+			if (frandom() > 0.2f)
+				return;
+
+		// don't go into pain while attacking
+		if (skill->integer >= 1)
+		{
+			if ((self->s.frame >= FRAME_attak301) && (self->s.frame <= FRAME_attak322))
+				return;
+			if ((self->s.frame >= FRAME_attak101) && (self->s.frame <= FRAME_attak114))
+				return;
+		}
+	}
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	r = frandom();
+	if (r < 0.33f)
+		gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+	else if (r < 0.66f)
+		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_pain3, 1, ATTN_NORM, 0);
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	if (damage > 60)
+		M_SetAnimation(self, &sentien_move_pain3);
+	else if (damage > 30)
+		M_SetAnimation(self, &sentien_move_pain2);
+	else
+		M_SetAnimation(self, &sentien_move_pain1);
+}
+
+MONSTERINFO_SETSKIN(sentien_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// attacks
+//
+
+mframe_t sentien_frames_pre_blast_attack[] =
+{
+   {ai_charge},
+   {ai_charge},
+   {ai_charge},
+   {ai_charge}
+};
+MMOVE_T(sentien_move_pre_blast_attack) = { FRAME_attak101, FRAME_attak104, sentien_frames_pre_blast_attack, sentien_blast_attack };
+
+mframe_t sentien_frames_blast_attack[] =
+{
+   {ai_charge, 0, sentien_machinegun},
+   {ai_charge, 0, sentien_machinegun},
+   {ai_charge, 0, sentien_machinegun},
+   {ai_charge, 0, sentien_machinegun},
+   {ai_charge, 0, sentien_machinegun},
+   {ai_charge, 0, sentien_machinegun}
+};
+MMOVE_T(sentien_move_blast_attack) = { FRAME_attak105, FRAME_attak110, sentien_frames_blast_attack, sentien_post_blast_attack };
+
+mframe_t sentien_frames_post_blast_attack[] =
+{
+   {ai_charge},
+   {ai_charge},
+   {ai_charge},
+   {ai_charge}
+};
+MMOVE_T(sentien_move_post_blast_attack) = { FRAME_attak111, FRAME_attak114, sentien_frames_post_blast_attack, sentien_run };
+
+void sentien_blast_attack(edict_t* self)
+{
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+	{
+		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+		M_SetAnimation(self, &sentien_move_post_blast_attack);
+		return;
+	}
+
+	if (visible(self, self->enemy))
+		if (self->enemy->health > 0)
+			if (frandom() <= 0.6f)
+			{
+				M_SetAnimation(self, &sentien_move_blast_attack);
+				return;
+			}
+	M_SetAnimation(self, &sentien_move_post_blast_attack);
+}
+
+void sentien_post_blast_attack(edict_t* self)
+{
+	float refire = 0.25;
+	float r;
+
+	if (visible(self, self->enemy) &&
+		infront(self, self->enemy))
+	{
+		if (skill->integer == 1)
+			refire = 0.40;
+		else if (skill->integer == 2)
+			refire = 0.60;
+		else if (skill->integer >= 3)
+			refire = 0.75;
+
+		r = frandom();
+		if (r > refire)
+			M_SetAnimation(self, &sentien_move_post_blast_attack);
+	}
+	else
+		M_SetAnimation(self, &sentien_move_post_blast_attack);
+}
+
+vec3_t sentien_flash_offset[] =
+{
+	// frames 116+ (hex fire)
+	 {23.7, 25.4, 29.6},
+	 {23.7, 25.3, 26.7},
+	 {23.7, 27.7, 28.1},
+	 {23.7, 27.4, 31.2},
+	 {23.7, 24.9, 32.3},
+	 {23.7, 22.5, 30.6},
+	 {23.7, 22.7, 27.8}
+};
+
+void sentien_machinegun(edict_t* self)
+{
+	vec3_t					 start;
+	vec3_t					 aim;
+	vec3_t					 forward, right;
+	monster_muzzleflash_id_t flash_number;
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+	
+	flash_number = static_cast<monster_muzzleflash_id_t>(MZ2_TANK_MACHINEGUN_1 + (self->s.frame - FRAME_attak105));
+	
+	AngleVectors(self->s.angles, forward, right, nullptr);
+
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+	PredictAim(self, self->enemy, start, 0, true, -0.2f, &aim, nullptr);
+	
+	monster_fire_bullet(self, start, aim, 5, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
+
+	sentien_sound_attack1(self);
+}
+
+
+/*=========================================================================
+   Sentien laser attack.
+  =========================================================================*/
+void sentien_do_laser(edict_t* self);
+
+mframe_t sentien_frames_pre_laser_attack[] =
+{
+   {ai_charge},
+   {ai_charge},
+   {ai_charge},
+   {ai_charge},
+   {ai_charge}
+};
+MMOVE_T(sentien_move_pre_laser_attack) = { FRAME_attak201, FRAME_attak205, sentien_frames_pre_laser_attack, sentien_laser_attack };
+
+mframe_t sentien_frames_laser_attack[] =
+{
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser}
+};
+MMOVE_T(sentien_move_laser_attack) = { FRAME_attak206, FRAME_attak216, sentien_frames_laser_attack, sentien_post_laser_attack };
+
+mframe_t sentien_frames_post_laser_attack[] =
+{
+   {ai_charge},
+   {ai_charge},
+   {ai_charge},
+   {ai_charge}
+};
+MMOVE_T(sentien_move_post_laser_attack) = { FRAME_attak217, FRAME_attak220, sentien_frames_post_laser_attack, sentien_run };
+
+void sentien_laser_attack(edict_t* self)
+{
+	// is a player right infront?
+	if (visible(self, self->enemy) &&
+		infront(self, self->enemy))
+	{
+		M_SetAnimation(self, &sentien_move_laser_attack);
+	}
+	else
+	{
+		sentien_post_laser_attack(self);
+	}
+}
+
+void sentien_post_laser_attack(edict_t* self)
+{
+	M_SetAnimation(self, &sentien_move_post_laser_attack);
+}
+
+vec3_t sentien_laser_offset[] =
+{
+	{43.8, -22.8 + 1, 43.6 - 0.8},
+	{44.2, -22.9 + 1, 43.9 - 0.8},
+	{43.9, -22.8 + 1, 44.0 - 0.8},
+	{43.2, -23.0 + 1, 44.0 - 0.8},
+	{42.4, -23.4 + 1, 43.9 - 0.8},
+	{42.0, -23.5 + 1, 44.0 - 0.8},
+	{42.4, -23.3 + 1, 44.0 - 0.8},
+	{43.1, -23.1 + 1, 43.9 - 0.8},
+	{43.8, -22.9 + 1, 43.9 - 0.8},
+	{44.2, -22.8 + 1, 44.1 - 0.8},
+	{43.8, -22.8 + 1, 43.5 - 0.8}
+};
+
+PRETHINK(sentien_fire_update) (edict_t* laser) -> void
+{
+	if (!laser->spawnflags.has(SPAWNFLAG_DABEAM_SPAWNED))
+	{
+		edict_t* self = laser->owner;
+
+		vec3_t forward, right, target;
+		vec3_t start;
+
+		AngleVectors(self->s.angles, forward, right, nullptr);
+		start = M_ProjectFlashSource(self, sentien_laser_offset[laser->spawnflags.has(SPAWNFLAG_DABEAM_SECONDARY) ? 1 : 0], forward, right);
+		PredictAim(self, self->enemy, start, 0, false, 0.3f, &forward, &target);
+
+		laser->s.origin = start;
+		forward[0] += crandom() * 0.02f;
+		forward[1] += crandom() * 0.02f;
+		forward.normalize();
+		laser->movedir = forward;
+		gi.linkentity(laser);
+	}
+	dabeam_update(laser, false);
+}
+
+void sentien_do_laser(edict_t* self)
+{
+	sentien_sound_attack2(self);
+	monster_fire_dabeam(self, 15, self->s.frame & 1, sentien_fire_update);
+}
+
+MONSTERINFO_ATTACK(sentien_attack) (edict_t* self) -> void
+{
+	vec3_t	vec;
+	float	range;
+	float	r;
+
+	vec = self->enemy->s.origin - self->s.origin;
+	range = vec.length();
+
+	r = frandom();
+
+	if (range <= 128)
+		M_SetAnimation(self, &sentien_move_pre_blast_attack);
+	else if (range <= 500)
+	{
+		if (r < 0.50)
+			M_SetAnimation(self, &sentien_move_pre_blast_attack);
+		else
+			M_SetAnimation(self, &sentien_move_pre_laser_attack);
+	}
+	else
+	{
+		if (r < 0.25)
+			M_SetAnimation(self, &sentien_move_pre_blast_attack);
+		else
+			M_SetAnimation(self, &sentien_move_pre_laser_attack);
+	}
+}
+
+
+/*=========================================================================
+   Sentien fending.
+  =========================================================================*/
+void sentien_fend_ready(edict_t* self)
+{
+	if (self->monsterinfo.aiflags & AI_REDUCEDDAMAGE)
+		return;
+	self->monsterinfo.pausetime = level.time + 1_sec;
+}
+
+void sentien_fend_hold(edict_t* self)
+{
+	if (level.time >= self->monsterinfo.pausetime)
+	{
+		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+		self->monsterinfo.aiflags &= ~AI_REDUCEDDAMAGE;
+	}
+	else
+	{
+		self->monsterinfo.aiflags |= (AI_HOLD_FRAME | AI_REDUCEDDAMAGE);
+	}
+}
+
+
+mframe_t sentien_frames_fend[] =
+{
+	{ai_move, 0,  sentien_sound_fend},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0,  sentien_fend_ready},
+	{ai_move, 0,  sentien_fend_hold},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0}
+};
+MMOVE_T(sentien_move_fend) = { FRAME_fend01, FRAME_fend15, sentien_frames_fend, sentien_run };
+
+void sentien_fend(edict_t* self, edict_t* attacker, float eta)
+{
+	// don't flinch if attacking
+	if (self->monsterinfo.active_move == &sentien_move_laser_attack ||
+		self->monsterinfo.active_move == &sentien_move_blast_attack)
+		return;
+
+	if (skill->integer == 0)
+	{
+		if (frandom() > 0.45)
+			return;
+	}
+	else if (skill->integer == 1)
+	{
+		if (frandom() > 0.60)
+			return;
+	}
+	else
+	{
+		if (frandom() > 0.80)
+			return;
+	}
+
+	if (!self->enemy)
+		self->enemy = attacker;
+
+	M_SetAnimation(self, &sentien_move_fend);
+}
+
+//
+// DEATH
+//
+
+void sentien_dead(edict_t* self)
+{
+	self->mins = { -16, -16, -16 };
+	self->maxs = { 16, 16, -0 };
+	monster_dead(self);
+}
+
+static void sentien_shrink(edict_t* self)
+{
+	self->maxs[2] = 0;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t sentien_frames_death1[] =
+{
+   {ai_move, 0,  sentien_sound_die1},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move, 0, sentien_shrink},
+   {ai_move}
+};
+MMOVE_T(sentien_move_death1) = { FRAME_death101, FRAME_death128, sentien_frames_death1, sentien_dead };
+
+mframe_t sentien_frames_death2[] =
+{
+   {ai_move, 0,  sentien_sound_die2},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move, 0, sentien_shrink},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move}
+};
+MMOVE_T(sentien_move_death2) = { FRAME_death201, FRAME_death229, sentien_frames_death2, sentien_dead };
+
+
+DIE(sentien_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ "models/objects/gibs/sm_meat/tris.md2" },
+			{ 3, "models/objects/gibs/sm_metal/tris.md2", GIB_METALLIC },
+			{ "models/objects/gibs/gear/tris.md2", GIB_METALLIC },
+			//{ 2, "models/monsters/sentien/gibs/leg.md2", GIB_SKINNED | GIB_METALLIC },
+			//{ "models/monsters/sentien/gibs/chest.md2", GIB_SKINNED },
+			{ "models/objects/gibs/chest/tris.md2", GIB_SKINNED },
+			//{ "models/monsters/sentien/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			{ "models/objects/gibs/head2/tris.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		if (!self->style)
+			ThrowGib(self, "models/monsters/tank/gibs/barm.md2", damage, GIB_SKINNED | GIB_UPRIGHT, self->s.scale);
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	self->deadflag = true;
+	self->takedamage = true;
+
+	if (frandom() < 0.80)
+		M_SetAnimation(self, &sentien_move_death1);
+	else
+			M_SetAnimation(self, &sentien_move_death2);
+}
+
+
+/*=========================================================================
+   Spawn code.
+  =========================================================================*/
+void SP_monster_sentien(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	self->s.modelindex = gi.modelindex("models/monsters/sentien/tris.md2");
+	self->mins = { -28, -28, -16 };
+	self->maxs = { 28, 28, 64 };
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	sound_idle1.assign("monsters/sentien/sen_idle1.wav");
+	sound_idle2.assign("monsters/sentien/sen_idle2.wav");
+	sound_idle3.assign("monsters/sentien/sen_idle3.wav");
+	sound_step.assign("monsters/sentien/sen_walk.wav");
+	sound_fend.assign("monsters/sentien/sen_fend.wav");
+	sound_pain1.assign("monsters/sentien/sen_pain1.wav");
+	sound_pain2.assign("monsters/sentien/sen_pain2.wav");
+	sound_pain3.assign("monsters/sentien/sen_pain3.wav");
+	sound_die1.assign("monsters/sentien/sen_die1.wav");
+	sound_die2.assign("monsters/sentien/sen_die2.wav");
+	sound_attack1.assign("monsters/sentien/sen_att1.wav");
+	sound_attack2.assign("monsters/sentien/sen_att2.wav");
+	sound_attack3.assign("monsters/sentien/sen_att3.wav");
+	sound_sight.assign("monsters/tank/sight1.wav");
+
+	self->mass = 500;
+	self->health = 900;
+	self->gib_health = -425;
+	self->yaw_speed = 10;
+	self->random = 1;
+
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 200;
+
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	// setup the functions
+	self->pain = sentien_pain;
+	self->die = sentien_die;
+	self->monsterinfo.stand = sentien_stand;
+	self->monsterinfo.walk = sentien_walk;
+	self->monsterinfo.run = sentien_run;
+	self->monsterinfo.attack = sentien_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = nullptr;
+	self->monsterinfo.idle = nullptr;
+
+	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &sentien_move_stand1);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	walkmonster_start(self);
+}
--- /dev/null
+++ b/m_sentien.h	2025-09-04 19:53:48
@@ -0,0 +1,328 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+// G:\quake2\baseq2\models/monsters/sentien
+
+enum
+{
+	FRAME_idle101,
+	FRAME_idle102,
+	FRAME_idle103,
+	FRAME_idle104,
+	FRAME_idle105,
+	FRAME_idle106,
+	FRAME_idle107,
+	FRAME_idle108,
+	FRAME_idle109,
+	FRAME_idle110,
+	FRAME_idle111,
+	FRAME_idle112,
+	FRAME_idle113,
+	FRAME_idle114,
+	FRAME_idle115,
+	FRAME_idle116,
+	FRAME_idle117,
+	FRAME_idle118,
+	FRAME_idle119,
+	FRAME_idle120,
+	FRAME_idle121,
+	FRAME_idle122,
+	FRAME_idle123,
+	FRAME_idle124,
+	FRAME_idle125,
+	FRAME_idle126,
+	FRAME_idle127,
+	FRAME_idle128,
+	FRAME_idle129,
+	FRAME_idle201,
+	FRAME_idle202,
+	FRAME_idle203,
+	FRAME_idle204,
+	FRAME_idle205,
+	FRAME_idle206,
+	FRAME_idle207,
+	FRAME_idle208,
+	FRAME_idle209,
+	FRAME_idle210,
+	FRAME_idle211,
+	FRAME_idle212,
+	FRAME_idle213,
+	FRAME_idle214,
+	FRAME_idle215,
+	FRAME_idle216,
+	FRAME_idle217,
+	FRAME_idle218,
+	FRAME_idle219,
+	FRAME_idle220,
+	FRAME_idle301,
+	FRAME_idle302,
+	FRAME_idle303,
+	FRAME_idle304,
+	FRAME_idle305,
+	FRAME_idle306,
+	FRAME_idle307,
+	FRAME_idle308,
+	FRAME_idle309,
+	FRAME_idle310,
+	FRAME_idle311,
+	FRAME_idle312,
+	FRAME_idle313,
+	FRAME_idle314,
+	FRAME_idle315,
+	FRAME_idle316,
+	FRAME_idle317,
+	FRAME_idle318,
+	FRAME_idle319,
+	FRAME_idle320,
+	FRAME_idle321,
+	FRAME_idle322,
+	FRAME_idle323,
+	FRAME_idle324,
+	FRAME_idle325,
+	FRAME_idle326,
+	FRAME_idle327,
+	FRAME_idle328,
+	FRAME_idle329,
+	FRAME_idle330,
+	FRAME_idle331,
+	FRAME_walk01,
+	FRAME_walk02,
+	FRAME_walk03,
+	FRAME_walk04,
+	FRAME_walk05,
+	FRAME_walk06,
+	FRAME_walk07,
+	FRAME_walk08,
+	FRAME_walk09,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12,
+	FRAME_walk13,
+	FRAME_walk14,
+	FRAME_walk15,
+	FRAME_walk16,
+	FRAME_walk17,
+	FRAME_walk18,
+	FRAME_walk19,
+	FRAME_walk20,
+	FRAME_walk21,
+	FRAME_walk22,
+	FRAME_walk23,
+	FRAME_walk24,
+	FRAME_walk25,
+	FRAME_walk26,
+	FRAME_walk27,
+	FRAME_walk28,
+	FRAME_walk29,
+	FRAME_walk30,
+	FRAME_walk31,
+	FRAME_walk32,
+	FRAME_attak101,
+	FRAME_attak102,
+	FRAME_attak103,
+	FRAME_attak104,
+	FRAME_attak105,
+	FRAME_attak106,
+	FRAME_attak107,
+	FRAME_attak108,
+	FRAME_attak109,
+	FRAME_attak110,
+	FRAME_attak111,
+	FRAME_attak112,
+	FRAME_attak113,
+	FRAME_attak114,
+	FRAME_attak201,
+	FRAME_attak202,
+	FRAME_attak203,
+	FRAME_attak204,
+	FRAME_attak205,
+	FRAME_attak206,
+	FRAME_attak207,
+	FRAME_attak208,
+	FRAME_attak209,
+	FRAME_attak210,
+	FRAME_attak211,
+	FRAME_attak212,
+	FRAME_attak213,
+	FRAME_attak214,
+	FRAME_attak215,
+	FRAME_attak216,
+	FRAME_attak217,
+	FRAME_attak218,
+	FRAME_attak219,
+	FRAME_attak220,
+	FRAME_attak301,
+	FRAME_attak302,
+	FRAME_attak303,
+	FRAME_attak304,
+	FRAME_attak305,
+	FRAME_attak306,
+	FRAME_attak307,
+	FRAME_attak308,
+	FRAME_attak309,
+	FRAME_attak310,
+	FRAME_attak311,
+	FRAME_attak312,
+	FRAME_attak313,
+	FRAME_attak314,
+	FRAME_attak315,
+	FRAME_attak316,
+	FRAME_attak317,
+	FRAME_attak318,
+	FRAME_attak319,
+	FRAME_attak320,
+	FRAME_attak321,
+	FRAME_attak322,
+	FRAME_fend01,
+	FRAME_fend02,
+	FRAME_fend03,
+	FRAME_fend04,
+	FRAME_fend05,
+	FRAME_fend06,
+	FRAME_fend07,
+	FRAME_fend08,
+	FRAME_fend09,
+	FRAME_fend10,
+	FRAME_fend11,
+	FRAME_fend12,
+	FRAME_fend13,
+	FRAME_fend14,
+	FRAME_fend15,
+	FRAME_pain101,
+	FRAME_pain102,
+	FRAME_pain103,
+	FRAME_pain104,
+	FRAME_pain201,
+	FRAME_pain202,
+	FRAME_pain203,
+	FRAME_pain204,
+	FRAME_pain205,
+	FRAME_pain206,
+	FRAME_pain301,
+	FRAME_pain302,
+	FRAME_pain303,
+	FRAME_pain304,
+	FRAME_pain305,
+	FRAME_pain306,
+	FRAME_pain307,
+	FRAME_pain308,
+	FRAME_pain309,
+	FRAME_pain310,
+	FRAME_pain311,
+	FRAME_pain312,
+	FRAME_pain313,
+	FRAME_pain314,
+	FRAME_pain315,
+	FRAME_pain316,
+	FRAME_pain317,
+	FRAME_pain318,
+	FRAME_pain319,
+	FRAME_pain320,
+	FRAME_pain321,
+	FRAME_death101,
+	FRAME_death102,
+	FRAME_death103,
+	FRAME_death104,
+	FRAME_death105,
+	FRAME_death106,
+	FRAME_death107,
+	FRAME_death108,
+	FRAME_death109,
+	FRAME_death110,
+	FRAME_death111,
+	FRAME_death112,
+	FRAME_death113,
+	FRAME_death114,
+	FRAME_death115,
+	FRAME_death116,
+	FRAME_death117,
+	FRAME_death118,
+	FRAME_death119,
+	FRAME_death120,
+	FRAME_death121,
+	FRAME_death122,
+	FRAME_death123,
+	FRAME_death124,
+	FRAME_death125,
+	FRAME_death126,
+	FRAME_death127,
+	FRAME_death128,
+	FRAME_death201,
+	FRAME_death202,
+	FRAME_death203,
+	FRAME_death204,
+	FRAME_death205,
+	FRAME_death206,
+	FRAME_death207,
+	FRAME_death208,
+	FRAME_death209,
+	FRAME_death210,
+	FRAME_death211,
+	FRAME_death212,
+	FRAME_death213,
+	FRAME_death214,
+	FRAME_death215,
+	FRAME_death216,
+	FRAME_death217,
+	FRAME_death218,
+	FRAME_death219,
+	FRAME_death220,
+	FRAME_death221,
+	FRAME_death222,
+	FRAME_death223,
+	FRAME_death224,
+	FRAME_death225,
+	FRAME_death226,
+	FRAME_death227,
+	FRAME_death228,
+	FRAME_death229,
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
+
+/*
+#define FRAME_stand1start	0
+#define FRAME_stand1end		28
+#define FRAME_stand2start	29
+#define FRAME_stand2end		48
+#define FRAME_stand3start	49
+#define FRAME_stand3end		79
+#define FRAME_walkStartStart	80
+#define FRAME_walkStartEnd	87
+#define FRAME_walkLoopStart	88
+#define FRAME_walkLoopEnd	103
+#define FRAME_walkEndStart	104
+#define FRAME_walkEndEnd	111
+
+#define FRAME_blastPreStart	112
+#define FRAME_blastPreEnd	115
+#define FRAME_blastStart	116
+#define FRAME_blastEnd		121
+#define FRAME_blastPostStart	122
+#define FRAME_blastPostEnd	125
+#define FRAME_laserPreStart	126
+#define FRAME_laserPreEnd	130
+#define FRAME_laserStart	131
+#define FRAME_laserEnd		141
+#define FRAME_laserPostStart	142
+#define FRAME_laserPostEnd	145
+#define FRAME_slashPreStart   146
+#define FRAME_slashPreEnd     150
+#define FRAME_slashStart      151
+#define FRAME_slashEnd        154
+#define FRAME_slashPostStart  155
+#define FRAME_slashPostEnd    167
+
+#define FRAME_dodgeStart	168
+#define FRAME_dodgeHold		173
+#define FRAME_dodgeEnd		182
+#define FRAME_pain1Start	183
+#define FRAME_pain1End		186
+#define FRAME_pain2Start	187
+#define FRAME_pain2End		192
+#define FRAME_pain3Start	193
+#define FRAME_pain3End		213
+#define FRAME_die1Start		214
+#define FRAME_die1End		241
+#define FRAME_die2Start		242
+#define FRAME_die2End		270
+*/
--- a/m_shambler.cpp	2023-10-03 19:43:06
+++ b/m_shambler.cpp	2025-09-04 19:53:48
@@ -228,11 +228,11 @@
 
 MONSTERINFO_SETSKIN(shambler_setskin) (edict_t* self) -> void
 {
-	// FIXME: create pain skin?
-	//if (self->health < (self->max_health / 2))
-	//	self->s.skinnum |= 1;
-	//else
-	//	self->s.skinnum &= ~1;
+	/* KONIG - allow multiple skins */
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 //
@@ -267,7 +267,7 @@
 	shambler_lightning_update(self);
 }
 
-constexpr spawnflags_t SPAWNFLAG_SHAMBLER_PRECISE = 1_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_SHAMBLER_PRECISE = 8_spawnflag; //KONIG - fixed bug
 
 vec3_t FindShamblerOffset(edict_t *self)
 {
@@ -546,6 +546,8 @@
 
 void SP_monster_shambler(edict_t* self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/m_soldier.cpp	2023-10-03 19:43:06
+++ b/m_soldier.cpp	2025-09-04 19:53:48
@@ -1897,6 +1897,8 @@
  */
 void SP_monster_soldier_light(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1923,6 +1925,8 @@
  */
 void SP_monster_soldier(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1944,6 +1948,8 @@
  */
 void SP_monster_soldier_ss(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1975,6 +1981,8 @@
  */
 void SP_monster_soldier_ripper(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -2002,6 +2010,8 @@
  */
 void SP_monster_soldier_hypergun(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -2029,6 +2039,8 @@
  */
 void SP_monster_soldier_lasergun(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- /dev/null
+++ b/m_soldier2.cpp	2025-09-04 19:53:48
@@ -0,0 +1,2159 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+SOLDIER
+
+==============================================================================
+*/
+
+#include "g_local.h"
+#include "m_soldier.h"
+#include "m_flash.h"
+
+static cached_soundindex sound_idle;
+static cached_soundindex sound_sight1;
+static cached_soundindex sound_sight2;
+static cached_soundindex sound_pain_light;
+static cached_soundindex sound_pain;
+static cached_soundindex sound_pain_ss;
+static cached_soundindex sound_death_light;
+static cached_soundindex sound_death;
+static cached_soundindex sound_death_ss;
+static cached_soundindex sound_cock;
+
+void soldier2_start_charge(edict_t* self)
+{
+	self->monsterinfo.aiflags |= AI_CHARGING;
+}
+
+void soldier2_stop_charge(edict_t* self)
+{
+	self->monsterinfo.aiflags &= ~AI_CHARGING;
+}
+
+void soldier2_idle(edict_t* self)
+{
+	if (frandom() > 0.8f)
+		gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+void soldier2_cock(edict_t* self)
+{
+	if (self->s.frame == FRAME_stand322)
+		gi.sound(self, CHAN_WEAPON, sound_cock, 1, ATTN_IDLE, 0);
+	else
+		gi.sound(self, CHAN_WEAPON, sound_cock, 1, ATTN_NORM, 0);
+
+	// [Paril-KEX] reset cockness
+	self->dmg = 0;
+}
+
+// STAND
+
+void soldier2_stand(edict_t* self);
+
+mframe_t soldier2_frames_stand1[] = {
+	{ ai_stand, 0, soldier2_idle },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(soldier2_move_stand1) = { FRAME_stand101, FRAME_stand130, soldier2_frames_stand1, soldier2_stand };
+
+mframe_t soldier2_frames_stand2[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, monster_footstep },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand, 0, monster_footstep }
+};
+MMOVE_T(soldier2_move_stand2) = { FRAME_stand201, FRAME_stand240, soldier2_frames_stand2, soldier2_stand };
+
+mframe_t soldier2_frames_stand3[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand, 0, soldier2_cock },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(soldier2_move_stand3) = { FRAME_stand301, FRAME_stand339, soldier2_frames_stand3, soldier2_stand };
+
+MONSTERINFO_STAND(soldier2_stand) (edict_t* self) -> void
+{
+	float r = frandom();
+
+	if ((self->monsterinfo.active_move != &soldier2_move_stand1) || (r < 0.6f))
+		M_SetAnimation(self, &soldier2_move_stand1);
+	else if (r < 0.8f)
+		M_SetAnimation(self, &soldier2_move_stand2);
+	else
+		M_SetAnimation(self, &soldier2_move_stand3);
+}
+
+//
+// WALK
+//
+
+void soldier2_walk1_random(edict_t* self)
+{
+	if (frandom() > 0.1f)
+		self->monsterinfo.nextframe = FRAME_walk101;
+}
+
+mframe_t soldier2_frames_walk1[] = {
+	{ ai_walk, 3 },
+	{ ai_walk, 6 },
+	{ ai_walk, 2 },
+	{ ai_walk, 2, monster_footstep },
+	{ ai_walk, 2 },
+	{ ai_walk, 1 },
+	{ ai_walk, 6 },
+	{ ai_walk, 5 },
+	{ ai_walk, 3, monster_footstep },
+	{ ai_walk, -1, soldier2_walk1_random },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk },
+	{ ai_walk }
+};
+MMOVE_T(soldier2_move_walk1) = { FRAME_walk101, FRAME_walk133, soldier2_frames_walk1, nullptr };
+
+mframe_t soldier2_frames_walk2[] = {
+	{ ai_walk, 4, monster_footstep },
+	{ ai_walk, 4 },
+	{ ai_walk, 9 },
+	{ ai_walk, 8 },
+	{ ai_walk, 5 },
+	{ ai_walk, 1, monster_footstep },
+	{ ai_walk, 3 },
+	{ ai_walk, 7 },
+	{ ai_walk, 6 },
+	{ ai_walk, 7 }
+};
+MMOVE_T(soldier2_move_walk2) = { FRAME_walk209, FRAME_walk218, soldier2_frames_walk2, nullptr };
+
+MONSTERINFO_WALK(soldier2_walk) (edict_t* self) -> void
+{
+	// [Paril-KEX] during N64 cutscene, always use fast walk or we bog down the line
+	if (!(self->hackflags & HACKFLAG_END_CUTSCENE) && frandom() < 0.5f)
+		M_SetAnimation(self, &soldier2_move_walk1);
+	else
+		M_SetAnimation(self, &soldier2_move_walk2);
+}
+
+//
+// RUN
+//
+
+void soldier2_run(edict_t* self);
+
+mframe_t soldier2_frames_start_run[] = {
+	{ ai_run, 7 },
+	{ ai_run, 5 }
+};
+MMOVE_T(soldier2_move_start_run) = { FRAME_run01, FRAME_run02, soldier2_frames_start_run, soldier2_run };
+
+mframe_t soldier2_frames_run[] = {
+	{ ai_run, 10 },
+	{ ai_run, 11, [](edict_t* self) { monster_done_dodge(self); monster_footstep(self); } },
+	{ ai_run, 11 },
+	{ ai_run, 16 },
+	{ ai_run, 10, monster_footstep },
+	{ ai_run, 15, monster_done_dodge }
+};
+MMOVE_T(soldier2_move_run) = { FRAME_run03, FRAME_run08, soldier2_frames_run, nullptr };
+
+MONSTERINFO_RUN(soldier2_run) (edict_t* self) -> void
+{
+	monster_done_dodge(self);
+
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+	{
+		M_SetAnimation(self, &soldier2_move_stand1);
+		return;
+	}
+
+	if (self->monsterinfo.active_move == &soldier2_move_walk1 ||
+		self->monsterinfo.active_move == &soldier2_move_walk2 ||
+		self->monsterinfo.active_move == &soldier2_move_start_run ||
+		self->monsterinfo.active_move == &soldier2_move_run)
+	{
+		M_SetAnimation(self, &soldier2_move_run);
+	}
+	else
+	{
+		M_SetAnimation(self, &soldier2_move_start_run);
+	}
+}
+
+//
+// PAIN
+//
+
+mframe_t soldier2_frames_pain1[] = {
+	{ ai_move, -3 },
+	{ ai_move, 4 },
+	{ ai_move, 1 },
+	{ ai_move, 1 },
+	{ ai_move }
+};
+MMOVE_T(soldier2_move_pain1) = { FRAME_pain101, FRAME_pain105, soldier2_frames_pain1, soldier2_run };
+
+mframe_t soldier2_frames_pain2[] = {
+	{ ai_move, -13 },
+	{ ai_move, -1 },
+	{ ai_move, 2 },
+	{ ai_move, 4 },
+	{ ai_move, 2 },
+	{ ai_move, 3 },
+	{ ai_move, 2 }
+};
+MMOVE_T(soldier2_move_pain2) = { FRAME_pain201, FRAME_pain207, soldier2_frames_pain2, soldier2_run };
+
+mframe_t soldier2_frames_pain3[] = {
+	{ ai_move, -8 },
+	{ ai_move, 10 },
+	{ ai_move, -4, monster_footstep },
+	{ ai_move, -1 },
+	{ ai_move, -3 },
+	{ ai_move },
+	{ ai_move, 3 },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 1 },
+	{ ai_move },
+	{ ai_move, 1 },
+	{ ai_move, 2 },
+	{ ai_move, 4 },
+	{ ai_move, 3 },
+	{ ai_move, 2, monster_footstep }
+};
+MMOVE_T(soldier2_move_pain3) = { FRAME_pain301, FRAME_pain318, soldier2_frames_pain3, soldier2_run };
+
+mframe_t soldier2_frames_pain4[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, -10 },
+	{ ai_move, -6 },
+	{ ai_move, 8 },
+	{ ai_move, 4 },
+	{ ai_move, 1 },
+	{ ai_move },
+	{ ai_move, 2 },
+	{ ai_move, 5 },
+	{ ai_move, 2 },
+	{ ai_move, -1 },
+	{ ai_move, -1 },
+	{ ai_move, 3 },
+	{ ai_move, 2 },
+	{ ai_move }
+};
+MMOVE_T(soldier2_move_pain4) = { FRAME_pain401, FRAME_pain417, soldier2_frames_pain4, soldier2_run };
+
+PAIN(soldier2_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	float r;
+	int	  n;
+
+	monster_done_dodge(self);
+	soldier2_stop_charge(self);
+
+	// if we're blind firing, this needs to be turned off here
+	self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+
+	if (level.time < self->pain_debounce_time)
+	{
+		if ((self->velocity[2] > 100) && ((self->monsterinfo.active_move == &soldier2_move_pain1) || (self->monsterinfo.active_move == &soldier2_move_pain2) || (self->monsterinfo.active_move == &soldier2_move_pain3)))
+		{
+			// PMM - clear duck flag
+			if (self->monsterinfo.aiflags & AI_DUCKED)
+				monster_duck_up(self);
+			M_SetAnimation(self, &soldier2_move_pain4);
+		}
+		return;
+	}
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	n = self->count | 1;
+	if (n == 1)
+		gi.sound(self, CHAN_VOICE, sound_pain_light, 1, ATTN_NORM, 0);
+	else if (n == 3)
+		gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_pain_ss, 1, ATTN_NORM, 0);
+
+	if (self->velocity[2] > 100)
+	{
+		// PMM - clear duck flag
+		if (self->monsterinfo.aiflags & AI_DUCKED)
+			monster_duck_up(self);
+		M_SetAnimation(self, &soldier2_move_pain4);
+		return;
+	}
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	r = frandom();
+
+	if (r < 0.33f)
+		M_SetAnimation(self, &soldier2_move_pain1);
+	else if (r < 0.66f)
+		M_SetAnimation(self, &soldier2_move_pain2);
+	else
+		M_SetAnimation(self, &soldier2_move_pain3);
+
+	// PMM - clear duck flag
+	if (self->monsterinfo.aiflags & AI_DUCKED)
+		monster_duck_up(self);
+}
+
+MONSTERINFO_SETSKIN(soldier2_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// ATTACK
+//
+
+constexpr monster_muzzleflash_id_t blaster_flash[] = { MZ2_SOLDIER_BLASTER_1, MZ2_SOLDIER_BLASTER_2, MZ2_SOLDIER_BLASTER_3, MZ2_SOLDIER_BLASTER_4, MZ2_SOLDIER_BLASTER_5, MZ2_SOLDIER_BLASTER_6, MZ2_SOLDIER_BLASTER_7, MZ2_SOLDIER_BLASTER_8, MZ2_SOLDIER_BLASTER_9 };
+constexpr monster_muzzleflash_id_t shotgun_flash[] = { MZ2_SOLDIER_SHOTGUN_1, MZ2_SOLDIER_SHOTGUN_2, MZ2_SOLDIER_SHOTGUN_3, MZ2_SOLDIER_SHOTGUN_4, MZ2_SOLDIER_SHOTGUN_5, MZ2_SOLDIER_SHOTGUN_6, MZ2_SOLDIER_SHOTGUN_7, MZ2_SOLDIER_SHOTGUN_8, MZ2_SOLDIER_SHOTGUN_9 };
+constexpr monster_muzzleflash_id_t machinegun_flash[] = { MZ2_SOLDIER_MACHINEGUN_1, MZ2_SOLDIER_MACHINEGUN_2, MZ2_SOLDIER_MACHINEGUN_3, MZ2_SOLDIER_MACHINEGUN_4, MZ2_SOLDIER_MACHINEGUN_5, MZ2_SOLDIER_MACHINEGUN_6, MZ2_SOLDIER_MACHINEGUN_7, MZ2_SOLDIER_MACHINEGUN_8, MZ2_SOLDIER_MACHINEGUN_9 };
+
+void soldier2_fire_vanilla_unseen(edict_t* self, int flash_number, bool angle_limited)
+{
+	vec3_t					 start;
+	vec3_t					 forward, right, up;
+	vec3_t					 aim;
+	vec3_t					 dir;
+	vec3_t					 end;
+	float					 r, u;
+	monster_muzzleflash_id_t flash_index;
+	vec3_t					 aim_norm;
+	float					 angle;
+	vec3_t					 aim_good;
+
+	if (self->count < 2)
+		flash_index = blaster_flash[flash_number];
+	else if (self->count < 4)
+		flash_index = shotgun_flash[flash_number];
+	else
+		flash_index = machinegun_flash[flash_number];
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_index], forward, right);
+
+	if (flash_number == 5 || flash_number == 6) // he's dead
+	{
+		if (self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
+			return;
+
+		aim = forward;
+	}
+	else
+	{
+		if ((!self->enemy) || (!self->enemy->inuse))
+		{
+			self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+			return;
+		}
+
+		// PMM
+		if (self->monsterinfo.attack_state == AS_BLIND)
+			end = self->monsterinfo.blind_fire_target;
+		else
+			end = self->enemy->s.origin;
+		// pmm
+		end[2] += self->enemy->viewheight;
+		aim = end - start;
+		aim_good = end;
+		// PMM
+		if (angle_limited)
+		{
+			aim_norm = aim;
+			aim_norm.normalize();
+			angle = aim_norm.dot(forward);
+			if (angle < 0.5f) // ~25 degree angle
+			{
+				if (level.time >= self->monsterinfo.fire_wait)
+					self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+				else
+					self->monsterinfo.aiflags |= AI_HOLD_FRAME;
+
+				return;
+			}
+		}
+		//-PMM
+		dir = vectoangles(aim);
+		AngleVectors(dir, forward, right, up);
+
+		if (self->count >= 2) //shotgun/machinegun
+		{
+			r = crandom() * 1000;
+			u = crandom() * 500;
+		}
+		else //blaster
+		{
+			r = crandom() * 100;
+			u = crandom() * 50;
+		}
+
+		end = start + (forward * 8192);
+		end += (right * r);
+		end += (up * u);
+
+		aim = end - start;
+		aim.normalize();
+	}
+
+	if (self->count <= 1) //psoldier_light
+	{
+		monster_fire_blaster(self, start, aim, 5, 600, flash_index, EF_BLASTER);
+	}
+	else if (self->count <= 3) //psoldier
+	{
+		monster_fire_shotgun(self, start, aim, 2, 1, 1500, 750, 9, flash_index);
+		// [Paril-KEX] indicates to soldier that he must cock
+		self->dmg = 1;
+	}
+	else if (self->count <= 5) //psoldier_ss
+	{
+		if (!(self->monsterinfo.aiflags & AI_HOLD_FRAME))
+			self->monsterinfo.fire_wait = level.time + random_time(300_ms, 1.1_sec);
+
+		monster_fire_bullet(self, start, aim, 2, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_index);
+
+		if (level.time >= self->monsterinfo.fire_wait)
+			self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+		else
+			self->monsterinfo.aiflags |= AI_HOLD_FRAME;
+	}
+	else //psoldier_captain
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/railgf1a.wav"), 1, ATTN_NORM, 0);
+		monster_fire_railgun(self, start, aim, 35, 100, flash_index);
+	}
+}
+
+constexpr monster_muzzleflash_id_t ripper_flash[] = { MZ2_SOLDIER_RIPPER_1, MZ2_SOLDIER_RIPPER_2, MZ2_SOLDIER_RIPPER_3, MZ2_SOLDIER_RIPPER_4, MZ2_SOLDIER_RIPPER_5, MZ2_SOLDIER_RIPPER_6, MZ2_SOLDIER_RIPPER_7, MZ2_SOLDIER_RIPPER_8, MZ2_SOLDIER_RIPPER_9 };
+constexpr monster_muzzleflash_id_t hyper_flash[] = { MZ2_SOLDIER_HYPERGUN_1, MZ2_SOLDIER_HYPERGUN_2, MZ2_SOLDIER_HYPERGUN_3, MZ2_SOLDIER_HYPERGUN_4, MZ2_SOLDIER_HYPERGUN_5, MZ2_SOLDIER_HYPERGUN_6, MZ2_SOLDIER_HYPERGUN_7, MZ2_SOLDIER_HYPERGUN_8, MZ2_SOLDIER_HYPERGUN_9 };
+
+void soldier2_fire_unseen(edict_t* self, int flash_number, bool angle_limited)
+{
+	vec3_t					 start;
+	vec3_t					 forward, right, up;
+	vec3_t					 aim;
+	vec3_t					 dir;
+	vec3_t					 end;
+	float					 r, u;
+	monster_muzzleflash_id_t flash_index;
+	vec3_t					 aim_norm;
+	float					 angle;
+	vec3_t					 aim_good;
+	int						 spread = 900;
+	int						 idx;
+
+	idx = self->s.frame - FRAME_attak105 + 1;
+
+	if (self->count < 2)
+		flash_index = shotgun_flash[flash_number]; // buckblaster
+	else if (self->count < 4)
+		flash_index = hyper_flash[flash_number]; // flakcannon
+	else
+		flash_index = machinegun_flash[flash_number]; // railgun
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_index], forward, right);
+
+	if (flash_number == 5 || flash_number == 6)
+	{
+		if (self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
+			return;
+
+		aim = forward;
+	}
+	else
+	{
+		// [Paril-KEX] no enemy = no fire
+		if ((!self->enemy) || (!self->enemy->inuse))
+		{
+			self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+			return;
+		}
+
+		// PMM
+		if (self->monsterinfo.attack_state == AS_BLIND)
+			end = self->monsterinfo.blind_fire_target;
+		else
+			end = self->enemy->s.origin;
+		// pmm
+		end[2] += self->enemy->viewheight;
+
+		aim = end - start;
+		aim_good = end;
+
+		// PMM
+		if (angle_limited)
+		{
+			aim_norm = aim;
+			aim_norm.normalize();
+			angle = aim_norm.dot(forward);
+
+			if (angle < 0.5f) // ~25 degree angle
+			{
+				if (level.time >= self->monsterinfo.fire_wait)
+					self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+				else
+					self->monsterinfo.aiflags |= AI_HOLD_FRAME;
+
+				return;
+			}
+		}
+		//-PMM
+
+		dir = vectoangles(aim);
+		AngleVectors(dir, forward, right, up);
+
+		r = crandom() * 1000;
+		u = crandom() * 500;
+		end = start + (forward * 8192);
+		end += (right * r);
+		end += (up * u);
+
+		aim = end - start;
+		aim.normalize();
+	}
+
+	if (self->count <= 1) //psoldier_elite
+	{
+		monster_fire_flakblaster(self, start, aim, 5, 600, spread, spread, 5, flash_index, EF_BLUEHYPERBLASTER, 1);
+	}
+	else if (self->count <= 3) //psoldier_special
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/flakgn.wav"), 1, ATTN_NORM, 0);
+		monster_fire_flakcannon(self, start, aim, 4, 800, spread, spread, 5, flash_index);
+	}
+	else //psoldier_death
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/railgf1a.wav"), 1, ATTN_NORM, 0);
+		monster_fire_railgun(self, start, aim, 35, 100, flash_index);
+	}
+}
+
+void soldier2_fire_ionized(edict_t* self, int flash_number, bool angle_limited)
+{
+	vec3_t					 start;
+	vec3_t					 forward, right, up;
+	vec3_t					 aim;
+	vec3_t					 dir;
+	vec3_t					 end;
+	float					 r, u;
+	monster_muzzleflash_id_t flash_index;
+	vec3_t					 aim_norm;
+	float					 angle;
+	vec3_t					 aim_good;
+	int						 spread = 900;
+
+	if (self->count < 6)
+		flash_index = blaster_flash[flash_number]; // cobalt - deatomizer - disruptor
+	else
+		flash_index = hyper_flash[flash_number];  // discharger
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_index], forward, right);
+
+	if (flash_number == 5 || flash_number == 6)
+	{
+		if (self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
+			return;
+
+		aim = forward;
+	}
+	else
+	{
+		// [Paril-KEX] no enemy = no fire
+		if ((!self->enemy) || (!self->enemy->inuse))
+		{
+			self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+			return;
+		}
+
+		// PMM
+		if (self->monsterinfo.attack_state == AS_BLIND)
+			end = self->monsterinfo.blind_fire_target;
+		else
+			end = self->enemy->s.origin;
+		// pmm
+		end[2] += self->enemy->viewheight;
+
+		aim = end - start;
+		aim_good = end;
+
+		// PMM
+		if (angle_limited)
+		{
+			aim_norm = aim;
+			aim_norm.normalize();
+			angle = aim_norm.dot(forward);
+
+			if (angle < 0.5f) // ~25 degree angle
+			{
+				if (level.time >= self->monsterinfo.fire_wait)
+					self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+				else
+					self->monsterinfo.aiflags |= AI_HOLD_FRAME;
+
+				return;
+			}
+		}
+		//-PMM
+
+		dir = vectoangles(aim);
+		AngleVectors(dir, forward, right, up);
+
+		r = crandom() * 1000;
+		u = crandom() * 500;
+		end = start + (forward * 8192);
+		end += (right * r);
+		end += (up * u);
+
+		aim = end - start;
+		aim.normalize();
+	}
+
+	if (self->count <= 1) // cobalt
+		monster_fire_blaster2(self, start, aim, 5, 800, flash_index, EF_BLASTER);
+	else if (self->count <= 3) // deatomizer
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/disint2.wav"), 1, ATTN_NORM, 0);
+		monster_fire_tracker(self, start, aim, 10, 500, nullptr, flash_index);
+	}
+	else if (self->count <= 5) // disruptor
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/disint2.wav"), 1, ATTN_NORM, 0);
+		monster_fire_tracker(self, start, aim, 10, 1200, nullptr, flash_index);
+	}
+	else // discharger
+	{
+		gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/lhit.wav"), 1, ATTN_NORM, 0);
+		if (!(self->monsterinfo.aiflags & AI_HOLD_FRAME))
+			self->monsterinfo.fire_wait = level.time + random_time(300_ms, 1.1_sec);
+
+		monster_fire_lightning(self, start, aim, 2, 800, flash_index, EF_PLASMA);
+
+		if (level.time >= self->monsterinfo.fire_wait)
+			self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+		else
+			self->monsterinfo.aiflags |= AI_HOLD_FRAME;
+	}
+}
+
+void soldier2_fire(edict_t* self, int flash_number, bool angle_limited)
+{
+	if (self->style == 1)
+		soldier2_fire_unseen(self, flash_number, angle_limited);
+	else if (self->style == 2)
+			soldier2_fire_ionized(self, flash_number, angle_limited);
+	else
+		soldier2_fire_vanilla_unseen(self, flash_number, angle_limited);
+}
+
+// ATTACK1 (blaster/shotgun)
+
+void soldier2_fire1(edict_t* self)
+{
+	soldier2_fire(self, 0, false);
+}
+
+void soldier2_attack1_refire1(edict_t* self)
+{
+	// [Paril-KEX]
+	if (self->count <= 0)
+		self->monsterinfo.nextframe = FRAME_attak110;
+
+	// PMM - blindfire
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+	{
+		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+		return;
+	}
+	// pmm
+
+	if (!self->enemy)
+		return;
+
+	if (self->count > 1)
+		return;
+
+	if (self->enemy->health <= 0)
+		return;
+
+	if (((frandom() < 0.5f) && visible(self, self->enemy)) || (range_to(self, self->enemy) <= RANGE_MELEE))
+		self->monsterinfo.nextframe = FRAME_attak102;
+	else
+		self->monsterinfo.nextframe = FRAME_attak110;
+}
+
+void soldier2_attack1_refire2(edict_t* self)
+{
+	if (!self->enemy)
+		return;
+
+	if (self->count < 2)
+		return;
+
+	if (self->enemy->health <= 0)
+		return;
+
+	if (((self->radius_dmg || frandom() < 0.5f) && visible(self, self->enemy)) || (range_to(self, self->enemy) <= RANGE_MELEE))
+	{
+		self->monsterinfo.nextframe = FRAME_attak102;
+		self->radius_dmg = 0;
+	}
+}
+
+static void soldier2_attack1_shotgun_check(edict_t* self)
+{
+	if (self->dmg)
+	{
+		self->monsterinfo.nextframe = FRAME_attak106;
+		// [Paril-KEX] indicate that we should force a refire
+		self->radius_dmg = 1;
+	}
+}
+
+static void soldier2_blind_check(edict_t* self)
+{
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+	{
+		vec3_t aim = self->monsterinfo.blind_fire_target - self->s.origin;
+		self->ideal_yaw = vectoyaw(aim);
+	}
+}
+
+mframe_t soldier2_frames_attack1[] = {
+	{ ai_charge, 0, soldier2_blind_check },
+	{ ai_charge, 0, soldier2_attack1_shotgun_check },
+	{ ai_charge, 0, soldier2_fire1 },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, soldier2_attack1_refire1 },
+	{ ai_charge },
+	{ ai_charge, 0, soldier2_cock },
+	{ ai_charge, 0, soldier2_attack1_refire2 },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(soldier2_move_attack1) = { FRAME_attak101, FRAME_attak112, soldier2_frames_attack1, soldier2_run };
+
+void soldier2_fire2(edict_t* self)
+{
+	soldier2_fire(self, 1, false);
+}
+
+void soldier2_attack2_refire1(edict_t* self)
+{
+	if (self->count <= 0)
+		self->monsterinfo.nextframe = FRAME_attak216;
+
+	if (!self->enemy)
+		return;
+
+	if (self->count > 1)
+		return;
+
+	if (self->enemy->health <= 0)
+		return;
+
+	if (((frandom() < 0.5f) && visible(self, self->enemy)) || (range_to(self, self->enemy) <= RANGE_MELEE))
+		self->monsterinfo.nextframe = FRAME_attak204;
+}
+
+void soldier2_attack2_refire2(edict_t* self)
+{
+	if (!self->enemy)
+		return;
+
+	if (self->count < 2)
+		return;
+
+	if (self->enemy->health <= 0)
+		return;
+
+	if (((self->radius_dmg || frandom() < 0.5f) && visible(self, self->enemy)) || ((self->style == 0 || self->count < 4) && (range_to(self, self->enemy) <= RANGE_MELEE)))
+	{
+		self->monsterinfo.nextframe = FRAME_attak204;
+		self->radius_dmg = 0;
+	}
+}
+
+static void soldier2_attack2_shotgun_check(edict_t* self)
+{
+	if (self->dmg)
+	{
+		self->monsterinfo.nextframe = FRAME_attak210;
+		// [Paril-KEX] indicate that we should force a refire
+		self->radius_dmg = 1;
+	}
+}
+
+mframe_t soldier2_frames_attack2[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, soldier2_attack2_shotgun_check },
+	{ ai_charge },
+	{ ai_charge, 0, soldier2_fire2 },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, soldier2_attack2_refire1 },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, soldier2_cock },
+	{ ai_charge },
+	{ ai_charge, 0, soldier2_attack2_refire2 },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(soldier2_move_attack2) = { FRAME_attak201, FRAME_attak218, soldier2_frames_attack2, soldier2_run };
+
+// ATTACK3 (duck and shoot)
+void soldier2_fire3(edict_t* self)
+{
+	soldier2_fire(self, 2, false);
+}
+
+void soldier2_attack3_refire(edict_t* self)
+{
+	if (self->dmg)
+		monster_duck_hold(self);
+	else if ((level.time + 400_ms) < self->monsterinfo.duck_wait_time)
+		self->monsterinfo.nextframe = FRAME_attak303;
+}
+
+mframe_t soldier2_frames_attack3[] = {
+	{ ai_charge, 0, monster_duck_down },
+	{ ai_charge },
+	{ ai_charge, 0, soldier2_fire3 },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, soldier2_attack3_refire },
+	{ ai_charge, 0, monster_duck_up },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(soldier2_move_attack3) = { FRAME_attak301, FRAME_attak309, soldier2_frames_attack3, soldier2_run };
+
+// ATTACK4 (machinegun)
+
+void soldier2_fire4(edict_t* self)
+{
+	soldier2_fire(self, 3, false);
+}
+
+mframe_t soldier2_frames_attack4[] = {
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge, 0, soldier2_fire4 },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge }
+};
+MMOVE_T(soldier2_move_attack4) = { FRAME_attak401, FRAME_attak406, soldier2_frames_attack4, soldier2_run };
+
+// ATTACK6 (run & shoot)
+
+void soldier2_fire8(edict_t* self)
+{
+	soldier2_fire(self, 7, true);
+}
+
+void soldier2_attack6_refire1(edict_t* self)
+{
+	// PMM - make sure dodge & charge bits are cleared
+	monster_done_dodge(self);
+	soldier2_stop_charge(self);
+
+	if (!self->enemy)
+		return;
+
+	if (self->count > 1)
+		return;
+
+	if (self->enemy->health <= 0 ||
+		range_to(self, self->enemy) < RANGE_NEAR ||
+		!visible(self, self->enemy)) // don't endlessly run into walls
+	{
+		soldier2_run(self);
+		return;
+	}
+
+	if (frandom() < 0.25f)
+		self->monsterinfo.nextframe = FRAME_runs03;
+	else
+		soldier2_run(self);
+}
+
+void soldier2_attack6_refire2(edict_t* self)
+{
+	// PMM - make sure dodge & charge bits are cleared
+	monster_done_dodge(self);
+	soldier2_stop_charge(self);
+
+	if (!self->enemy || self->count <= 0)
+		return;
+
+	if (self->radius_dmg || frandom() < 0.25f)
+	{
+		self->monsterinfo.nextframe = FRAME_runs03;
+		self->radius_dmg = 0;
+	}
+}
+
+static void soldier2_attack6_shotgun_check(edict_t* self)
+{
+	if (self->dmg)
+	{
+		self->monsterinfo.nextframe = FRAME_runs09;
+		// [Paril-KEX] indicate that we should force a refire
+		self->radius_dmg = 1;
+	}
+}
+
+mframe_t soldier2_frames_attack6[] = {
+	{ ai_run, 10, soldier2_start_charge },
+	{ ai_run, 4, soldier2_attack6_shotgun_check },
+	{ ai_run, 12 },
+	{ ai_run, 11, [](edict_t* self) { soldier2_fire8(self); monster_footstep(self); } },
+	{ ai_run, 13, monster_done_dodge },
+	{ ai_run, 18 },
+	{ ai_run, 15, monster_footstep },
+	{ ai_run, 14, soldier2_attack6_refire1 },
+	{ ai_run, 11 },
+	{ ai_run, 8, monster_footstep },
+	{ ai_run, 11, soldier2_cock },
+	{ ai_run, 12 },
+	{ ai_run, 12, monster_footstep },
+	{ ai_run, 17, soldier2_attack6_refire2 }
+};
+MMOVE_T(soldier2_move_attack6) = { FRAME_runs01, FRAME_runs14, soldier2_frames_attack6, soldier2_run, 0.65f };
+
+MONSTERINFO_ATTACK(soldier2_attack) (edict_t* self) -> void
+{
+	float r, chance;
+
+	monster_done_dodge(self);
+
+	// PMM - blindfire!
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		// setup shot probabilities
+		if (self->monsterinfo.blind_fire_delay < 1_sec)
+			chance = 1.0f;
+		else if (self->monsterinfo.blind_fire_delay < 7.5_sec)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		r = frandom();
+
+		// minimum of 4.1 seconds, plus 0-3, after the shots are done
+		self->monsterinfo.blind_fire_delay += 4.1_sec + random_time(3_sec);
+
+		// don't shoot at the origin
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		// don't shoot if the dice say not to
+		if (r > chance)
+			return;
+
+		// turn on manual steering to signal both manual steering and blindfire
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+
+		M_SetAnimation(self, &soldier2_move_attack1);
+		self->monsterinfo.attack_finished = level.time + random_time(1.5_sec, 2.5_sec);
+		return;
+	}
+	// pmm
+
+	// PMM - added this so the soldiers now run toward you and shoot instead of just stopping and shooting
+	r = frandom();
+
+	// nb: run-shoot not limited by `M_CheckClearShot` since they will be far enough
+	// away that it doesn't matter
+
+	if ((!(self->monsterinfo.aiflags & (AI_BLOCKED | AI_STAND_GROUND))) &&
+		(r < 0.25f &&
+			(self->count <= 3)) &&
+		(range_to(self, self->enemy) >= (RANGE_NEAR * 0.5f)))
+	{
+		M_SetAnimation(self, &soldier2_move_attack6);
+	}
+	else
+	{
+		if (self->count < 4)
+		{
+			bool attack1_possible;
+
+			// [Paril-KEX] shotgun guard only uses attack2 at close range
+			if ((!self->style && self->count >= 2 && self->count <= 3) && range_to(self, self->enemy) <= (RANGE_NEAR * 0.65f))
+				attack1_possible = false;
+			else
+				attack1_possible = M_CheckClearShot(self, monster_flash_offset[MZ2_SOLDIER_BLASTER_1]);
+
+			bool attack2_possible = M_CheckClearShot(self, monster_flash_offset[MZ2_SOLDIER_BLASTER_2]);
+
+			if (attack1_possible && (!attack2_possible || frandom() < 0.5f))
+			{
+				M_SetAnimation(self, &soldier2_move_attack1);
+			}
+			else if (attack2_possible)
+			{
+				M_SetAnimation(self, &soldier2_move_attack2);
+			}
+		}
+		else if (M_CheckClearShot(self, monster_flash_offset[MZ2_SOLDIER_MACHINEGUN_4]))
+		{
+			M_SetAnimation(self, &soldier2_move_attack4);
+		}
+	}
+}
+
+//
+// SIGHT
+//
+
+MONSTERINFO_SIGHT(soldier2_sight) (edict_t* self, edict_t* other) -> void
+{
+	if (frandom() < 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_sight1, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_sight2, 1, ATTN_NORM, 0);
+
+	if (self->enemy && (range_to(self, self->enemy) >= RANGE_NEAR) &&
+		visible(self, self->enemy) // Paril: don't run-shoot if we can't see them
+		)
+	{
+		if (self->count < 4)
+			M_SetAnimation(self, &soldier2_move_attack6);
+	}
+}
+
+//
+// DUCK
+//
+mframe_t soldier2_frames_duck[] = {
+	{ ai_move, 5, monster_duck_down },
+	{ ai_move, -1, monster_duck_hold },
+	{ ai_move, 1 },
+	{ ai_move, 0, monster_duck_up },
+	{ ai_move, 5 }
+};
+MMOVE_T(soldier2_move_duck) = { FRAME_duck01, FRAME_duck05, soldier2_frames_duck, soldier2_run };
+
+extern const mmove_t soldier2_move_trip;
+
+static void soldier2_stand_up(edict_t* self)
+{
+	M_SetAnimation(self, &soldier2_move_trip, false);
+	self->monsterinfo.nextframe = FRAME_runt08;
+}
+
+static bool soldier2_prone_shoot_ok(edict_t* self)
+{
+	if (!self->enemy || !self->enemy->inuse)
+		return false;
+
+	vec3_t fwd;
+	AngleVectors(self->s.angles, fwd, nullptr, nullptr);
+
+	vec3_t diff = self->enemy->s.origin - self->s.origin;
+	diff.z = 0;
+	diff.normalize();
+
+	float v = fwd.dot(diff);
+
+	if (v < 0.80f)
+		return false;
+
+	return true;
+}
+
+static void ai_soldier2_move(edict_t* self, float dist)
+{
+	ai_move(self, dist);
+
+	if (!soldier2_prone_shoot_ok(self))
+	{
+		soldier2_stand_up(self);
+		return;
+	}
+}
+
+void soldier2_fire5(edict_t* self)
+{
+	soldier2_fire(self, 8, true);
+}
+
+mframe_t soldier2_frames_attack5[] = {
+	{ ai_move, 18, monster_duck_down },
+	{ ai_move, 11, monster_footstep },
+	{ ai_move, 0, monster_footstep },
+	{ ai_soldier2_move },
+	{ ai_soldier2_move },
+	{ ai_soldier2_move, 0, soldier2_fire5 },
+	{ ai_soldier2_move },
+	{ ai_soldier2_move },
+};
+MMOVE_T(soldier2_move_attack5) = { FRAME_attak501, FRAME_attak508, soldier2_frames_attack5, soldier2_stand_up };
+
+static void monster_check_prone(edict_t* self)
+{
+	// we're a shotgun guard waiting to cock
+	if (!self->style && self->count >= 2 && self->count <= 3 && self->dmg)
+		return;
+
+	// not going to shoot at this angle
+	if (!soldier2_prone_shoot_ok(self))
+		return;
+
+	M_SetAnimation(self, &soldier2_move_attack5, false);
+}
+
+mframe_t soldier2_frames_trip[] = {
+	{ ai_move, 10 },
+	{ ai_move, 2, monster_check_prone },
+	{ ai_move, 18, monster_duck_down },
+	{ ai_move, 11, monster_footstep },
+	{ ai_move, 9 },
+	{ ai_move, -11, monster_footstep },
+	{ ai_move, -2 },
+	{ ai_move, 0 },
+	{ ai_move, 6 },
+	{ ai_move, -5 },
+	{ ai_move, 0 },
+	{ ai_move, 1 },
+	{ ai_move, 0, monster_footstep },
+	{ ai_move, 0, monster_duck_up },
+	{ ai_move, 3 },
+	{ ai_move, 2, monster_footstep },
+	{ ai_move, -1 },
+	{ ai_move, 2 },
+	{ ai_move, 0 },
+};
+MMOVE_T(soldier2_move_trip) = { FRAME_runt01, FRAME_runt19, soldier2_frames_trip, soldier2_run };
+
+// pmm - blocking code
+
+MONSTERINFO_BLOCKED(soldier2_blocked) (edict_t* self, float dist) -> bool
+{
+	// don't do anything if you're dodging
+	if ((self->monsterinfo.aiflags & AI_DODGING) || (self->monsterinfo.aiflags & AI_DUCKED))
+		return false;
+
+	return blocked_checkplat(self, dist);
+}
+
+//
+// DEATH
+//
+
+void soldier2_fire6(edict_t* self)
+{
+	soldier2_fire(self, 5, false);
+
+	if (self->dmg)
+		self->monsterinfo.nextframe = FRAME_death126;
+}
+
+void soldier2_fire7(edict_t* self)
+{
+	soldier2_fire(self, 6, false);
+}
+
+void soldier2_dead(edict_t* self)
+{
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, -8 };
+	monster_dead(self);
+}
+
+static void soldier2_death_shrink(edict_t* self)
+{
+	self->svflags |= SVF_DEADMONSTER;
+	self->maxs[2] = 0;
+	gi.linkentity(self);
+}
+
+mframe_t soldier2_frames_death1[] = {
+	{ ai_move },
+	{ ai_move, -10 },
+	{ ai_move, -10 },
+	{ ai_move, -10, soldier2_death_shrink },
+	{ ai_move, -5 },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move, 0, soldier2_fire6 },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, soldier2_fire7 },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(soldier2_move_death1) = { FRAME_death101, FRAME_death136, soldier2_frames_death1, soldier2_dead };
+
+mframe_t soldier2_frames_death2[] = {
+	{ ai_move, -5 },
+	{ ai_move, -5 },
+	{ ai_move, -5 },
+	{ ai_move, 0, soldier2_death_shrink },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(soldier2_move_death2) = { FRAME_death201, FRAME_death235, soldier2_frames_death2, soldier2_dead };
+
+mframe_t soldier2_frames_death3[] = {
+	{ ai_move, -5 },
+	{ ai_move, -5 },
+	{ ai_move, -5 },
+	{ ai_move, 0, soldier2_death_shrink },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+};
+MMOVE_T(soldier2_move_death3) = { FRAME_death301, FRAME_death345, soldier2_frames_death3, soldier2_dead };
+
+mframe_t soldier2_frames_death4[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 1.5f },
+	{ ai_move, 2.5f },
+	{ ai_move, -1.5f },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, -0.5f },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move, 4.0f },
+	{ ai_move, 4.0f },
+	{ ai_move, 8.0f, soldier2_death_shrink },
+	{ ai_move, 8.0f },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 5.5f },
+
+	{ ai_move, 2.5f },
+	{ ai_move, -2.0f },
+	{ ai_move, -2.0f }
+};
+MMOVE_T(soldier2_move_death4) = { FRAME_death401, FRAME_death453, soldier2_frames_death4, soldier2_dead };
+
+mframe_t soldier2_frames_death5[] = {
+	{ ai_move, -5 },
+	{ ai_move, -5 },
+	{ ai_move, -5 },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, soldier2_death_shrink },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(soldier2_move_death5) = { FRAME_death501, FRAME_death524, soldier2_frames_death5, soldier2_dead };
+
+mframe_t soldier2_frames_death6[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, soldier2_death_shrink },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(soldier2_move_death6) = { FRAME_death601, FRAME_death610, soldier2_frames_death6, soldier2_dead };
+
+DIE(soldier2_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	int n;
+
+	// check for gib
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		if (self->beam)
+		{
+			G_FreeEdict(self->beam);
+			self->beam = nullptr;
+		}
+
+		ThrowGibs(self, damage, {
+			{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+			{ "models/objects/gibs/bone2/tris.md2" },
+			{ "models/objects/gibs/bone/tris.md2" },
+			{ "models/monsters/soldier2/gibs/arm.md2", GIB_SKINNED },
+			{ "models/monsters/soldier2/gibs/gun.md2", GIB_SKINNED | GIB_UPRIGHT },
+			{ "models/monsters/soldier2/gibs/chest.md2", GIB_SKINNED },
+			{ "models/monsters/soldier2/gibs/head.md2", GIB_HEAD | GIB_SKINNED }
+			});
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	// regular death
+	self->deadflag = true;
+	self->takedamage = true;
+
+	n = self->count | 1;
+
+	if (n == 1)
+		gi.sound(self, CHAN_VOICE, sound_death_light, 1, ATTN_NORM, 0);
+	else if (n == 3)
+		gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	else // (n == 5)
+		gi.sound(self, CHAN_VOICE, sound_death_ss, 1, ATTN_NORM, 0);
+
+	if (fabsf((self->s.origin[2] + self->viewheight) - point[2]) <= 4 &&
+		self->velocity.z < 65.f)
+	{
+		// head shot
+		M_SetAnimation(self, &soldier2_move_death3);
+		return;
+	}
+
+	// if we die while on the ground, do a quicker death4
+	if (self->monsterinfo.active_move == &soldier2_move_trip ||
+		self->monsterinfo.active_move == &soldier2_move_attack5)
+	{
+		M_SetAnimation(self, &soldier2_move_death4);
+		self->monsterinfo.nextframe = FRAME_death413;
+		soldier2_death_shrink(self);
+		return;
+	}
+
+	// only do the spin-death if we have enough velocity to justify it
+	if (self->velocity.z > 65.f || self->velocity.length() > 150.f)
+		n = irandom(5);
+	else
+		n = irandom(4);
+
+	if (n == 0)
+		M_SetAnimation(self, &soldier2_move_death1);
+	else if (n == 1)
+		M_SetAnimation(self, &soldier2_move_death2);
+	else if (n == 2)
+		M_SetAnimation(self, &soldier2_move_death4);
+	else if (n == 3)
+		M_SetAnimation(self, &soldier2_move_death5);
+	else
+		M_SetAnimation(self, &soldier2_move_death6);
+}
+
+//
+// NEW DODGE CODE
+//
+
+MONSTERINFO_SIDESTEP(soldier2_sidestep) (edict_t* self) -> bool
+{
+	// don't sidestep during trip or up pain
+	if (self->monsterinfo.active_move == &soldier2_move_trip ||
+		self->monsterinfo.active_move == &soldier2_move_attack5 ||
+		self->monsterinfo.active_move == &soldier2_move_pain4)
+		return false;
+
+	if (self->count <= 3)
+	{
+		if (self->monsterinfo.active_move != &soldier2_move_attack6)
+		{
+			M_SetAnimation(self, &soldier2_move_attack6);
+		}
+	}
+	else
+	{
+		if (self->monsterinfo.active_move != &soldier2_move_start_run &&
+			self->monsterinfo.active_move != &soldier2_move_run)
+		{
+			M_SetAnimation(self, &soldier2_move_start_run);
+		}
+	}
+
+	return true;
+}
+
+MONSTERINFO_DUCK(soldier2_duck) (edict_t* self, gtime_t eta) -> bool
+{
+	self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+
+	if (self->monsterinfo.active_move == &soldier2_move_attack6)
+	{
+		M_SetAnimation(self, &soldier2_move_trip);
+	}
+	else if (self->dmg || brandom())
+	{
+		M_SetAnimation(self, &soldier2_move_duck);
+	}
+	else
+	{
+		M_SetAnimation(self, &soldier2_move_attack3);
+	}
+
+	return true;
+}
+
+//=========
+// ROGUE
+void soldier2_blind(edict_t* self);
+
+mframe_t soldier2_frames_blind[] = {
+	{ ai_move, 0, soldier2_idle },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(soldier2_move_blind) = { FRAME_stand101, FRAME_stand130, soldier2_frames_blind, soldier2_blind };
+
+MONSTERINFO_STAND(soldier2_blind) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &soldier2_move_blind);
+}
+// ROGUE
+//=========
+
+//
+// SPAWN
+//
+
+constexpr spawnflags_t SPAWNFLAG_SOLDIER_BLIND = 8_spawnflag;
+
+void SP_monster_soldier2_x(edict_t* self)
+{
+	self->s.modelindex = gi.modelindex("models/monsters/soldier2/tris.md2");
+	self->monsterinfo.scale = MODEL_SCALE;
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 32 };
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	sound_idle.assign("soldier2/solidle1.wav");
+	sound_sight1.assign("soldier2/solsght1.wav");
+	sound_sight2.assign("soldier2/solsrch1.wav");
+	sound_cock.assign("infantry/infatck3.wav");
+
+	gi.modelindex("models/monsters/soldier2/gibs/head.md2");
+	gi.modelindex("models/monsters/soldier2/gibs/gun.md2");
+	gi.modelindex("models/monsters/soldier2/gibs/arm.md2");
+	gi.modelindex("models/monsters/soldier2/gibs/chest.md2");
+
+	self->mass = 100;
+
+	self->pain = soldier2_pain;
+	self->die = soldier2_die;
+
+	self->monsterinfo.stand = soldier2_stand;
+	self->monsterinfo.walk = soldier2_walk;
+	self->monsterinfo.run = soldier2_run;
+	self->monsterinfo.dodge = M_MonsterDodge;
+	self->monsterinfo.attack = soldier2_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = soldier2_sight;
+	self->monsterinfo.setskin = soldier2_setskin;
+
+	//=====
+	// ROGUE
+	self->monsterinfo.blocked = soldier2_blocked;
+	self->monsterinfo.duck = soldier2_duck;
+	self->monsterinfo.unduck = monster_duck_up;
+	self->monsterinfo.sidestep = soldier2_sidestep;
+
+	if (self->spawnflags.has(SPAWNFLAG_SOLDIER_BLIND)) // blind
+		self->monsterinfo.stand = soldier2_blind;
+	// ROGUE
+	//=====
+
+	gi.linkentity(self);
+
+	self->monsterinfo.stand(self);
+
+	walkmonster_start(self);
+}
+
+//UNSEEN
+/*QUAKED monster_psoldier_light (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+ */
+void SP_monster_psoldier_light(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_soldier2_x(self);
+
+	sound_pain_light.assign("soldier2/solpain2.wav");
+	sound_death_light.assign("soldier2/soldeth2.wav");
+	gi.modelindex("models/objects/laser/tris.md2");
+	gi.soundindex("misc/lasfly.wav");
+	gi.soundindex("soldier/solatack2.wav");
+
+	self->s.skinnum = 0;
+	self->count = self->s.skinnum;
+	self->health = self->max_health = 30 * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 100;
+	self->gib_health = -30;
+
+	// PMM - blindfire
+	self->monsterinfo.blindfire = true;
+}
+
+/*QUAKED monster_psoldier (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+ */
+void SP_monster_psoldier(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_soldier2_x(self);
+
+	sound_pain.assign("soldier2/solpain1.wav");
+	sound_death.assign("soldier2/soldeth1.wav");
+	gi.soundindex("soldier/solatack1.wav");
+
+	self->s.skinnum = 2;
+	self->count = self->s.skinnum;
+	self->health = self->max_health = 40 * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 100;
+	self->gib_health = -30;
+}
+
+/*QUAKED monster_psoldier_ss (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+ */
+void SP_monster_psoldier_ss(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_soldier2_x(self);
+
+	sound_pain_ss.assign("soldier2/solpain3.wav");
+	sound_death_ss.assign("soldier2/soldeth3.wav");
+	gi.soundindex("soldier/solatack3.wav");
+
+	self->s.skinnum = 4;
+	self->count = self->s.skinnum;
+	self->health = self->max_health = 50 * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 100;
+	self->gib_health = -30;
+}
+
+//
+// SPAWN
+//
+
+void SP_monster_soldier2_h(edict_t* self)
+{
+	SP_monster_soldier2_x(self);
+	self->style = 1;
+}
+
+/*QUAKED monster_psoldier_elite (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+ */
+void SP_monster_psoldier_elite(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_soldier2_h(self);
+
+	sound_pain_light.assign("soldier2/solpain2.wav");
+	sound_death_light.assign("soldier2/soldeth2.wav");
+
+	gi.modelindex("models/objects/boomrang/tris.md2");
+	gi.soundindex("misc/lasfly.wav");
+	gi.soundindex("soldier/solatack2.wav");
+
+	self->s.skinnum = 6;
+	self->count = self->s.skinnum - 6;
+	self->health = self->max_health = 40 * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 100;
+	self->gib_health = -30;
+
+	// PMM - blindfire
+	self->monsterinfo.blindfire = true;
+}
+
+/*QUAKED monster_psoldier_special (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+ */
+void SP_monster_psoldier_special(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_soldier2_h(self);
+
+	gi.modelindex("models/objects/laser/tris.md2");
+	sound_pain.assign("soldier2/solpain1.wav");
+	sound_death.assign("soldier2/soldeth1.wav");
+	gi.soundindex("soldier/solatck1.wav");
+	gi.soundindex("weapons/flakgn.wav");
+
+	self->s.skinnum = 8;
+	self->count = self->s.skinnum - 6;
+	self->health = self->max_health = 50 * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 100;
+	self->gib_health = -30;
+
+	// PMM - blindfire
+	self->monsterinfo.blindfire = true;
+}
+
+/*QUAKED monster_psoldier_death (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+ */
+void SP_monster_psoldier_death(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_soldier2_h(self);
+
+	sound_pain_ss.assign("soldier2/solpain3.wav");
+	sound_death_ss.assign("soldier2/soldeth3.wav");
+	gi.soundindex("soldier/solatck3.wav");
+
+	self->s.skinnum = 10;
+	self->count = self->s.skinnum - 6;
+	self->health = self->max_health = 60 * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 100;
+	self->gib_health = -30;
+}
+
+/*QUAKED monster_psoldier_captain (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+ */
+void SP_monster_psoldier_captain(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_soldier2_h(self);
+
+	sound_pain_ss.assign("soldier2/solpain3.wav");
+	sound_death_ss.assign("soldier2/soldeth3.wav");
+	gi.soundindex("soldier/solatck3.wav");
+
+	self->s.skinnum = 12;
+	self->count = self->s.skinnum - 8;
+	self->health = self->max_health = 280 * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 200;
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SCREEN;
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = 200;
+	self->gib_health = -50;
+}
+//CITADEL-25A-OBLIVION-IONIZED
+void SP_monster_soldier2_k(edict_t* self)
+{
+	SP_monster_soldier2_x(self);
+	self->style = 2;
+
+	self->s.modelindex = gi.modelindex("models/monsters/soldier3/tris.md2");
+
+	gi.modelindex("models/monsters/soldier3/gibs/head.md2");
+	gi.modelindex("models/monsters/soldier3/gibs/gun.md2");
+	gi.modelindex("models/monsters/soldier3/gibs/arm.md2");
+	gi.modelindex("models/monsters/soldier3/gibs/chest.md2");
+}
+
+/*QUAKED monster_soldier_cobalt (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+ */
+void SP_monster_soldier_cobalt(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_soldier2_k(self);
+
+	sound_pain_light.assign("soldier2/solpain2.wav");
+	sound_death_light.assign("soldier2/soldeth2.wav");
+	gi.modelindex("models/objects/laser/tris.md2");
+	gi.soundindex("misc/lasfly.wav");
+	gi.soundindex("soldier/solatck2.wav");
+
+	self->s.skinnum = 0;
+	self->count = self->s.skinnum;
+
+	self->health = self->max_health = 60 * st.health_multiplier;
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SCREEN;
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = 100;
+	self->gib_health = -50;
+
+	// PMM - blindfire
+	self->monsterinfo.blindfire = true;
+}
+
+void SP_monster_soldier_deatom(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_soldier2_k(self);
+
+	sound_pain_ss.assign("soldier3/pain.wav");
+	sound_death_ss.assign("soldier3/deth3.wav");
+	sound_idle.assign("soldier3/idle.wav");
+	sound_sight1.assign("soldier3/sight1.wav");
+	sound_sight2.assign("soldier3/sight2.wav");
+	gi.soundindex("weapons/disrupt.wav");
+	gi.soundindex("weapons/disint2.wav");
+
+	self->s.skinnum = 2;
+	self->count = self->s.skinnum;
+
+	self->health = self->max_health = 80 * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 100;
+	self->gib_health = -50;
+}
+
+void SP_monster_soldier_dist(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_soldier2_k(self);
+
+	sound_pain_ss.assign("soldier3/pain.wav");
+	sound_death_ss.assign("soldier3/deth3.wav");
+	sound_idle.assign("soldier3/idle.wav");
+	sound_sight1.assign("soldier3/sight1.wav");
+	sound_sight2.assign("soldier3/sight2.wav");
+	gi.soundindex("weapons/disrupt.wav");
+	gi.soundindex("weapons/disint2.wav");
+
+	self->s.skinnum = 4;
+	self->count = self->s.skinnum;
+
+	self->health = self->max_health = 80 * st.health_multiplier;
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SCREEN;
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = 100;
+	self->gib_health = -50;
+}
+
+void SP_monster_soldier_discharger(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	SP_monster_soldier2_k(self);
+
+	sound_pain_ss.assign("soldier3/pain.wav");
+	sound_death_ss.assign("soldier3/deth3.wav");
+	sound_idle.assign("soldier3/idle.wav");
+	sound_sight1.assign("soldier3/sight1.wav");
+	sound_sight2.assign("soldier3/sight2.wav");
+	gi.soundindex("weapons/tesla.wav");
+
+	self->s.skinnum = 6;
+	self->count = self->s.skinnum;
+
+	self->health = self->max_health = 70 * st.health_multiplier;
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SCREEN;
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = 100;
+	self->gib_health = -50;
+}
--- a/m_supertank.cpp	2023-10-03 19:43:06
+++ b/m_supertank.cpp	2025-09-04 19:53:48
@@ -12,7 +12,7 @@
 #include "m_supertank.h"
 #include "m_flash.h"
 
-constexpr spawnflags_t SPAWNFLAG_SUPERTANK_POWERSHIELD = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_SUPERTANK_HEATSEEKING = 8_spawnflag;
 // n64
 constexpr spawnflags_t SPAWNFLAG_SUPERTANK_LONG_DEATH = 16_spawnflag;
 
@@ -24,6 +24,9 @@
 static cached_soundindex sound_search2;
 
 static cached_soundindex tread_sound;
+
+/* KONIG - universal boss powerup copy */
+void BossPowerups(edict_t* self);
 
 void TreadSound(edict_t *self)
 {
@@ -471,7 +474,7 @@
 	AngleVectors(self->s.angles, forward, right, nullptr);
 	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
 
-	if (self->spawnflags.has(SPAWNFLAG_SUPERTANK_POWERSHIELD))
+	if (self->spawnflags.has(SPAWNFLAG_SUPERTANK_HEATSEEKING))
 	{
 		vec = self->enemy->s.origin;
 		vec[2] += self->enemy->viewheight;
@@ -622,9 +625,16 @@
 
 	return false;
 }
-// PGM
-//===========
-
+
+MONSTERINFO_CHECKATTACK(supertank_checkattack) (edict_t* self) -> bool
+{
+	if (!self->enemy)
+		return false;
+
+	BossPowerups(self);
+
+	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.6f, 0.7f, 0.85f, 0.f);
+}
 //
 // monster_supertank
 //
@@ -635,6 +645,8 @@
  */
 void SP_monster_supertank(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -669,7 +681,47 @@
 	self->mins = { -64, -64, 0 };
 	self->maxs = { 64, 64, 112 };
 
-	self->health = 1500 * st.health_multiplier;
+	/* KONIG - GZ health scaling; adding body armor*/
+	self->health = max(1500, 1500 + 1000 * (skill->integer - 1)) * st.health_multiplier;
+	if (coop->integer)
+		self->health += (250 * (CountPlayers() - 1));
+
+	if (strcmp(self->classname, "monster_boss5") == 0)
+	{
+		if (!st.was_key_specified("power_armor_type"))
+			self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+		if (!st.was_key_specified("power_armor_power"))
+			self->monsterinfo.power_armor_power = max(350, 350 + 100 * (skill->integer - 1));
+		if (coop->integer)
+			self->monsterinfo.power_armor_power += (100 * (CountPlayers() - 1));
+	}
+	else if (strcmp(self->classname, "monster_boss5_gamma") == 0)
+	{
+		self->health = max(3000, 3000 + 1000 * (skill->integer - 1)) * st.health_multiplier;
+
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_BODY;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = max(350, 350 + 100 * (skill->integer - 1));
+		if (!st.was_key_specified("power_armor_type"))
+			self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+		if (!st.was_key_specified("power_armor_power"))
+			self->monsterinfo.power_armor_power = max(350, 350 + 100 * (skill->integer - 1));
+		if (coop->integer)
+		{
+			self->monsterinfo.armor_power += (100 * (CountPlayers() - 1));
+			self->monsterinfo.power_armor_power += (100 * (CountPlayers() - 1));
+		}
+	}
+	else
+	{
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_BODY;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = max(350, 350 + 100 * (skill->integer - 1));
+		if (coop->integer)
+			self->monsterinfo.armor_power += (100 * (CountPlayers() - 1));
+	}
 	self->gib_health = -500;
 	self->mass = 800;
 
@@ -684,22 +736,13 @@
 	self->monsterinfo.melee = nullptr;
 	self->monsterinfo.sight = nullptr;
 	self->monsterinfo.blocked = supertank_blocked; // PGM
+	self->monsterinfo.checkattack = supertank_checkattack;
 	self->monsterinfo.setskin = supertank_setskin;
 
 	gi.linkentity(self);
 
 	M_SetAnimation(self, &supertank_move_stand);
 	self->monsterinfo.scale = MODEL_SCALE;
-
-	// RAFAEL
-	if (self->spawnflags.has(SPAWNFLAG_SUPERTANK_POWERSHIELD))
-	{
-		if (!st.was_key_specified("power_armor_type"))
-			self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
-		if (!st.was_key_specified("power_armor_power"))
-			self->monsterinfo.power_armor_power = 400;
-	}
-	// RAFAEL
 
 	walkmonster_start(self);
 
@@ -724,8 +767,27 @@
  */
 void SP_monster_boss5(edict_t *self)
 {
-	self->spawnflags |= SPAWNFLAG_SUPERTANK_POWERSHIELD;
+	self->spawnflags |= SPAWNFLAG_SUPERTANK_HEATSEEKING;
 	SP_monster_supertank(self);
 	gi.soundindex("weapons/railgr1a.wav");
 	self->s.skinnum = 2;
 }
+
+//Citadel boss
+/*QUAKED monster_boss5_gamma (1 .5 0) (-64 -64 0) (64 64 72) Ambush Trigger_Spawn Sight
+ */
+void SP_monster_boss5_gamma(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	self->spawnflags |= SPAWNFLAG_SUPERTANK_HEATSEEKING;
+	SP_monster_supertank(self);
+	gi.soundindex("weapons/railgr1a.wav");
+	self->s.skinnum = 4;
+
+	if (!self->s.scale)
+		self->s.scale = 1.25f;
+
+	self->mins = { -80, -80, 0 };
+	self->maxs = { 80, 80, 128 };
+}
--- a/m_tank.cpp	2023-10-03 19:43:06
+++ b/m_tank.cpp	2025-09-04 19:53:48
@@ -25,8 +25,12 @@
 static cached_soundindex sound_windup;
 static cached_soundindex sound_strike;
 
-constexpr spawnflags_t SPAWNFLAG_TANK_COMMANDER_GUARDIAN = 8_spawnflag;
-constexpr spawnflags_t SPAWNFLAG_TANK_COMMANDER_HEAT_SEEKING = 16_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_TANK_GUARDIAN = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_TANK_HEAT_SEEKING = 16_spawnflag;
+
+/* KONIG - universal boss powerup copy; melee attack */
+void BossPowerups(edict_t* self);
+void T_SlamRadiusDamage(vec3_t point, edict_t* inflictor, edict_t* attacker, float damage, float kick, edict_t* ignore, float radius, mod_t mod);
 
 //
 // misc
@@ -391,7 +395,23 @@
 		PredictAim(self, self->enemy, start, 0, false, 0.f, &dir, nullptr);
 	// pmm
 
-	monster_fire_blaster(self, start, dir, 30, 800, flash_number, EF_BLASTER);
+	/*KONIG - Tanks now use blue blaster, slightly slower; Guardians use buckblasters*/
+	if (self->count == 3)
+	{
+		monster_fire_flakblaster(self, start, dir, 15, 800, 500, 800, max(3, 3 + 2 * (skill->integer - 2)), flash_number, EF_BLASTER, 2);
+	}
+	else if (self->count == 2)
+	{
+		monster_fire_flakblaster(self, start, dir, 15, 600, 500, 800, max(3, 3 + 2 * (skill->integer - 2)), flash_number, EF_BLASTER, 0);
+	}
+	else if (self->count == 1)
+	{
+		monster_fire_blaster(self, start, dir, 30, 800, flash_number, EF_BLASTER);
+	}
+	else
+	{
+		monster_fire_blueblaster(self, start, dir, 30, 600, flash_number, EF_BLUEHYPERBLASTER);
+	}
 }
 
 void TankStrike(edict_t *self)
@@ -429,7 +449,7 @@
 
 	if (self->speed)
 		rocketSpeed = self->speed;
-	else if (self->spawnflags.has(SPAWNFLAG_TANK_COMMANDER_HEAT_SEEKING))
+	else if (self->spawnflags.has(SPAWNFLAG_TANK_HEAT_SEEKING))
 		rocketSpeed = 500;
 	else
 		rocketSpeed = 650;
@@ -481,7 +501,7 @@
 		// blindfire has different fail criteria for the trace
 		if (M_AdjustBlindfireTarget(self, start, vec, right, dir))
 		{
-			if (self->spawnflags.has(SPAWNFLAG_TANK_COMMANDER_HEAT_SEEKING))
+			if (self->spawnflags.has(SPAWNFLAG_TANK_HEAT_SEEKING))
 				monster_fire_heat(self, start, dir, 50, rocketSpeed, flash_number, self->accel);
 			else
 				monster_fire_rocket(self, start, dir, 50, rocketSpeed, flash_number);
@@ -493,7 +513,7 @@
 
 		if (trace.fraction > 0.5f || trace.ent->solid != SOLID_BSP)
 		{
-			if (self->spawnflags.has(SPAWNFLAG_TANK_COMMANDER_HEAT_SEEKING))
+			if (self->spawnflags.has(SPAWNFLAG_TANK_HEAT_SEEKING))
 				monster_fire_heat(self, start, dir, 50, rocketSpeed, flash_number, self->accel);
 			else
 				monster_fire_rocket(self, start, dir, 50, rocketSpeed, flash_number);
@@ -538,7 +558,11 @@
 
 	AngleVectors(dir, forward, nullptr, nullptr);
 
-	monster_fire_bullet(self, start, forward, 20, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
+	/*KONIG - Commander hits slightly harder; Commander Guardian uses railgun */
+	if (self->count >= 2)
+		monster_fire_railgun(self, start, forward, 40, 100, flash_number);
+	else
+		monster_fire_bullet(self, start, forward, 20, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, flash_number);
 }
 
 static void tank_blind_check(edict_t *self)
@@ -898,22 +922,70 @@
 // death
 //
 
-void tank_dead(edict_t *self)
-{
-	self->mins = { -16, -16, -16 };
-	self->maxs = { 16, 16, -0 };
-	monster_dead(self);
-}
-
-static void tank_shrink(edict_t *self)
-{
-	self->maxs[2] = 0;
-	self->svflags |= SVF_DEADMONSTER;
-	gi.linkentity(self);
+/* KONIG - Faithful n64 explosions on spawnflags */
+
+static void tank_gib(edict_t* self)
+{
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_EXPLOSION1_BIG);
+	gi.WritePosition(self->s.origin);
+	gi.multicast(self->s.origin, MULTICAST_PHS, false);
+
+	self->s.sound = 0;
+	self->s.skinnum /= 2;
+
+	ThrowGibs(self, 500, {
+				{ "models/objects/gibs/sm_meat/tris.md2" },
+				{ 3, "models/objects/gibs/sm_metal/tris.md2", GIB_METALLIC },
+				{ "models/objects/gibs/gear/tris.md2", GIB_METALLIC },
+				{ 2, "models/monsters/tank/gibs/foot.md2", GIB_SKINNED | GIB_METALLIC },
+				{ 2, "models/monsters/tank/gibs/thigh.md2", GIB_SKINNED | GIB_METALLIC },
+				{ "models/monsters/tank/gibs/chest.md2", GIB_SKINNED },
+				{ "models/monsters/tank/gibs/head.md2", GIB_HEAD | GIB_SKINNED }
+		});
+}
+
+void tank_dead(edict_t* self)
+{
+
+	// no blowy on deady
+	if (self->spawnflags.has(SPAWNFLAG_TANK_GUARDIAN))
+	{
+		if (self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
+		{
+			self->deadflag = false;
+			self->takedamage = true;
+			return;
+		}
+
+		tank_gib(self);
+	}
+	else
+	{
+		self->mins = { -16, -16, -16 };
+		self->maxs = { 16, 16, -0 };
+		monster_dead(self);
+	}
+}
+
+static void tank_shrink(edict_t* self)
+{
+	if (!self->spawnflags.has(SPAWNFLAG_TANK_GUARDIAN))
+	{
+		self->maxs[2] = 0;
+		self->svflags |= SVF_DEADMONSTER;
+		gi.linkentity(self);
+	}
+}
+
+static void TankExplode(edict_t* self)
+{
+	if (self->spawnflags.has(SPAWNFLAG_TANK_GUARDIAN))
+		BossExplode(self);
 }
 
 mframe_t tank_frames_death1[] = {
-	{ ai_move, -7 },
+	{ ai_move, -7, TankExplode },
 	{ ai_move, -2 },
 	{ ai_move, -2 },
 	{ ai_move, 1 },
@@ -950,55 +1022,78 @@
 
 DIE(tank_die) (edict_t *self, edict_t *inflictor, edict_t *attacker, int damage, const vec3_t &point, const mod_t &mod) -> void
 {
-	// check for gib
-	if (M_CheckGib(self, mod))
-	{
-		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
-
-		self->s.skinnum /= 2;
-
-		ThrowGibs(self, damage, {
-			{ "models/objects/gibs/sm_meat/tris.md2" },
-			{ 3, "models/objects/gibs/sm_metal/tris.md2", GIB_METALLIC },
-			{ "models/objects/gibs/gear/tris.md2", GIB_METALLIC },
-			{ 2, "models/monsters/tank/gibs/foot.md2", GIB_SKINNED | GIB_METALLIC },
-			{ 2, "models/monsters/tank/gibs/thigh.md2", GIB_SKINNED | GIB_METALLIC },
-			{ "models/monsters/tank/gibs/chest.md2", GIB_SKINNED },
-			{ "models/monsters/tank/gibs/head.md2", GIB_HEAD | GIB_SKINNED }
-		});
-
+	if (self->spawnflags.has(SPAWNFLAG_TANK_GUARDIAN) && self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
+	{
+		// check for gib
+		if (M_CheckGib(self, mod))
+		{
+			tank_gib(self);
+			self->deadflag = true;
+			return;
+		}
+
+		if (self->deadflag)
+			return;
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_TANK_GUARDIAN))
+	{
+		gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
+		self->deadflag = true;
+		self->takedamage = false;
+	}
+	else
+	{
+
+		// check for gib
+		if (M_CheckGib(self, mod))
+		{
+			gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+			self->s.skinnum /= 2;
+
+			ThrowGibs(self, damage, {
+				{ "models/objects/gibs/sm_meat/tris.md2" },
+				{ 3, "models/objects/gibs/sm_metal/tris.md2", GIB_METALLIC },
+				{ "models/objects/gibs/gear/tris.md2", GIB_METALLIC },
+				{ 2, "models/monsters/tank/gibs/foot.md2", GIB_SKINNED | GIB_METALLIC },
+				{ 2, "models/monsters/tank/gibs/thigh.md2", GIB_SKINNED | GIB_METALLIC },
+				{ "models/monsters/tank/gibs/chest.md2", GIB_SKINNED },
+				{ "models/monsters/tank/gibs/head.md2", GIB_HEAD | GIB_SKINNED }
+				});
+
+			if (!self->style)
+				ThrowGib(self, "models/monsters/tank/gibs/barm.md2", damage, GIB_SKINNED | GIB_UPRIGHT, self->s.scale);
+
+			self->deadflag = true;
+			return;
+		}
+
+		if (self->deadflag)
+			return;
+
+		// [Paril-KEX] dropped arm
 		if (!self->style)
-			ThrowGib(self, "models/monsters/tank/gibs/barm.md2", damage, GIB_SKINNED | GIB_UPRIGHT, self->s.scale);
-
+		{
+			self->style = 1;
+
+			auto [fwd, rgt, up] = AngleVectors(self->s.angles);
+
+			edict_t* arm_gib = ThrowGib(self, "models/monsters/tank/gibs/barm.md2", damage, GIB_SKINNED | GIB_UPRIGHT, self->s.scale);
+			arm_gib->s.origin = self->s.origin + (rgt * -16.f) + (up * 23.f);
+			arm_gib->s.old_origin = arm_gib->s.origin;
+			arm_gib->avelocity = { crandom() * 15.f, crandom() * 15.f, 180.f };
+			arm_gib->velocity = (up * 100.f) + (rgt * -120.f);
+			arm_gib->s.angles = self->s.angles;
+			arm_gib->s.angles[2] = -90.f;
+			arm_gib->s.skinnum /= 2;
+			gi.linkentity(arm_gib);
+		}
+
+		// regular death
+		gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
 		self->deadflag = true;
-		return;
-	}
-
-	if (self->deadflag)
-		return;
-
-	// [Paril-KEX] dropped arm
-	if (!self->style)
-	{
-		self->style = 1;
-
-		auto [ fwd, rgt, up] = AngleVectors(self->s.angles);
-
-		edict_t *arm_gib = ThrowGib(self, "models/monsters/tank/gibs/barm.md2", damage, GIB_SKINNED | GIB_UPRIGHT, self->s.scale);
-		arm_gib->s.origin = self->s.origin + (rgt * -16.f) + (up * 23.f);
-		arm_gib->s.old_origin = arm_gib->s.origin;
-		arm_gib->avelocity = { crandom() * 15.f, crandom() * 15.f, 180.f };
-		arm_gib->velocity = (up * 100.f) + (rgt * -120.f);
-		arm_gib->s.angles = self->s.angles;
-		arm_gib->s.angles[2] = -90.f;
-		arm_gib->s.skinnum /= 2;
-		gi.linkentity(arm_gib);
-	}
-
-	// regular death
-	gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
-	self->deadflag = true;
-	self->takedamage = true;
+		self->takedamage = true;
+	}
 
 	M_SetAnimation(self, &tank_move_death);
 }
@@ -1012,8 +1107,14 @@
 
 	return false;
 }
-// PGM
-//===========
+
+/* KONIG - use generic checkattack for Tank Guardian*/
+MONSTERINFO_CHECKATTACK(Tank_CheckAttack) (edict_t* self) -> bool
+{
+	if (self->spawnflags.has(SPAWNFLAG_TANK_GUARDIAN))
+		BossPowerups(self);
+	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.8f, 0.8f, 0.f, 0.f);
+}
 
 //
 // monster_tank
@@ -1026,6 +1127,8 @@
  */
 void SP_monster_tank(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1059,29 +1162,84 @@
 	gi.soundindex("tank/tnkatk2e.wav");
 	gi.soundindex("tank/tnkatck3.wav");
 
-	if (strcmp(self->classname, "monster_tank_commander") == 0)
-	{
-		self->health = 1000 * st.health_multiplier;
+	/* KONIG - reworked code to make Tank Guardians their own visual entity; Tank Guardians get GZ health scaling; reduced health, added armor; Tank Commanders always heatseeking rockets*/
+	if (strcmp(self->classname, "monster_tank_commander") == 0 && self->spawnflags.has(SPAWNFLAG_TANK_GUARDIAN))
+	{
+		self->count = 3;
+
+		self->s.skinnum = 6;
+
+		// [Paril-KEX] N64 tank commander is a chonky boy
+		if (!self->s.scale)
+			self->s.scale = 1.5f;
+
+		self->health = max(1500, 1500 + 1000 * (skill->integer - 1)) * st.health_multiplier;
+		self->gib_health = -300;
+
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_BODY;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = max(250, 250 + 100 * (skill->integer - 1));
+		if (coop->integer)
+		{
+			self->health += (250 * (CountPlayers() - 1));
+			self->monsterinfo.armor_power += (100 * (CountPlayers() - 1));
+		}
+	}
+	else if (self->spawnflags.has(SPAWNFLAG_TANK_GUARDIAN))
+	{
+		self->count = 2;
+
+		self->s.skinnum = 4;
+
+		if (!self->s.scale)
+			self->s.scale = 1.5f;
+
+		self->health = max(1500, 1500 + 1000 * (skill->integer - 1)) * st.health_multiplier;
+		self->gib_health = -300;
+
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_BODY;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = max(250, 250 + 100 * (skill->integer - 1));
+		if (coop->integer)
+		{
+			self->health += (250 * (CountPlayers() - 1));
+			self->monsterinfo.armor_power += (100 * (CountPlayers() - 1));
+		}
+	}
+	else if (strcmp(self->classname, "monster_tank_commander") == 0)
+	{
+		self->count = 1;
+
+		self->spawnflags |= SPAWNFLAG_TANK_HEAT_SEEKING;
+		sound_pain2.assign("tank/pain.wav");
+
+		self->s.skinnum = 2;
+
+		self->health = 950 * st.health_multiplier;
 		self->gib_health = -225;
-		self->count = 1;
-		sound_pain2.assign("tank/pain.wav");
-	}
-	else
-	{
+
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = 200;
+	}
+	else
+	{
+		self->count = 0;
+
+		sound_pain.assign("tank/tnkpain2.wav");
 		self->health = 750 * st.health_multiplier;
 		self->gib_health = -200;
-		sound_pain.assign("tank/tnkpain2.wav");
+
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = 200;
 	}
 
 	self->monsterinfo.scale = MODEL_SCALE;
-
-	// [Paril-KEX] N64 tank commander is a chonky boy
-	if (self->spawnflags.has(SPAWNFLAG_TANK_COMMANDER_GUARDIAN))
-	{
-		if (!self->s.scale)
-			self->s.scale = 1.5f;
-		self->health = 1500 * st.health_multiplier;
-	}
 
 	// heat seekingness
 	if (!self->accel)
@@ -1100,6 +1258,7 @@
 	self->monsterinfo.sight = tank_sight;
 	self->monsterinfo.idle = tank_idle;
 	self->monsterinfo.blocked = tank_blocked; // PGM
+	self->monsterinfo.checkattack = Tank_CheckAttack;
 	self->monsterinfo.setskin = tank_setskin;
 
 	gi.linkentity(self);
@@ -1111,9 +1270,6 @@
 	// PMM
 	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
 	self->monsterinfo.blindfire = true;
-	// pmm
-	if (strcmp(self->classname, "monster_tank_commander") == 0)
-		self->s.skinnum = 2;
 }
 
 void Use_Boss3(edict_t *ent, edict_t *other, edict_t *activator);
@@ -1144,7 +1300,8 @@
 	self->model = "models/monsters/tank/tris.md2";
 	self->s.modelindex = gi.modelindex(self->model);
 	self->s.frame = FRAME_stand01;
-	self->s.skinnum = 2;
+	/*KONIG - New skin for N64*/
+	self->s.skinnum = 6;
 
 	gi.soundindex("misc/bigtele.wav");
 	
--- a/p_client.cpp	2023-10-03 19:43:06
+++ b/p_client.cpp	2025-09-04 19:53:48
@@ -16,6 +16,8 @@
 	gi.linkentity(self);
 }
 
+constexpr spawnflags_t SPAWNFLAG_SPAWN_RIDE = 1_spawnflag;
+
 /*QUAKED info_player_start (1 0 0) (-16 -16 -24) (16 16 32)
 The normal starting point for a level.
 */
@@ -27,11 +29,14 @@
 
 	// [Paril-KEX] on n64, since these can spawn riding elevators,
 	// allow them to "ride" the elevators so respawning works
-	if (level.is_n64)
+	if (level.is_n64 || level.is_psx || self->spawnflags.has(SPAWNFLAG_SPAWN_RIDE))
 	{
 		self->think = info_player_start_drop;
 		self->nextthink = level.time + FRAME_TIME_S;
 	}
+
+	if (level.is_psx)
+		self->s.origin[2] -= PLAYER_MINS[2] - (PLAYER_MINS[2] * PSX_PHYSICS_SCALAR);
 }
 
 /*QUAKED info_player_deathmatch (1 0 1) (-16 -16 -24) (16 16 32)
@@ -178,7 +183,13 @@
 		case MOD_DOPPLE_EXPLODE:
 			base = "$g_mod_self_dopple_explode";
 			break;
-			// ROGUE
+			// ZAERO
+		case MOD_A2K:
+			base = "{0} realized they were expendable.\n";
+			break;
+		case MOD_SONICCANNON:
+			base = "{0} got carried away.\n";
+			break;
 		default:
 			base = "$g_mod_self_default";
 			break;
@@ -322,7 +333,22 @@
 		case MOD_GRAPPLE:
 			base = "$g_mod_kill_grapple";
 			break;
-			// ZOID
+			//ZAERO
+		case MOD_FLARE:
+			base = "{0} didn't see {1}'s flare.\n";
+			break;
+		case MOD_TRIPBOMB:
+			base = "{0} tripped over {1}'s trip bomb.\n";
+			break;
+		case MOD_SONICCANNON:
+			base = "{0} got microwaved by {1}.\n";
+			break;
+		case MOD_SNIPERRIFLE:
+			base = "{0} got ventilated by {1}'s bullet.\n";
+			break;
+		case MOD_A2K:
+			base = "{0} got dissassembled by {1}.\n";
+			break;
 		default:
 			base = "$g_mod_kill_generic";
 			break;
@@ -874,6 +900,9 @@
 			if (level.start_items && *level.start_items)
 				Player_GiveStartItems(ent, level.start_items);
 
+			// power armor from start items
+			G_CheckPowerArmor(ent);
+
 			if (!deathmatch->integer)
 				client->pers.inventory[IT_ITEM_COMPASS] = 1;
 
@@ -902,7 +931,7 @@
 		client->pers.lives = g_coop_num_lives->integer + 1;
 
 	if (ent->client->pers.autoshield >= AUTO_SHIELD_AUTO)
-		ent->flags |= FL_WANTS_POWER_ARMOR;
+		client->pers.savedFlags |= FL_WANTS_POWER_ARMOR;
 
 	client->pers.connected = true;
 	client->pers.spawned = true;
@@ -3047,7 +3076,10 @@
 
 	float delta = pm.impact_delta;
 
-	delta = delta * delta * 0.0001f;
+	if (level.is_psx)
+		delta = delta * delta * 0.000078f;
+	else
+		delta = delta * delta * 0.0001f;
 
 	if (pm.waterlevel == WATER_WAIST)
 		delta *= 0.25f;
@@ -3087,9 +3119,11 @@
 			ent->s.event = EV_FALL;
 
 		ent->pain_debounce_time = level.time + FRAME_TIME_S; // no normal pain sound
-		damage = (int) ((delta - 30) / 2);
-		if (damage < 1)
-			damage = 1;
+		damage = std::max((int) ((delta - 30) / 2), 1);
+
+		if (level.is_psx)
+			damage = std::min(4, damage);
+
 		dir = { 0, 0, 1 };
 
 		if (!deathmatch->integer || !g_dm_no_fall_damage->integer)
@@ -3161,7 +3195,7 @@
 	client->latched_buttons |= client->buttons & ~client->oldbuttons;
 	client->cmd = *ucmd;
 
-	if ((ucmd->buttons & BUTTON_CROUCH) && pm_config.n64_physics)
+	if ((ucmd->buttons & BUTTON_CROUCH) && PM_CrouchingDisabled(pm_config.physics_flags))
 	{
 		if (client->pers.n64_crouch_warn_times < 12 &&
 			client->pers.n64_crouch_warning < level.time &&
@@ -3242,7 +3276,17 @@
 			client->ps.pmove.pm_flags &= ~PMF_IGNORE_PLAYER_COLLISION;
 
 		// PGM	trigger_gravity support
-		client->ps.pmove.gravity = (short) (level.gravity * ent->gravity);
+		if (ent->no_gravity_time > level.time)
+		{
+			client->ps.pmove.gravity = 0;
+			client->ps.pmove.pm_flags |= PMF_NO_GROUND_SEEK;
+		}
+		else
+		{
+			client->ps.pmove.gravity = (short) (level.gravity * ent->gravity);
+			client->ps.pmove.pm_flags &= ~PMF_NO_GROUND_SEEK;
+		}
+
 		pm.s = client->ps.pmove;
 
 		pm.s.origin = ent->s.origin;
--- a/p_hud.cpp	2023-10-03 19:43:06
+++ b/p_hud.cpp	2025-09-04 19:53:48
@@ -613,25 +613,39 @@
 	}
 	else 
 	{
+		const char *first_message = game.helpmessage1;
+		const char *first_title = level.primary_objective_title;
+
+		const char *second_message = game.helpmessage2;
+		const char *second_title = level.secondary_objective_title;
+
+		if (level.is_psx)
+		{
+			std::swap(first_message, second_message);
+			std::swap(first_title, second_title);
+		}
+
 		int y = 54;
-		if (strlen(game.helpmessage1))
-		{
-			helpString += G_Fmt("xv 0 yv {} loc_cstring2 0 \"$g_pc_primary_objective\" "  // title
+		if (strlen(first_message))
+		{
+			helpString += G_Fmt("xv 0 yv {} loc_cstring2 0 \"{}\" "  // title
 				"xv 0 yv {} loc_cstring 0 \"{}\" ",
 				y,
+				first_title,
 				y + 11,
-				game.helpmessage1);
+				first_message);
 
 			y += 58;
 		}
 
-		if (strlen(game.helpmessage2))
-		{
-			helpString += G_Fmt("xv 0 yv {} loc_cstring2 0 \"$g_pc_secondary_objective\" "  // title
+		if (strlen(second_message))
+		{
+			helpString += G_Fmt("xv 0 yv {} loc_cstring2 0 \"{}\" "  // title
 				"xv 0 yv {} loc_cstring 0 \"{}\" ",
 				y,
+				second_title,
 				y + 11,
-				game.helpmessage2);
+				second_message);
 		}
 
 	}
@@ -749,7 +763,7 @@
 	//
 	uint32_t weaponbits = 0;
 
-	for (invIndex = IT_WEAPON_GRAPPLE; invIndex <= IT_WEAPON_DISRUPTOR; invIndex++)
+	for (invIndex = IT_WEAPON_GRAPPLE; invIndex <= IT_WEAPON_DISINTEGRATOR; invIndex++)
 	{
 		if (ent->client->pers.inventory[invIndex])
 		{
--- a/p_move.cpp	2023-10-03 19:43:06
+++ b/p_move.cpp	2025-09-04 19:53:48
@@ -5,6 +5,36 @@
 
 #define GAME_INCLUDE
 #include "bg_local.h"
+
+// In PSX SP, step-ups aren't allowed
+inline bool PM_AllowStepUp()
+{
+	if (pm_config.physics_flags & PHYSICS_PSX_MOVEMENT)
+		return !!(pm_config.physics_flags & PHYSICS_DEATHMATCH);
+
+	return true;
+}
+
+template<typename T>
+inline T PM_ApplyPSXScalar(T v, float scalar = PSX_PHYSICS_SCALAR)
+{
+	if (pm_config.physics_flags & PHYSICS_PSX_SCALE)
+		return static_cast<T>(v * scalar);
+
+	return v;
+}
+
+// PSX / N64 can't trick-jump except in DM
+inline bool PM_AllowTrickJump()
+{
+	return !(pm_config.physics_flags & (PHYSICS_N64_MOVEMENT | PHYSICS_PSX_MOVEMENT)) || (pm_config.physics_flags & PHYSICS_DEATHMATCH);
+}
+
+// PSX / N64 (single player) require landing before a next jump
+inline bool PM_NeedsLandTime()
+{
+	return (pm_config.physics_flags & (PHYSICS_N64_MOVEMENT | PHYSICS_PSX_MOVEMENT)) && !(pm_config.physics_flags & PHYSICS_DEATHMATCH);
+}
 
 // [Paril-KEX] generic code to detect & fix a stuck object
 stuck_result_t G_FixStuckObject_Generic(vec3_t &origin, const vec3_t &own_mins, const vec3_t &own_maxs, std::function<stuck_object_trace_fn_t> trace)
@@ -458,6 +488,13 @@
 
 	PM_StepSlideMove_();
 
+	if (!PM_AllowStepUp())
+	{
+		// no step up
+		if (!(pm->s.pm_flags & PMF_ON_GROUND))
+			return;
+	}
+
 	down_o = pml.origin;
 	down_v = pml.velocity;
 
@@ -563,14 +600,16 @@
 	// apply ground friction
 	if ((pm->groundentity && pml.groundsurface && !(pml.groundsurface->flags & SURF_SLICK)) || (pm->s.pm_flags & PMF_ON_LADDER))
 	{
-		friction = pm_friction;
-		control = speed < pm_stopspeed ? pm_stopspeed : speed;
+		friction = PM_ApplyPSXScalar(pm_friction);
+		control = speed < PM_ApplyPSXScalar(pm_stopspeed) ? PM_ApplyPSXScalar(pm_stopspeed) : speed;
 		drop += control * friction * pml.frametime;
 	}
 
 	// apply water friction
 	if (pm->waterlevel && !(pm->s.pm_flags & PMF_ON_LADDER))
-		drop += speed * pm_waterfriction * (float) pm->waterlevel * pml.frametime;
+	{
+		drop += speed * PM_ApplyPSXScalar(pm_waterfriction) * (float) pm->waterlevel * pml.frametime;
+	}
 
 	// scale the velocity
 	newspeed = speed - drop;
@@ -594,37 +633,35 @@
 */
 void PM_Accelerate(const vec3_t &wishdir, float wishspeed, float accel)
 {
-	int	  i;
-	float addspeed, accelspeed, currentspeed;
-
-	currentspeed = pml.velocity.dot(wishdir);
-	addspeed = wishspeed - currentspeed;
+	wishspeed = PM_ApplyPSXScalar(wishspeed);
+	accel = PM_ApplyPSXScalar(accel);
+
+	float currentspeed = pml.velocity.dot(wishdir);
+	float addspeed = wishspeed - currentspeed;
 	if (addspeed <= 0)
 		return;
-	accelspeed = accel * pml.frametime * wishspeed;
+	float accelspeed = accel * pml.frametime * wishspeed;
 	if (accelspeed > addspeed)
 		accelspeed = addspeed;
 
-	for (i = 0; i < 3; i++)
+	for (int i = 0; i < 3; i++)
 		pml.velocity[i] += accelspeed * wishdir[i];
 }
 
 void PM_AirAccelerate(const vec3_t &wishdir, float wishspeed, float accel)
 {
-	int	  i;
-	float addspeed, accelspeed, currentspeed, wishspd = wishspeed;
-
+	float wishspd = wishspeed;
 	if (wishspd > 30)
 		wishspd = 30;
-	currentspeed = pml.velocity.dot(wishdir);
-	addspeed = wishspd - currentspeed;
+	float currentspeed = pml.velocity.dot(wishdir);
+	float addspeed = wishspd - currentspeed;
 	if (addspeed <= 0)
 		return;
-	accelspeed = accel * wishspeed * pml.frametime;
+	float accelspeed = accel * wishspeed * pml.frametime;
 	if (accelspeed > addspeed)
 		accelspeed = addspeed;
 
-	for (i = 0; i < 3; i++)
+	for (int i = 0; i < 3; i++)
 		pml.velocity[i] += accelspeed * wishdir[i];
 }
 
@@ -825,10 +862,12 @@
 	}
 	wishspeed *= 0.5f;
 
-	if ((pm->s.pm_flags & PMF_DUCKED) && wishspeed > pm_duckspeed)
-	{
-		wishvel *= pm_duckspeed / wishspeed;
-		wishspeed = pm_duckspeed;
+	float duckspeed = PM_ApplyPSXScalar(pm_duckspeed, 1.25f);
+
+	if ((pm->s.pm_flags & PMF_DUCKED) && wishspeed > duckspeed)
+	{
+		wishvel *= duckspeed / wishspeed;
+		wishspeed = duckspeed;
 	}
 
 	PM_Accelerate(wishdir, wishspeed, pm_wateraccelerate);
@@ -863,10 +902,12 @@
 	wishdir = wishvel;
 	wishspeed = wishdir.normalize();
 
+	float duckspeed = PM_ApplyPSXScalar(pm_duckspeed, 1.25f);
+
 	//
 	// clamp to server defined max speed
 	//
-	maxspeed = (pm->s.pm_flags & PMF_DUCKED) ? pm_duckspeed : pm_maxspeed;
+	maxspeed = (pm->s.pm_flags & PMF_DUCKED) ? duckspeed : pm_maxspeed;
 
 	if (wishspeed > maxspeed)
 	{
@@ -978,7 +1019,7 @@
 	point[1] = pml.origin[1];
 	point[2] = pml.origin[2] - 0.25f;
 
-	if (pml.velocity[2] > 180 || pm->s.pm_type == PM_GRAPPLE) //!!ZOID changed from 100 to 180 (ramp accel)
+	if ((pm->s.pm_flags & PMF_NO_GROUND_SEEK) || pml.velocity[2] > 180 || pm->s.pm_type == PM_GRAPPLE) //!!ZOID changed from 100 to 180 (ramp accel)
 	{
 		pm->s.pm_flags &= ~PMF_ON_GROUND;
 		pm->groundentity = nullptr;
@@ -1025,7 +1066,7 @@
 				// just hit the ground
 
 				// [Paril-KEX]
-				if (!pm_config.n64_physics && pml.velocity[2] >= 100.f && pm->groundplane.normal[2] >= 0.9f && !(pm->s.pm_flags & PMF_DUCKED))
+				if (PM_AllowTrickJump() && pml.velocity[2] >= 100.f && pm->groundplane.normal[2] >= 0.9f && !(pm->s.pm_flags & PMF_DUCKED))
 				{
 					pm->s.pm_flags |= PMF_TIME_TRICK;
 					pm->s.pm_time = 64;
@@ -1035,14 +1076,14 @@
 				vec3_t clipped_velocity;
 				PM_ClipVelocity(pml.velocity, pm->groundplane.normal, clipped_velocity, 1.01f);
 
-				pm->impact_delta = pml.start_velocity[2] - clipped_velocity[2];
+				pm->impact_delta = PM_ApplyPSXScalar(pml.start_velocity[2] - clipped_velocity[2], 1.f / PSX_PHYSICS_SCALAR);
 
 				pm->s.pm_flags |= PMF_ON_GROUND;
 
-				if (pm_config.n64_physics || (pm->s.pm_flags & PMF_DUCKED))
+				if (PM_NeedsLandTime() || (pm->s.pm_flags & PMF_DUCKED))
 				{
 					pm->s.pm_flags |= PMF_TIME_LAND;
-					pm->s.pm_time = 128;
+					pm->s.pm_time = PM_ApplyPSXScalar(128, 0.5f);
 				}
 			}
 		}
@@ -1095,7 +1136,7 @@
 	pm->groundentity = nullptr;
 	pm->s.pm_flags &= ~PMF_ON_GROUND;
 
-	float jump_height = 270.f;
+	float jump_height = PM_ApplyPSXScalar(270.f, (PSX_PHYSICS_SCALAR * 1.15f));
 
 	pml.velocity[2] += jump_height;
 	if (pml.velocity[2] < jump_height)
@@ -1381,7 +1422,7 @@
 		(pm->cmd.buttons & BUTTON_CROUCH) &&
 		(pm->groundentity || (pm->waterlevel <= WATER_FEET && !PM_AboveWater())) &&
 		!(pm->s.pm_flags & PMF_ON_LADDER) &&
-		!pm_config.n64_physics)
+		!PM_CrouchingDisabled(pm_config.physics_flags))
 	{ // duck
 		if (!(pm->s.pm_flags & PMF_DUCKED))
 		{
--- a/p_view.cpp	2023-10-03 19:43:06
+++ b/p_view.cpp	2025-09-04 19:53:48
@@ -4,33 +4,22 @@
 #include "g_local.h"
 #include "m_player.h"
 #include "bots/bot_includes.h"
-
-static edict_t   *current_player;
-static gclient_t *current_client;
-
-static vec3_t forward, right, up;
-float		  xyspeed;
-
-float bobmove;
-int	  bobcycle, bobcycle_run;	  // odd cycles are right foot going forward
-float bobfracsin; // sinf(bobfrac*M_PI)
 
 /*
 ===============
 SkipViewModifiers
 ===============
 */
-inline bool SkipViewModifiers() {
+inline bool SkipViewModifiers(gclient_t *client) {
 	if ( g_skipViewModifiers->integer && sv_cheats->integer ) {
 		return true;
 	}
 	// don't do bobbing, etc on grapple
-	if (current_client->ctf_grapple &&
-		 current_client->ctf_grapplestate > CTF_GRAPPLE_STATE_FLY) {
+	if (client->ctf_grapple && client->ctf_grapplestate > CTF_GRAPPLE_STATE_FLY) {
 		return true;
 	}
 	// spectator mode
-	if (current_client->resp.spectator || (G_TeamplayEnabled() && current_client->resp.ctf_team == CTF_NOTEAM)) {
+	if (client->resp.spectator || (G_TeamplayEnabled() && client->resp.ctf_team == CTF_NOTEAM)) {
 		return true;
 	}
 	return false;
@@ -42,9 +31,9 @@
 
 ===============
 */
-float SV_CalcRoll(const vec3_t &angles, const vec3_t &velocity)
+static float SV_CalcRoll(gclient_t *client, const vec3_t &angles, const vec3_t &velocity, const vec3_t &right)
 {
-	if ( SkipViewModifiers() ) {
+	if ( SkipViewModifiers(client) ) {
 		return 0.0f;
 	}
 
@@ -73,7 +62,7 @@
 Handles color blends and view kicks
 ===============
 */
-void P_DamageFeedback(edict_t *player)
+static void P_DamageFeedback(edict_t *player, const vec3_t &forward, const vec3_t &right, const vec3_t &up)
 {
 	gclient_t		  *client;
 	float			 side;
@@ -294,7 +283,7 @@
 
 ===============
 */
-void SV_CalcViewOffset(edict_t *ent)
+static void SV_CalcViewOffset(edict_t *ent, const vec3_t &forward, const vec3_t &right, const step_parameters_t &step)
 {
 	float  bob;
 	float  ratio;
@@ -323,7 +312,7 @@
 		}
 		ent->client->ps.viewangles[YAW] = ent->client->killer_yaw;
 	}
-	else if (!ent->client->pers.bob_skip && !SkipViewModifiers())
+	else if (!ent->client->pers.bob_skip && !SkipViewModifiers(ent->client))
 	{
 		// add angles based on weapon kick
 		angles = P_CurrentKickAngles(ent);
@@ -371,7 +360,7 @@
 		}
 
 		// add angles based on velocity
-		if (!ent->client->pers.bob_skip && !SkipViewModifiers())
+		if (!ent->client->pers.bob_skip && !SkipViewModifiers(ent->client))
 		{
 			delta = ent->velocity.dot(forward);
 			angles[PITCH] += delta * run_pitch->value;
@@ -380,16 +369,16 @@
 			angles[ROLL] += delta * run_roll->value;
 
 			// add angles based on bob
-			delta = bobfracsin * bob_pitch->value * xyspeed;
+			delta = step.bobfracsin * bob_pitch->value * step.xyspeed;
 			if ((ent->client->ps.pmove.pm_flags & PMF_DUCKED) && ent->groundentity)
 				delta *= 6; // crouching
 			delta = min(delta, 1.2f);
 			angles[PITCH] += delta;
-			delta = bobfracsin * bob_roll->value * xyspeed;
+			delta = step.bobfracsin * bob_roll->value * step.xyspeed;
 			if ((ent->client->ps.pmove.pm_flags & PMF_DUCKED) && ent->groundentity)
 				delta *= 6; // crouching
 			delta = min(delta, 1.2f);
-			if (bobcycle & 1)
+			if (step.bobcycle & 1)
 				delta = -delta;
 			angles[ROLL] += delta;
 		}
@@ -417,7 +406,7 @@
 
 	// add fall height
 
-	if (!ent->client->pers.bob_skip && !SkipViewModifiers())
+	if (!ent->client->pers.bob_skip && !SkipViewModifiers(ent->client))
 	{
 		if (ent->client->fall_time > level.time)
 		{
@@ -439,7 +428,7 @@
 		}
 
 	// add bob height
-		bob = bobfracsin * xyspeed * bob_up->value;
+		bob = step.bobfracsin * step.xyspeed * bob_up->value;
 		if (bob > 6)
 			bob = 6;
 		// gi.DebugGraph (bob *2, 255);
@@ -448,7 +437,7 @@
 
 	// add kick offset
 
-	if (!ent->client->pers.bob_skip && !SkipViewModifiers())
+	if (!ent->client->pers.bob_skip && !SkipViewModifiers(ent->client))
 		v += P_CurrentKickOrigin(ent);
 
 	// absolutely bound offsets
@@ -475,7 +464,7 @@
 SV_CalcGunOffset
 ==============
 */
-void SV_CalcGunOffset(edict_t *ent)
+static void SV_CalcGunOffset(edict_t *ent, const vec3_t &forward, const vec3_t &right, const vec3_t &up, const step_parameters_t &step)
 {
 	int	  i;
 	// ROGUE
@@ -483,19 +472,19 @@
 	// ROGUE - heatbeam shouldn't bob so the beam looks right
 	if (ent->client->pers.weapon && 
 		!((ent->client->pers.weapon->id == IT_WEAPON_PLASMABEAM || ent->client->pers.weapon->id == IT_WEAPON_GRAPPLE) && ent->client->weaponstate == WEAPON_FIRING)
-		&& !SkipViewModifiers())
+		&& !SkipViewModifiers(ent->client))
 	{
 		// ROGUE
 		// gun angles from bobbing
-		ent->client->ps.gunangles[ROLL] = xyspeed * bobfracsin * 0.005f;
-		ent->client->ps.gunangles[YAW] = xyspeed * bobfracsin * 0.01f;
-		if (bobcycle & 1)
+		ent->client->ps.gunangles[ROLL] = step.xyspeed * step.bobfracsin * 0.005f;
+		ent->client->ps.gunangles[YAW] = step.xyspeed * step.bobfracsin * 0.01f;
+		if (step.bobcycle & 1)
 		{
 			ent->client->ps.gunangles[ROLL] = -ent->client->ps.gunangles[ROLL];
 			ent->client->ps.gunangles[YAW] = -ent->client->ps.gunangles[YAW];
 		}
 
-		ent->client->ps.gunangles[PITCH] = xyspeed * bobfracsin * 0.005f;
+		ent->client->ps.gunangles[PITCH] = step.xyspeed * step.bobfracsin * 0.005f;
 
 		vec3_t viewangles_delta = ent->client->oldviewangles - ent->client->ps.viewangles;
 		
@@ -561,7 +550,7 @@
 SV_CalcBlend
 =============
 */
-void SV_CalcBlend(edict_t *ent)
+static void SV_CalcBlend(edict_t *ent)
 {
 	gtime_t remaining;
 
@@ -686,41 +675,43 @@
 P_WorldEffects
 =============
 */
-void P_WorldEffects()
+static void P_WorldEffects(edict_t *ent, const step_parameters_t &step)
 {
 	bool		  breather;
 	bool		  envirosuit;
 	water_level_t waterlevel, old_waterlevel;
 
-	if (current_player->movetype == MOVETYPE_NOCLIP)
-	{
-		current_player->air_finished = level.time + 12_sec; // don't need air
+	if (ent->movetype == MOVETYPE_NOCLIP)
+	{
+		ent->air_finished = level.time + 12_sec; // don't need air
 		return;
 	}
 
-	waterlevel = current_player->waterlevel;
-	old_waterlevel = current_client->old_waterlevel;
-	current_client->old_waterlevel = waterlevel;
-
-	breather = current_client->breather_time > level.time;
-	envirosuit = current_client->enviro_time > level.time;
+	gclient_t *client = ent->client;
+
+	waterlevel = ent->waterlevel;
+	old_waterlevel = client->old_waterlevel;
+	client->old_waterlevel = waterlevel;
+
+	breather = client->breather_time > level.time;
+	envirosuit = client->enviro_time > level.time;
 
 	//
 	// if just entered a water volume, play a sound
 	//
 	if (!old_waterlevel && waterlevel)
 	{
-		PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
-		if (current_player->watertype & CONTENTS_LAVA)
-			gi.sound(current_player, CHAN_BODY, gi.soundindex("player/lava_in.wav"), 1, ATTN_NORM, 0);
-		else if (current_player->watertype & CONTENTS_SLIME)
-			gi.sound(current_player, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
-		else if (current_player->watertype & CONTENTS_WATER)
-			gi.sound(current_player, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
-		current_player->flags |= FL_INWATER;
+		PlayerNoise(ent, ent->s.origin, PNOISE_SELF);
+		if (ent->watertype & CONTENTS_LAVA)
+			gi.sound(ent, CHAN_BODY, gi.soundindex("player/lava_in.wav"), 1, ATTN_NORM, 0);
+		else if (ent->watertype & CONTENTS_SLIME)
+			gi.sound(ent, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
+		else if (ent->watertype & CONTENTS_WATER)
+			gi.sound(ent, CHAN_BODY, gi.soundindex("player/watr_in.wav"), 1, ATTN_NORM, 0);
+		ent->flags |= FL_INWATER;
 
 		// clear damage_debounce, so the pain sound will play immediately
-		current_player->damage_debounce_time = level.time - 1_sec;
+		ent->damage_debounce_time = level.time - 1_sec;
 	}
 
 	//
@@ -728,9 +719,9 @@
 	//
 	if (old_waterlevel && !waterlevel)
 	{
-		PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
-		gi.sound(current_player, CHAN_BODY, gi.soundindex("player/watr_out.wav"), 1, ATTN_NORM, 0);
-		current_player->flags &= ~FL_INWATER;
+		PlayerNoise(ent, ent->s.origin, PNOISE_SELF);
+		gi.sound(ent, CHAN_BODY, gi.soundindex("player/watr_out.wav"), 1, ATTN_NORM, 0);
+		ent->flags &= ~FL_INWATER;
 	}
 
 	//
@@ -738,22 +729,22 @@
 	//
 	if (old_waterlevel != WATER_UNDER && waterlevel == WATER_UNDER)
 	{
-		gi.sound(current_player, CHAN_BODY, gi.soundindex("player/watr_un.wav"), 1, ATTN_NORM, 0);
+		gi.sound(ent, CHAN_BODY, gi.soundindex("player/watr_un.wav"), 1, ATTN_NORM, 0);
 	}
 
 	//
 	// check for head just coming out of water
 	//
-	if (current_player->health > 0 && old_waterlevel == WATER_UNDER && waterlevel != WATER_UNDER)
-	{
-		if (current_player->air_finished < level.time)
+	if (ent->health > 0 && old_waterlevel == WATER_UNDER && waterlevel != WATER_UNDER)
+	{
+		if (ent->air_finished < level.time)
 		{ // gasp for air
-			gi.sound(current_player, CHAN_VOICE, gi.soundindex("player/gasp1.wav"), 1, ATTN_NORM, 0);
-			PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
-		}
-		else if (current_player->air_finished < level.time + 11_sec)
+			gi.sound(ent, CHAN_VOICE, gi.soundindex("player/gasp1.wav"), 1, ATTN_NORM, 0);
+			PlayerNoise(ent, ent->s.origin, PNOISE_SELF);
+		}
+		else if (ent->air_finished < level.time + 11_sec)
 		{ // just break surface
-			gi.sound(current_player, CHAN_VOICE, gi.soundindex("player/gasp2.wav"), 1, ATTN_NORM, 0);
+			gi.sound(ent, CHAN_VOICE, gi.soundindex("player/gasp2.wav"), 1, ATTN_NORM, 0);
 		}
 	}
 
@@ -765,89 +756,98 @@
 		// breather or envirosuit give air
 		if (breather || envirosuit)
 		{
-			current_player->air_finished = level.time + 10_sec;
-
-			if (((current_client->breather_time - level.time).milliseconds() % 2500) == 0)
+			ent->air_finished = level.time + 10_sec;
+
+			if (((client->breather_time - level.time).milliseconds() % 2500) == 0)
 			{
-				if (!current_client->breather_sound)
-					gi.sound(current_player, CHAN_AUTO, gi.soundindex("player/u_breath1.wav"), 1, ATTN_NORM, 0);
+				if (!client->breather_sound)
+					gi.sound(ent, CHAN_AUTO, gi.soundindex("player/u_breath1.wav"), 1, ATTN_NORM, 0);
 				else
-					gi.sound(current_player, CHAN_AUTO, gi.soundindex("player/u_breath2.wav"), 1, ATTN_NORM, 0);
-				current_client->breather_sound ^= 1;
-				PlayerNoise(current_player, current_player->s.origin, PNOISE_SELF);
+					gi.sound(ent, CHAN_AUTO, gi.soundindex("player/u_breath2.wav"), 1, ATTN_NORM, 0);
+				client->breather_sound ^= 1;
+				PlayerNoise(ent, ent->s.origin, PNOISE_SELF);
 				// FIXME: release a bubble?
 			}
 		}
 
 		// if out of air, start drowning
-		if (current_player->air_finished < level.time)
+		if (ent->air_finished < level.time)
 		{ // drown!
-			if (current_player->client->next_drown_time < level.time && current_player->health > 0)
+			if (ent->client->next_drown_time < level.time && ent->health > 0)
 			{
-				current_player->client->next_drown_time = level.time + 1_sec;
+				ent->client->next_drown_time = level.time + 1_sec;
 
 				// take more damage the longer underwater
-				current_player->dmg += 2;
-				if (current_player->dmg > 15)
-					current_player->dmg = 15;
+				ent->dmg += 2;
+				if (ent->dmg > 15)
+					ent->dmg = 15;
 
 				// play a gurp sound instead of a normal pain sound
-				if (current_player->health <= current_player->dmg)
-					gi.sound(current_player, CHAN_VOICE, gi.soundindex("*drown1.wav"), 1, ATTN_NORM, 0); // [Paril-KEX]
+				if (ent->health <= ent->dmg)
+					gi.sound(ent, CHAN_VOICE, gi.soundindex("*drown1.wav"), 1, ATTN_NORM, 0); // [Paril-KEX]
 				else if (brandom())
-					gi.sound(current_player, CHAN_VOICE, gi.soundindex("*gurp1.wav"), 1, ATTN_NORM, 0);
+					gi.sound(ent, CHAN_VOICE, gi.soundindex("*gurp1.wav"), 1, ATTN_NORM, 0);
 				else
-					gi.sound(current_player, CHAN_VOICE, gi.soundindex("*gurp2.wav"), 1, ATTN_NORM, 0);
-
-				current_player->pain_debounce_time = level.time;
-
-				T_Damage(current_player, world, world, vec3_origin, current_player->s.origin, vec3_origin, current_player->dmg, 0, DAMAGE_NO_ARMOR, MOD_WATER);
+					gi.sound(ent, CHAN_VOICE, gi.soundindex("*gurp2.wav"), 1, ATTN_NORM, 0);
+
+				ent->pain_debounce_time = level.time;
+
+				T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, ent->dmg, 0, DAMAGE_NO_ARMOR, MOD_WATER);
 			}
 		}
 		// Paril: almost-drowning sounds
-		else if (current_player->air_finished <= level.time + 3_sec)
-		{
-			if (current_player->client->next_drown_time < level.time)
+		else if (ent->air_finished <= level.time + 3_sec)
+		{
+			if (ent->client->next_drown_time < level.time)
 			{
-				gi.sound(current_player, CHAN_VOICE, gi.soundindex(fmt::format("player/wade{}.wav", 1 + ((int32_t) level.time.seconds() % 3)).c_str()), 1, ATTN_NORM, 0);
-				current_player->client->next_drown_time = level.time + 1_sec;
+				gi.sound(ent, CHAN_VOICE, gi.soundindex(G_Fmt("player/breathout{}.wav", 1 + ((int32_t) level.time.seconds() % 3)).data()), 1, ATTN_NORM, 0);
+				ent->client->next_drown_time = level.time + 1_sec;
 			}
 		}
 	}
 	else
 	{
-		current_player->air_finished = level.time + 12_sec;
-		current_player->dmg = 2;
+		if (waterlevel == WATER_WAIST)
+		{
+			if (level.is_psx)
+			{
+				if ((int) (client->bobtime + step.bobmove) != step.bobcycle_run)
+					gi.sound(ent, CHAN_VOICE, gi.soundindex(G_Fmt("player/wade{}.wav", irandom(1, 4)).data()), 1, ATTN_NORM, 0);
+			}
+		}
+
+		ent->air_finished = level.time + 12_sec;
+		ent->dmg = 2;
 	}
 
 	//
 	// check for sizzle damage
 	//
-	if (waterlevel && (current_player->watertype & (CONTENTS_LAVA | CONTENTS_SLIME)) && current_player->slime_debounce_time <= level.time)
-	{
-		if (current_player->watertype & CONTENTS_LAVA)
-		{
-			if (current_player->health > 0 && current_player->pain_debounce_time <= level.time && current_client->invincible_time < level.time)
+	if (waterlevel && (ent->watertype & (CONTENTS_LAVA | CONTENTS_SLIME)) && ent->slime_debounce_time <= level.time)
+	{
+		if (ent->watertype & CONTENTS_LAVA)
+		{
+			if (ent->health > 0 && ent->pain_debounce_time <= level.time && client->invincible_time < level.time)
 			{
 				if (brandom())
-					gi.sound(current_player, CHAN_VOICE, gi.soundindex("player/burn1.wav"), 1, ATTN_NORM, 0);
+					gi.sound(ent, CHAN_VOICE, gi.soundindex("player/burn1.wav"), 1, ATTN_NORM, 0);
 				else
-					gi.sound(current_player, CHAN_VOICE, gi.soundindex("player/burn2.wav"), 1, ATTN_NORM, 0);
-				current_player->pain_debounce_time = level.time + 1_sec;
+					gi.sound(ent, CHAN_VOICE, gi.soundindex("player/burn2.wav"), 1, ATTN_NORM, 0);
+				ent->pain_debounce_time = level.time + 1_sec;
 			}
 
 			int dmg = (envirosuit ? 1 : 3) * waterlevel; // take 1/3 damage with envirosuit
 
-			T_Damage(current_player, world, world, vec3_origin, current_player->s.origin, vec3_origin, dmg, 0, DAMAGE_NONE, MOD_LAVA);
-			current_player->slime_debounce_time = level.time + 10_hz;
-		}
-
-		if (current_player->watertype & CONTENTS_SLIME)
+			T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, dmg, 0, DAMAGE_NONE, MOD_LAVA);
+			ent->slime_debounce_time = level.time + 10_hz;
+		}
+
+		if (ent->watertype & CONTENTS_SLIME)
 		{
 			if (!envirosuit)
 			{ // no damage from slime with envirosuit
-				T_Damage(current_player, world, world, vec3_origin, current_player->s.origin, vec3_origin, 1 * waterlevel, 0, DAMAGE_NONE, MOD_SLIME);
-				current_player->slime_debounce_time = level.time + 10_hz;
+				T_Damage(ent, world, world, vec3_origin, ent->s.origin, vec3_origin, 1 * waterlevel, 0, DAMAGE_NONE, MOD_SLIME);
+				ent->slime_debounce_time = level.time + 10_hz;
 			}
 		}
 	}
@@ -858,7 +858,7 @@
 G_SetClientEffects
 ===============
 */
-void G_SetClientEffects(edict_t *ent)
+static void G_SetClientEffects(edict_t *ent)
 {
 	int pa_type;
 
@@ -993,25 +993,27 @@
 G_SetClientEvent
 ===============
 */
-void G_SetClientEvent(edict_t *ent)
+static void G_SetClientEvent(edict_t *ent, const step_parameters_t &step)
 {
 	if (ent->s.event)
 		return;
 
+	gclient_t *client = ent->client;
+
 	if (ent->client->ps.pmove.pm_flags & PMF_ON_LADDER)
 	{
 		if (!deathmatch->integer &&
-			current_client->last_ladder_sound < level.time &&
-			(current_client->last_ladder_pos - ent->s.origin).length() > 48.f)
+			client->last_ladder_sound < level.time &&
+			(client->last_ladder_pos - ent->s.origin).length() > 48.f)
 		{
 			ent->s.event = EV_LADDER_STEP;
-			current_client->last_ladder_pos = ent->s.origin;
-			current_client->last_ladder_sound = level.time + LADDER_SOUND_TIME;
-		}
-	}
-	else if (ent->groundentity && xyspeed > 225)
-	{
-		if ((int) (current_client->bobtime + bobmove) != bobcycle_run)
+			client->last_ladder_pos = ent->s.origin;
+			client->last_ladder_sound = level.time + LADDER_SOUND_TIME;
+		}
+	}
+	else if (ent->groundentity && step.xyspeed > 225)
+	{
+		if ((int) (client->bobtime + step.bobmove) != step.bobcycle_run)
 			ent->s.event = EV_FOOTSTEP;
 	}
 }
@@ -1021,7 +1023,7 @@
 G_SetClientSound
 ===============
 */
-void G_SetClientSound(edict_t *ent)
+static void G_SetClientSound(edict_t *ent)
 {
 	// help beep (no more than three times)
 	if (ent->client->pers.helpchanged && ent->client->pers.helpchanged <= 3 && ent->client->pers.help_time < level.time)
@@ -1080,7 +1082,7 @@
 G_SetClientFrame
 ===============
 */
-void G_SetClientFrame(edict_t *ent)
+void G_SetClientFrame(edict_t *ent, const step_parameters_t &step)
 {
 	gclient_t *client;
 	bool	   duck, run;
@@ -1094,7 +1096,7 @@
 		duck = true;
 	else
 		duck = false;
-	if (xyspeed)
+	if (step.xyspeed)
 		run = true;
 	else
 		run = false;
@@ -1347,10 +1349,7 @@
 	if (!ent->client->pers.spawned)
 		return;
 
-	float bobtime, bobtime_run;
-
-	current_player = ent;
-	current_client = ent->client;
+	gclient_t *client = ent->client;
 
 	// check fog changes
 	P_ForceFogTransition(ent, false);
@@ -1369,8 +1368,8 @@
 	// If it wasn't updated here, the view position would lag a frame
 	// behind the body position when pushed -- "sinking into plats"
 	//
-	current_client->ps.pmove.origin = ent->s.origin;
-	current_client->ps.pmove.velocity = ent->velocity;
+	client->ps.pmove.origin = ent->s.origin;
+	client->ps.pmove.velocity = ent->velocity;
 
 	//
 	// If the end of unit layout is displayed, don't give
@@ -1380,9 +1379,9 @@
 	{
 		if (ent->client->awaiting_respawn || (level.intermission_eou || level.is_n64 || (deathmatch->integer && level.intermissiontime)))
 		{
-			current_client->ps.screen_blend[3] = current_client->ps.damage_blend[3] = 0;
-			current_client->ps.fov = 90;
-			current_client->ps.gunindex = 0;
+			client->ps.screen_blend[3] = client->ps.damage_blend[3] = 0;
+			client->ps.fov = 90;
+			client->ps.gunindex = 0;
 		}
 		G_SetStats(ent);
 		G_SetCoopStats(ent);
@@ -1403,10 +1402,8 @@
 	CTFApplyRegeneration(ent);
 	// ZOID
 
+	vec3_t forward, right, up;
 	AngleVectors(ent->client->v_angle, forward, right, up);
-
-	// burn from lava, etc
-	P_WorldEffects();
 
 	//
 	// set model angles from view angles so other things in
@@ -1420,47 +1417,50 @@
 	ent->s.angles[YAW] = ent->client->v_angle[YAW];
 	ent->s.angles[ROLL] = 0;
 	// [Paril-KEX] cl_rollhack
-	ent->s.angles[ROLL] = -SV_CalcRoll(ent->s.angles, ent->velocity) * 4;
+	ent->s.angles[ROLL] = -SV_CalcRoll(ent->client, ent->s.angles, ent->velocity, right) * 4;
 
 	//
 	// calculate speed and cycle to be used for
 	// all cyclic walking effects
 	//
-	xyspeed = sqrt(ent->velocity[0] * ent->velocity[0] + ent->velocity[1] * ent->velocity[1]);
-
-	if (xyspeed < 5)
-	{
-		bobmove = 0;
-		current_client->bobtime = 0; // start at beginning of cycle again
+	step_parameters_t step {};
+	step.xyspeed = sqrt(ent->velocity[0] * ent->velocity[0] + ent->velocity[1] * ent->velocity[1]);
+
+	if (step.xyspeed < 5)
+	{
+		client->bobtime = 0; // start at beginning of cycle again
 	}
 	else if (ent->groundentity)
 	{ // so bobbing only cycles when on ground
-		if (xyspeed > 210)
-			bobmove = gi.frame_time_ms / 400.f;
-		else if (xyspeed > 100)
-			bobmove = gi.frame_time_ms / 800.f;
+		if (step.xyspeed > 210)
+			step.bobmove = gi.frame_time_ms / 400.f;
+		else if (step.xyspeed > 100)
+			step.bobmove = gi.frame_time_ms / 800.f;
 		else
-			bobmove = gi.frame_time_ms / 1600.f;
-	}
-
-	bobtime = (current_client->bobtime += bobmove);
-	bobtime_run = bobtime;
-
-	if ((current_client->ps.pmove.pm_flags & PMF_DUCKED) && ent->groundentity)
+			step.bobmove = gi.frame_time_ms / 1600.f;
+	}
+
+	float bobtime = (client->bobtime += step.bobmove);
+	float bobtime_run = bobtime;
+
+	if ((client->ps.pmove.pm_flags & PMF_DUCKED) && ent->groundentity)
 		bobtime *= 4;
 
-	bobcycle = (int) bobtime;
-	bobcycle_run = (int) bobtime_run;
-	bobfracsin = fabsf(sinf(bobtime * PIf));
+	step.bobcycle = (int) bobtime;
+	step.bobcycle_run = (int) bobtime_run;
+	step.bobfracsin = fabsf(sinf(bobtime * PIf));
+
+	// burn from lava, etc
+	P_WorldEffects(ent, step);
 
 	// apply all the damage taken this frame
-	P_DamageFeedback(ent);
+	P_DamageFeedback(ent, forward, right, up);
 
 	// determine the view offsets
-	SV_CalcViewOffset(ent);
+	SV_CalcViewOffset(ent, forward, right, step);
 
 	// determine the gun offsets
-	SV_CalcGunOffset(ent);
+	SV_CalcGunOffset(ent, forward, right, up, step);
 
 	// determine the full screen color blend
 	// must be after viewoffset, so eye contents can be
@@ -1477,13 +1477,13 @@
 
 	G_SetCoopStats(ent);
 
-	G_SetClientEvent(ent);
+	G_SetClientEvent(ent, step);
 
 	G_SetClientEffects(ent);
 
 	G_SetClientSound(ent);
 
-	G_SetClientFrame(ent);
+	G_SetClientFrame(ent, step);
 
 	ent->client->oldvelocity = ent->velocity;
 	ent->client->oldviewangles = ent->client->ps.viewangles;
--- a/p_weapon.cpp	2023-10-03 19:43:06
+++ b/p_weapon.cpp	2025-09-04 19:53:48
@@ -266,7 +266,15 @@
 			if (G_CheckInfiniteAmmo(ammo))
 				Add_Ammo(other, ammo, 1000);
 			else
-				Add_Ammo(other, ammo, ammo->quantity);
+			{
+				// in PSX, we get double ammo with pickups
+				int given_quantity = ammo->quantity;
+
+				if (level.is_psx && deathmatch->integer)
+					given_quantity *= 2;
+
+				Add_Ammo(other, ammo, given_quantity);
+			}
 		}
 
 		if (!(ent->spawnflags & SPAWNFLAG_ITEM_DROPPED_PLAYER))
@@ -1420,7 +1428,7 @@
 				damage = 15;
 			else
 				damage = 20;
-			Blaster_Fire(ent, offset, damage, true, (ent->client->ps.gunframe % 4) ? EF_NONE : EF_HYPERBLASTER);
+			Blaster_Fire(ent, offset, damage, true, ((ent->client->ps.gunframe - 6) % 4) == 0 ? EF_HYPERBLASTER : EF_NONE);
 			Weapon_PowerupSound(ent);
 
 			G_RemoveAmmo(ent);
@@ -1893,33 +1901,3 @@
 
 	Weapon_Generic(ent, 8, 32, 54, 58, pause_frames, fire_frames, weapon_bfg_fire);
 }
-
-//======================================================================
-
-void weapon_disint_fire(edict_t *self)
-{
-	vec3_t start, dir;
-	P_ProjectSource(self, self->client->v_angle, { 24, 8, -8 }, start, dir);
-
-	P_AddWeaponKick(self, self->client->v_forward * -2, { -1.f, 0.f, 0.f });
-
-	fire_disintegrator(self, start, dir, 800);
-
-	// send muzzle flash
-	gi.WriteByte(svc_muzzleflash);
-	gi.WriteEntity(self);
-	gi.WriteByte(MZ_BLASTER2);
-	gi.multicast(self->s.origin, MULTICAST_PVS, false);
-
-	PlayerNoise(self, start, PNOISE_WEAPON);
-
-	G_RemoveAmmo(self);
-}
-
-void Weapon_Beta_Disintegrator(edict_t *ent)
-{
-	constexpr int pause_frames[] = { 30, 37, 45, 0 };
-	constexpr int fire_frames[] = { 17, 0 };
-
-	Weapon_Generic(ent, 16, 23, 46, 50, pause_frames, fire_frames, weapon_disint_fire);
-}
--- a/q_std.h	2023-10-03 19:43:06
+++ b/q_std.h	2025-09-04 19:53:48
@@ -24,11 +24,11 @@
 // format!
 #ifndef USE_CPP20_FORMAT
 #ifdef __cpp_lib_format
-#define USE_CPP20_FORMAT 1
-#endif
-#endif
-
-#if USE_CPP20_FORMAT
+#define USE_CPP20_FORMAT
+#endif
+#endif
+
+#ifdef USE_CPP20_FORMAT
 #include <format>
 namespace fmt = std;
 #define FMT_STRING(s) s
@@ -104,8 +104,8 @@
 
 using byte = uint8_t;
 
-// note: only works on actual arrays
-#define q_countof(a) std::extent_v<decltype(a)>
+template<class T, std::size_t N>
+constexpr size_t q_countof(const T (&array)[N]) { return std::size<T, N>(array); }
 
 using std::max;
 using std::min;
--- a/q_vec3.h	2023-10-03 19:43:06
+++ b/q_vec3.h	2025-09-04 19:53:48
@@ -514,10 +514,19 @@
     float dot = from.dot(to);
     float aFactor;
     float bFactor;
-    if (fabsf(dot) > 0.9995f)
+	if (dot >= 0.9995f)
+	{
+		aFactor = 1.0f - t;
+		bFactor = t;
+	}
+    else if (dot <= -0.9995f)
     {
-        aFactor = 1.0f - t;
-        bFactor = t;
+		vec3_t c = vec3_t { 1.0f, 0.0f, 0.0f }.cross(to);
+
+		if (t <= 0.5f)
+			return lerp(from, c, t * 2);
+		else
+			return lerp(c, to, (t - 0.5f) * 2);
     }
     else
     {
@@ -536,7 +545,7 @@
 struct fmt::formatter<vec3_t> : fmt::formatter<float>
 {
     template<typename FormatContext>
-    auto format(const vec3_t &p, FormatContext &ctx) -> decltype(ctx.out())
+    auto format(const vec3_t &p, FormatContext &ctx) const
     {
 		auto out = fmt::formatter<float>::format(p.x, ctx);
         out = fmt::format_to(out, " ");
--- /dev/null
+++ b/quake1/g_q1_ai.cpp	2025-09-04 19:53:48
@@ -0,0 +1,131 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+
+
+PRETHINK(CheckTeleportReturn) (edict_t* self) -> void
+{
+	gi.Com_PrintFmt("{}: checking to return 1\n", *self);
+	if (!self->active)
+		return;
+
+	gi.Com_PrintFmt("{}: checking to return 2\n", *self);
+	// Only check after timer
+	if (level.time < self->timeout)
+		return;
+
+	gi.Com_PrintFmt("{}: checking to return 3\n", *self);
+	// If the monster cannot see its enemy, return to pre-teleport position
+	if (!self->enemy || !visible(self, self->enemy)) {
+		// Teleport effect - departure
+		gi.WriteByte(svc_temp_entity);
+		gi.WriteByte(TE_TELEPORT_EFFECT);
+		gi.WritePosition(self->s.origin);
+		gi.multicast(self->s.origin, MULTICAST_PVS, false);
+
+		gi.Com_PrintFmt("{}: returning\n", *self);
+		// Restore original position
+		self->s.origin = self->monsterinfo.shottarget;
+		gi.linkentity(self);
+
+		// Teleport effect - arrival
+		gi.WriteByte(svc_temp_entity);
+		gi.WriteByte(TE_TELEPORT_EFFECT);
+		gi.WritePosition(self->s.origin);
+		gi.multicast(self->s.origin, MULTICAST_PVS, false);
+	}
+
+	// Reset flag
+	self->active = false;
+}
+
+bool TryRandomTeleportPosition(edict_t* self, float radius)
+{
+
+	for (int i = 0; i < 10; ++i) {
+		vec3_t offset = {
+			crandom() * radius,
+			crandom() * radius,
+			crandom() * (radius * 0.5f)  // vertical variation
+		};
+		vec3_t target = self->s.origin + offset;
+
+		// Check if location is in solid
+		trace_t tr = gi.trace(self->s.origin, self->mins, self->maxs, target, self, MASK_SOLID);
+		if (tr.startsolid) {
+			continue;
+		}
+
+		// Check if occupied by other entity
+		trace_t occ = gi.trace(target, self->mins, self->maxs, target, self, MASK_MONSTERSOLID);
+		if (occ.fraction < 1.0f) {
+			continue;
+		}
+
+		// Teleport effect - departure
+		gi.WriteByte(svc_temp_entity);
+		gi.WriteByte(TE_TELEPORT_EFFECT);
+		gi.WritePosition(self->s.origin);
+		gi.multicast(self->s.origin, MULTICAST_PVS, false);
+
+		// Move monster
+		self->monsterinfo.shottarget = self->s.origin;
+		self->timeout = level.time + 1_sec;
+		self->active = 1;
+		self->postthink = CheckTeleportReturn;
+
+		self->s.origin = target;
+		gi.linkentity(self);
+
+		// Teleport effect - arrival
+		gi.WriteByte(svc_temp_entity);
+		gi.WriteByte(TE_TELEPORT_EFFECT);
+		gi.WritePosition(self->s.origin);
+		gi.multicast(self->s.origin, MULTICAST_PVS, false);
+
+		return true;
+	}
+	return false;
+}
+
+// TO DO: Replace explosions with gibs
+
+THINK(Q1BossExplode_think) (edict_t* self) -> void
+{
+    // owner gone or changed
+    if (!self->owner->inuse || self->owner->s.modelindex != self->style || self->count != self->owner->spawn_count)
+    {
+        G_FreeEdict(self);
+        return;
+    }
+
+    vec3_t org = self->owner->s.origin + self->owner->mins;
+
+    org.x += frandom() * self->owner->size.x;
+    org.y += frandom() * self->owner->size.y;
+    org.z += frandom() * self->owner->size.z;
+
+    gi.WriteByte(svc_temp_entity);
+    gi.WriteByte(!(self->viewheight % 3) ? TE_EXPLOSION1 : TE_EXPLOSION1_NL);
+    gi.WritePosition(org);
+    gi.multicast(org, MULTICAST_PVS, false);
+
+    self->viewheight++;
+
+    self->nextthink = level.time + random_time(50_ms, 200_ms);
+}
+
+void Q1BossExplode(edict_t* self)
+{
+    // no blowy on deady
+    if (self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
+        return;
+
+    edict_t* exploder = G_Spawn();
+    exploder->owner = self;
+    exploder->count = self->spawn_count;
+    exploder->style = self->s.modelindex;
+    exploder->think = Q1BossExplode_think;
+    exploder->nextthink = level.time + random_time(75_ms, 250_ms);
+    exploder->viewheight = 0;
+}
--- /dev/null
+++ b/quake1/g_q1_monster.cpp	2025-09-04 19:53:48
@@ -0,0 +1,691 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+
+/*
+=================
+fire_lavaball
+
+Fires a single explosive lavaball. Used by eldritch monsters.
+=================
+*/
+
+TOUCH(lavaball_touch) (edict_t* ent, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	vec3_t origin;
+
+	if (other == ent->owner)
+		return;
+
+	if (tr.surface && (tr.surface->flags & SURF_SKY))
+	{
+		G_FreeEdict(ent);
+		return;
+	}
+
+	if (ent->owner->client)
+		PlayerNoise(ent->owner, ent->s.origin, PNOISE_IMPACT);
+
+	// calculate position for the explosion entity
+	origin = ent->s.origin + tr.plane.normal;
+
+	if (other->takedamage)
+	{
+		T_Damage(other, ent, ent->owner, ent->velocity, ent->s.origin, tr.plane.normal, ent->dmg, ent->dmg, DAMAGE_NONE, MOD_ROCKET);
+	}
+	else
+	{
+		// don't throw any debris in net games
+		if (!deathmatch->integer && !coop->integer)
+		{
+			if (tr.surface && !(tr.surface->flags & (SURF_WARP | SURF_TRANS33 | SURF_TRANS66 | SURF_FLOWING)))
+			{
+				BecomeExplosion1(ent);
+			}
+		}
+	}
+
+	T_RadiusDamage(ent, ent->owner, (float)ent->radius_dmg, other, ent->dmg_radius, DAMAGE_NONE, MOD_R_SPLASH);
+
+	gi.WriteByte(svc_temp_entity);
+	if (ent->waterlevel)
+		gi.WriteByte(TE_ROCKET_EXPLOSION_WATER);
+	else
+		gi.WriteByte(TE_ROCKET_EXPLOSION);
+	gi.WritePosition(origin);
+	gi.multicast(ent->s.origin, MULTICAST_PHS, false);
+
+	G_FreeEdict(ent);
+}
+
+edict_t* fire_lavaball(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, float damage_radius, int radius_damage)
+{
+	edict_t* lavaball;
+
+	lavaball = G_Spawn();
+	lavaball->s.origin = start;
+	lavaball->s.angles = vectoangles(dir);
+	lavaball->s.effects |= EF_FIREBALL;
+	lavaball->velocity = dir * speed;
+	lavaball->movetype = MOVETYPE_FLYMISSILE;
+	lavaball->svflags |= SVF_PROJECTILE;
+	lavaball->flags |= FL_DODGE;
+	lavaball->clipmask = MASK_PROJECTILE;
+	// [Paril-KEX]
+	if (self->client && !G_ShouldPlayersCollide(true))
+		lavaball->clipmask &= ~CONTENTS_PLAYER;
+	lavaball->solid = SOLID_BBOX;
+	lavaball->s.modelindex = gi.modelindex("models/objects/gibs/sm_meat/tris.md2");
+	lavaball->owner = self;
+	lavaball->touch = lavaball_touch;
+	lavaball->nextthink = level.time + gtime_t::from_sec(8000.f / speed);
+	lavaball->think = G_FreeEdict;
+	lavaball->dmg = damage;
+	lavaball->radius_dmg = radius_damage;
+	lavaball->dmg_radius = damage_radius;
+	lavaball->classname = "lavaball";
+
+	gi.linkentity(lavaball);
+
+	return lavaball;
+}
+
+/*
+=================
+fire_vorepod
+
+Fires a homing explosive spiked ball. Used by eldritch monsters.
+=================
+*/
+TOUCH(vorepod_touch) (edict_t* ent, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	vec3_t origin;
+
+	if (other == ent->owner)
+		return;
+
+	if (tr.surface && (tr.surface->flags & SURF_SKY))
+	{
+		G_FreeEdict(ent);
+		return;
+	}
+
+	if (ent->owner->client)
+		PlayerNoise(ent->owner, ent->s.origin, PNOISE_IMPACT);
+
+	// calculate position for the explosion entity
+	origin = ent->s.origin + tr.plane.normal;
+
+	if (other->takedamage)
+	{
+		T_Damage(other, ent, ent->owner, ent->velocity, ent->s.origin, tr.plane.normal, ent->dmg, ent->dmg, DAMAGE_NONE, MOD_ROCKET);
+	}
+
+	T_RadiusDamage(ent, ent->owner, (float)ent->radius_dmg, other, ent->dmg_radius, DAMAGE_NONE, MOD_R_SPLASH);
+
+	gi.WriteByte(svc_temp_entity);
+	if (ent->waterlevel)
+		gi.WriteByte(TE_ROCKET_EXPLOSION_WATER);
+	else
+		gi.WriteByte(TE_ROCKET_EXPLOSION);
+	gi.WritePosition(origin);
+	gi.multicast(ent->s.origin, MULTICAST_PHS, false);
+
+	G_FreeEdict(ent);
+}
+
+THINK(vorepod_think) (edict_t* self) -> void
+{
+	edict_t* acquire = nullptr;
+	float	 oldlen = 0;
+	float	 olddot = 1;
+
+	vec3_t fwd = AngleVectors(self->s.angles).forward;
+
+	// try to stay on current target if possible
+	if (self->enemy)
+	{
+		acquire = self->enemy;
+
+		if (acquire->health <= 0 ||
+			!visible(self, acquire))
+		{
+			self->enemy = acquire = nullptr;
+		}
+	}
+
+	if (!acquire)
+	{
+		edict_t* target = nullptr;
+
+		// acquire new target
+		while ((target = findradius(target, self->s.origin, 1024)) != nullptr)
+		{
+			if (self->owner == target)
+				continue;
+			if (!target->client)
+				continue;
+			if (target->health <= 0)
+				continue;
+			if (!visible(self, target))
+				continue;
+
+			vec3_t vec = self->s.origin - target->s.origin;
+			float len = vec.length();
+
+			float dot = vec.normalized().dot(fwd);
+
+			// targets that require us to turn less are preferred
+			if (dot >= olddot)
+				continue;
+
+			if (acquire == nullptr || dot < olddot || len < oldlen)
+			{
+				acquire = target;
+				oldlen = len;
+				olddot = dot;
+			}
+		}
+	}
+
+	if (acquire != nullptr)
+	{
+		vec3_t vec = (acquire->s.origin - self->s.origin).normalized();
+		float t = self->accel;
+
+		float d = self->movedir.dot(vec);
+
+		if (d < 0.45f && d > -0.45f)
+			vec = -vec;
+
+		self->movedir = slerp(self->movedir, vec, t).normalized();
+		self->s.angles = vectoangles(self->movedir);
+
+		if (self->enemy != acquire)
+		{
+			self->enemy = acquire;
+		}
+	}
+	else
+		self->enemy = nullptr;
+
+	self->velocity = self->movedir * self->speed;
+	self->nextthink = level.time + FRAME_TIME_MS;
+}
+
+// RAFAEL
+void fire_vorepod(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, float damage_radius, int radius_damage, float turn_fraction, int skin)
+{
+	edict_t* vorepod;
+
+	vorepod = G_Spawn();
+	vorepod->s.origin = start;
+	vorepod->movedir = dir;
+	vorepod->s.angles = vectoangles(dir);
+	vorepod->velocity = dir * speed;
+	vorepod->flags |= FL_DODGE;
+	vorepod->movetype = MOVETYPE_FLYMISSILE;
+	vorepod->svflags |= SVF_PROJECTILE;
+	vorepod->clipmask = MASK_PROJECTILE;
+	vorepod->solid = SOLID_BBOX;
+	vorepod->s.effects |= EF_TRACKER;
+	vorepod->s.modelindex = gi.modelindex("models/proj/pod/tris.md2");
+	vorepod->s.skinnum |= skin; //0 = purple, 1 = red
+	vorepod->owner = self;
+	vorepod->touch = vorepod_touch;
+	vorepod->speed = speed;
+	vorepod->accel = turn_fraction;
+
+	vorepod->nextthink = level.time + FRAME_TIME_MS;
+	vorepod->think = vorepod_think;
+
+	vorepod->dmg = damage;
+	vorepod->radius_dmg = radius_damage;
+	vorepod->dmg_radius = damage_radius;
+
+	if (visible(vorepod, self->enemy))
+	{
+		vorepod->enemy = self->enemy;
+	}
+
+	gi.linkentity(vorepod);
+}
+
+/*
+=================
+fire_flame
+
+Fires a flame bolt. Used by eldritch monsters.
+=================
+*/
+TOUCH(flame_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (other == self->owner)
+		return;
+
+	if (tr.surface && (tr.surface->flags & SURF_SKY))
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	// PMM - crash prevention
+	if (self->owner && self->owner->client)
+		PlayerNoise(self->owner, self->s.origin, PNOISE_IMPACT);
+
+	if (other->takedamage)
+		T_Damage(other, self, self->owner, self->velocity, self->s.origin, tr.plane.normal, self->dmg, 1, DAMAGE_ENERGY, static_cast<mod_id_t>(self->style));
+	else
+	{
+		gi.WriteByte(svc_temp_entity);
+		gi.WriteByte(TE_SPARKS);
+		gi.WritePosition(self->s.origin);
+		gi.WriteDir(tr.plane.normal);
+		gi.multicast(self->s.origin, MULTICAST_PHS, false);
+	}
+
+	G_FreeEdict(self);
+}
+
+edict_t* fire_flame(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed)
+{
+	edict_t* flame;
+	trace_t	 tr;
+
+	flame = G_Spawn();
+	flame->svflags = SVF_PROJECTILE;
+	flame->s.origin = start;
+	flame->s.old_origin = start;
+	flame->s.angles = vectoangles(dir);
+	flame->velocity = dir * speed;
+	flame->movetype = MOVETYPE_FLYMISSILE;
+	flame->clipmask = MASK_PROJECTILE;
+	// [Paril-KEX]
+	if (self->client && !G_ShouldPlayersCollide(true))
+		flame->clipmask &= ~CONTENTS_PLAYER;
+	flame->flags |= FL_DODGE;
+	flame->solid = SOLID_BBOX;
+	flame->s.effects |= EF_IONRIPPER;
+	flame->s.modelindex = gi.modelindex("models/proj/firebolt/tris.md2");
+	flame->s.sound = gi.soundindex("monsters/hknight/attack1.wav");
+	flame->owner = self;
+	flame->touch = flame_touch;
+	flame->nextthink = level.time + 2_sec;
+	flame->think = G_FreeEdict;
+	flame->dmg = damage;
+	flame->classname = "flame";
+	gi.linkentity(flame);
+
+	tr = gi.traceline(self->s.origin, flame->s.origin, flame, flame->clipmask);
+	if (tr.fraction < 1.0f)
+	{
+		flame->s.origin = tr.endpos + (tr.plane.normal * 1.f);
+		flame->touch(flame, tr.ent, tr, false);
+	}
+
+	return flame;
+}
+
+/*
+=================
+q1_fire_gib
+
+Fires a gib projectile.  Used by the Zombie.
+=================
+*/
+
+TOUCH(zombiegib_touch) (edict_t *ent, edict_t *other, const trace_t& tr, bool surf) -> void
+{
+	edict_t* owner = ent;
+	vec3_t normal;
+
+	if (other == ent->owner)
+		return;
+
+	if (tr.surface && (tr.surface->flags & SURF_SKY))
+	{
+		G_FreeEdict (ent);
+		return;
+	}
+
+	if (other->takedamage)
+	{
+		vec3_t dir = other->s.origin - ent->s.origin;
+		// FIX MOD
+		T_Damage(other, ent, owner, dir, ent->s.origin, normal, ent->dmg, ent->dmg, DAMAGE_NONE, MOD_GEKK);
+
+		gi.sound (ent, CHAN_RELIABLE|CHAN_WEAPON, gi.soundindex ("q1zombie/z_hit.wav"), 1.0, ATTN_NORM, 0);	
+	}
+	else
+	{
+		gi.sound (ent, CHAN_RELIABLE|CHAN_WEAPON, gi.soundindex ("q1zombie/z_miss.wav"), 1.0, ATTN_NORM, 0);
+		gi.WriteByte (svc_temp_entity);
+		gi.WriteByte (TE_BLOOD);
+		gi.WritePosition (ent->s.origin);
+		gi.WriteDir(tr.plane.normal);
+		gi.multicast (ent->s.origin, MULTICAST_PVS, false);
+	}
+		
+//	no more touches	
+	ent->touch = nullptr ;
+
+	ent->nextthink = level.time + 3_sec;
+	ent->think = G_FreeEdict;
+}
+
+
+void fire_gib (edict_t *self, vec3_t start, vec3_t aimdir, int damage, int speed, float right_adjust, float up_adjust)
+{
+	edict_t	*gib;
+	vec3_t	dir;
+	vec3_t	 forward, right, up;
+
+	dir = vectoangles(aimdir);
+	AngleVectors(dir, forward, right, up);
+
+	gib = G_Spawn();
+	gib->s.origin = start;
+	gib->velocity = aimdir * speed;
+
+	if (up_adjust)
+	{
+		float gravityAdjustment = level.gravity / 800.f;
+
+		gib->velocity += up * up_adjust * gravityAdjustment;
+	}
+
+	if (right_adjust)
+	gib->velocity += right * right_adjust;
+
+	gib->movetype = MOVETYPE_BOUNCE;
+	gib->clipmask = MASK_PROJECTILE;
+	if (self->client && !G_ShouldPlayersCollide(true))
+		gib->clipmask &= ~CONTENTS_PLAYER;
+	gib->solid = SOLID_BBOX;
+	gib->svflags |= SVF_PROJECTILE;
+	gib->flags |= FL_DODGE;
+	gib->s.effects |= EF_GIB;
+	gib->speed = speed;
+	gib->mins = { -6, -6, -6 };
+	gib->maxs = { 6, 6, 6 };
+	gib->avelocity = { crandom() * 360, crandom() * 360, crandom() * 360 };
+	gib->s.modelindex = gi.modelindex ("models/proj/zomgib/tris.md2");
+	gib->owner = self;
+	gib->touch = zombiegib_touch;
+	gib->nextthink = level.time + 2.5_sec;
+	gib->think = G_FreeEdict;
+	gib->dmg = damage;
+	gib->classname = "gib";
+
+	gi.linkentity (gib);
+}
+
+/*
+=================
+fire_plasmaball
+
+Fires a ball of lightning that explodes on impact. Magical partial-BFG.
+=================
+*/
+
+THINK(plasmaball_explode) (edict_t* self) -> void
+{
+	edict_t* ent;
+	float	 points;
+	vec3_t	 v;
+	float	 dist;
+
+	if (self->s.frame == 0)
+	{
+		// the BFG effect
+		ent = nullptr;
+		while ((ent = findradius(ent, self->s.origin, self->dmg_radius)) != nullptr)
+		{
+			if (!ent->takedamage)
+				continue;
+			if (ent == self->owner)
+				continue;
+			if (!CanDamage(ent, self))
+				continue;
+			if (!CanDamage(ent, self->owner))
+				continue;
+			// ROGUE - make tesla hurt by bfg
+			if (!(ent->svflags & SVF_MONSTER) && !(ent->flags & FL_DAMAGEABLE) && (!ent->client) && (strcmp(ent->classname, "misc_explobox") != 0))
+				continue;
+			// ZOID
+			// don't target players in CTF
+			if (CheckTeamDamage(ent, self->owner))
+				continue;
+			// ZOID
+
+			v = ent->mins + ent->maxs;
+			v = ent->s.origin + (v * 0.5f);
+			vec3_t centroid = v;
+			v = self->s.origin - centroid;
+			dist = v.length();
+			points = self->radius_dmg * (1.0f - sqrtf(dist / self->dmg_radius));
+
+			T_Damage(ent, self, self->owner, self->velocity, centroid, vec3_origin, (int)points, 0, DAMAGE_ENERGY, MOD_BFG_EFFECT);
+
+			// Paril: draw BFG lightning laser to enemies
+			gi.WriteByte(svc_temp_entity);
+			gi.WriteByte(TE_LIGHTNING);
+			gi.WriteEntity(self);	// source entity
+			gi.WriteEntity(world); // destination entity
+			gi.WritePosition(self->s.origin);
+			gi.WritePosition(centroid);
+			gi.multicast(self->s.origin, MULTICAST_PHS, false);
+		}
+	}
+
+	self->nextthink = level.time;
+	self->think = G_FreeEdict;
+}
+
+TOUCH(plasmaball_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (other == self->owner)
+		return;
+
+	if (tr.surface && (tr.surface->flags & SURF_SKY))
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	if (self->owner->client)
+		PlayerNoise(self->owner, self->s.origin, PNOISE_IMPACT);
+
+	// core explosion - prevents firing it into the wall/floor
+	if (other->takedamage)
+		T_Damage(other, self, self->owner, self->velocity, self->s.origin, tr.plane.normal, 200, 0, DAMAGE_ENERGY, MOD_BFG_BLAST);
+	T_RadiusDamage(self, self->owner, 200, other, 100, DAMAGE_ENERGY, MOD_BFG_BLAST);
+
+	gi.sound(self, CHAN_VOICE, gi.soundindex("weapons/bfg__x1b.wav"), 1, ATTN_NORM, 0);
+	self->solid = SOLID_NOT;
+	self->touch = nullptr;
+	self->s.origin += self->velocity * (-1 * gi.frame_time_s);
+	self->velocity = {};
+//	self->s.modelindex = gi.modelindex("sprites/s_bfg3.sp2");
+	self->s.frame = 0;
+	self->s.sound = 0;
+	self->s.effects &= ~EF_ANIM_ALLFAST;
+	self->think = plasmaball_explode;
+	self->nextthink = level.time + 10_hz;
+	self->enemy = other;
+
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_NUKEBLAST);
+	gi.WritePosition(self->s.origin);
+	gi.multicast(self->s.origin, MULTICAST_PHS, false);
+}
+
+void fire_plasmaball(edict_t* self, const vec3_t& start, const vec3_t& dir, int damage, int speed, float damage_radius)
+{
+	edict_t* plasma;
+
+	plasma = G_Spawn();
+	plasma->s.origin = start;
+	plasma->s.angles = vectoangles(dir);
+	plasma->velocity = dir * speed;
+	plasma->svflags = SVF_PROJECTILE;
+	plasma->movetype = MOVETYPE_FLYMISSILE;
+	plasma->clipmask = MASK_PROJECTILE;
+	plasma->flags |= FL_DODGE;
+
+	// [Paril-KEX]
+	if (self->client && !G_ShouldPlayersCollide(true))
+		plasma->clipmask &= ~CONTENTS_PLAYER;
+
+	plasma->solid = SOLID_BBOX;
+	plasma->s.effects |= EF_PLASMA;
+	plasma->s.modelindex = gi.modelindex("models/proj/plasma/tris.md2");
+	plasma->touch = plasmaball_touch;
+
+	plasma->owner = self;
+	plasma->nextthink = level.time + gtime_t::from_sec(8000.f / speed);
+	plasma->think = G_FreeEdict;
+	plasma->radius_dmg = damage;
+	plasma->dmg_radius = damage_radius;
+	plasma->classname = "plasma blast";
+	plasma->s.sound = gi.soundindex("weapons/plasma__l1a.wav");
+
+	plasma->teammaster = plasma;
+	plasma->teamchain = nullptr;
+
+	gi.linkentity(plasma);
+}
+
+/*
+=================
+fire_multigrenade
+
+Fires a grenade that splits into four smaller grenades. Used by multigrenade ogre.
+=================
+*/
+//PLACEHOLDER - Functions like grenades for now.
+static void MultiGrenade_ExplodeReal(edict_t* ent, edict_t* other, vec3_t normal)
+{
+	vec3_t origin;
+	mod_t  mod;
+
+	if (ent->owner->client)
+		PlayerNoise(ent->owner, ent->s.origin, PNOISE_IMPACT);
+
+	// FIXME: if we are onground then raise our Z just a bit since we are a point?
+	if (other)
+	{
+		vec3_t dir = other->s.origin - ent->s.origin;
+		mod = MOD_GRENADE;
+		T_Damage(other, ent, ent->owner, dir, ent->s.origin, normal, ent->dmg, ent->dmg, mod.id == MOD_HANDGRENADE ? DAMAGE_RADIUS : DAMAGE_NONE, mod);
+	}
+
+	mod = MOD_G_SPLASH;
+	T_RadiusDamage(ent, ent->owner, (float)ent->dmg, other, ent->dmg_radius, DAMAGE_NONE, mod);
+
+	origin = ent->s.origin + normal;
+	gi.WriteByte(svc_temp_entity);
+	if (ent->waterlevel)
+	{
+		if (ent->groundentity)
+			gi.WriteByte(TE_GRENADE_EXPLOSION_WATER);
+		else
+			gi.WriteByte(TE_ROCKET_EXPLOSION_WATER);
+	}
+	else
+	{
+		if (ent->groundentity)
+			gi.WriteByte(TE_GRENADE_EXPLOSION);
+		else
+			gi.WriteByte(TE_ROCKET_EXPLOSION);
+	}
+	gi.WritePosition(origin);
+	gi.multicast(ent->s.origin, MULTICAST_PHS, false);
+
+	G_FreeEdict(ent);
+}
+
+THINK(MultiGrenade_Explode) (edict_t* ent) -> void
+{
+	MultiGrenade_ExplodeReal(ent, nullptr, ent->velocity * -0.02f);
+}
+
+TOUCH(MultiGrenade_Touch) (edict_t* ent, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (other == ent->owner)
+		return;
+
+	if (tr.surface && (tr.surface->flags & SURF_SKY))
+	{
+		G_FreeEdict(ent);
+		return;
+	}
+
+	if (!other->takedamage)
+	{
+		gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/grenlb1b.wav"), 1, ATTN_NORM, 0);
+	
+		return;
+	}
+
+	MultiGrenade_ExplodeReal(ent, other, tr.plane.normal);
+}
+
+void fire_multigrenade(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, gtime_t timer, float damage_radius, float right_adjust, float up_adjust, bool monster)
+{
+	edict_t* grenade;
+	vec3_t	 dir;
+	vec3_t	 forward, right, up;
+
+	dir = vectoangles(aimdir);
+	AngleVectors(dir, forward, right, up);
+
+	grenade = G_Spawn();
+	grenade->s.origin = start;
+	grenade->velocity = aimdir * speed;
+
+	if (up_adjust)
+	{
+		float gravityAdjustment = level.gravity / 800.f;
+		grenade->velocity += up * up_adjust * gravityAdjustment;
+	}
+
+	if (right_adjust)
+		grenade->velocity += right * right_adjust;
+
+	grenade->movetype = MOVETYPE_BOUNCE;
+	grenade->clipmask = MASK_PROJECTILE;
+	if (self->client && !G_ShouldPlayersCollide(true))
+		grenade->clipmask &= ~CONTENTS_PLAYER;
+	grenade->solid = SOLID_BBOX;
+	grenade->svflags |= SVF_PROJECTILE;
+	grenade->flags |= (FL_DODGE | FL_TRAP);
+	grenade->s.effects |= EF_GRENADE;
+	grenade->speed = speed;
+	grenade->avelocity = { crandom() * 360, crandom() * 360, crandom() * 360 };
+	grenade->s.modelindex = gi.modelindex("models/objects/grenade/tris.md2");
+	grenade->nextthink = level.time + timer;
+	grenade->think = MultiGrenade_Explode;
+	grenade->s.effects |= EF_GRENADE_LIGHT;
+	grenade->owner = self;
+	grenade->touch = MultiGrenade_Touch;
+	grenade->dmg = damage;
+	grenade->dmg_radius = damage_radius;
+	grenade->classname = "grenade";
+
+	gi.linkentity(grenade);
+}
+
+void monster_fire_multigrenade(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed,
+	monster_muzzleflash_id_t flashtype, float right_adjust, float up_adjust)
+{
+	if (EMPNukeCheck(self, self->s.origin))
+	{
+		gi.sound(self, CHAN_AUTO, gi.soundindex("items/empnuke/emp_missfire.wav"), 1, ATTN_NORM, 0);
+		fire_grenade(self, start, aimdir, damage, speed, 2.5_sec, damage + 40.f, right_adjust, up_adjust, true);
+		monster_muzzleflash(self, start, flashtype);
+		return;
+	}
+	fire_multigrenade(self, start, aimdir, damage, speed, 2.5_sec, damage + 40.f, right_adjust, up_adjust, true);
+	monster_muzzleflash(self, start, flashtype);
+}
--- /dev/null
+++ b/quake1/m_army.cpp	2025-09-04 19:53:48
@@ -0,0 +1,453 @@
+/*
+==============================================================================
+
+QUAKE ARMY
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_army.h"
+#include "../m_flash.h"
+
+constexpr spawnflags_t SPAWNFLAG_ARMY_NOJUMPING = 8_spawnflag;
+
+static cached_soundindex	sound_idle;
+static cached_soundindex	sound_sight;
+static cached_soundindex	sound_pain1;
+static cached_soundindex	sound_pain2;
+static cached_soundindex	sound_death;
+static cached_soundindex	sound_attack;
+
+void army_run(edict_t* self);
+void army_stand(edict_t* self);
+void army_attack(edict_t* self);
+
+MONSTERINFO_SEARCH(army_search) (edict_t* self) -> void
+{
+	gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_STATIC, 0);
+}
+
+// STAND
+
+mframe_t army_frames_stand [] =
+{
+	{ai_stand, 0},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(army_move_stand) = {FRAME_stand1, FRAME_stand8, army_frames_stand, army_stand};
+
+MONSTERINFO_STAND(army_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &army_move_stand);
+}
+
+//
+// WALK
+//
+
+mframe_t army_frames_walk [] =
+{
+	{ai_walk, 1},
+	{ai_walk, 1},
+	{ai_walk, 1},
+	{ai_walk, 1},
+	{ai_walk, 2},
+	{ai_walk, 3},
+	{ai_walk, 4},
+	{ai_walk, 4},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 1},
+	{ai_walk},
+	{ai_walk, 1},
+	{ai_walk, 1},
+	{ai_walk, 1},
+	{ai_walk, 3},
+	{ai_walk, 3},
+	{ai_walk, 3},
+	{ai_walk, 3},
+	{ai_walk, 2},
+	{ai_walk, 1},
+	{ai_walk, 1},
+	{ai_walk, 1}
+};
+MMOVE_T(army_move_walk) = {FRAME_prowl_1, FRAME_prowl_24, army_frames_walk, nullptr };
+
+MONSTERINFO_WALK(army_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &army_move_walk);
+}
+
+//
+// RUN
+//
+
+mframe_t army_frames_run [] =
+{
+	{ai_run, 11},
+	{ai_run, 15},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 8},
+	{ai_run, 15},
+	{ai_run, 10},
+	{ai_run, 15}
+};
+MMOVE_T(army_move_run) = {FRAME_run1, FRAME_run8, army_frames_run, army_run};
+
+MONSTERINFO_RUN(army_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+	{
+		M_SetAnimation(self, &army_move_stand);
+		return;
+	}
+	else
+		M_SetAnimation(self, &army_move_run);
+}
+
+//
+// PAIN
+//
+
+mframe_t army_frames_pain1 [] =
+{
+	{ai_move, -2},
+	{ai_move, 3},
+	{ai_move, 1},
+	{ai_move, 1},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(army_move_pain1) = {FRAME_pain1, FRAME_pain6, army_frames_pain1, army_run};
+
+mframe_t army_frames_pain2 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move, 13},
+	{ai_move, 9},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, -2},
+	{ai_move}
+};
+MMOVE_T(army_move_pain2) = {FRAME_painb1, FRAME_painb14, army_frames_pain2, army_run};
+
+mframe_t army_frames_pain3 [] =
+{
+	{ai_move},
+	{ai_move, -1},
+	{ai_move},
+	{ai_move},
+	{ai_move, 1},
+	{ai_move, 1},
+	{ai_move},
+	{ai_move, -1},
+	{ai_move, 4},
+	{ai_move, 3},
+	{ai_move, 6},
+	{ai_move, 8},
+	{ai_move}
+};
+MMOVE_T(army_move_pain3) = {FRAME_painc1, FRAME_painc13, army_frames_pain3, army_run};
+
+PAIN(army_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	float	r = frandom();
+	
+	if (level.time < self->pain_debounce_time)
+		return;
+	
+	if (self->health <= 0)
+		return;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	if (r < 0.2)
+	{
+		self->pain_debounce_time = level.time + 0.6_sec;
+		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &army_move_pain1);
+	}
+	else if (r < 0.6)
+	{
+		self->pain_debounce_time = level.time + 1.1_sec;
+		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &army_move_pain2);
+	}
+	else
+	{
+		self->pain_debounce_time = level.time + 1.1_sec;
+		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &army_move_pain3);
+	}
+}
+
+MONSTERINFO_SETSKIN(army_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// ATTACK
+//
+
+void army_fire (edict_t *self)
+{
+	vec3_t	start;
+	vec3_t	forward, right, up;
+	vec3_t	aim;
+	vec3_t	dir;
+	vec3_t	end;
+	float	r, u;
+	vec3_t					 aim_good;
+		
+	if (!self->enemy)
+		return;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[MZ2_SOLDIER_SHOTGUN_1], forward, right);
+
+	if ((!self->enemy) || (!self->enemy->inuse))
+	{
+		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+		return;
+	}
+
+	// PMM
+	if (self->monsterinfo.attack_state == AS_BLIND)
+		end = self->monsterinfo.blind_fire_target;
+	else
+		end = self->enemy->s.origin;
+	// pmm
+	end[2] += self->enemy->viewheight;
+	aim = end - start;
+	aim_good = end;
+	dir = vectoangles(aim);
+	AngleVectors(dir, forward, right, up);
+
+	r = crandom() * 1000;
+	u = crandom() * 500;
+
+	end = start + (forward * 8192);
+	end += (right * r);
+	end += (up * u);
+
+	aim = end - start;
+	aim.normalize();
+	
+	gi.sound (self, CHAN_VOICE, sound_attack, 1, ATTN_NORM, 0);
+	monster_fire_shotgun (self, start, aim, 2, 1, DEFAULT_SHOTGUN_HSPREAD, DEFAULT_SHOTGUN_VSPREAD, DEFAULT_SHOTGUN_COUNT, MZ2_SOLDIER_SHOTGUN_1);
+}
+
+void army_attack_refire (edict_t *self)
+{
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+	{
+		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+		return;
+	}
+
+	if (!self->enemy)
+		return;
+
+	if (self->count > 1)
+		return;
+
+	if (self->enemy->health <= 0)
+		return;
+
+	if (((frandom() < 0.5f) && visible(self, self->enemy)) || (range_to(self, self->enemy) <= RANGE_MELEE))
+		self->monsterinfo.nextframe = FRAME_shoot1;
+	else
+		self->monsterinfo.nextframe = FRAME_shoot8;
+}
+
+mframe_t army_frames_attack [] =
+{
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, army_fire},
+	{ai_charge},
+	{ai_charge, 0, army_attack_refire},
+	{ai_charge},
+	{ai_charge}
+};
+MMOVE_T(army_move_attack) = {FRAME_shoot1, FRAME_shoot9, army_frames_attack, army_run};
+
+MONSTERINFO_ATTACK(army_attack) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &army_move_attack);
+}
+
+//
+// SIGHT
+//
+
+MONSTERINFO_SIGHT(army_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+
+	if (self->enemy && (range_to(self, self->enemy) >= RANGE_NEAR) && visible(self, self->enemy))
+	{
+		M_SetAnimation(self, &army_move_attack);
+	}
+}
+
+//
+// DEATH
+//
+mframe_t army_frames_death1 [] =
+{
+	{ai_move},
+	{ai_move, -10},
+	{ai_move, -10},
+	{ai_move, -10},
+	{ai_move, -5},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(army_move_death1) = {FRAME_death1, FRAME_death10, army_frames_death1, monster_dead };
+
+mframe_t army_frames_death2 [] =
+{
+	{ai_move},
+	{ai_move, -5},
+	{ai_move, -4},
+	{ai_move, -13},
+	{ai_move, -3},
+	{ai_move, -4},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(army_move_death2) = {FRAME_deathc1, FRAME_deathc11, army_frames_death2, monster_dead };
+
+DIE(army_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	// check for gib
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+			//{ "models/monsters/army/gibs/chest.md2", GIB_SKINNED },
+			//{ 2, "models/monsters/army/gibs/arm.md2", GIB_SKINNED | GIB_UPRIGHT },
+			//{ "models/monsters/army/gibs/gun.md2", GIB_SKINNED | GIB_UPRIGHT },
+			//{ 2, "models/monsters/army/gibs/leg.md2", GIB_SKINNED },
+			{ "models/objects/gibs/chest/tris.md2" },
+			{ "models/monsters/army/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	// regular death
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	if (frandom() < 0.5)
+		M_SetAnimation(self, &army_move_death1);
+	else
+		M_SetAnimation(self, &army_move_death2);
+}
+
+/*QUAKED monster_army (1 .5 0) (-16 -16 -24) (16 16 40) Ambush Trigger_Spawn Sight
+model="models/monsters/army/tris.md2"
+*/
+void SP_monster_army (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+	
+	sound_idle.assign("army/idle.wav");
+	sound_sight.assign("army/sight1.wav");
+	sound_pain1.assign("army/pain1.wav");
+	sound_pain2.assign("army/pain2.wav");
+	sound_death.assign("army/death1.wav");
+	sound_attack.assign("army/sattck1.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex ("models/monsters/army/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 40 };
+	
+	self->health = 45 * st.health_multiplier;
+	self->gib_health = -35;
+	self->mass = 100;
+
+	self->pain = army_pain;
+	self->die = army_die;
+
+
+
+	self->monsterinfo.aiflags |= AI_STINKY;
+
+	self->monsterinfo.stand = army_stand;
+	self->monsterinfo.walk = army_walk;
+	self->monsterinfo.run = army_run;
+	self->monsterinfo.attack = army_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = army_sight;
+	self->monsterinfo.search = army_search;
+	self->monsterinfo.setskin = army_setskin;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &army_move_stand);
+
+	self->monsterinfo.scale = MODEL_SCALE;
+	self->monsterinfo.can_jump = !(self->spawnflags & SPAWNFLAG_ARMY_NOJUMPING);
+	self->monsterinfo.drop_height = 256;
+	self->monsterinfo.jump_height = 68;
+
+	walkmonster_start (self);
+}
+
+void Pickup_ArmyPack(edict_t* self)
+{
+	self->model = "models/items/pack/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_SHELLS), ED_GetSpawnTemp());
+	self->count = 5;
+}
--- /dev/null
+++ b/quake1/m_army.h	2025-09-04 19:53:48
@@ -0,0 +1,121 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_stand1,
+	FRAME_stand2,
+	FRAME_stand3,
+	FRAME_stand4,
+	FRAME_stand5,
+	FRAME_stand6,
+	FRAME_stand7,
+	FRAME_stand8,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_death8,
+	FRAME_death9,
+	FRAME_death10,
+	FRAME_deathc1,
+	FRAME_deathc2,
+	FRAME_deathc3,
+	FRAME_deathc4,
+	FRAME_deathc5,
+	FRAME_deathc6,
+	FRAME_deathc7,
+	FRAME_deathc8,
+	FRAME_deathc9,
+	FRAME_deathc10,
+	FRAME_deathc11,
+	FRAME_load1,
+	FRAME_load2,
+	FRAME_load3,
+	FRAME_load4,
+	FRAME_load5,
+	FRAME_load6,
+	FRAME_load7,
+	FRAME_load8,
+	FRAME_load9,
+	FRAME_load10,
+	FRAME_load11,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_pain4,
+	FRAME_pain5,
+	FRAME_pain6,
+	FRAME_painb1,
+	FRAME_painb2,
+	FRAME_painb3,
+	FRAME_painb4,
+	FRAME_painb5,
+	FRAME_painb6,
+	FRAME_painb7,
+	FRAME_painb8,
+	FRAME_painb9,
+	FRAME_painb10,
+	FRAME_painb11,
+	FRAME_painb12,
+	FRAME_painb13,
+	FRAME_painb14,
+	FRAME_painc1,
+	FRAME_painc2,
+	FRAME_painc3,
+	FRAME_painc4,
+	FRAME_painc5,
+	FRAME_painc6,
+	FRAME_painc7,
+	FRAME_painc8,
+	FRAME_painc9,
+	FRAME_painc10,
+	FRAME_painc11,
+	FRAME_painc12,
+	FRAME_painc13,
+	FRAME_run1,
+	FRAME_run2,
+	FRAME_run3,
+	FRAME_run4,
+	FRAME_run5,
+	FRAME_run6,
+	FRAME_run7,
+	FRAME_run8,
+	FRAME_shoot1,
+	FRAME_shoot2,
+	FRAME_shoot3,
+	FRAME_shoot4,
+	FRAME_shoot5,
+	FRAME_shoot6,
+	FRAME_shoot7,
+	FRAME_shoot8,
+	FRAME_shoot9,
+	FRAME_prowl_1,
+	FRAME_prowl_2,
+	FRAME_prowl_3,
+	FRAME_prowl_4,
+	FRAME_prowl_5,
+	FRAME_prowl_6,
+	FRAME_prowl_7,
+	FRAME_prowl_8,
+	FRAME_prowl_9,
+	FRAME_prowl_10,
+	FRAME_prowl_11,
+	FRAME_prowl_12,
+	FRAME_prowl_13,
+	FRAME_prowl_14,
+	FRAME_prowl_15,
+	FRAME_prowl_16,
+	FRAME_prowl_17,
+	FRAME_prowl_18,
+	FRAME_prowl_19,
+	FRAME_prowl_20,
+	FRAME_prowl_21,
+	FRAME_prowl_22,
+	FRAME_prowl_23,
+	FRAME_prowl_24
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_centroid.cpp	2025-09-04 19:53:48
@@ -0,0 +1,537 @@
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+QUAKE CENTROID
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_centroid.h"
+
+
+static cached_soundindex sound_idle;
+static cached_soundindex sound_pain1;
+static cached_soundindex sound_pain2;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_search;
+static cached_soundindex sound_melee1;
+static cached_soundindex sound_melee2;
+static cached_soundindex sound_walk;
+static cached_soundindex sound_fire1;
+static cached_soundindex sound_fire2;
+static cached_soundindex sound_death;
+
+//
+// SOUNDS
+//
+
+MONSTERINFO_IDLE(centroid_idle) (edict_t* self) -> void
+{
+	if (frandom() <= 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SEARCH(centroid_search) (edict_t* self) -> void
+{
+	if (frandom() <= 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SIGHT(centroid_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+//
+// STAND
+//
+
+mframe_t centroid_frames_stand[] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+
+	{ ai_stand },
+	{ ai_stand }
+};
+MMOVE_T(centroid_move_stand) = { FRAME_stand1, FRAME_stand12, centroid_frames_stand, nullptr };
+
+MONSTERINFO_STAND(centroid_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &centroid_move_stand);
+}
+
+// 
+// WALK
+// 
+
+mframe_t centroid_frames_walk[] = {
+	{ ai_walk, 8 },
+	{ ai_walk, 8 },
+	{ ai_walk, 8 },
+	{ ai_walk, 8 },
+	{ ai_walk, 8 },
+
+	{ ai_walk, 8 }
+};
+MMOVE_T(centroid_move_walk) = { FRAME_walk1, FRAME_walk6, centroid_frames_walk, nullptr };
+
+MONSTERINFO_WALK(centroid_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &centroid_move_walk);
+}
+
+// 
+// RUN
+// 
+
+mframe_t centroid_frames_run[] = {
+	{ ai_run, 14 },
+	{ ai_run, 14 },
+	{ ai_run, 14 },
+	{ ai_run, 14 },
+	{ ai_run, 14 },
+	{ ai_run, 14, monster_done_dodge }
+};
+MMOVE_T(centroid_move_run) = { FRAME_walk1, FRAME_walk6, centroid_frames_run, nullptr };
+
+mframe_t centroid_frames_run2[] = {
+	{ ai_run, 28 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 24 },
+	{ ai_run, 22 },
+	{ ai_run, 19, monster_done_dodge }
+};
+MMOVE_T(centroid_move_run2) = { FRAME_walk1, FRAME_walk6, centroid_frames_run2, nullptr };
+
+MONSTERINFO_RUN(centroid_run) (edict_t* self) -> void
+{
+	monster_done_dodge(self);
+
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+	{
+		M_SetAnimation(self, &centroid_move_stand);
+		return;
+	}
+
+	M_SetAnimation(self, &centroid_move_run);
+}
+
+// 
+// ATTACKS
+// 
+
+void centroid_attack2(edict_t* self);
+void centroid_reattack(edict_t* self);
+
+void centroid_fire_inner(edict_t* self)
+{
+	vec3_t					start;
+	vec3_t					forward, right, up;
+	vec3_t					aim;
+	gvec3_t					offset_right, offset_left;
+
+	AngleVectors(self->s.angles, forward, right, up);
+
+	offset_right = { 19, 26 , -14 };
+	offset_left = { 19, -26, -14 };
+
+	start = M_ProjectFlashSource(self, offset_right, forward, right);
+	PredictAim(self, self->enemy, start, 600, false, frandom() * 0.3f, &aim, nullptr);
+	fire_flechette(self, start, aim, 9, 600, 9 / 2);
+
+	start = M_ProjectFlashSource(self, offset_left, forward, right);
+	PredictAim(self, self->enemy, start, 600, false, frandom() * 0.3f, &aim, nullptr);
+	fire_flechette(self, start, aim, 9, 600, 9 / 2);
+
+	gi.sound(self, CHAN_WEAPON, sound_fire1, 1, ATTN_NORM, 0);
+}
+
+void centroid_fire_outer(edict_t* self)
+{
+	vec3_t					start;
+	vec3_t					forward, right, up;
+	vec3_t					aim;
+	gvec3_t					offset_right, offset_left;
+
+	AngleVectors(self->s.angles, forward, right, up);
+
+	offset_right = { 19, 38 , -14 };
+	offset_left = { 19, -38, -14 };
+
+	start = M_ProjectFlashSource(self, offset_right, forward, right);
+	PredictAim(self, self->enemy, start, 600, false, frandom() * 0.3f, &aim, nullptr);
+	fire_flechette(self, start, aim, 9, 600, 9 / 2);
+
+	start = M_ProjectFlashSource(self, offset_left, forward, right);
+	PredictAim(self, self->enemy, start, 600, false, frandom() * 0.3f, &aim, nullptr);
+	fire_flechette(self, start, aim, 9, 600, 9 / 2);
+
+	gi.sound(self, CHAN_WEAPON, sound_fire1, 1, ATTN_NORM, 0);
+}
+
+void centroid_fire_attack(edict_t* self)
+{
+	if (frandom() <= 0.25f)
+		centroid_fire_outer(self);
+	else if (frandom() <= 0.5f)
+		centroid_fire_inner(self);
+}
+
+mframe_t centroid_frames_attack1[] = {
+	{ ai_charge, 14, centroid_fire_inner },
+	{ ai_charge, 14, centroid_fire_outer }
+};
+MMOVE_T(centroid_move_attack1) = { FRAME_shoot1, FRAME_shoot2, centroid_frames_attack1, centroid_attack2 };
+
+mframe_t centroid_frames_attack2[] = {
+	{ ai_charge, 14, centroid_fire_inner },
+	{ ai_charge, 14, [](edict_t* self) { centroid_fire_outer(self); centroid_reattack(self); } },
+};
+MMOVE_T(centroid_move_attack2) = { FRAME_shoot1, FRAME_shoot2, centroid_frames_attack2, nullptr };
+
+void centroid_attack2(edict_t* self)
+{
+	M_SetAnimation(self, &centroid_move_attack2);
+}
+
+void centroid_reattack(edict_t* self)
+{
+	if (self->enemy->health > 0 && (visible(self, self->enemy)) && frandom() <= 0.6f)
+	{
+		if (frandom() <= 0.3f)
+			M_SetAnimation(self, &centroid_move_attack1);
+		else
+			M_SetAnimation(self, &centroid_move_run);
+	}
+	else
+		M_SetAnimation(self, &centroid_move_run);
+}
+
+MONSTERINFO_ATTACK(centroid_attack) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &centroid_move_attack1);
+}
+
+void centroid_swing(edict_t* self)
+{
+	gi.sound(self, CHAN_WEAPON, sound_melee1, 1, ATTN_NORM, 0);
+}
+
+void centroid_stinger(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->mins[0], 10 };
+	gi.sound(self, CHAN_WEAPON, sound_melee2, 1, ATTN_NORM, 0);
+	fire_hit(self, aim, irandom(10, 40), 100);
+}
+
+mframe_t centroid_frames_melee[] = {
+	{ ai_charge, 3 },
+	{ ai_charge, 3 },
+	{ ai_charge, 2 },
+	{ ai_charge, 2 },
+	{ ai_charge, 3, centroid_swing },
+
+	{ ai_charge, 1 },
+	{ ai_charge, 0, centroid_stinger },
+	{ ai_charge },
+	{ ai_charge },
+	{ ai_charge },
+
+	{ ai_charge }
+};
+MMOVE_T(centroid_move_melee) = { FRAME_sting1, FRAME_sting11, centroid_frames_melee, centroid_run };
+
+MONSTERINFO_MELEE(centroid_melee) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &centroid_move_melee);
+}
+
+// 
+// DODGE
+// 
+
+void centroid_jump_straightup(edict_t* self)
+{
+	if (self->deadflag)
+		return;
+	if (self->groundentity)
+	{
+		self->velocity[0] += crandom() * 5;
+		self->velocity[1] += crandom() * 5;
+		self->velocity[2] += -400 * self->gravityVector[2];
+	}
+}
+
+void centroid_jump_wait_land(edict_t* self)
+{
+	if ((frandom() < 0.4f) && (level.time >= self->monsterinfo.attack_finished))
+	{
+		self->monsterinfo.attack_finished = level.time + 300_ms;
+		centroid_fire_attack(self);
+	}
+
+	if (self->groundentity == nullptr)
+	{
+		self->gravity = 1.3f;
+		self->monsterinfo.nextframe = self->s.frame;
+
+		if (monster_jump_finished(self))
+		{
+			self->gravity = 1;
+			self->monsterinfo.nextframe = self->s.frame + 1;
+		}
+	}
+	else
+	{
+		self->gravity = 1;
+		self->monsterinfo.nextframe = self->s.frame + 1;
+	}
+}
+
+mframe_t centroid_frames_jump[] = {
+	{ ai_move, 1, centroid_jump_straightup },
+	{ ai_move, 1, centroid_jump_wait_land },
+	{ ai_move, 1 },
+	{ ai_move, -1 },
+	{ ai_move, -1 },
+	{ ai_move, -1 }
+};
+MMOVE_T(centroid_move_jump) = { FRAME_walk1, FRAME_walk6, centroid_frames_jump, centroid_run };
+
+void centroid_dodge_jump(edict_t* self)
+{
+	M_SetAnimation(self, &centroid_move_jump);
+}
+
+bool centroid_sidestep(edict_t* self);
+
+MONSTERINFO_DODGE(centroid_dodge) (edict_t* self, edict_t* attacker, gtime_t eta, trace_t* tr, bool gravity) -> void
+{
+	if (!self->groundentity || self->health <= 0)
+		return;
+
+	if (frandom() <= 0.66)
+	{
+		centroid_sidestep(self);
+		return;
+	}
+
+	if (!self->enemy)
+	{
+		self->enemy = attacker;
+		FoundTarget(self);
+		return;
+	}
+
+	if ((eta < FRAME_TIME_MS) || (eta > 5_sec))
+		return;
+
+	if (self->timestamp > level.time)
+		return;
+
+	self->timestamp = level.time + random_time(1_sec, 5_sec);
+	centroid_dodge_jump(self);
+}
+
+MONSTERINFO_SIDESTEP(centroid_sidestep) (edict_t* self) -> bool
+{
+	if ((self->monsterinfo.active_move == &centroid_move_jump))
+		return false;
+
+	if (self->monsterinfo.active_move != &centroid_move_run || self->monsterinfo.active_move != &centroid_move_run2)
+		M_SetAnimation(self, &centroid_move_run2);
+
+	return true;
+}
+
+MONSTERINFO_BLOCKED(centroid_blocked) (edict_t *self, float dist) -> bool
+{
+	if (blocked_checkplat(self, dist))
+		return true;
+
+	return false;
+}
+
+// 
+// PAIN
+// 
+
+mframe_t centroid_frames_pain1[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(centroid_move_pain) = { FRAME_pain1, FRAME_pain5, centroid_frames_pain1, centroid_run };
+
+PAIN(centroid_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	monster_done_dodge(self);
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	float r = frandom();
+	if (r < 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+
+	M_SetAnimation(self, &centroid_move_pain);
+}
+
+MONSTERINFO_SETSKIN(centroid_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+// 
+// DEATH
+// 
+
+void centroid_dead(edict_t* self)
+{
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 8 };
+	monster_dead(self);
+}
+
+static void centroid_shrink(edict_t* self)
+{
+	self->maxs[2] = 12;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t centroid_frames_death[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, centroid_shrink },
+	{ ai_move },
+	{ ai_move, 0, monster_footstep }
+};
+MMOVE_T(centroid_move_death) = { FRAME_death1, FRAME_death5, centroid_frames_death, centroid_dead };
+
+DIE(centroid_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+			{ 2, "models/objects/gibs/sm_metal/tris.md2" },
+			{ "models/monsters/centroid/gibs/head.md2", GIB_HEAD | GIB_SKINNED }
+			});
+		self->deadflag = true;
+
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	self->deadflag = true;
+	self->takedamage = true;
+
+	M_SetAnimation(self, &centroid_move_death);
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+}
+
+
+/*QUAKED monster_centroid (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping
+ */
+void SP_monster_centroid(edict_t *self)
+{
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
+	if ( !M_AllowSpawn( self ) ) {
+		G_FreeEdict( self );
+		return;
+	}
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex("models/monsters/centroid/tris.md2");
+
+	sound_idle.assign("centroid/idle1.wav");
+	sound_pain1.assign("centroid/pain.wav");
+	sound_pain2.assign("centroid/pain2.wav");
+	sound_sight.assign("centroid/sight.wav");
+	sound_search.assign("centroid/sight.wav");
+	sound_melee1.assign("centroid/tailswing.wav");
+	sound_melee2.assign("centroid/tailswing.wav");
+	sound_walk.assign("centroid/walk.wav");
+	sound_fire1.assign("weapons/nail1.wav");
+	sound_fire2.assign("guncmdr/gcdratck2.wav");
+	sound_death.assign("centroid/pain2.wav");
+
+	gi.modelindex("models/monsters/centroid/gibs/head.md2");
+	gi.modelindex("models/monsters/centroid/gibs/chest.md2");
+	gi.modelindex("models/monsters/centroid/gibs/gun.md2");
+	gi.modelindex("models/monsters/centroid/gibs/arm.md2");
+	gi.modelindex("models/monsters/centroid/gibs/foot.md2");
+
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 32 };
+
+	self->health = 250 * st.health_multiplier;
+	if (!st.was_key_specified("power_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("power_power"))
+		self->monsterinfo.armor_power = 100;
+	self->gib_health = -65;
+	self->mass = 400;
+
+	self->pain = centroid_pain;
+	self->die = centroid_die;
+
+	self->monsterinfo.combat_style = COMBAT_MIXED;
+
+	self->monsterinfo.search = centroid_search;
+	self->monsterinfo.sight = centroid_sight;
+	self->monsterinfo.idle = centroid_idle;
+
+	self->monsterinfo.stand = centroid_stand;
+	self->monsterinfo.walk = centroid_walk;
+	self->monsterinfo.run = centroid_run;
+
+	self->monsterinfo.dodge = M_MonsterDodge;
+	self->monsterinfo.unduck = monster_duck_up;
+	self->monsterinfo.sidestep = centroid_sidestep;
+	self->monsterinfo.blocked = centroid_blocked;
+
+	self->monsterinfo.attack = centroid_attack;
+	self->monsterinfo.melee = centroid_melee;
+	self->monsterinfo.setskin = centroid_setskin;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &centroid_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	walkmonster_start(self);
+}
--- /dev/null
+++ b/quake1/m_centroid.h	2025-09-04 19:53:48
@@ -0,0 +1,48 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_stand1,
+	FRAME_stand2,
+	FRAME_stand3,
+	FRAME_stand4,
+	FRAME_stand5,
+	FRAME_stand6,
+	FRAME_stand7,
+	FRAME_stand8,
+	FRAME_stand9,
+	FRAME_stand10,
+	FRAME_stand11,
+	FRAME_stand12,
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_shoot1,
+	FRAME_shoot2,
+	FRAME_sting1,
+	FRAME_sting2,
+	FRAME_sting3,
+	FRAME_sting4,
+	FRAME_sting5,
+	FRAME_sting6,
+	FRAME_sting7,
+	FRAME_sting8,
+	FRAME_sting9,
+	FRAME_sting10,
+	FRAME_sting11,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_pain4,
+	FRAME_pain5,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_chthon.cpp	2025-09-04 19:53:48
@@ -0,0 +1,707 @@
+/*
+==============================================================================
+
+CHTHON - MG1 STYLE
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_chthon.h"
+
+static cached_soundindex	sound_pain;
+static cached_soundindex	sound_death;
+static cached_soundindex	sound_sight;
+static cached_soundindex	sound_throw;
+static cached_soundindex	sound_rise;
+
+void chthon_stand(edict_t* self);
+void chthon_run(edict_t* self);
+void chthon_rise(edict_t* self);
+static void chthon_check_attack(edict_t* self);
+
+static void chthon_rise_sound (edict_t *self)
+{
+	gi.sound (self, CHAN_VOICE, sound_rise, 1, ATTN_NORM, 0);
+}
+
+static void chthon_sight_sound (edict_t *self)
+{
+	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+static void chthon_sight_sound2 (edict_t *self)
+{
+	if(frandom() < 0.1f)
+	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+mframe_t chthon_frames_stand [] = {
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand, 0, chthon_check_attack},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand, 0, chthon_check_attack},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand, 0, chthon_check_attack},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand, 0, chthon_sight_sound},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand, 0, chthon_check_attack},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand, 0, chthon_check_attack},
+	{ai_stand}
+};
+MMOVE_T(chthon_move_stand) = {FRAME_walk1, FRAME_walk31, chthon_frames_stand, nullptr };
+
+MONSTERINFO_STAND(chthon_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &chthon_move_stand);
+}
+
+mframe_t chthon_frames_rise [] =
+{
+	{ai_move, 0, chthon_rise_sound},
+	{ai_move},
+	{ai_move, 0, chthon_sight_sound},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0, chthon_stand}
+};
+MMOVE_T(chthon_move_rise) = {FRAME_rise1, FRAME_rise17, chthon_frames_rise, nullptr };
+
+void chthon_rise(edict_t *self)
+{
+	M_SetAnimation(self, &chthon_move_rise);
+}
+
+mframe_t chthon_frames_walk [] =
+{
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk, 0, chthon_sight_sound2},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk, 0, chthon_check_attack},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk, 0, chthon_check_attack}
+};
+MMOVE_T(chthon_move_walk) = {FRAME_walk1, FRAME_walk31, chthon_frames_walk, nullptr };
+
+MONSTERINFO_WALK(chthon_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &chthon_move_walk);
+}
+
+mframe_t chthon_frames_run [] =
+{
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, chthon_sight_sound2},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, chthon_check_attack},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, chthon_check_attack},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, chthon_check_attack}
+};
+MMOVE_T(chthon_move_run) = {FRAME_walk1, FRAME_walk31, chthon_frames_walk, nullptr };
+
+MONSTERINFO_RUN(chthon_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &chthon_move_run);
+}
+
+/// 
+/// PAIN
+/// 
+
+mframe_t chthon_frames_shock1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0,	 chthon_check_attack}
+};
+MMOVE_T(chthon_frames_move_shock1) = {FRAME_shocka1, FRAME_shocka10, chthon_frames_shock1, chthon_walk};
+
+mframe_t chthon_frames_shock2 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0,  chthon_check_attack}
+};
+MMOVE_T(chthon_frames_move_shock2) = {FRAME_shockb1, FRAME_shockb6, chthon_frames_shock2, chthon_walk};
+
+mframe_t chthon_frames_shock3 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0,	 chthon_check_attack}
+};
+MMOVE_T(chthon_frames_move_shock3) = {FRAME_shockc1, FRAME_shockc10, chthon_frames_shock3, chthon_walk};
+
+PAIN(chthon_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+
+	//Only energy weapons can damage him IF IT WORKED
+	if (!IsEnergyWeapon(mod)) {
+		self->health += damage;
+		return;
+	}
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	self->pain_debounce_time = level.time + 6_sec;
+	gi.sound (self, CHAN_VOICE, sound_pain, 1.0, ATTN_NORM, 0);
+
+	if(damage > 25)
+	{
+		if (self->health < 1500)
+		{
+			M_SetAnimation(self, &chthon_frames_move_shock1);
+		
+		}
+		else if (self->health < 1000)
+		{
+			M_SetAnimation(self, &chthon_frames_move_shock2);
+		}
+		else if (self->health < 500)
+		{
+			M_SetAnimation(self, &chthon_frames_move_shock3);
+		}
+	}
+}
+MONSTERINFO_SETSKIN(chthon_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+///
+/// DEATH
+/// 
+
+static void chthon_gib(edict_t* self)
+{
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_EXPLOSION1_BIG);
+	gi.WritePosition(self->s.origin);
+	gi.multicast(self->s.origin, MULTICAST_PHS, false);
+
+	self->s.sound = 0;
+	self->s.skinnum /= 2;
+
+	ThrowGibs(self, 500, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 1, "models/objects/gibs/bone2/tris.md2" },
+			{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+			{ "models/objects/gibs/sm_meat/tris.md2" },
+			{ 10, "models/monsters/shambler/gibs/head.md2" },
+			{ 10, "models/monsters/zombie/gibs/head.md2" },
+			{ "models/objects/gibs/chest/tris.md2", GIB_HEAD }
+		});
+}
+
+void chthon_dead(edict_t *self)
+{
+	if (self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
+	{
+		self->deadflag = false;
+		self->takedamage = true;
+		return;
+	}
+
+	chthon_gib(self);
+}
+
+mframe_t chthon_frames_death [] =
+{
+	{ai_move, 0, Q1BossExplode},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(chthon_move_death) = {FRAME_death1, FRAME_death9, chthon_frames_death, chthon_dead};
+
+
+DIE(chthon_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
+	{
+		// check for gib
+		if (M_CheckGib(self, mod))
+		{
+			chthon_gib(self);
+			self->deadflag = true;
+			return;
+		}
+
+		if (self->deadflag)
+			return;
+	}
+	else
+	{
+		gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+		self->deadflag = true;
+		self->takedamage = false;
+	}
+
+	M_SetAnimation(self, &chthon_move_death);
+}
+
+void chthon_bolt(edict_t *self, int no)
+{
+	switch(no)
+	{
+	case 1:
+
+		gi.sound (self, CHAN_VOICE, sound_pain, 1.0, ATTN_NORM, 0);	
+		M_SetAnimation(self, &chthon_frames_move_shock1);
+		self->pain_debounce_time = level.time + 6_sec;
+		break;
+	case 2:
+		gi.sound (self, CHAN_VOICE, sound_pain, 1.0, ATTN_NORM, 0);	
+		M_SetAnimation(self, &chthon_frames_move_shock2);
+		self->pain_debounce_time = level.time + 6_sec;
+		break;
+	case 3:
+		gi.sound (self, CHAN_VOICE, sound_pain, 1.0, ATTN_NORM, 0);	
+		M_SetAnimation(self, &chthon_frames_move_shock3);
+		self->pain_debounce_time = level.time + 6_sec;
+		self->health = -50;
+		gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NONE, 0);
+		self->deadflag = true;
+		self->takedamage = true;
+		M_SetAnimation(self, &chthon_move_death);
+		monster_death_use(self);
+		break;
+	}
+}
+
+void chthon_attack_left (edict_t *self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	vec;
+	trace_t trace;
+	vec3_t target;
+	bool   blindfire = false;
+	vec3_t offset = { 36, 160, 200 };
+	int damage;
+	int speed = 750;
+
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+	else
+		blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse)
+		return;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+
+	if (blindfire)
+		target = self->monsterinfo.blind_fire_target;
+	else
+		target = self->enemy->s.origin;
+
+	if (strcmp(self->classname, "monster_lavaman") == 0)
+	{
+		damage = 40;
+	}
+	else
+	{
+		damage = 100;
+	}
+
+	if (blindfire)
+	{
+		vec = target;
+		dir = vec - start;
+	}
+
+	else if (frandom() < 0.33f || (start[2] < self->enemy->absmin[2]))
+	{
+		vec = target;
+		vec[2] += self->enemy->viewheight;
+		dir = vec - start;
+	}
+	else
+	{
+		vec = target;
+		vec[2] = self->enemy->absmin[2] + 1;
+		dir = vec - start;
+	}
+
+	if ((!blindfire) && (frandom() < 0.35f))
+		PredictAim(self, self->enemy, start, 750, false, 0.f, &dir, &vec);
+
+	dir.normalize();
+
+	trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+	if (blindfire)
+	{
+		if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+			fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+		else
+		{
+			vec = target;
+			vec += (right * -10);
+			dir = vec - start;
+			dir.normalize();
+			trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+			if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+				fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+			else
+			{
+				vec = target;
+				vec += (right * 10);
+				dir = vec - start;
+				dir.normalize();
+				trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+				if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+					fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+			}
+		}
+	}
+	else
+	{
+		if (trace.fraction > 0.5f || trace.ent->solid != SOLID_BSP)
+			fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+	}
+}	
+
+void chthon_attack_right (edict_t *self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	vec;
+	trace_t trace;
+	vec3_t target;
+	bool   blindfire = false;
+	vec3_t  offset = { 36, -160, 200 };
+	int damage;
+	int speed = 750;
+
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+	else
+		blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse)
+		return;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+
+	if (blindfire)
+		target = self->monsterinfo.blind_fire_target;
+	else
+		target = self->enemy->s.origin;
+
+	if (strcmp(self->classname, "monster_lavaman") == 0)
+	{
+		damage = 40;
+	}
+	else
+	{
+		damage = 100;
+	}
+
+	if (blindfire)
+	{
+		vec = target;
+		dir = vec - start;
+	}
+
+	else if (frandom() < 0.33f || (start[2] < self->enemy->absmin[2]))
+	{
+		vec = target;
+		vec[2] += self->enemy->viewheight;
+		dir = vec - start;
+	}
+	else
+	{
+		vec = target;
+		vec[2] = self->enemy->absmin[2] + 1;
+		dir = vec - start;
+	}
+
+	if ((!blindfire) && (frandom() < 0.35f))
+		PredictAim(self, self->enemy, start, 750, false, 0.f, &dir, &vec);
+
+	dir.normalize();
+
+	trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+	if (blindfire)
+	{
+		if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+			fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+		else
+		{
+			vec = target;
+			vec += (right * -10);
+			dir = vec - start;
+			dir.normalize();
+			trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+			if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+				fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+			else
+			{
+				vec = target;
+				vec += (right * 10);
+				dir = vec - start;
+				dir.normalize();
+				trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+				if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+					fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+			}
+		}
+	}
+	else
+	{
+		if (trace.fraction > 0.5f || trace.ent->solid != SOLID_BSP)
+			fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+	}
+}	
+
+mframe_t chthon_frames_attack [] =
+{
+	{ai_charge},
+	{ai_charge, 0, chthon_sight_sound2},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, chthon_attack_left},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, chthon_attack_right},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, chthon_check_attack}
+};
+MMOVE_T(chthon_move_attack) = {FRAME_attack1, FRAME_attack23, chthon_frames_attack, chthon_walk};
+
+MONSTERINFO_ATTACK(chthon_attack) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &chthon_move_attack);
+}
+
+MONSTERINFO_SIGHT(chthon_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_IDLE, 0);
+}
+
+static void chthon_check_attack (edict_t *self)
+{
+	if (!self->enemy || !self->enemy->inuse || self->enemy->health <= 0)
+		return;
+	M_SetAnimation(self, &chthon_move_attack);
+}
+
+MONSTERINFO_CHECKATTACK(chthon_checkattack) (edict_t* self) -> bool
+{
+	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.8f, 0.8f, 0.f, 0.f);
+}
+
+void SP_monster_chthon (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_pain.assign("chthon/pain.wav");	
+	sound_death.assign("chthon/death.wav");
+	sound_rise.assign("chthon/out1.wav");
+	sound_throw.assign("chthon/throw.wav");
+	sound_sight.assign("chthon/sight1.wav");
+	
+	self->movetype = MOVETYPE_NONE;
+
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex ("models/monsters/chthon/tris.md2");
+	
+	self->mins = { -128, -128, -24 };
+	self->maxs = { 128, 128, 226 };
+
+	if (strcmp(self->classname, "monster_lavaman") == 0)
+	{
+		self->s.skinnum = 2;
+		self->health = max(1500, 1500 + 1000 * (skill->integer - 1)) * st.health_multiplier;
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_BODY;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = max(350, 350 + 100 * (skill->integer - 1));
+		if (coop->integer)
+		{
+			self->health += (250 * (CountPlayers() - 1));
+			self->monsterinfo.armor_power += (100 * (CountPlayers() - 1));
+		}
+
+		if (!self->s.scale)
+			self->s.scale = 0.75f;
+	}
+	else
+	{
+		self->health = max(3000, 3000 + 1250 * (skill->integer - 1)) * st.health_multiplier;
+		if (!st.was_key_specified("armor_type"))
+			self->monsterinfo.armor_type = IT_ARMOR_BODY;
+		if (!st.was_key_specified("armor_power"))
+			self->monsterinfo.armor_power = max(500, 500 + 150 * (skill->integer - 1));
+		if (coop->integer)
+		{
+			self->health += (500 * skill->integer) + (500 * (CountPlayers() - 1));
+			self->monsterinfo.armor_power += (250 * skill->integer) + (250 * (CountPlayers() - 1));
+		}
+	}
+	self->gib_health = -1000;
+	self->mass = 1500;
+
+	self->flags |= FL_IMMUNE_LAVA;
+
+	self->pain = chthon_pain;
+	self->die = chthon_die;
+
+	self->monsterinfo.stand = chthon_stand; 
+	self->monsterinfo.walk = chthon_walk;
+	self->monsterinfo.run = chthon_run; 
+	self->monsterinfo.dodge = nullptr;
+	self->monsterinfo.attack = chthon_attack;
+	self->monsterinfo.melee = nullptr; 
+	self->monsterinfo.sight = chthon_sight;
+	self->monsterinfo.search = nullptr;
+	self->monsterinfo.checkattack = chthon_checkattack;
+	self->monsterinfo.setskin = chthon_setskin;
+
+	self->s.renderfx |= RF_FULLBRIGHT;
+	
+	gi.linkentity (self);
+
+	self->monsterinfo.scale = MODEL_SCALE;
+	M_SetAnimation(self, &chthon_move_rise);
+
+	walkmonster_start(self);	
+}
+
+void SP_monster_lavaman(edict_t* self)
+{
+	SP_monster_chthon(self);
+}
--- /dev/null
+++ b/quake1/m_chthon.h	2025-09-04 19:53:48
@@ -0,0 +1,113 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_rise1,
+	FRAME_rise2,
+	FRAME_rise3,
+	FRAME_rise4,
+	FRAME_rise5,
+	FRAME_rise6,
+	FRAME_rise7,
+	FRAME_rise8,
+	FRAME_rise9,
+	FRAME_rise10,
+	FRAME_rise11,
+	FRAME_rise12,
+	FRAME_rise13,
+	FRAME_rise14,
+	FRAME_rise15,
+	FRAME_rise16,
+	FRAME_rise17,
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_walk7,
+	FRAME_walk8,
+	FRAME_walk9,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12,
+	FRAME_walk13,
+	FRAME_walk14,
+	FRAME_walk15,
+	FRAME_walk16,
+	FRAME_walk17,
+	FRAME_walk18,
+	FRAME_walk19,
+	FRAME_walk20,
+	FRAME_walk21,
+	FRAME_walk22,
+	FRAME_walk23,
+	FRAME_walk24,
+	FRAME_walk25,
+	FRAME_walk26,
+	FRAME_walk27,
+	FRAME_walk28,
+	FRAME_walk29,
+	FRAME_walk30,
+	FRAME_walk31,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_death8,
+	FRAME_death9,
+	FRAME_attack1,
+	FRAME_attack2,
+	FRAME_attack3,
+	FRAME_attack4,
+	FRAME_attack5,
+	FRAME_attack6,
+	FRAME_attack7,
+	FRAME_attack8,
+	FRAME_attack9,
+	FRAME_attack10,
+	FRAME_attack11,
+	FRAME_attack12,
+	FRAME_attack13,
+	FRAME_attack14,
+	FRAME_attack15,
+	FRAME_attack16,
+	FRAME_attack17,
+	FRAME_attack18,
+	FRAME_attack19,
+	FRAME_attack20,
+	FRAME_attack21,
+	FRAME_attack22,
+	FRAME_attack23,
+	FRAME_shocka1,
+	FRAME_shocka2,
+	FRAME_shocka3,
+	FRAME_shocka4,
+	FRAME_shocka5,
+	FRAME_shocka6,
+	FRAME_shocka7,
+	FRAME_shocka8,
+	FRAME_shocka9,
+	FRAME_shocka10,
+	FRAME_shockb1,
+	FRAME_shockb2,
+	FRAME_shockb3,
+	FRAME_shockb4,
+	FRAME_shockb5,
+	FRAME_shockb6,
+	FRAME_shockc1,
+	FRAME_shockc2,
+	FRAME_shockc3,
+	FRAME_shockc4,
+	FRAME_shockc5,
+	FRAME_shockc6,
+	FRAME_shockc7,
+	FRAME_shockc8,
+	FRAME_shockc9,
+	FRAME_shockc10
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_dog.cpp	2025-09-04 19:53:48
@@ -0,0 +1,530 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+dog
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_dog.h"
+
+constexpr spawnflags_t SPAWNFLAG_DOG_NOJUMPING = 8_spawnflag;
+
+static cached_soundindex sound_pain1;
+static cached_soundindex sound_die;
+static cached_soundindex sound_launch;
+static cached_soundindex sound_impact;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_search;
+static cached_soundindex sound_bite;
+static cached_soundindex sound_bitemiss;
+static cached_soundindex sound_jump;
+
+///
+/// SOUNDS
+/// 
+
+void dog_launch(edict_t* self)
+{
+	gi.sound(self, CHAN_WEAPON, sound_launch, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SIGHT(dog_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SEARCH(dog_search) (edict_t* self) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
+}
+
+//
+// STAND
+//
+
+mframe_t dog_frames_stand[] = {
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(dog_move_stand) = { FRAME_stand1, FRAME_stand9, dog_frames_stand, nullptr };
+
+MONSTERINFO_STAND(dog_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &dog_move_stand);
+}
+
+//
+// WALK
+//
+
+mframe_t dog_frames_walk[] =
+{
+	{ai_walk, 7},
+	{ai_walk, 7},
+	{ai_walk, 7},
+	{ai_walk, 7},
+	{ai_walk, 7},
+	{ai_walk, 7},
+	{ai_walk, 7},
+	{ai_walk, 7}
+};
+MMOVE_T(dog_move_walk) = { FRAME_walk1, FRAME_walk8, dog_frames_walk, nullptr };
+
+MONSTERINFO_WALK(dog_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &dog_move_walk);
+}
+
+//
+// RUN
+//
+
+mframe_t dog_frames_run[] =
+{
+	{ai_run, 12},
+	{ai_run, 20},
+	{ai_run, 20},
+	{ai_run, 16},
+	{ai_run, 22},
+	{ai_run, 20},
+	{ai_run, 12},
+	{ai_run, 20},
+	{ai_run, 20},
+	{ai_run, 16},
+
+	{ai_run, 22},
+	{ai_run, 20}
+};
+MMOVE_T(dog_move_run) = { FRAME_run1, FRAME_run12, dog_frames_run, nullptr };
+
+MONSTERINFO_RUN(dog_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		dog_stand(self);
+	else
+		M_SetAnimation(self, &dog_move_run);
+}
+
+//
+// MELEE
+//
+
+void dog_bite(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->maxs[0], 8 };
+	if (fire_hit(self, aim, irandom(1, 24), 100))
+		gi.sound(self, CHAN_WEAPON, sound_bite, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_bitemiss, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+mframe_t dog_frames_attack[] =
+{
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 10, dog_bite},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 10}
+};
+MMOVE_T(dog_move_attack) = { FRAME_attack1, FRAME_attack8, dog_frames_attack, dog_run };
+
+MONSTERINFO_MELEE(dog_melee) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &dog_move_attack);
+}
+
+//
+// ATTACK
+//
+
+TOUCH(dog_jump_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (self->health <= 0)
+	{
+		self->touch = nullptr;
+		return;
+	}
+
+	if (self->style == 1 && other->takedamage)
+	{
+		if (self->velocity.length() > 400)
+		{
+			vec3_t	point;
+			vec3_t	normal;
+			int		damage;
+
+			normal = self->velocity;
+			normal.normalize();
+			point = self->s.origin + (normal * self->maxs[0]);
+			damage = (int)frandom(20, 25);
+			T_Damage(other, self, self, self->velocity, point, normal, damage, damage, DAMAGE_NONE, MOD_UNKNOWN);
+			self->style = 0;
+		}
+	}
+
+	if (!M_CheckBottom(self))
+	{
+		if (self->groundentity)
+		{
+			self->monsterinfo.nextframe = FRAME_attack4;
+			self->touch = nullptr;
+		}
+		return;
+	}
+
+	self->touch = nullptr;
+}
+
+void dog_jump_takeoff(edict_t* self)
+{
+	vec3_t	forward;
+
+	gi.sound(self, CHAN_VOICE, sound_jump, 1, ATTN_NORM, 0);
+	AngleVectors(self->s.angles, forward, nullptr, nullptr);
+	self->s.origin[2] += 1;
+	self->velocity = forward * 400;
+	self->velocity[2] = 200;
+	self->groundentity = nullptr;
+	self->monsterinfo.aiflags |= AI_DUCKED;
+	self->monsterinfo.attack_finished = level.time + 3_sec;
+	self->style = 1;
+	self->touch = dog_jump_touch;
+}
+
+void dog_check_landing(edict_t* self)
+{
+	monster_jump_finished(self);
+
+	if (self->groundentity)
+	{
+		gi.sound(self, CHAN_WEAPON, sound_impact, 1, ATTN_NORM, 0);
+		self->monsterinfo.attack_finished = level.time + random_time(500_ms, 1.5_sec);
+
+		if (self->monsterinfo.unduck)
+			self->monsterinfo.unduck(self);
+
+		if (range_to(self, self->enemy) <= RANGE_MELEE * 2.f)
+			self->monsterinfo.melee(self);
+
+		return;
+	}
+
+	if (level.time > self->monsterinfo.attack_finished)
+		self->monsterinfo.nextframe = FRAME_leap4;
+	else
+		self->monsterinfo.nextframe = FRAME_leap5;
+}
+
+void dog_check_landing2(edict_t* self)
+{
+	monster_jump_finished(self);
+
+	self->owner = nullptr;
+
+	if (self->groundentity)
+	{
+		gi.sound(self, CHAN_WEAPON, sound_impact, 1, ATTN_NORM, 0);
+		self->monsterinfo.attack_finished = level.time + random_time(500_ms, 1.5_sec);
+
+		if (self->monsterinfo.unduck)
+			self->monsterinfo.unduck(self);
+
+		if (range_to(self, self->enemy) <= RANGE_MELEE * 2.f)
+			self->monsterinfo.melee(self);
+
+		return;
+	}
+}
+
+mframe_t dog_frames_jump[] =
+{
+	{ai_charge,	20},
+	{ai_charge,	20,	dog_jump_takeoff},
+	{ai_move,	40},
+	{ai_move,	30},
+	{ai_move,	30,	dog_check_landing},
+	{ai_move,	 0},
+	{ai_move,	 0},
+	{ai_move,	 0},
+	{ai_move,	 0}
+};
+MMOVE_T(dog_move_jump) = { FRAME_leap1, FRAME_leap9, dog_frames_jump, dog_run };
+
+MONSTERINFO_ATTACK(dog_jump) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &dog_move_jump);
+}
+
+//
+// CHECKATTACK
+//
+
+bool dog_check_melee(edict_t* self)
+{
+	return range_to(self, self->enemy) <= RANGE_MELEE && self->monsterinfo.melee_debounce_time <= level.time;
+}
+
+bool dog_check_jump(edict_t* self)
+{
+	vec3_t	v;
+	float	distance;
+
+	if (self->absmin[2] > (self->enemy->absmin[2] + 0.75 * self->enemy->size[2]))
+		return false;
+
+	if (self->absmax[2] < (self->enemy->absmin[2] + 0.25 * self->enemy->size[2]))
+		return false;
+
+	v[0] = self->s.origin[0] - self->enemy->s.origin[0];
+	v[1] = self->s.origin[1] - self->enemy->s.origin[1];
+	v[2] = 0;
+	distance = v.length();
+
+	if (distance < 100 && self->monsterinfo.melee_debounce_time <= level.time)
+		return false;
+	if (distance > 100)
+	{
+		if (frandom() < 0.9f)
+			return false;
+	}
+
+	return true;
+}
+
+MONSTERINFO_CHECKATTACK(dog_checkattack) (edict_t* self) -> bool
+{
+	if (!self->enemy || self->enemy->health <= 0)
+		return false;
+
+	if (dog_check_melee(self))
+	{
+		self->monsterinfo.attack_state = AS_MELEE;
+		return true;
+	}
+
+	if (!self->spawnflags.has(SPAWNFLAG_DOG_NOJUMPING) && dog_check_jump(self))
+	{
+		self->monsterinfo.attack_state = AS_MISSILE;
+		return true;
+	}
+
+	return false;
+}
+
+//
+// PAIN
+//
+
+mframe_t dog_frames_pain1[] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(dog_move_pain1) = { FRAME_pain1, FRAME_pain6, dog_frames_pain1, dog_run };
+
+mframe_t dog_frames_pain2[] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move,  -4},
+	{ai_move,  -12},
+	{ai_move,  -12},
+	{ai_move,  -2},
+	{ai_move},
+	{ai_move,  -4},
+	{ai_move},
+	{ai_move,  -10},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(dog_move_pain2) = { FRAME_painb1, FRAME_painb16, dog_frames_pain2, dog_run };
+
+PAIN(dog_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+
+	if (frandom() < 0.5f)
+		M_SetAnimation(self, &dog_move_pain1);
+	else
+		M_SetAnimation(self, &dog_move_pain2);
+}
+
+MONSTERINFO_SETSKIN(dog_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// DEATH
+//
+
+void dog_shrink(edict_t* self)
+{
+	self->maxs[2] = 0;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t dog_frames_death1[] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0, dog_shrink},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(dog_move_death1) = { FRAME_death1, FRAME_death9, dog_frames_death1, monster_dead };
+
+mframe_t dog_frames_death2[] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0, dog_shrink},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(dog_move_death2) = { FRAME_deathb1, FRAME_deathb9, dog_frames_death2, monster_dead };
+
+DIE(dog_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 4, "models/objects/gibs/sm_meat/tris.md2" },
+			//{ "models/monsters/dog/gibs/chest.md2", GIB_SKINNED },
+			{ "models/objects/gibs/chest/tris.md2" },
+			{ "models/monsters/dog/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	if (frandom() < 0.8f)
+		M_SetAnimation(self, &dog_move_death1);
+	else
+		M_SetAnimation(self, &dog_move_death2);
+
+}
+
+/*QUAKED monster_dog (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping
+*/
+void SP_monster_dog(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_pain1.assign("dog/dpain1.wav");
+	sound_die.assign("dog/death1.wav");
+	sound_launch.assign("hound/hlaunch.wav");
+	sound_impact.assign("hound/himpact.wav");
+	sound_sight.assign("dog/dsight.wav");
+	sound_search.assign("dog/idle.wav");
+	sound_jump.assign("hound/hjump.wav");
+	sound_bite.assign("dog/dattack1.wav");
+	sound_bitemiss.assign("hound/hbite2.wav");
+
+	gi.modelindex("models/monsters/dog/tris.md2");
+
+	self->monsterinfo.aiflags |= AI_STINKY;
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex("models/monsters/dog/tris.md2");
+
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 32 };
+
+	self->health = 40 * st.health_multiplier;
+	self->gib_health = -35;
+	self->mass = 80;
+
+	self->pain = dog_pain;
+	self->die = dog_die;
+
+	self->monsterinfo.stand = dog_stand;
+	self->monsterinfo.walk = dog_walk;
+	self->monsterinfo.run = dog_run;
+	self->monsterinfo.dodge = nullptr;
+	self->monsterinfo.attack = dog_jump;
+	self->monsterinfo.melee = dog_melee;
+	self->monsterinfo.sight = dog_sight;
+	self->monsterinfo.search = dog_search;
+	self->monsterinfo.checkattack = dog_checkattack;
+	self->monsterinfo.blocked = nullptr;
+	self->monsterinfo.setskin = dog_setskin;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &dog_move_stand);
+
+	self->monsterinfo.combat_style = COMBAT_MELEE;
+
+	self->monsterinfo.scale = MODEL_SCALE;
+	self->monsterinfo.can_jump = !(self->spawnflags & SPAWNFLAG_DOG_NOJUMPING);
+	self->monsterinfo.drop_height = 256;
+	self->monsterinfo.jump_height = 68;
+
+	walkmonster_start(self);
+}
--- /dev/null
+++ b/quake1/m_dog.h	2025-09-04 19:53:48
@@ -0,0 +1,93 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_attack1,
+	FRAME_attack2,
+	FRAME_attack3,
+	FRAME_attack4,
+	FRAME_attack5,
+	FRAME_attack6,
+	FRAME_attack7,
+	FRAME_attack8,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_death8,
+	FRAME_death9,
+	FRAME_deathb1,
+	FRAME_deathb2,
+	FRAME_deathb3,
+	FRAME_deathb4,
+	FRAME_deathb5,
+	FRAME_deathb6,
+	FRAME_deathb7,
+	FRAME_deathb8,
+	FRAME_deathb9,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_pain4,
+	FRAME_pain5,
+	FRAME_pain6,
+	FRAME_painb1,
+	FRAME_painb2,
+	FRAME_painb3,
+	FRAME_painb4,
+	FRAME_painb5,
+	FRAME_painb6,
+	FRAME_painb7,
+	FRAME_painb8,
+	FRAME_painb9,
+	FRAME_painb10,
+	FRAME_painb11,
+	FRAME_painb12,
+	FRAME_painb13,
+	FRAME_painb14,
+	FRAME_painb15,
+	FRAME_painb16,
+	FRAME_run1,
+	FRAME_run2,
+	FRAME_run3,
+	FRAME_run4,
+	FRAME_run5,
+	FRAME_run6,
+	FRAME_run7,
+	FRAME_run8,
+	FRAME_run9,
+	FRAME_run10,
+	FRAME_run11,
+	FRAME_run12,
+	FRAME_leap1,
+	FRAME_leap2,
+	FRAME_leap3,
+	FRAME_leap4,
+	FRAME_leap5,
+	FRAME_leap6,
+	FRAME_leap7,
+	FRAME_leap8,
+	FRAME_leap9,
+	FRAME_stand1,
+	FRAME_stand2,
+	FRAME_stand3,
+	FRAME_stand4,
+	FRAME_stand5,
+	FRAME_stand6,
+	FRAME_stand7,
+	FRAME_stand8,
+	FRAME_stand9,
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_walk7,
+	FRAME_walk8
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_dragon.cpp	2025-09-04 19:53:48
@@ -0,0 +1,725 @@
+/*
+==============================================================================
+
+QUAKE WYVERN
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_dragon.h"
+
+static cached_soundindex	sound_sight1;
+static cached_soundindex	sound_search1;
+static cached_soundindex	sound_attack;
+static cached_soundindex	sound_die1;
+static cached_soundindex	sound_pain1;
+
+void dragon_hover(edict_t* self);
+void dragon_attack(edict_t* self);
+void dragon_reattack(edict_t* self);
+void dragon_walk(edict_t* self);
+void dragon_run(edict_t* self);
+
+MONSTERINFO_SIGHT(dragon_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight1, 1, ATTN_NONE, 0);
+}
+
+MONSTERINFO_SEARCH(dragon_search) (edict_t* self) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_search1, 1, ATTN_NONE, 0);
+}
+
+//================
+// HOVER
+//================
+mframe_t dragon_frames_hover [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(dragon_move_hover) = { FRAME_drgfly01, FRAME_drgfly13, dragon_frames_hover, nullptr };
+
+MONSTERINFO_STAND(dragon_hover) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &dragon_move_hover);
+}
+
+//================
+// WALK
+//================
+mframe_t dragon_frames_walk [] =
+{
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5}
+};
+MMOVE_T(dragon_move_walk) = { FRAME_drgfly01, FRAME_drgfly13, dragon_frames_walk, nullptr };
+
+
+MONSTERINFO_WALK(dragon_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &dragon_move_walk);
+}
+
+//================
+// FLY
+//================
+mframe_t dragon_frames_run[] =
+{
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10}
+};
+MMOVE_T(dragon_move_run) = { FRAME_drgfly01, FRAME_drgfly13, dragon_frames_run, nullptr };
+
+
+MONSTERINFO_RUN(dragon_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &dragon_move_run);
+}
+
+//================
+// PAIN
+//================
+mframe_t dragon_frames_pain1 [] =
+{	
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(dragon_move_pain1) = { FRAME_drgpan1a, FRAME_drgpan1c, dragon_frames_pain1, dragon_run };
+
+mframe_t dragon_frames_pain2[] =
+{
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(dragon_move_pain2) = { FRAME_drgpan2a, FRAME_drgpan2c, dragon_frames_pain2, dragon_run };
+
+mframe_t dragon_frames_pain3[] =
+{
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(dragon_move_pain3) = { FRAME_drgpan3a, FRAME_drgpan3c, dragon_frames_pain3, dragon_run };
+
+mframe_t dragon_frames_pain4[] =
+{
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(dragon_move_pain4) = { FRAME_drgpan4a, FRAME_drgpan4c, dragon_frames_pain4, dragon_run };
+
+mframe_t dragon_frames_pain5[] =
+{
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(dragon_move_pain5) = { FRAME_drgpan5a, FRAME_drgpan5c, dragon_frames_pain5, dragon_run };
+
+mframe_t dragon_frames_pain6[] =
+{
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(dragon_move_pain6) = { FRAME_drgpan6a, FRAME_drgpan6c, dragon_frames_pain6, dragon_run };
+
+PAIN(dragon_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+
+	if (damage < 30)
+		M_SetAnimation(self, &dragon_move_pain1);
+	else if(damage < 60)
+	{
+		if (frandom() >= 0.5)
+			M_SetAnimation(self, &dragon_move_pain2);
+		else
+			M_SetAnimation(self, &dragon_move_pain3);
+	}
+	else if (damage > 120)
+		M_SetAnimation(self, &dragon_move_pain6);
+	else
+	{
+		if (frandom() >= 0.5)
+			M_SetAnimation(self, &dragon_move_pain4);
+		else
+			M_SetAnimation(self, &dragon_move_pain5);
+	}
+
+
+}
+
+MONSTERINFO_SETSKIN(dragon_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//================
+// DEAD
+//================
+static void dragon_gib(edict_t* self)
+{
+	gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+	self->s.skinnum /= 2;
+
+	ThrowGibs(self, 1000, {
+		{ 2, "models/objects/gibs/bone/tris.md2" },
+		{ 4, "models/objects/gibs/sm_meat/tris.md2" },
+		{ "models/monsters/dragon/gibs/leg.md2"},
+		{ "models/monsters/dragon/gibs/wing.md2" },
+		{ "models/monsters/dragon/gibs/head.md2", GIB_HEAD }
+		});
+}
+
+THINK(dragon_deadthink) (edict_t* self) -> void
+{
+	if (!self->groundentity && level.time < self->timestamp)
+	{
+		self->nextthink = level.time + FRAME_TIME_S;
+		return;
+	}
+
+	return;
+}
+
+void dragon_dead(edict_t * self)
+{
+	self->mins = { -144, -136, -36 };
+	self->maxs = { 88, 128, 24 };
+	self->movetype = MOVETYPE_TOSS;
+	self->think = dragon_deadthink;
+	self->nextthink = level.time + FRAME_TIME_S;
+	self->timestamp = level.time + 15_sec;
+	gi.linkentity(self);
+
+	dragon_gib(self);
+}
+
+mframe_t dragon_frames_die1 [] =
+{	
+	{ai_move, 0, Q1BossExplode},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move}
+};
+MMOVE_T(dragon_move_die1) = { FRAME_drgdth01, FRAME_drgdth21, dragon_frames_die1, dragon_dead};
+
+DIE(dragon_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		dragon_gib(self);
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	self->deadflag = true;
+	self->takedamage = true;
+
+	gi.sound(self, CHAN_VOICE, sound_die1, 1, ATTN_NORM, 0);
+	M_SetAnimation(self, &dragon_move_die1);
+}
+
+//================
+// ATTACK
+//================
+
+void dragon_fireball (edict_t *self)
+{
+	vec3_t		forward, right;
+	vec3_t		start;
+	vec3_t		dir;
+	vec3_t		vec;
+	trace_t		trace; // PMM - check target
+	vec3_t		target;
+	int			damage;
+	int			speed;
+	bool		blindfire = false;
+	vec3_t		offset;
+	float		fireCount;
+	float		r;
+	
+	offset = {96, 0, 32};
+
+	if (frandom() > 0.66f)
+	{
+		if (skill->integer > 1)
+			fireCount = 2;
+		else
+			fireCount = 1;
+		damage = 80 + frandom() * 20;
+		speed = 1250;
+		self->style = 1;
+	}
+	else
+	{
+		fireCount = frandom() * skill->integer;
+		fireCount = rint(fireCount) + 1;
+		damage = 90;
+		speed = frandom() * 300 + 900;
+		self->style = 0;
+	}
+
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+	else
+		blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse)
+		return;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+
+	if (blindfire)
+		target = self->monsterinfo.blind_fire_target;
+	else
+		target = self->enemy->s.origin;
+
+
+	if (blindfire)
+	{
+		vec = target;
+		dir = vec - start;
+	}
+
+	else if (frandom() < 0.33f || (start[2] < self->enemy->absmin[2]))
+	{
+		vec = target;
+		vec[2] += self->enemy->viewheight;
+		dir = vec - start;
+	}
+	else
+	{
+		vec = target;
+		vec[2] = self->enemy->absmin[2] + 1;
+		dir = vec - start;
+	}
+
+	if ((!blindfire) && (frandom() < 0.35f))
+		PredictAim(self, self->enemy, start, 750, false, 0.f, &dir, &vec);
+
+	dir.normalize();
+
+	trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+	while (fireCount > 0)
+	{
+		if (blindfire)
+		{
+			if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+			{
+				if (self->style == 1)
+					fire_plasmaball(self, start, dir, damage, speed, damage * 2);
+				else
+					fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+			}
+			else
+			{
+				vec = target;
+				vec += (right * -10);
+				dir = vec - start;
+				dir.normalize();
+				trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+				if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+				{
+					if (self->style == 1)
+						fire_plasmaball(self, start, dir, damage, speed, damage * 2);
+					else
+						fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+				}
+				else
+				{
+					vec = target;
+					vec += (right * 10);
+					dir = vec - start;
+					dir.normalize();
+					trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+					if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+					{
+						if (self->style == 1)
+							fire_plasmaball(self, start, dir, damage, speed, damage * 2);
+						else
+							fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+					}
+				}
+			}
+		}
+		else
+		{
+			r = crandom() * 1000;
+
+			vec = start + (forward * 8192);
+			vec += (right * r);
+
+			dir = vec - start;
+			dir.normalize();
+
+			if (trace.fraction > 0.5f || trace.ent->solid != SOLID_BSP)
+			{
+				if (self->style == 1)
+					fire_plasmaball(self, start, dir, damage, speed, damage * 2);
+				else
+					fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+			}
+		}
+		gi.sound(self, CHAN_VOICE, sound_attack, 1, ATTN_NORM, 0);
+
+		fireCount -= 1;
+	}
+}
+
+void dragon_tail(edict_t* self)
+{
+	if (fire_hit(self, vec3_t{ MELEE_DISTANCE, 0.f, -32.f }, (frandom() * 30) + 30, 400.f))
+	{
+		if (self->enemy && self->enemy->client && self->enemy->velocity.z < 270.f)
+			self->enemy->velocity.z = 270.f;
+	}
+}
+
+mframe_t dragon_frames_attack1 [] =
+{
+	{ai_charge, 17},
+	{ai_charge, 12},
+	{ai_charge, 7},
+	{ai_charge, 2},
+	{ai_charge},
+
+	{ai_charge, -2},
+	{ai_charge, -7},
+	{ai_charge, -12, dragon_fireball},
+	{ai_charge, -7},
+	{ai_charge, -2, dragon_reattack}
+};
+MMOVE_T(dragon_move_attack1) = { FRAME_drgfir01, FRAME_drgfir10, dragon_frames_attack1, nullptr };
+
+void dragon_postfix1(edict_t* self)
+{
+	M_SetAnimation(self, &dragon_move_run, false);
+	self->monsterinfo.nextframe = FRAME_drgfly05;
+}
+void dragon_postfix2(edict_t* self)
+{
+	M_SetAnimation(self, &dragon_move_run, false);
+	self->monsterinfo.nextframe = FRAME_drgfly07;
+}
+void dragon_postfix3(edict_t* self)
+{
+	M_SetAnimation(self, &dragon_move_run, false);
+	self->monsterinfo.nextframe = FRAME_drgfly09;
+}
+void dragon_postfix4(edict_t* self)
+{
+	M_SetAnimation(self, &dragon_move_run, false);
+	self->monsterinfo.nextframe = FRAME_drgfly11;
+}
+void dragon_postfix5(edict_t* self)
+{
+	M_SetAnimation(self, &dragon_move_run, false);
+	self->monsterinfo.nextframe = FRAME_drgfly13;
+}
+void dragon_postfix6(edict_t* self)
+{
+	M_SetAnimation(self, &dragon_move_run, false);
+	self->monsterinfo.nextframe = FRAME_drgfly03;
+}
+
+mframe_t dragon_frames_attack_fix1[] =
+{
+	{ai_charge, 17},
+	{ai_charge, 17, dragon_fireball },
+	{ai_charge, 17, dragon_postfix1 },
+};
+MMOVE_T(dragon_move_fix1) = { FRAME_drgfix1a, FRAME_drgfix1c, dragon_frames_attack_fix1, nullptr };
+
+mframe_t dragon_frames_attack_fix2[] =
+{
+	{ai_charge, 17},
+	{ai_charge, 17, dragon_fireball },
+	{ai_charge, 17, dragon_postfix2 },
+};
+MMOVE_T(dragon_move_fix2) = { FRAME_drgfix2a, FRAME_drgfix2c, dragon_frames_attack_fix1, nullptr };
+
+mframe_t dragon_frames_attack_fix3[] =
+{
+	{ai_charge, 17},
+	{ai_charge, 17, dragon_fireball },
+	{ai_charge, 17, dragon_postfix3 },
+};
+MMOVE_T(dragon_move_fix3) = { FRAME_drgfix3a, FRAME_drgfix3c, dragon_frames_attack_fix3, nullptr };
+
+mframe_t dragon_frames_attack_fix4[] =
+{
+	{ai_charge, 17},
+	{ai_charge, 17, dragon_fireball },
+	{ai_charge, 17, dragon_postfix4 },
+};
+MMOVE_T(dragon_move_fix4) = { FRAME_drgfix4a, FRAME_drgfix4c, dragon_frames_attack_fix4, nullptr };
+
+mframe_t dragon_frames_attack_fix5[] =
+{
+	{ai_charge, 17},
+	{ai_charge, 17, dragon_fireball },
+	{ai_charge, 17, dragon_postfix5 },
+};
+MMOVE_T(dragon_move_fix5) = { FRAME_drgfix5a, FRAME_drgfix5c, dragon_frames_attack_fix5, nullptr };
+
+mframe_t dragon_frames_attack_fix6[] =
+{
+	{ai_charge, 17},
+	{ai_charge, 17, dragon_fireball },
+	{ai_charge, 17},
+	{ai_charge, 17, dragon_postfix6 },
+};
+MMOVE_T(dragon_move_fix6) = { FRAME_drgfix6a, FRAME_drgfix6d, dragon_frames_attack_fix6, nullptr };
+
+MONSTERINFO_ATTACK(dragon_attack) (edict_t* self) -> void
+{
+	if (!M_CheckClearShot(self, { 0, 96, 32 }))
+		return;
+
+	float r, chance;
+
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		// setup shot probabilities
+		if (self->monsterinfo.blind_fire_delay < 1.0_sec)
+			chance = 1.0;
+		else if (self->monsterinfo.blind_fire_delay < 7.5_sec)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		r = frandom();
+
+		// minimum of 5.5 seconds, plus 0-1, after the shots are done
+		self->monsterinfo.blind_fire_delay += random_time(5.5_sec, 6.5_sec);
+
+		// don't shoot at the origin
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		// don't shoot if the dice say not to
+		if (r > chance)
+			return;
+
+		// turn on manual steering to signal both manual steering and blindfire
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+		M_SetAnimation(self, &dragon_move_attack1);
+		self->monsterinfo.attack_finished = level.time + random_time(2_sec);
+		return;
+	}
+
+	if (self->s.frame == FRAME_drgfly01)
+		M_SetAnimation(self, &dragon_move_fix1);
+	else if (self->s.frame == FRAME_drgfly03)
+		M_SetAnimation(self, &dragon_move_fix2);
+	else if (self->s.frame == FRAME_drgfly05)
+		M_SetAnimation(self, &dragon_move_fix3);
+	else if (self->s.frame == FRAME_drgfly07)
+		M_SetAnimation(self, &dragon_move_fix4);
+	else if (self->s.frame == FRAME_drgfly09)
+		M_SetAnimation(self, &dragon_move_fix5);
+	else if (self->s.frame == FRAME_drgfly11)
+		M_SetAnimation(self, &dragon_move_fix6);
+	else
+		M_SetAnimation(self, &dragon_move_attack1);
+}
+
+void dragon_reattack(edict_t* self)
+{
+	if (self->enemy->health > 0)
+		if (visible(self, self->enemy))
+			if (frandom() <= 0.4f)
+			{
+				M_SetAnimation(self, &dragon_move_attack1);
+				return;
+			}
+
+	dragon_run(self);
+}
+
+//
+// MELEE
+//
+
+mframe_t dragon_frames_melee[] =
+{
+	{ai_charge, 12},
+	{ai_charge, 12},
+	{ai_charge, 12},
+	{ai_charge, 12},
+	{ai_charge, 12},
+
+	{ai_charge, 12},
+	{ai_charge, 12},
+	{ai_charge, 12},
+	{ai_charge, 12},
+	{ai_charge, 0, dragon_tail},
+
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge}
+};
+MMOVE_T(dragon_move_melee) = { FRAME_drgslh01, FRAME_drgslh13, dragon_frames_melee, dragon_run };
+
+MONSTERINFO_MELEE(dragon_melee) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &dragon_move_melee);
+}
+
+
+static void dragon_set_fly_parameters(edict_t* self)
+{
+	self->monsterinfo.fly_thrusters = false;
+	self->monsterinfo.fly_acceleration = 20.f;
+	self->monsterinfo.fly_speed = 120.f;
+	self->monsterinfo.fly_min_distance = 550.f;
+	self->monsterinfo.fly_max_distance = 750.f;
+}
+
+/*QUAKED monster_dragon (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+*/
+
+void SP_monster_dragon(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_sight1.assign("dragon/see.wav");
+	sound_search1.assign("dragon/active.wav");
+	sound_pain1.assign("dragon/pain.wav");
+	sound_die1.assign("dragon/death.wav");
+	sound_attack.assign("dragon/attack.wav");
+	
+	self->s.modelindex = gi.modelindex ("models/monsters/dragon/tris.md2");
+
+	self->mins = { -72, -48, -32 };
+	self->maxs = { 104, 48, 48 };
+	
+	self->movetype = MOVETYPE_FLY;
+	self->solid = SOLID_BBOX;
+
+	self->health = max(3000, 3000 + 1250 * (skill->integer - 1)) * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_BODY;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = max(500, 500 + 150 * (skill->integer - 1));
+	self->gib_health = -500;
+	self->mass = 750;
+	if (coop->integer)
+	{
+		self->health += (500 * skill->integer) + (500 * (CountPlayers() - 1));
+		self->monsterinfo.armor_power += (250 * skill->integer) + (250 * (CountPlayers() - 1));
+	}
+
+	self->pain = dragon_pain;
+	self->die = dragon_die;
+
+	self->yaw_speed = 20;
+	
+	self->monsterinfo.stand = dragon_hover;
+	self->monsterinfo.walk = dragon_walk;
+	self->monsterinfo.run = dragon_run;
+	self->monsterinfo.attack = dragon_attack;
+	self->monsterinfo.melee = dragon_melee;
+	self->monsterinfo.sight = dragon_sight;
+	self->monsterinfo.search = dragon_search;
+	self->monsterinfo.setskin = dragon_setskin;
+	
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &dragon_move_hover);	
+	self->monsterinfo.scale = MODEL_SCALE;
+	
+	flymonster_start(self);
+
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+	dragon_set_fly_parameters(self);
+}
--- /dev/null
+++ b/quake1/m_dragon.h	2025-09-04 19:53:48
@@ -0,0 +1,108 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_dragon6,
+	FRAME_drgfly01,
+	FRAME_drgfly02,
+	FRAME_drgfly03,
+	FRAME_drgfly04,
+	FRAME_drgfly05,
+	FRAME_drgfly06,
+	FRAME_drgfly07,
+	FRAME_drgfly08,
+	FRAME_drgfly09,
+	FRAME_drgfly10,
+	FRAME_drgfly11,
+	FRAME_drgfly12,
+	FRAME_drgfly13,
+	FRAME_drgtrn01,
+	FRAME_drgtrn02,
+	FRAME_drgtrn03,
+	FRAME_drgtrn04,
+	FRAME_drgtrn05,
+	FRAME_drgtrn06,
+	FRAME_drgslh01,
+	FRAME_drgslh02,
+	FRAME_drgslh03,
+	FRAME_drgslh04,
+	FRAME_drgslh05,
+	FRAME_drgslh06,
+	FRAME_drgslh07,
+	FRAME_drgslh08,
+	FRAME_drgslh09,
+	FRAME_drgslh10,
+	FRAME_drgslh11,
+	FRAME_drgslh12,
+	FRAME_drgslh13,
+	FRAME_drgfir01,
+	FRAME_drgfir02,
+	FRAME_drgfir03,
+	FRAME_drgfir04,
+	FRAME_drgfir05,
+	FRAME_drgfir06,
+	FRAME_drgfir07,
+	FRAME_drgfir08,
+	FRAME_drgfir09,
+	FRAME_drgfir10,
+	FRAME_drgfix1a,
+	FRAME_drgfix1b,
+	FRAME_drgfix1c,
+	FRAME_drgfix2a,
+	FRAME_drgfix2b,
+	FRAME_drgfix2c,
+	FRAME_drgfix3a,
+	FRAME_drgfix3b,
+	FRAME_drgfix3c,
+	FRAME_drgfix4a,
+	FRAME_drgfix4b,
+	FRAME_drgfix4c,
+	FRAME_drgfix5a,
+	FRAME_drgfix5b,
+	FRAME_drgfix5c,
+	FRAME_drgfix6a,
+	FRAME_drgfix6b,
+	FRAME_drgfix6c,
+	FRAME_drgfix6d,
+	FRAME_drgpan1a,
+	FRAME_drgpan1b,
+	FRAME_drgpan1c,
+	FRAME_drgpan2a,
+	FRAME_drgpan2b,
+	FRAME_drgpan2c,
+	FRAME_drgpan3a,
+	FRAME_drgpan3b,
+	FRAME_drgpan3c,
+	FRAME_drgpan4a,
+	FRAME_drgpan4b,
+	FRAME_drgpan4c,
+	FRAME_drgpan5a,
+	FRAME_drgpan5b,
+	FRAME_drgpan5c,
+	FRAME_drgpan6a,
+	FRAME_drgpan6b,
+	FRAME_drgpan6c,
+	FRAME_drgdth01,
+	FRAME_drgdth02,
+	FRAME_drgdth03,
+	FRAME_drgdth04,
+	FRAME_drgdth05,
+	FRAME_drgdth06,
+	FRAME_drgdth07,
+	FRAME_drgdth08,
+	FRAME_drgdth09,
+	FRAME_drgdth10,
+	FRAME_drgdth11,
+	FRAME_drgdth12,
+	FRAME_drgdth13,
+	FRAME_drgdth14,
+	FRAME_drgdth15,
+	FRAME_drgdth16,
+	FRAME_drgdth17,
+	FRAME_drgdth18,
+	FRAME_drgdth19,
+	FRAME_drgdth20,
+	FRAME_drgdth21
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_eel.cpp	2025-09-04 19:53:48
@@ -0,0 +1,287 @@
+/*
+==============================================================================
+
+QUAKE ROTFISH
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_eel.h"
+
+static cached_soundindex	sound_chomp;
+static cached_soundindex	sound_death;
+static cached_soundindex	sound_idle;
+
+void eel_stand(edict_t* self);
+
+void eel_idle (edict_t *self)
+{
+	if (frandom() < 0.5)
+		gi.sound (self, CHAN_AUTO, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+
+mframe_t eel_frames_stand [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};	
+MMOVE_T(eel_move_stand) = { FRAME_eelswim1, FRAME_eelswim6, eel_frames_stand, nullptr };
+
+MONSTERINFO_STAND(eel_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &eel_move_stand);
+}
+
+mframe_t eel_frrun_loop [] =
+{
+	{ai_run, 9},
+	{ai_run, 9},
+	{ai_run, 9},
+	{ai_run, 9},
+	{ai_run, 9},
+	{ai_run, 9}
+};	
+MMOVE_T(eel_move_run_loop) = { FRAME_eelswim1, FRAME_eelswim6, eel_frrun_loop, nullptr };
+
+MONSTERINFO_RUN(eel_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &eel_move_run_loop);
+}
+
+/* Standard Swimming */ 
+mframe_t eel_walk_loop [] =
+{
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6}
+};	
+MMOVE_T(eel_move_walk_loop) = { FRAME_eelswim1, FRAME_eelswim6, eel_walk_loop, nullptr };
+
+MONSTERINFO_WALK(eel_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &eel_move_walk_loop);
+}
+
+mframe_t eel_frames_pain1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(eel_move_pain1) = { FRAME_eeldth1, FRAME_eeldth4, eel_frames_pain1, eel_run};
+
+static void eel_skin_fire(edict_t* self)
+{
+	if (self->s.skinnum < 5)
+		self->s.skinnum += 1;
+	else
+		return;
+}
+
+void eel_shoot (edict_t *self)
+{
+	vec3_t					start;
+	vec3_t					forward, right;
+	vec3_t					aim;
+	vec3_t					offset = { 0, 0, 0 };
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+	PredictAim(self, self->enemy, start, 800, false, frandom() * 0.3f, &aim, nullptr);
+	for (int i = 0; i < 3; i++)
+		aim[i] += crandom_open() * 0.025f;
+	fire_lightning(self, start, aim, 5, 600, EF_PLASMA);
+
+	self->s.skinnum = 0;
+}
+
+mframe_t eel_frames_attack1 [] =
+{
+	{ai_charge, 0, eel_skin_fire},
+	{ai_charge, 0, eel_skin_fire},
+	{ai_charge, 0, eel_skin_fire},
+	{ai_charge, 0, eel_skin_fire},
+	{ai_charge, -1, eel_skin_fire},
+	{ai_charge, -2, eel_shoot}
+};
+MMOVE_T(eel_move_attack1) = { FRAME_eelswim1, FRAME_eelswim6, eel_frames_attack1, eel_run};
+
+mframe_t eel_frames_attack2[] =
+{
+	{ai_charge, 5, eel_skin_fire},
+	{ai_charge, 5, eel_skin_fire},
+	{ai_charge, 5, eel_skin_fire},
+	{ai_charge, 5, eel_skin_fire},
+	{ai_charge, 5, eel_skin_fire},
+	{ai_charge, 5, eel_shoot}
+};
+MMOVE_T(eel_move_attack2) = { FRAME_eelswim1, FRAME_eelswim6, eel_frames_attack2, eel_run };
+
+MONSTERINFO_ATTACK(eel_attack) (edict_t* self) -> void
+{
+	float chance = 0.5f;
+
+	if (frandom() > chance)
+	{
+		M_SetAnimation(self, &eel_move_attack1);
+		self->monsterinfo.attack_state = AS_STRAIGHT;
+	}
+	else // circle strafe
+	{
+		if (frandom() <= 0.5f) // switch directions
+			self->monsterinfo.lefty = !self->monsterinfo.lefty;
+		M_SetAnimation(self, &eel_move_attack2);
+		self->monsterinfo.attack_state = AS_SLIDING;
+	}
+}
+
+PAIN(eel_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 1_sec;
+		
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+	
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	M_SetAnimation(self, &eel_move_pain1);
+}
+
+void eel_dead(edict_t* self)
+{
+	self->mins = { -16, -16, -8 };
+	self->maxs = { 16, 16, 8 };
+	monster_dead(self);
+}
+
+static void eel_skin_death(edict_t* self)
+{
+	if (self->s.skinnum > 0)
+		self->s.skinnum -= 1;
+	else
+		return;
+}
+
+mframe_t eel_frames_death [] =
+{
+	{ai_move},
+	{ai_move, 0, eel_skin_death},
+	{ai_move},
+	{ai_move, 0, eel_skin_death},
+	{ai_move},
+	{ai_move, 0, eel_skin_death},
+	{ai_move},
+	{ai_move, 0, eel_skin_death},
+	{ai_move},
+	{ai_move, 0, eel_skin_death},
+	
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(eel_move_death) = { FRAME_eeldth1, FRAME_eeldth15, eel_frames_death, eel_dead};
+
+MONSTERINFO_SIGHT(eel_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_NORM, 0);
+}
+
+DIE(eel_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	// check for gib
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ "models/objects/gibs/sm_meat/tris.md2" },
+			{"models/monsters/eel/gibs/head.md2", GIB_HEAD }
+			});
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	// regular death
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+	self->svflags |= SVF_DEADMONSTER;
+	M_SetAnimation(self, &eel_move_death);
+}
+
+static void eel_set_fly_parameters(edict_t* self)
+{
+	self->monsterinfo.fly_thrusters = false;
+	self->monsterinfo.fly_acceleration = 30.f;
+	self->monsterinfo.fly_speed = 110.f;
+	// only melee, so get in close
+	self->monsterinfo.fly_min_distance = 10.f;
+	self->monsterinfo.fly_max_distance = 10.f;
+}
+
+/*QUAKED monster_eel (1 .5 0) (-16 -16 -24) (16 16 24) Ambush Trigger_Spawn Sight
+model="models/monsters/eel/tris.md2"
+*/
+void SP_monster_eel (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_death.assign("eel/death.wav");	
+	sound_chomp.assign("eel/bite.wav");
+	sound_idle.assign("eel/idle.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex ("models/monsters/eel/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 32 };
+
+	self->health = 90 * st.health_multiplier;
+	self->gib_health = -50;
+	self->mass = 100;
+
+	self->pain = eel_pain;
+	self->die = eel_die;
+
+	self->monsterinfo.stand = eel_stand;
+	self->monsterinfo.walk = eel_walk;
+	self->monsterinfo.run = eel_run;
+	self->monsterinfo.attack = eel_attack;
+	self->monsterinfo.sight = eel_sight;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &eel_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+	eel_set_fly_parameters(self);
+
+	swimmonster_start (self);
+}
--- /dev/null
+++ b/quake1/m_eel.h	2025-09-04 19:53:48
@@ -0,0 +1,28 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_eelswim1,
+	FRAME_eelswim2,
+	FRAME_eelswim3,
+	FRAME_eelswim4,
+	FRAME_eelswim5,
+	FRAME_eelswim6,
+	FRAME_eeldth1,
+	FRAME_eeldth2,
+	FRAME_eeldth3,
+	FRAME_eeldth4,
+	FRAME_eeldth5,
+	FRAME_eeldth6,
+	FRAME_eeldth7,
+	FRAME_eeldth8,
+	FRAME_eeldth9,
+	FRAME_eeldth10,
+	FRAME_eeldth11,
+	FRAME_eeldth12,
+	FRAME_eeldth13,
+	FRAME_eeldth14,
+	FRAME_eeldth15
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_enforcer.cpp	2025-09-04 19:53:48
@@ -0,0 +1,373 @@
+/*
+==============================================================================
+
+QUAKE ENFORCER
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_enforcer.h"
+#include "../m_flash.h"
+
+static int	sound_pain1;
+static int	sound_pain2;
+static int	sound_death;
+static int	sound_gib;
+static int	sound_idle;
+static int	sound_sight1;
+static int	sound_sight2;
+static int	sound_sight3;
+static int	sound_sight4;
+static int	sound_fire;
+
+void enforcer_fire (edict_t *self);
+
+MONSTERINFO_IDLE(enforcer_idlesound) (edict_t* self) -> void
+{
+	gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+MONSTERINFO_SIGHT (enforcer_sight) (edict_t *self, edict_t *other) -> void
+{
+	float r = frandom();
+
+	if (r < 0.25f)
+		gi.sound (self, CHAN_VOICE, sound_sight1, 1, ATTN_NORM, 0);
+	else if (r < 0.5f)
+		gi.sound (self, CHAN_VOICE, sound_sight2, 1, ATTN_NORM, 0);
+	else if (r < 0.75f)
+		gi.sound (self, CHAN_VOICE, sound_sight3, 1, ATTN_NORM, 0);
+	else
+		gi.sound (self, CHAN_VOICE, sound_sight4, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SEARCH(enforcer_search) (edict_t *self) -> void
+{
+	gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+mframe_t enforcer_frames_stand [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(enforcer_move_stand) = {FRAME_stand1, FRAME_stand7, enforcer_frames_stand, nullptr };
+
+MONSTERINFO_STAND(enforcer_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &enforcer_move_stand);
+}
+
+mframe_t enforcer_frames_walk [] =
+{
+	{ai_walk, 3},
+	{ai_walk, 4},
+	{ai_walk, 4},
+	{ai_walk, 5},
+	{ai_walk, 4},
+	{ai_walk, 3},
+	{ai_walk, 2},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk, 2},
+	{ai_walk, 3},
+	{ai_walk, 4},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 4},
+	{ai_walk, 3}
+};
+MMOVE_T(enforcer_move_walk) = {FRAME_walk1, FRAME_walk16, enforcer_frames_walk, nullptr };
+
+MONSTERINFO_WALK(enforcer_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &enforcer_move_walk);
+}
+
+mframe_t enforcer_frames_run [] =
+{
+	{ai_run, 22},
+	{ai_run, 8},
+	{ai_run, 7},
+	{ai_run, 8},
+	{ai_run, 13},
+	{ai_run, 12},
+	{ai_run, 11},
+	{ai_run, 7}
+};
+
+MMOVE_T(enforcer_move_run) = {FRAME_run1, FRAME_run8, enforcer_frames_run, nullptr };
+
+MONSTERINFO_RUN(enforcer_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &enforcer_move_stand);
+	else
+		M_SetAnimation(self, &enforcer_move_run);
+}
+
+mframe_t enforcer_frames_pain3 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(enforcer_move_pain3) = {FRAME_paina1, FRAME_paina4, enforcer_frames_pain3, enforcer_run};
+
+mframe_t enforcer_frames_pain2 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(enforcer_move_pain2) = {FRAME_painb1, FRAME_painb5, enforcer_frames_pain2, enforcer_run};
+
+mframe_t enforcer_frames_pain1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(enforcer_move_pain1) = {FRAME_painc1, FRAME_painc8, enforcer_frames_pain1, enforcer_run};
+
+PAIN(enforcer_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum = 1;
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	if (rand()&1)
+		gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+	else
+		gi.sound (self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+
+	if (damage <= 10)
+		M_SetAnimation(self, &enforcer_move_pain3);
+	else if (damage <= 25)
+		M_SetAnimation(self, &enforcer_move_pain2);
+	else
+		M_SetAnimation(self, &enforcer_move_pain1);
+}
+
+MONSTERINFO_SETSKIN(enforcer_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+void enforcer_dead (edict_t *self)
+{
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, -8 };
+	monster_dead(self);
+}
+
+static void enfrocer_shrink(edict_t* self)
+{
+	self->maxs[2] = -4;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t enforcer_frames_death1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(enforcer_move_death1) = {FRAME_death1, FRAME_death14, enforcer_frames_death1, enforcer_dead};
+
+mframe_t enforcer_frames_death2 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(enforcer_move_death2) = {FRAME_fdeath1, FRAME_fdeath11, enforcer_frames_death2, enforcer_dead};
+
+DIE(enforcer_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	// check for gib
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+			{ "models/monsters/enforcer/head/tris.md2", GIB_HEAD | GIB_SKINNED }
+			});
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	self->deadflag = true;
+	self->takedamage = true;
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+
+	if (frandom() < 0.5f)
+		M_SetAnimation(self, &enforcer_move_death1);
+	else
+		M_SetAnimation(self, &enforcer_move_death2);
+}
+
+void enforcer_fire (edict_t *self)
+{
+	vec3_t	forward, right;
+	vec3_t	start, aim;
+
+	if ((!self->enemy) || (!self->enemy->inuse))
+	{
+		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+		return;
+	}
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[MZ2_SOLDIER_BLASTER_1], forward, right);
+	PredictAim(self, self->enemy, start, 0, true, -0.2f, &aim, nullptr);
+
+	gi.sound (self, CHAN_WEAPON|CHAN_RELIABLE, sound_fire, 1, ATTN_NORM, 0);
+	monster_fire_blaster(self, start, aim, 15, 600, MZ2_SOLDIER_BLASTER_1, EF_BLASTER);
+}
+
+void enforcer_secondfire (edict_t *self)
+{
+	if (!self->radius_dmg)
+	{
+		self->monsterinfo.nextframe = 36;
+		self->radius_dmg = 1;
+	}
+	else
+		self->radius_dmg = 0;
+}
+
+mframe_t enforcer_frames_start_chain [] =
+{
+	{ai_charge,   0},
+	{ai_charge,   1},
+	{ai_charge,   1},
+	{ai_charge,   0},
+	{ai_charge,   0},
+	{ai_charge, 0, enforcer_fire},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, enforcer_secondfire},
+	{ai_charge}
+};
+MMOVE_T(enforcer_move_start_fire) = {FRAME_attack1, FRAME_attack10, enforcer_frames_start_chain, enforcer_run};
+
+MONSTERINFO_ATTACK(enforcer_attack) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &enforcer_move_start_fire);
+}
+
+
+//
+// SPAWN
+//
+
+/*QUAKED SP_monster_enforcer (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+model="models/monsters/enforcer/tris.md2"
+*/
+void SP_monster_enforcer (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_pain1		= gi.soundindex ("enforcer/pain1.wav");
+	sound_pain2		= gi.soundindex ("enforcer/pain2.wav");
+	sound_death		= gi.soundindex ("enforcer/death1.wav");
+	sound_gib		= gi.soundindex ("q1player/udeath.wav");
+	sound_idle		= gi.soundindex ("enforcer/idle1.wav");
+	sound_sight1	= gi.soundindex ("enforcer/sight1.wav");
+	sound_sight2	= gi.soundindex ("enforcer/sight2.wav");
+	sound_sight3	= gi.soundindex ("enforcer/sight3.wav");
+	sound_sight4	= gi.soundindex ("enforcer/sight4.wav");
+	sound_fire		= gi.soundindex ("enforcer/enfire.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex ("models/monsters/enforcer/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 40 };
+
+	self->health = 80 * st.health_multiplier;
+	self->gib_health = -35;
+	self->mass = 175;
+
+	self->monsterinfo.aiflags |= AI_STINKY;
+
+	self->pain = enforcer_pain;
+	self->die = enforcer_die;
+
+	self->monsterinfo.stand = enforcer_stand;
+	self->monsterinfo.walk = enforcer_walk;
+	self->monsterinfo.run = enforcer_run;
+	self->monsterinfo.dodge = nullptr ;
+	self->monsterinfo.attack = enforcer_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = enforcer_sight;
+	self->monsterinfo.search = enforcer_search;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &enforcer_move_stand);	
+	self->monsterinfo.scale = MODEL_SCALE;
+	
+	walkmonster_start (self);
+}
--- /dev/null
+++ b/quake1/m_enforcer.h	2025-09-04 19:53:48
@@ -0,0 +1,109 @@
+// ENFORCER
+	
+enum
+{
+	FRAME_stand1,
+	FRAME_stand2,
+	FRAME_stand3,
+	FRAME_stand4,
+	FRAME_stand5,
+	FRAME_stand6,
+	FRAME_stand7,
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_walk7,
+	FRAME_walk8,
+	FRAME_walk9,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12,
+	FRAME_walk13,
+	FRAME_walk14,
+	FRAME_walk15,
+	FRAME_walk16,
+	FRAME_run1,
+	FRAME_run2,
+	FRAME_run3,
+	FRAME_run4,
+	FRAME_run5,
+	FRAME_run6,
+	FRAME_run7,
+	FRAME_run8,
+	FRAME_attack1,
+	FRAME_attack2,
+	FRAME_attack3,
+	FRAME_attack4,
+	FRAME_attack5,
+	FRAME_attack6,
+	FRAME_attack7,
+	FRAME_attack8,
+	FRAME_attack9,
+	FRAME_attack10,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_death8,
+	FRAME_death9,
+	FRAME_death10,
+	FRAME_death11,
+	FRAME_death12,
+	FRAME_death13,
+	FRAME_death14,
+	FRAME_fdeath1,
+	FRAME_fdeath2,
+	FRAME_fdeath3,
+	FRAME_fdeath4,
+	FRAME_fdeath5,
+	FRAME_fdeath6,
+	FRAME_fdeath7,
+	FRAME_fdeath8,
+	FRAME_fdeath9,
+	FRAME_fdeath10,
+	FRAME_fdeath11,
+	FRAME_paina1,
+	FRAME_paina2,
+	FRAME_paina3,
+	FRAME_paina4,
+	FRAME_painb1,
+	FRAME_painb2,
+	FRAME_painb3,
+	FRAME_painb4,
+	FRAME_painb5,
+	FRAME_painc1,
+	FRAME_painc2,
+	FRAME_painc3,
+	FRAME_painc4,
+	FRAME_painc5,
+	FRAME_painc6,
+	FRAME_painc7,
+	FRAME_painc8,
+	FRAME_paind1,
+	FRAME_paind2,
+	FRAME_paind3,
+	FRAME_paind4,
+	FRAME_paind5,
+	FRAME_paind6,
+	FRAME_paind7,
+	FRAME_paind8,
+	FRAME_paind9,
+	FRAME_paind10,
+	FRAME_paind11,
+	FRAME_paind12,
+	FRAME_paind13,
+	FRAME_paind14,
+	FRAME_paind15,
+	FRAME_paind16,
+	FRAME_paind17,
+	FRAME_paind18,
+	FRAME_paind19
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_fiend.cpp	2025-09-04 19:53:48
@@ -0,0 +1,591 @@
+/*
+==============================================================================
+
+QUAKE FIEND
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_fiend.h"
+
+constexpr spawnflags_t SPAWNFLAG_FIEND_NOJUMPING = 8_spawnflag;
+
+static cached_soundindex	sound_swing;
+static cached_soundindex	sound_hit;
+static cached_soundindex	sound_jump;
+static cached_soundindex	sound_death;
+static cached_soundindex	sound_idle1;
+static cached_soundindex	sound_idle2;
+static cached_soundindex	sound_pain;
+static cached_soundindex	sound_sight1;
+static cached_soundindex	sound_sight2;
+static cached_soundindex	sound_land;
+
+//
+// SOUNDS
+//
+
+MONSTERINFO_SIGHT(fiend_sight) (edict_t* self, edict_t* other) -> void
+{
+	if (frandom() > 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_sight1, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_sight2, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SEARCH(fiend_search) (edict_t* self) -> void
+{
+	if (frandom() > 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_idle1, 1, ATTN_STATIC, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_idle2, 1, ATTN_STATIC, 0);
+}
+
+//
+// STAND
+//
+
+mframe_t fiend_frames_stand [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(fiend_move_stand) = { FRAME_stand1, FRAME_stand13, fiend_frames_stand, nullptr };
+
+MONSTERINFO_STAND(fiend_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &fiend_move_stand);
+}
+
+//
+// WALK
+//
+
+mframe_t fiend_frames_walk [] =
+{
+	{ai_walk,	8},
+	{ai_walk,	6},
+	{ai_walk,	6},
+	{ai_walk,	7},
+	{ai_walk,	4},
+	{ai_walk,	6},
+	{ai_walk,	10},
+	{ai_walk,	10}
+};
+MMOVE_T(fiend_move_walk) = { FRAME_walk1, FRAME_walk8, fiend_frames_walk, nullptr };
+
+MONSTERINFO_WALK(fiend_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &fiend_move_walk);
+}
+
+//
+// RUN
+//
+
+mframe_t fiend_frames_run [] =
+{
+	{ai_run,	20},
+	{ai_run,	15},
+	{ai_run,	36},
+	{ai_run,	20},
+	{ai_run,	15},
+	{ai_run,	36}
+};
+MMOVE_T(fiend_move_run) = { FRAME_run1, FRAME_run6, fiend_frames_run, nullptr };
+
+MONSTERINFO_RUN(fiend_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &fiend_move_stand);
+	else
+		M_SetAnimation(self, &fiend_move_run);
+}
+
+//
+// MELEE
+//
+
+void fiend_hit_left (edict_t *self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->mins[0], 8 };
+	if (fire_hit(self, aim, irandom(5, 15), 100))
+		gi.sound(self, CHAN_WEAPON, sound_hit, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_swing, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+void fiend_hit_right (edict_t *self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->maxs[0], 8 };
+	if (fire_hit(self, aim, irandom(5, 15), 100))
+		gi.sound(self, CHAN_WEAPON, sound_hit, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_swing, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+void fiend_check_refire (edict_t *self)
+{
+	if (!self->enemy || !self->enemy->inuse || self->enemy->health <= 0)
+		return;
+
+	if ((self->monsterinfo.melee_debounce_time <= level.time) && ((frandom() < 0.5f) || (range_to(self, self->enemy) <= RANGE_MELEE)))
+		self->monsterinfo.nextframe = FRAME_attacka1;
+}
+
+mframe_t fiend_frames_attack [] =
+{
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge,	0,	fiend_hit_left},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+
+	{ai_charge},
+	{ai_charge,	0,	fiend_hit_right},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge,	0,	fiend_check_refire}
+};
+MMOVE_T(fiend_move_attack) = { FRAME_attacka1, FRAME_attacka15, fiend_frames_attack, fiend_run };
+
+MONSTERINFO_MELEE(fiend_melee) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &fiend_move_attack);
+}
+
+//
+// ATTACK
+//
+
+TOUCH(fiend_jump_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (self->health <= 0)
+	{
+		self->touch = nullptr;
+		return;
+	}
+
+	if (self->style == 1 && other->takedamage)
+	{
+		if (self->velocity.length() > 30)
+		{
+			vec3_t point;
+			vec3_t normal;
+			int	   damage;
+
+			normal = self->velocity;
+			normal.normalize();
+			point = self->s.origin + (normal * self->maxs[0]);
+			damage = (int)frandom(40, 50);
+			T_Damage(other, self, self, self->velocity, point, normal, damage, damage, DAMAGE_NONE, MOD_UNKNOWN);
+			self->style = 0;
+		}
+	}
+
+	if (!M_CheckBottom (self))
+	{
+		if (self->groundentity)
+		{
+			self->monsterinfo.nextframe = FRAME_attacka1;
+			self->touch = nullptr;
+		}
+		return;
+	}
+
+	self->touch = nullptr;
+}
+
+void fiend_jump_takeoff (edict_t *self)
+{
+	vec3_t forward;
+
+	gi.sound(self, CHAN_VOICE, sound_jump, 1, ATTN_NORM, 0);
+	AngleVectors(self->s.angles, forward, nullptr, nullptr);
+	self->s.origin[2] += 1;
+	self->velocity = forward * 425;
+	self->velocity[2] = 160;
+	self->groundentity = nullptr;
+	self->monsterinfo.aiflags |= AI_DUCKED;
+	self->monsterinfo.attack_finished = level.time + 3_sec;
+	self->style = 1;
+	self->touch = fiend_jump_touch;
+}
+
+void fiend_check_landing (edict_t *self)
+{
+	monster_jump_finished(self);
+
+	self->owner = nullptr;
+
+	if (self->groundentity)
+	{
+		gi.sound(self, CHAN_WEAPON, sound_land, 1, ATTN_NORM, 0);
+		self->monsterinfo.attack_finished = level.time + random_time(500_ms, 1.5_sec);
+
+		if (self->monsterinfo.unduck)
+			self->monsterinfo.unduck(self);
+
+		if (range_to(self, self->enemy) <= RANGE_MELEE * 2.f)
+			self->monsterinfo.melee(self);
+
+		return;
+	}
+
+	if (level.time > self->monsterinfo.attack_finished)
+		self->monsterinfo.nextframe = FRAME_attacka1;
+	else
+		self->monsterinfo.nextframe = FRAME_attacka8;
+}
+
+mframe_t fiend_frames_jump [] =
+{
+	{ai_charge,	 5},
+	{ai_charge,	 5},
+	{ai_charge,	 5,	fiend_jump_takeoff},
+	{ai_charge,	10},
+	{ai_charge,	10},
+	{ai_charge,	15},
+	{ai_charge,	15},
+	{ai_charge,	10},
+	{ai_charge,	10},
+	{ai_charge,	 5},
+
+	{ai_charge,	 5,	fiend_check_landing},
+	{ai_charge,	 5}
+};
+MMOVE_T(fiend_move_jump) = { FRAME_leap1, FRAME_leap12, fiend_frames_jump, fiend_run };
+
+MONSTERINFO_ATTACK(fiend_jump) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &fiend_move_jump);
+}
+
+//
+// CHECKATTACK
+//
+
+bool fiend_check_melee(edict_t* self)
+{
+	return range_to(self, self->enemy) <= RANGE_MELEE && self->monsterinfo.melee_debounce_time <= level.time;
+}
+
+bool fiend_check_jump(edict_t *self)
+{
+	vec3_t	v;
+	float	distance;
+
+	if (self->absmin[2] > (self->enemy->absmin[2] + 0.75 * self->enemy->size[2]))
+		return false;
+
+	if (self->absmax[2] < (self->enemy->absmin[2] + 0.25 * self->enemy->size[2]))
+		return false;
+
+	v[0] = self->s.origin[0] - self->enemy->s.origin[0];
+	v[1] = self->s.origin[1] - self->enemy->s.origin[1];
+	v[2] = 0;
+	distance = v.length();
+
+	if (distance < 100 && self->monsterinfo.melee_debounce_time <= level.time)
+		return false;
+	if (distance > 100)
+	{
+		if (frandom() < 0.9f)
+			return false;
+	}
+
+	return true;
+}
+
+MONSTERINFO_CHECKATTACK(fiend_checkattack) (edict_t* self) -> bool
+{
+	if (!self->enemy || self->enemy->health <= 0)
+		return false;
+
+	if (fiend_check_melee(self))
+	{
+		self->monsterinfo.attack_state = AS_MELEE;
+		return true;
+	}
+
+	if (!self->spawnflags.has(SPAWNFLAG_FIEND_NOJUMPING) && fiend_check_jump(self))
+	{
+		self->monsterinfo.attack_state = AS_MISSILE;
+		return true;
+	}
+
+	return false;
+}
+
+//
+// PAIN
+//
+
+mframe_t fiend_frames_pain [] =
+{
+	{ai_move,	4},
+	{ai_move,	-3},
+	{ai_move,	-8},
+	{ai_move,	-3},
+	{ai_move,	2},
+	{ai_move,	5}
+};
+MMOVE_T(fiend_move_pain) = { FRAME_pain1, FRAME_pain6, fiend_frames_pain, fiend_run };
+
+PAIN(fiend_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	M_SetAnimation(self, &fiend_move_pain);
+}
+
+MONSTERINFO_SETSKIN(fiend_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// DEATH
+//
+
+void fiend_shrink(edict_t* self)
+{
+	self->maxs[2] = 0;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t fiend_frames_death [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0, fiend_shrink},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(fiend_move_death) = { FRAME_death1, FRAME_death9, fiend_frames_death, monster_dead };
+
+DIE(fiend_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 4, "models/objects/gibs/sm_meat/tris.md2" },
+			//{ "models/monsters/fiend/gibs/chest.md2", GIB_SKINNED },
+			{ "models/objects/gibs/chest/tris.md2" },
+			{ "models/monsters/fiend/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+	M_SetAnimation(self, &fiend_move_death);
+}
+
+//================
+// ROGUE
+void fiend_jump_down(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 100);
+	self->velocity += (up * 300);
+}
+
+void fiend_jump_up(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 200);
+	self->velocity += (up * 450);
+}
+
+void fiend_jump_wait_land(edict_t* self)
+{
+	if (!monster_jump_finished(self) && self->groundentity == nullptr)
+		self->monsterinfo.nextframe = self->s.frame;
+	else
+		self->monsterinfo.nextframe = self->s.frame + 1;
+}
+
+mframe_t fiend_frames_jump_up[] = {
+	{ ai_move, -8 },
+	{ ai_move },
+	{ ai_move, -8, fiend_jump_up },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, fiend_jump_wait_land },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(fiend_move_jump_up) = { FRAME_leap1, FRAME_leap12, fiend_frames_jump_up, fiend_run };
+
+mframe_t fiend_frames_jump_down[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, fiend_jump_down },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move, 0, fiend_jump_wait_land },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move }
+};
+MMOVE_T(fiend_move_jump_down) = { FRAME_leap1, FRAME_leap12, fiend_frames_jump_down, fiend_run };
+
+void fiend_jump_updown(edict_t* self, blocked_jump_result_t result)
+{
+	if (!self->enemy)
+		return;
+
+	if (result == blocked_jump_result_t::JUMP_JUMP_UP)
+		M_SetAnimation(self, &fiend_move_jump_up);
+	else
+		M_SetAnimation(self, &fiend_move_jump_down);
+}
+
+/*
+===
+Blocked
+===
+*/
+MONSTERINFO_BLOCKED(fiend_blocked) (edict_t* self, float dist) -> bool
+{
+	if (auto result = blocked_checkjump(self, dist); result != blocked_jump_result_t::NO_JUMP)
+	{
+		if (result != blocked_jump_result_t::JUMP_TURN)
+			fiend_jump_updown(self, result);
+		return true;
+	}
+
+	if (blocked_checkplat(self, dist))
+		return true;
+
+	return false;
+}
+// ROGUE
+//================
+
+//
+// SPAWN
+//
+
+/*QUAKED monster_fiend (1 .5 0) (-32 -32 -24) (32 32 48) Ambush Trigger_Spawn Sight NoJumping
+model="models/monsters/fiend/tris.md2"
+*/
+void SP_monster_fiend(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_swing.assign("mutant/mutatck1.wav");
+	sound_hit.assign("fiend/dhit2.wav");
+	sound_jump.assign("fiend/djump.wav");
+	sound_death.assign("fiend/ddeath.wav");
+	sound_idle1.assign("fiend/idle1.wav");
+	sound_idle2.assign("fiend/idle2.wav");
+	sound_pain.assign("fiend/dpain1.wav");
+	sound_sight1.assign("fiend/sight1.wav");
+	sound_sight2.assign("fiend/sight2.wav");
+	sound_land.assign("fiend/dland2.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex("models/monsters/fiend/tris.md2");
+	self->mins = { -32, -32, -24 };
+	self->maxs = { 32, 32, 48 };
+
+	self->health = 250 * st.health_multiplier;
+	self->gib_health = -180;
+	self->mass = 250;
+
+	self->pain = fiend_pain;
+	self->die = fiend_die;
+
+	self->monsterinfo.stand = fiend_stand;
+	self->monsterinfo.walk = fiend_walk;
+	self->monsterinfo.run = fiend_run;
+	self->monsterinfo.dodge = nullptr;
+	self->monsterinfo.attack = fiend_jump;
+	self->monsterinfo.melee = fiend_melee;
+	self->monsterinfo.sight = fiend_sight;
+	self->monsterinfo.search = fiend_search;
+	self->monsterinfo.checkattack = fiend_checkattack;
+	self->monsterinfo.blocked = fiend_blocked;
+	self->monsterinfo.setskin = fiend_setskin;
+
+	gi.linkentity (self);
+	
+	M_SetAnimation(self, &fiend_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+	self->monsterinfo.can_jump = !(self->spawnflags & SPAWNFLAG_FIEND_NOJUMPING);
+	self->monsterinfo.drop_height = 256;
+	self->monsterinfo.jump_height = 68;
+
+	walkmonster_start (self);
+}
--- /dev/null
+++ b/quake1/m_fiend.h	2025-09-04 19:53:48
@@ -0,0 +1,76 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_stand1,
+	FRAME_stand2,
+	FRAME_stand3,
+	FRAME_stand4,
+	FRAME_stand5,
+	FRAME_stand6,
+	FRAME_stand7,
+	FRAME_stand8,
+	FRAME_stand9,
+	FRAME_stand10,
+	FRAME_stand11,
+	FRAME_stand12,
+	FRAME_stand13,
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_walk7,
+	FRAME_walk8,
+	FRAME_run1,
+	FRAME_run2,
+	FRAME_run3,
+	FRAME_run4,
+	FRAME_run5,
+	FRAME_run6,
+	FRAME_leap1,
+	FRAME_leap2,
+	FRAME_leap3,
+	FRAME_leap4,
+	FRAME_leap5,
+	FRAME_leap6,
+	FRAME_leap7,
+	FRAME_leap8,
+	FRAME_leap9,
+	FRAME_leap10,
+	FRAME_leap11,
+	FRAME_leap12,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_pain4,
+	FRAME_pain5,
+	FRAME_pain6,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_death8,
+	FRAME_death9,
+	FRAME_attacka1,
+	FRAME_attacka2,
+	FRAME_attacka3,
+	FRAME_attacka4,
+	FRAME_attacka5,
+	FRAME_attacka6,
+	FRAME_attacka7,
+	FRAME_attacka8,
+	FRAME_attacka9,
+	FRAME_attacka10,
+	FRAME_attacka11,
+	FRAME_attacka12,
+	FRAME_attacka13,
+	FRAME_attacka14,
+	FRAME_attacka15
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_hknight.cpp	2025-09-04 19:53:48
@@ -0,0 +1,484 @@
+/*
+==============================================================================
+
+QUAKE HELL KNIGHT
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_hknight.h"
+
+static cached_soundindex sound_sword1;
+static cached_soundindex sound_flame;
+static cached_soundindex sound_death;
+static cached_soundindex sound_gib;
+static cached_soundindex sound_idle;
+static cached_soundindex sound_pain;
+static cached_soundindex sound_sight;
+
+void hknight_check_dist (edict_t *self);
+void hknight_melee (edict_t *self);
+
+//
+// SOUNDS
+//
+MONSTERINFO_SIGHT(hknight_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+
+	hknight_check_dist(self);
+}
+
+MONSTERINFO_IDLE(hknight_idle) (edict_t* self) -> void
+{
+	if (frandom() < 0.1)
+		gi.sound (self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+//
+// STAND
+//
+
+mframe_t hknight_frames_stand [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}		
+
+};
+MMOVE_T(hknight_move_stand) = {FRAME_stand1, FRAME_stand9, hknight_frames_stand, nullptr };
+
+MONSTERINFO_STAND (hknight_stand) (edict_t *self) -> void
+{
+	M_SetAnimation(self, &hknight_move_stand);
+}
+
+//
+// WALK
+//
+
+mframe_t hknight_frames_walk [] =
+{
+	{ai_walk,	5},
+	{ai_walk,	5},
+	{ai_walk,	4},
+	{ai_walk,	4},
+	{ai_walk,	2},
+	{ai_walk,	2},
+	{ai_walk,	3},
+	{ai_walk,	3},
+	{ai_walk,	4},
+	{ai_walk,	3},
+	{ai_walk,	4},
+	{ai_walk,	6},
+	{ai_walk,	2},
+	{ai_walk,	2},
+	{ai_walk,	4},
+	{ai_walk,	3},
+	{ai_walk,	3},
+	{ai_walk,	3},
+	{ai_walk,	3},
+	{ai_walk,	2}
+};
+MMOVE_T(hknight_move_walk) = {FRAME_walk1, FRAME_walk20, hknight_frames_walk, nullptr };
+
+MONSTERINFO_WALK (hknight_walk) (edict_t *self) -> void
+{
+	M_SetAnimation(self, &hknight_move_walk);
+}
+
+//
+// RUN
+//
+
+void hknight_check_dist (edict_t *self)
+{
+	if (!self->enemy || !self->enemy->inuse || self->enemy->health <= 0)
+		return;
+
+	if (range_to(self, self->enemy) <= RANGE_MELEE)
+		hknight_melee(self);
+}
+
+
+mframe_t hknight_frames_run [] =
+{
+	{ai_run,	16},
+	{ai_run,	20},
+	{ai_run,	13},
+	{ai_run,	7},
+	{ai_run,	16},
+	{ai_run,	20},
+	{ai_run,	14},
+	{ai_run,	6,		hknight_check_dist}
+};
+MMOVE_T(hknight_move_run) = {FRAME_run1, FRAME_run8, hknight_frames_run, nullptr };
+
+
+MONSTERINFO_RUN (hknight_run) (edict_t *self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &hknight_move_stand);
+	else
+		M_SetAnimation(self, &hknight_move_run);
+}
+
+void hknight_melee_damage (edict_t *self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->mins[0], 2 };
+	if (fire_hit(self, aim, irandom(1, 9), 100))
+		gi.sound(self, CHAN_WEAPON, sound_sword1, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_sword1, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+mframe_t hknight_frames_smash [] =
+{
+	{ai_charge,	1},
+	{ai_charge,	13},
+	{ai_charge,	9},
+	{ai_charge,	11},
+	{ai_charge,	10,	hknight_melee_damage},
+	{ai_charge,	7,	hknight_melee_damage},
+	{ai_charge,	12,	hknight_melee_damage},
+	{ai_charge,	2,	hknight_melee_damage},
+	{ai_charge,	3,	hknight_melee_damage},
+	{ai_charge},
+	{ai_charge}
+};
+MMOVE_T(hknight_smash_attack) = {FRAME_smash1, FRAME_smash11, hknight_frames_smash, hknight_run};
+
+mframe_t hknight_frames_watk [] =
+{
+	{ai_charge,	2},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge,	1},
+	{ai_charge,	4},
+	{ai_charge,	5},
+	{ai_charge,	3,	hknight_melee_damage},
+	{ai_charge,	2,	hknight_melee_damage},
+	{ai_charge,	2,	hknight_melee_damage},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge,	1},
+	{ai_charge,	1,	hknight_melee_damage},
+	{ai_charge,	3,	hknight_melee_damage},
+	{ai_charge,	4,	hknight_melee_damage},
+	{ai_charge,	6},
+	{ai_charge,	7},
+	{ai_charge,	3}
+};
+MMOVE_T(hknight_watk_attack) = {FRAME_w_attack1, FRAME_w_attack22, hknight_frames_watk, hknight_run};
+
+mframe_t hknight_frames_srice [] =
+{
+	{ai_charge,	9},
+	{ai_charge,	6},
+	{ai_charge,	13},
+	{ai_charge,	4},
+	{ai_charge,	7,	hknight_melee_damage},
+	{ai_charge,	15,	hknight_melee_damage},
+	{ai_charge,	8,	hknight_melee_damage},
+	{ai_charge,	2,	hknight_melee_damage},
+	{ai_charge,	0,	hknight_melee_damage},
+	{ai_charge,	3}
+};
+MMOVE_T(hknight_slice_attack) = {FRAME_slice1, FRAME_slice10, hknight_frames_srice, hknight_run};
+
+MONSTERINFO_MELEE (hknight_melee) (edict_t *self) -> void
+{
+	gi.sound(self, CHAN_WEAPON, sound_sword1, 1, ATTN_NORM, 0.1f);
+
+	if (self->dmg == 0)
+	{
+		M_SetAnimation(self, &hknight_slice_attack);
+		self->dmg++;
+	}
+	else if (self->dmg == 1)
+	{
+		M_SetAnimation(self, &hknight_smash_attack);
+		self->dmg++;
+	}
+	else if (self->dmg == 2)
+	{
+		M_SetAnimation(self, &hknight_watk_attack);
+		self->dmg = 0;
+	}
+}
+
+//
+// PAIN
+//
+
+mframe_t hknight_frames_pain1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(hknight_move_pain1) = {FRAME_pain1, FRAME_pain5, hknight_frames_pain1, hknight_run};
+
+PAIN(hknight_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 1.1_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	gi.sound (self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	M_SetAnimation(self, &hknight_move_pain1);
+}
+
+MONSTERINFO_SETSKIN(hknight_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// DEATH
+//
+void hknight_shrink(edict_t* self)
+{
+	self->maxs[2] = 0;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+
+mframe_t hknight_frames_death1 [] =
+{
+	{ai_move,	10},
+	{ai_move,	8},
+	{ai_move,	7},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move,	10},
+	{ai_move,	11},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(hknight_move_death1) = {FRAME_death1, FRAME_death12, hknight_frames_death1, monster_dead };
+
+
+mframe_t hknight_frames_death2 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(hknight_move_death2) = {FRAME_deathb1, FRAME_deathb9, hknight_frames_death2, monster_dead };
+
+DIE(hknight_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		if (strcmp(self->classname, "monster_hstatue") == 0)
+		{
+			ThrowGibs(self, damage, {
+			   { 2, "models/objects/gibs/bone/tris.md2" },
+			   { 4, "models/objects/gibs/sm_meat/tris.md2" },
+			   //{ "models/monsters/knight/gibs/chest.md2", GIB_SKINNED | GIB_DEBRIS },
+			   //{ "models/monsters/knight/gibs/thigh.md2", GIB_SKINNED | GIB_DEBRIS },
+			   //{ "models/monsters/knight/gibs/statgib.md2", GIB_SKINNED | GIB_DEBRIS },
+			   { "models/monsters/hknight/gibs/head.md2", GIB_SKINNED | GIB_DEBRIS | GIB_HEAD }
+				});
+		}
+		else
+		{
+			ThrowGibs(self, damage, {
+			   { 2, "models/objects/gibs/bone/tris.md2" },
+			   { 4, "models/objects/gibs/sm_meat/tris.md2" },
+			   //{ "models/monsters/hknight/gibs/chest.md2", GIB_SKINNED },
+			   //{ "models/monsters/hknight/gibs/thigh.md2", GIB_SKINNED },
+			   { "models/objects/gibs/chest/tris.md2" },
+			   { "models/monsters/hknight/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+				});
+		}
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	if (frandom() < 0.5f)
+		M_SetAnimation(self, &hknight_move_death1);
+	else
+		M_SetAnimation(self, &hknight_move_death2);
+}
+
+void hknight_fire_flame (edict_t *self)
+{
+	float		lawl[] = { -2, -1, 0, 1, 2, 3 };
+	int		rem = 165;
+	int		arraynum = rem-self->s.frame;
+	float	offang_y = 0;
+	vec3_t	vec, forward, right, start;
+	vec3_t	offang, v_forward;
+	vec3_t temp = { 0, 0, 14 };
+
+	AngleVectors (self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, temp, forward, right);
+
+	temp = { 0, lawl[arraynum], 0 };
+	vec = self->s.angles - temp;
+	AngleVectors (vec, forward, nullptr, nullptr);
+
+	offang = self->enemy->s.origin - self->s.origin;
+	offang = vectoangles(offang);
+	offang_y = self->s.angles[1] + -lawl[arraynum] * 6;
+	offang[1] = offang_y;
+
+	AngleVectors (offang, v_forward, nullptr, nullptr);
+
+	gi.sound (self, CHAN_WEAPON, sound_flame, 1, ATTN_NORM, 0);
+
+	fire_flame(self, start, v_forward, 9, 500);
+}
+
+mframe_t hknight_frames_magic [] =
+{
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge,	0,	hknight_fire_flame},
+	{ai_charge,	0,	hknight_fire_flame},
+	{ai_charge,	0,	hknight_fire_flame},
+	{ai_charge,	0,	hknight_fire_flame},
+	{ai_charge,	0,	hknight_fire_flame},
+	{ai_charge,	0,	hknight_fire_flame}
+};
+MMOVE_T(hknight_magic_attack) = { FRAME_magicc1, FRAME_magicc11, hknight_frames_magic, hknight_run };
+
+MONSTERINFO_ATTACK (hknight_magic) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &hknight_magic_attack);
+}
+
+
+//
+// SPAWN
+//
+
+/*QUAKED SP_monster_hknight (1 .5 0) (-16 -16 -24) (16 16 40) Ambush Trigger_Spawn Sight
+model="models/monsters/hknight/tris.md2"
+*/
+void SP_monster_hknight (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_death.assign("hknight/death1.wav");
+	sound_pain.assign("hknight/pain1.wav");
+	sound_idle.assign("hknight/idle.wav");
+	sound_sight.assign("hknight/sight1.wav");
+	sound_sword1.assign("hknight/slash1.wav");
+	sound_flame.assign("hknight/attack1.wav");
+		
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex ("models/monsters/hknight/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 40 };
+
+	if (strcmp(self->classname, "monster_statue") == 0)
+	{
+		self->health = 350 * st.health_multiplier;
+		self->gib_health = -100;
+		self->mass = 230;
+	}
+	else
+	{
+		self->health = 250 * st.health_multiplier;
+		self->gib_health = -40;
+		self->mass = 175;
+	}
+
+	self->monsterinfo.combat_style = COMBAT_MIXED;
+
+	self->pain = hknight_pain;
+	self->die = hknight_die;
+
+	self->monsterinfo.stand = hknight_stand;
+	self->monsterinfo.walk = hknight_walk;
+	self->monsterinfo.run = hknight_run;
+	self->monsterinfo.dodge = nullptr ;
+	self->monsterinfo.attack = hknight_magic; 
+	self->monsterinfo.melee = hknight_melee;
+	self->monsterinfo.sight = hknight_sight;
+	self->monsterinfo.idle = hknight_idle;
+
+	gi.linkentity (self);
+	
+	M_SetAnimation(self, &hknight_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	walkmonster_start (self);
+}
+
+
+/*QUAKED monster_hstatue (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping Kneeling Stationary
+model="models/monsters/knight/tris.md2"
+*/
+void SP_monster_hstatue(edict_t* self)
+{
+	SP_monster_hknight(self);
+
+	sound_death.assign("statue/death.wav");
+	sound_pain.assign("statue/pain.wav");
+	sound_idle.assign("statue/idle.wav");
+	sound_sight.assign("statue/see.wav");
+
+	self->s.skinnum = 2;
+
+	self->flags |= FL_MECHANICAL;
+}
--- /dev/null
+++ b/quake1/m_hknight.h	2025-09-04 19:53:48
@@ -0,0 +1,173 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_stand1,
+	FRAME_stand2,
+	FRAME_stand3,
+	FRAME_stand4,
+	FRAME_stand5,
+	FRAME_stand6,
+	FRAME_stand7,
+	FRAME_stand8,
+	FRAME_stand9,
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_walk7,
+	FRAME_walk8,
+	FRAME_walk9,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12,
+	FRAME_walk13,
+	FRAME_walk14,
+	FRAME_walk15,
+	FRAME_walk16,
+	FRAME_walk17,
+	FRAME_walk18,
+	FRAME_walk19,
+	FRAME_walk20,
+	FRAME_run1,
+	FRAME_run2,
+	FRAME_run3,
+	FRAME_run4,
+	FRAME_run5,
+	FRAME_run6,
+	FRAME_run7,
+	FRAME_run8,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_pain4,
+	FRAME_pain5,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_death8,
+	FRAME_death9,
+	FRAME_death10,
+	FRAME_death11,
+	FRAME_death12,
+	FRAME_deathb1,
+	FRAME_deathb2,
+	FRAME_deathb3,
+	FRAME_deathb4,
+	FRAME_deathb5,
+	FRAME_deathb6,
+	FRAME_deathb7,
+	FRAME_deathb8,
+	FRAME_deathb9,
+	FRAME_char_a1,
+	FRAME_char_a2,
+	FRAME_char_a3,
+	FRAME_char_a4,
+	FRAME_char_a5,
+	FRAME_char_a6,
+	FRAME_char_a7,
+	FRAME_char_a8,
+	FRAME_char_a9,
+	FRAME_char_a10,
+	FRAME_char_a11,
+	FRAME_char_a12,
+	FRAME_char_a13,
+	FRAME_char_a14,
+	FRAME_char_a15,
+	FRAME_char_a16,
+	FRAME_magica1,
+	FRAME_magica2,
+	FRAME_magica3,
+	FRAME_magica4,
+	FRAME_magica5,
+	FRAME_magica6,
+	FRAME_magica7,
+	FRAME_magica8,
+	FRAME_magica9,
+	FRAME_magica10,
+	FRAME_magica11,
+	FRAME_magica12,
+	FRAME_magica13,
+	FRAME_magica14,
+	FRAME_magicb1,
+	FRAME_magicb2,
+	FRAME_magicb3,
+	FRAME_magicb4,
+	FRAME_magicb5,
+	FRAME_magicb6,
+	FRAME_magicb7,
+	FRAME_magicb8,
+	FRAME_magicb9,
+	FRAME_magicb10,
+	FRAME_magicb11,
+	FRAME_magicb12,
+	FRAME_magicb13,
+	FRAME_char_b1,
+	FRAME_char_b2,
+	FRAME_char_b3,
+	FRAME_char_b4,
+	FRAME_char_b5,
+	FRAME_char_b6,
+	FRAME_slice1,
+	FRAME_slice2,
+	FRAME_slice3,
+	FRAME_slice4,
+	FRAME_slice5,
+	FRAME_slice6,
+	FRAME_slice7,
+	FRAME_slice8,
+	FRAME_slice9,
+	FRAME_slice10,
+	FRAME_smash1,
+	FRAME_smash2,
+	FRAME_smash3,
+	FRAME_smash4,
+	FRAME_smash5,
+	FRAME_smash6,
+	FRAME_smash7,
+	FRAME_smash8,
+	FRAME_smash9,
+	FRAME_smash10,
+	FRAME_smash11,
+	FRAME_w_attack1,
+	FRAME_w_attack2,
+	FRAME_w_attack3,
+	FRAME_w_attack4,
+	FRAME_w_attack5,
+	FRAME_w_attack6,
+	FRAME_w_attack7,
+	FRAME_w_attack8,
+	FRAME_w_attack9,
+	FRAME_w_attack10,
+	FRAME_w_attack11,
+	FRAME_w_attack12,
+	FRAME_w_attack13,
+	FRAME_w_attack14,
+	FRAME_w_attack15,
+	FRAME_w_attack16,
+	FRAME_w_attack17,
+	FRAME_w_attack18,
+	FRAME_w_attack19,
+	FRAME_w_attack20,
+	FRAME_w_attack21,
+	FRAME_w_attack22,
+	FRAME_magicc1,
+	FRAME_magicc2,
+	FRAME_magicc3,
+	FRAME_magicc4,
+	FRAME_magicc5,
+	FRAME_magicc6,
+	FRAME_magicc7,
+	FRAME_magicc8,
+	FRAME_magicc9,
+	FRAME_magicc10,
+	FRAME_magicc11
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_knight.cpp	2025-09-04 19:53:48
@@ -0,0 +1,491 @@
+/*
+==============================================================================
+
+QUAKE KNIGHT
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_knight.h"
+
+constexpr spawnflags_t SPAWNFLAG_KNIGHT_NOJUMPING = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_KNIGHT_KNEEL = 16_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_STATUE_STATIONARY = 32_spawnflag;
+
+static cached_soundindex	sound_sword1;
+static cached_soundindex	sound_sword2;
+static cached_soundindex	sound_death;
+static cached_soundindex	sound_gib;
+static cached_soundindex	sound_pain;
+static cached_soundindex	sound_idle;
+static cached_soundindex	sound_sight;
+
+void knight_stand (edict_t *self);
+void knight_walk (edict_t *self);
+void knight_check_dist (edict_t *self);
+
+//
+// SOUNDS
+//
+
+MONSTERINFO_SIGHT(knight_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SEARCH(knight_search) (edict_t* self) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+void knight_sword_sound (edict_t *self)
+{
+	if (frandom() <= 0.5f)
+		gi.sound (self, CHAN_VOICE, sound_sword1, 1, ATTN_NORM, 0);
+	else
+		gi.sound (self, CHAN_VOICE, sound_sword2, 1, ATTN_NORM, 0);
+}
+
+mframe_t knight_frames_kneeling[] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(knight_move_kneeling) = {FRAME_kneel1, FRAME_kneel5, knight_frames_kneeling, knight_stand};
+
+void knight_kneeling (edict_t *self)
+{
+	if (frandom() <= 0.25f)
+		M_SetAnimation(self, &knight_move_kneeling);
+}
+
+mframe_t knight_frames_standing[] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(knight_move_standing) = {FRAME_standing2, FRAME_standing5, knight_frames_standing, knight_walk};
+
+void knight_standing (edict_t *self)
+{
+	if (frandom() <= 0.2)
+		M_SetAnimation(self, &knight_move_standing);
+}
+
+//
+// STAND
+//
+
+mframe_t knight_frames_stand [] =
+{
+	{ai_stand, 0},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(knight_move_stand) = {FRAME_stand1, FRAME_stand9, knight_frames_stand, knight_stand};
+
+mframe_t knight_frames_stationary[] = {
+	{ ai_stand }
+};
+MMOVE_T(knight_move_stationary) = { FRAME_stand1, FRAME_stand1, knight_frames_stationary, nullptr };
+
+mframe_t knight_frames_kneel[] = {
+	{ ai_stand }
+};
+MMOVE_T(knight_move_kneel) = { FRAME_kneel5, FRAME_kneel5, knight_frames_kneel, nullptr };
+
+MONSTERINFO_STAND(knight_stand) (edict_t* self) -> void
+{
+	if (self->monsterinfo.active_move == &knight_move_stationary)
+		M_SetAnimation(self, &knight_move_stationary);
+	if (self->monsterinfo.active_move == &knight_move_kneel)
+		M_SetAnimation(self, &knight_move_kneel);
+	else
+		M_SetAnimation(self, &knight_move_stand);
+}
+
+//
+// WALK
+//
+
+mframe_t knight_frames_walk [] =
+{
+	{ai_walk,	3},
+	{ai_walk,	2},
+	{ai_walk,	3},
+	{ai_walk,	4},
+	{ai_walk,	3},
+	{ai_walk,	3},
+	{ai_walk,	3},
+	{ai_walk,	4},
+	{ai_walk,	3,		knight_standing},
+	{ai_walk,	3},
+	{ai_walk,	2},
+	{ai_walk,	3},
+	{ai_walk,	4},
+	{ai_walk,	3}
+};
+MMOVE_T(knight_move_walk) = {FRAME_walk1, FRAME_walk14, knight_frames_walk, knight_walk};
+
+MONSTERINFO_WALK(knight_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &knight_move_walk);
+}
+
+//
+// RUN
+//
+// can be improved
+
+void knight_check_dist(edict_t* self)
+{
+	if (!self->enemy || !self->enemy->inuse || self->enemy->health <= 0)
+		return;
+
+	if (range_to(self, self->enemy) <= RANGE_MELEE)
+	{
+		self->monsterinfo.nextframe = FRAME_attackb1;
+	}
+	else
+	{
+		if (frandom() > 0.6f)
+			self->monsterinfo.nextframe = FRAME_runattack1;
+		else
+			self->monsterinfo.nextframe = FRAME_runb1;
+	}
+}
+
+mframe_t knight_frames_run[] =
+{
+	{ai_run,	16},
+	{ai_run,	20},
+	{ai_run,	13},
+	{ai_run,	7},
+	{ai_run,	16},
+	{ai_run,	20},
+	{ai_run,	14},
+	{ai_run,	6,		knight_check_dist}
+};
+MMOVE_T(knight_move_run) = {FRAME_runb1, FRAME_runb8, knight_frames_run, nullptr };
+
+MONSTERINFO_RUN(knight_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.active_move == &knight_move_stationary)
+		M_SetAnimation(self, &knight_move_run);
+	else if (self->monsterinfo.active_move == &knight_move_kneel)
+		M_SetAnimation(self, &knight_move_run);
+	else if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &knight_move_stand);
+	else
+		M_SetAnimation(self, &knight_move_run);
+}
+
+void knight_attack(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->mins[0], 2 };
+	if (fire_hit(self, aim, irandom(1, 9), 100))
+		gi.sound(self, CHAN_WEAPON, sound_sword1, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_sword1, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+mframe_t knight_frames_attack_run[] =
+{
+	{ai_charge,	20},
+	{ai_charge,	20,		knight_sword_sound},
+	{ai_charge,	13},
+	{ai_charge,	7},
+	{ai_charge,	16},
+	{ai_charge,	20,		knight_attack},
+	{ai_charge,	14},
+	{ai_charge,	14},
+	{ai_charge,	14},
+	{ai_charge,	14},
+	{ai_charge,	6,		knight_check_dist}
+};
+MMOVE_T(knight_move_attack_run) = {FRAME_runattack1, FRAME_runattack11, knight_frames_attack_run, knight_run};
+
+MONSTERINFO_ATTACK(knight_attack_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &knight_move_attack_run);
+}
+
+void knight_hit_left(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->mins[0], 4 };
+	if (fire_hit(self, aim, irandom(1, 9), 100))
+		gi.sound(self, CHAN_WEAPON, sound_sword1, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_sword1, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+mframe_t knight_frames_attack[] =
+{
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge,	0,	knight_hit_left},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge,	0,	knight_check_dist}
+};
+MMOVE_T(knight_move_attack) = {FRAME_attackb1, FRAME_attackb10, knight_frames_attack, knight_run};
+
+MONSTERINFO_MELEE(knight_melee) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &knight_move_attack);
+}
+
+//
+// PAIN
+//
+
+mframe_t knight_frames_pain1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(knight_move_pain1) = {FRAME_pain1, FRAME_pain3, knight_frames_pain1, knight_run};
+
+mframe_t knight_frames_pain2 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(knight_move_pain2) = {FRAME_painb1, FRAME_painb11, knight_frames_pain2, knight_run};
+
+PAIN(knight_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	if (frandom() < 0.5f)
+		M_SetAnimation(self, &knight_move_pain1);
+	else
+		M_SetAnimation(self, &knight_move_pain2);
+}
+
+MONSTERINFO_SETSKIN(knight_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// DEATH
+//
+void knight_shrink(edict_t* self)
+{
+	self->maxs[2] = 0;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t knight_frames_death1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0,	knight_shrink},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(knight_move_death1) = { FRAME_death1, FRAME_death10, knight_frames_death1, monster_dead };
+
+
+mframe_t knight_frames_death2 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0,	knight_shrink},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(knight_move_death2) = { FRAME_deathb1, FRAME_deathb11, knight_frames_death2, monster_dead };
+
+DIE(knight_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		if (strcmp(self->classname, "monster_statue") == 0)
+		{
+			ThrowGibs(self, damage, {
+			   { 2, "models/objects/gibs/bone/tris.md2" },
+			   { 4, "models/objects/gibs/sm_meat/tris.md2" },
+			   //{ "models/monsters/knight/gibs/chest.md2", GIB_SKINNED | GIB_DEBRIS },
+			   //{ "models/monsters/knight/gibs/thigh.md2", GIB_SKINNED | GIB_DEBRIS },
+			   //{ "models/monsters/knight/gibs/statgib.md2", GIB_SKINNED | GIB_DEBRIS },
+			   { "models/monsters/knight/gibs/head.md2", GIB_SKINNED | GIB_DEBRIS | GIB_HEAD }
+				});
+		}
+		else
+		{
+			ThrowGibs(self, damage, {
+			   { 2, "models/objects/gibs/bone/tris.md2" },
+			   { 4, "models/objects/gibs/sm_meat/tris.md2" },
+			   //{ "models/monsters/knight/gibs/chest.md2", GIB_SKINNED },
+			   //{ "models/monsters/knight/gibs/thigh.md2", GIB_SKINNED },
+			   { "models/objects/gibs/chest/tris.md2" },
+			   { "models/monsters/knight/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+				});
+		}
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	if (frandom() < 0.5f)
+		M_SetAnimation(self, &knight_move_death1);
+	else
+		M_SetAnimation(self, &knight_move_death2);
+
+}
+
+/*QUAKED monster_knight (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping Kneeling
+model="models/monsters/knight/tris.md2"
+*/
+void SP_monster_knight (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_sword1.assign("knight/sword1.wav");
+	sound_sword2.assign("knight/sword2.wav");
+	sound_death.assign("knight/kdeath.wav");
+	sound_pain.assign("knight/khurt.wav");
+	sound_idle.assign("knight/idle.wav");
+	sound_sight.assign("knight/ksight.wav");
+	
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex("models/monsters/knight/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 32 };
+
+	if (strcmp(self->classname, "monster_statue") == 0)
+	{
+		self->health = 125 * st.health_multiplier;
+		self->gib_health = -100;
+		self->mass = 175;
+	}
+	else
+	{
+		self->health = 75 * st.health_multiplier;
+		self->gib_health = -40;
+		self->mass = 120;
+	}
+
+	self->pain = knight_pain;
+	self->die = knight_die;
+
+	self->monsterinfo.stand = knight_stand;
+	self->monsterinfo.walk = knight_walk;
+	self->monsterinfo.run = knight_run;
+	self->monsterinfo.dodge = nullptr;
+	self->monsterinfo.attack = knight_attack_run; 
+	self->monsterinfo.melee = knight_melee;
+	self->monsterinfo.sight = knight_sight;
+	self->monsterinfo.search = knight_search;
+	self->monsterinfo.setskin = knight_setskin;
+
+	gi.linkentity (self);
+
+	if (self->spawnflags.has(SPAWNFLAG_STATUE_STATIONARY))
+		M_SetAnimation(self, &knight_move_stationary);
+	else if (self->spawnflags.has(SPAWNFLAG_KNIGHT_KNEEL))
+		M_SetAnimation(self, &knight_move_kneel);
+	else
+		M_SetAnimation(self, &knight_move_stand);
+
+	self->monsterinfo.combat_style = COMBAT_MELEE;
+
+	self->monsterinfo.scale = MODEL_SCALE;
+	self->monsterinfo.can_jump = !(self->spawnflags & SPAWNFLAG_KNIGHT_NOJUMPING);
+	self->monsterinfo.drop_height = 256;
+	self->monsterinfo.jump_height = 68;
+
+	walkmonster_start (self);
+}
+
+/*QUAKED monster_statue (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight NoJumping Kneeling Stationary
+model="models/monsters/knight/tris.md2"
+*/
+void SP_monster_statue(edict_t* self)
+{
+	SP_monster_knight(self);
+
+	sound_death.assign("statue/death.wav");
+	sound_pain.assign("statue/pain.wav");
+	sound_idle.assign("statue/idle.wav");
+	sound_sight.assign("statue/see.wav");
+	
+	self->s.skinnum = 2;
+
+	self->flags |= FL_MECHANICAL;
+}
--- /dev/null
+++ b/quake1/m_knight.h	2025-09-04 19:53:48
@@ -0,0 +1,103 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_stand1,
+	FRAME_stand2,
+	FRAME_stand3,
+	FRAME_stand4,
+	FRAME_stand5,
+	FRAME_stand6,
+	FRAME_stand7,
+	FRAME_stand8,
+	FRAME_stand9,
+	FRAME_runb1,
+	FRAME_runb2,
+	FRAME_runb3,
+	FRAME_runb4,
+	FRAME_runb5,
+	FRAME_runb6,
+	FRAME_runb7,
+	FRAME_runb8,
+	FRAME_runattack1,
+	FRAME_runattack2,
+	FRAME_runattack3,
+	FRAME_runattack4,
+	FRAME_runattack5,
+	FRAME_runattack6,
+	FRAME_runattack7,
+	FRAME_runattack8,
+	FRAME_runattack9,
+	FRAME_runattack10,
+	FRAME_runattack11,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_painb1,
+	FRAME_painb2,
+	FRAME_painb3,
+	FRAME_painb4,
+	FRAME_painb5,
+	FRAME_painb6,
+	FRAME_painb7,
+	FRAME_painb8,
+	FRAME_painb9,
+	FRAME_painb10,
+	FRAME_painb11,
+	FRAME_attackb1,
+	FRAME_attackb2,
+	FRAME_attackb3,
+	FRAME_attackb4,
+	FRAME_attackb5,
+	FRAME_attackb6,
+	FRAME_attackb7,
+	FRAME_attackb8,
+	FRAME_attackb9,
+	FRAME_attackb10,
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_walk7,
+	FRAME_walk8,
+	FRAME_walk9,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12,
+	FRAME_walk13,
+	FRAME_walk14,
+	FRAME_kneel1,
+	FRAME_kneel2,
+	FRAME_kneel3,
+	FRAME_kneel4,
+	FRAME_kneel5,
+	FRAME_standing2,
+	FRAME_standing3,
+	FRAME_standing4,
+	FRAME_standing5,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_death8,
+	FRAME_death9,
+	FRAME_death10,
+	FRAME_deathb1,
+	FRAME_deathb2,
+	FRAME_deathb3,
+	FRAME_deathb4,
+	FRAME_deathb5,
+	FRAME_deathb6,
+	FRAME_deathb7,
+	FRAME_deathb8,
+	FRAME_deathb9,
+	FRAME_deathb10,
+	FRAME_deathb11
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_ogre.cpp	2025-09-04 19:53:48
@@ -0,0 +1,607 @@
+/*
+==============================================================================
+
+QUAKE OGRE
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_ogre.h"
+#include "../m_flash.h"
+
+constexpr spawnflags_t SPAWNFLAG_OGRE_NOJUMPING = 8_spawnflag;
+
+static cached_soundindex	sound_pain;
+static cached_soundindex	sound_death;
+static cached_soundindex	sound_idle;
+static cached_soundindex	sound_idle2;
+static cached_soundindex	sound_sight;
+static cached_soundindex	sound_saw;
+static cached_soundindex	sound_drag;
+
+void ogre_check_refire (edict_t *self);
+void ogre_attack (edict_t *self);
+void ogre_stand(edict_t* self);
+void ogre_flak_fire(edict_t* self);
+void ogre_grenade_fire(edict_t* self);
+
+MONSTERINFO_SIGHT(ogre_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SEARCH(ogre_search) (edict_t* self) -> void
+{
+	if (frandom() < 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_idle2, 1, ATTN_IDLE, 0);
+}
+
+void ogre_drag_sound (edict_t *self)
+{
+	if (frandom() <= 0.5f)
+		gi.sound (self, CHAN_VOICE, sound_drag, 1, ATTN_IDLE, 0);
+}
+
+mframe_t ogre_frames_stand [] = {
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+	{ ai_stand },
+};
+MMOVE_T(ogre_move_stand) = { FRAME_stand1, FRAME_stand9, ogre_frames_stand, ogre_stand };
+
+MONSTERINFO_STAND(ogre_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &ogre_move_stand);
+}
+
+mframe_t ogre_frames_walk [] = {
+	{ai_walk, 3},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 6, ogre_drag_sound},
+	{ai_walk, 3},
+	{ai_walk, 2},
+	{ai_walk, 3},
+	{ai_walk, 1},
+
+	{ai_walk, 2},
+	{ai_walk, 3},
+	{ai_walk, 3},
+	{ai_walk, 3},
+	{ai_walk, 3},
+	{ai_walk, 4}
+};
+MMOVE_T(ogre_move_walk) = { FRAME_walk1, FRAME_walk16, ogre_frames_walk, nullptr};
+
+MONSTERINFO_WALK(ogre_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &ogre_move_walk);
+}
+
+mframe_t ogre_frames_run [] = {
+	{ai_run, 9},
+	{ai_run, 12},
+	{ai_run, 8},
+	{ai_run, 22},
+	{ai_run, 16},
+	{ai_run, 4},
+	{ai_run, 13, ogre_attack},
+	{ai_run, 24}
+};
+MMOVE_T(ogre_move_run) = { FRAME_run1, FRAME_run8, ogre_frames_run, nullptr};
+
+MONSTERINFO_RUN(ogre_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &ogre_move_stand);
+	else
+		M_SetAnimation(self, &ogre_move_run);
+}
+
+mframe_t ogre_frames_pain1 [] = {
+	{ai_move, -3},
+	{ai_move, 1},
+	{ai_move, 1},
+	{ai_move},
+	{ai_move, 1}
+};
+MMOVE_T(ogre_move_pain1) = { FRAME_pain1, FRAME_pain5, ogre_frames_pain1, ogre_run };
+
+mframe_t ogre_frames_pain2 [] = {
+	{ai_move, -1},
+	{ai_move},
+	{ai_move, 1}
+};
+MMOVE_T(ogre_move_pain2) = { FRAME_painb1, FRAME_painb3, ogre_frames_pain2, ogre_run };
+
+
+mframe_t ogre_frames_pain3 [] = {
+	{ai_move, -3},
+	{ai_move, 1},
+	{ai_move, 1},
+	{ai_move},
+	{ai_move},
+	{ai_move, 1}
+};
+MMOVE_T(ogre_move_pain3) = { FRAME_painc1, FRAME_painc6, ogre_frames_pain3, ogre_run };
+
+
+mframe_t ogre_frames_pain4 [] = {
+	{ai_move, -3},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 1},
+	{ai_move, 1},
+	{ai_move}
+};
+MMOVE_T(ogre_move_pain4) = { FRAME_paind1, FRAME_paind16, ogre_frames_pain4, ogre_run };
+
+mframe_t ogre_frames_pain5 [] =
+{
+	{ai_move, -3},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 1},
+	{ai_move, 1},
+	{ai_move},
+};
+MMOVE_T(ogre_move_pain5) = {FRAME_paine1, FRAME_paine15, ogre_frames_pain5, ogre_run};
+
+PAIN(ogre_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	float r = frandom();
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	gi.sound (self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);	
+
+	if (r < 0.20)
+	{
+		self->pain_debounce_time = level.time + 1_sec;
+		M_SetAnimation(self, &ogre_move_pain1);
+	}
+	else if (r < 0.4)
+	{
+		self->pain_debounce_time = level.time + 1_sec;
+		M_SetAnimation(self, &ogre_move_pain2);
+	}
+	else if (r < 0.6)
+	{
+		self->pain_debounce_time = level.time + 1_sec;
+		M_SetAnimation(self, &ogre_move_pain3);
+	}
+	else if (r < 0.8)
+	{
+		self->pain_debounce_time = level.time + 2_sec;
+		M_SetAnimation(self, &ogre_move_pain4);
+	}
+	else
+	{
+		self->pain_debounce_time = level.time + 2_sec;
+		M_SetAnimation(self,  &ogre_move_pain5);
+	}
+}
+
+MONSTERINFO_SETSKIN(ogre_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+void Pickup_OgrePack1(edict_t* self)
+{
+	self->model = "models/items/pack/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_GRENADES), ED_GetSpawnTemp());
+	self->count = 2;
+}
+
+void Pickup_OgrePack2(edict_t* self)
+{
+	self->model = "models/items/pack/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_FLECHETTES), ED_GetSpawnTemp());
+	self->count = 5;
+}
+
+void Pickup_OgrePack3(edict_t* self)
+{
+	self->model = "models/items/pack/tris.md2";
+	SpawnItem(self, GetItemByIndex(IT_AMMO_GRENADES), ED_GetSpawnTemp());
+	self->count = 2;
+}
+
+void ogre_droprockets (edict_t *self)
+{
+	//Pickup_OgrePack(self);
+	if (self->health <= self->gib_health)
+		return;
+}
+
+void ogre_dead (edict_t *self)
+{
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, -8 };
+	monster_dead(self);
+}
+
+mframe_t ogre_frames_death1 [] = {
+	{ai_move},
+	{ai_move},
+	{ai_move, 0, ogre_droprockets},
+	{ai_move, -7},
+	{ai_move, -3},
+	{ai_move, -5},
+	{ai_move, 8},
+	{ai_move, 6},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(ogre_move_death1) = {FRAME_death1, FRAME_death14, ogre_frames_death1, ogre_dead};
+
+mframe_t ogre_frames_death2 [] = {
+	{ai_move},
+	{ai_move},
+	{ai_move, 0, ogre_droprockets},
+	{ai_move, -7},
+	{ai_move, -3},
+
+	{ai_move, -5},
+	{ai_move, 8},
+	{ai_move, 6},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(ogre_move_death2) = {FRAME_bdeath1, FRAME_bdeath10, ogre_frames_death2, ogre_dead};
+
+DIE(ogre_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+			//{ "models/monsters/ogre/gibs/chest.md2", GIB_SKINNED },
+			//{ "models/monsters/ogre/gibs/chainsaw.md2", GIB_SKINNED | GIB_UPRIGHT },
+			//{ "models/monsters/ogre/gibs/gun.md2", GIB_SKINNED | GIB_UPRIGHT },
+			//{ "models/monsters/ogre/gibs/foot.md2", GIB_SKINNED },
+			{ "models/monsters/ogre/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	// regular death
+	gi.sound (self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	if (frandom() < 0.5)
+		M_SetAnimation(self, &ogre_move_death1);
+	else
+		M_SetAnimation(self, &ogre_move_death2);
+}
+
+void ogre_fire(edict_t* self)
+{
+	if (strcmp(self->classname, "monster_ogre_marksman") == 0)
+		ogre_flak_fire(self);
+	else
+		ogre_grenade_fire(self);
+}
+
+void ogre_flak_fire(edict_t* self)
+{
+	vec3_t						start;
+	vec3_t						forward, right;
+	vec3_t						aim;
+	monster_muzzleflash_id_t	flash_number;
+	int							spread = 500;
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	flash_number = static_cast<monster_muzzleflash_id_t>(MZ2_GUNCMDR_GRENADE_FRONT_1 + (self->s.frame - FRAME_shoot3));
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+	PredictAim(self, self->enemy, start, 0, true, -0.2f, &aim, nullptr);
+	monster_fire_flakcannon(self, start, aim, 4, 800, spread, spread, 5, flash_number);
+}
+
+void ogre_grenade_fire (edict_t *self)
+{
+	vec3_t					 start;
+	vec3_t					 forward, right, up;
+	vec3_t					 aim;
+	monster_muzzleflash_id_t flash_number;
+	float					 pitch = 0;
+	// PMM
+	vec3_t target;
+	bool   blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	flash_number = MZ2_GUNCMDR_GRENADE_FRONT_1;
+
+	// pmm
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+
+	if ((blindfire) && (!visible(self, self->enemy)))
+	{
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		target = self->monsterinfo.blind_fire_target;
+	}
+	else
+		target = self->enemy->s.origin;
+
+	AngleVectors(self->s.angles, forward, right, up); // PGM
+	start = M_ProjectFlashSource(self, monster_flash_offset[flash_number], forward, right);
+
+	if (self->enemy)
+	{
+		float dist;
+
+		aim = target - self->s.origin;
+		dist = aim.length();
+
+		// aim up if they're on the same level as me and far away.
+		if ((dist > 512) && (aim[2] < 64) && (aim[2] > -64))
+		{
+			aim[2] += (dist - 512);
+		}
+
+		aim.normalize();
+		pitch = aim[2];
+		if (pitch > 0.4f)
+			pitch = 0.4f;
+		else if (pitch < -0.5f)
+			pitch = -0.5f;
+	}
+
+	// mortar fires farther
+	float speed = 600.f;
+
+	// try search for best pitch
+	if (M_CalculatePitchToFire(self, target, start, aim, speed, 2.5f, (flash_number >= MZ2_GUNCMDR_GRENADE_MORTAR_1 && flash_number <= MZ2_GUNCMDR_GRENADE_MORTAR_3)))
+		if (strcmp(self->classname, "monster_ogre_multigrenade") == 0)
+			monster_fire_multigrenade(self, start, aim, 40, speed, flash_number, (crandom_open() * 10.0f), frandom() * 10.f);
+		else
+			monster_fire_grenade(self, start, aim, 40, speed, flash_number, (crandom_open() * 10.0f), frandom() * 10.f);
+	else
+		if (strcmp(self->classname, "monster_ogre_multigrenade") == 0)
+			monster_fire_multigrenade(self, start, aim, 40, speed, flash_number, (crandom_open() * 10.0f), frandom() * 10.f);
+		else
+			monster_fire_grenade(self, start, aim, 40, speed, flash_number, (crandom_open() * 10.0f), 200.f + (crandom_open() * 10.0f));
+}
+
+void ogre_swing_left (edict_t *self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->maxs[0], 8 };
+	if (!fire_hit(self, aim, ((frandom() + frandom() + frandom()) * 4), 100))
+		self->monsterinfo.melee_debounce_time = level.time + 1_sec;
+}
+
+void ogre_swing_right (edict_t *self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->maxs[0], 8 };
+	if (!fire_hit(self, aim, ((frandom() + frandom() + frandom()) * 4), 100))
+		self->monsterinfo.melee_debounce_time = level.time + 1_sec;
+}
+
+void ogre_smash (edict_t *self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->maxs[0], 8 };
+	if (!fire_hit (self, aim, (25 + (frandom() * 5)), 100))
+		self->monsterinfo.melee_debounce_time = level.time + 1.2_sec;
+
+	gi.sound(self, CHAN_WEAPON, sound_saw, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_MELEE(ogre_check_refire) (edict_t* self) -> void
+{
+	if (!self->enemy || !self->enemy->inuse || self->enemy->health <= 0)
+		return;
+
+	if ( (skill->value == 3) || (range_to(self, self->enemy) == RANGE_MELEE))
+	{
+		if (frandom() > 0.5)
+			self->monsterinfo.nextframe = FRAME_swing1;
+		else
+			self->monsterinfo.nextframe = FRAME_smash1;
+	}
+	else
+		ogre_attack(self);
+}
+
+void ogre_sawswingsound (edict_t *self)
+{
+	gi.sound (self, CHAN_WEAPON, sound_saw, 1, ATTN_NORM, 0);
+}
+
+mframe_t ogre_frames_swing [] = {
+	
+	{ai_charge},
+	{ai_charge, 0, ogre_sawswingsound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, ogre_swing_right},
+	{ai_charge},
+	{ai_charge, 0, ogre_sawswingsound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, ogre_swing_left},
+	{ai_charge},
+	{ai_charge, 0, ogre_check_refire}
+};
+MMOVE_T(ogre_move_swing_attack) = { FRAME_swing1, FRAME_swing14, ogre_frames_swing, ogre_run };
+
+mframe_t ogre_frames_smash [] = {
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, ogre_smash},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, ogre_check_refire}
+};
+MMOVE_T(ogre_move_smash_attack) = { FRAME_smash1, FRAME_smash14, ogre_frames_smash, ogre_run };
+
+mframe_t ogre_frames_attack_grenade [] = {
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, ogre_fire},
+	{ai_charge},
+	{ai_charge}
+};
+MMOVE_T(ogre_move_attack_grenade) = { FRAME_shoot1, FRAME_shoot6, ogre_frames_attack_grenade, ogre_run };
+
+MONSTERINFO_ATTACK(ogre_attack) (edict_t* self) -> void
+{
+	float r = range_to(self, self->enemy);
+
+	if (!self->bad_area && r <= RANGE_MELEE && self->monsterinfo.melee_debounce_time <= level.time)
+	{
+		M_SetAnimation(self, &ogre_move_swing_attack);
+	}
+	else if (visible(self,self->enemy) && infront(self, self->enemy)
+		&& (r <= RANGE_MID) && !(self->monsterinfo.aiflags & AI_SOUND_TARGET))
+	{
+		M_SetAnimation(self, &ogre_move_attack_grenade);
+	}
+	else
+		M_SetAnimation(self, &ogre_move_run);
+}
+
+/*QUAKED monster_ogre (1 .5 0) (-20 -20 -24) (20 20 32) Ambush Trigger_Spawn Sight GoodGuy NoGib
+model="models/monsters/ogre/tris.md2"
+*/
+void SP_monster_ogre (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_pain.assign("monsters/ogre/pain1.wav");
+	sound_death.assign("monsters/ogre/death.wav");
+	sound_idle.assign("monsters/ogre/idle.wav");
+	sound_idle2.assign("monsters/ogre/idle2.wav");
+	sound_sight.assign("monsters/ogre/wake.wav");
+	sound_saw.assign("monsters/ogre/sawatk.wav");
+	sound_drag.assign("monsters/ogre/drag.wav");
+
+	gi.modelindex ("models/items/pack/tris.md2");
+	gi.modelindex("models/monsters/ogre/gibs/head.md2");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex ("models/monsters/ogre/tris.md2");
+	self->mins = { -20, -20, -24 };
+	self->maxs = { 20, 20, 32 };
+
+	self->health = 300 * st.health_multiplier;
+	self->gib_health = -80;
+	self->mass = 250;
+
+	self->pain = ogre_pain;
+	self->die = ogre_die;
+
+
+
+	self->monsterinfo.aiflags |= AI_STINKY;
+
+	self->monsterinfo.stand = ogre_stand;
+	self->monsterinfo.walk = ogre_walk;
+	self->monsterinfo.run = ogre_run;
+	self->monsterinfo.dodge = nullptr;
+	self->monsterinfo.attack = ogre_attack;
+	self->monsterinfo.melee = ogre_check_refire;
+	self->monsterinfo.sight = ogre_sight;
+	self->monsterinfo.search = ogre_search;
+	self->monsterinfo.setskin = ogre_setskin;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &ogre_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+	self->monsterinfo.can_jump = !(self->spawnflags & SPAWNFLAG_OGRE_NOJUMPING);
+	self->monsterinfo.drop_height = 256;
+	self->monsterinfo.jump_height = 68;
+
+	walkmonster_start (self);
+}
+
+void SP_monster_ogre_marksman(edict_t* self)
+{
+	SP_monster_ogre(self);
+	self->s.skinnum = 2;
+}
+
+void SP_monster_ogre_multigrenade(edict_t* self)
+{
+	SP_monster_ogre(self);
+	self->s.skinnum = 4;
+}
--- /dev/null
+++ b/quake1/m_ogre.h	2025-09-04 19:53:48
@@ -0,0 +1,154 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_stand1,
+	FRAME_stand2,
+	FRAME_stand3,
+	FRAME_stand4,
+	FRAME_stand5,
+	FRAME_stand6,
+	FRAME_stand7,
+	FRAME_stand8,
+	FRAME_stand9,
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_walk7,
+	FRAME_walk8,
+	FRAME_walk9,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12,
+	FRAME_walk13,
+	FRAME_walk14,
+	FRAME_walk15,
+	FRAME_walk16,
+	FRAME_run1,
+	FRAME_run2,
+	FRAME_run3,
+	FRAME_run4,
+	FRAME_run5,
+	FRAME_run6,
+	FRAME_run7,
+	FRAME_run8,
+	FRAME_swing1,
+	FRAME_swing2,
+	FRAME_swing3,
+	FRAME_swing4,
+	FRAME_swing5,
+	FRAME_swing6,
+	FRAME_swing7,
+	FRAME_swing8,
+	FRAME_swing9,
+	FRAME_swing10,
+	FRAME_swing11,
+	FRAME_swing12,
+	FRAME_swing13,
+	FRAME_swing14,
+	FRAME_smash1,
+	FRAME_smash2,
+	FRAME_smash3,
+	FRAME_smash4,
+	FRAME_smash5,
+	FRAME_smash6,
+	FRAME_smash7,
+	FRAME_smash8,
+	FRAME_smash9,
+	FRAME_smash10,
+	FRAME_smash11,
+	FRAME_smash12,
+	FRAME_smash13,
+	FRAME_smash14,
+	FRAME_shoot1,
+	FRAME_shoot2,
+	FRAME_shoot3,
+	FRAME_shoot4,
+	FRAME_shoot5,
+	FRAME_shoot6,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_pain4,
+	FRAME_pain5,
+	FRAME_painb1,
+	FRAME_painb2,
+	FRAME_painb3,
+	FRAME_painc1,
+	FRAME_painc2,
+	FRAME_painc3,
+	FRAME_painc4,
+	FRAME_painc5,
+	FRAME_painc6,
+	FRAME_paind1,
+	FRAME_paind2,
+	FRAME_paind3,
+	FRAME_paind4,
+	FRAME_paind5,
+	FRAME_paind6,
+	FRAME_paind7,
+	FRAME_paind8,
+	FRAME_paind9,
+	FRAME_paind10,
+	FRAME_paind11,
+	FRAME_paind12,
+	FRAME_paind13,
+	FRAME_paind14,
+	FRAME_paind15,
+	FRAME_paind16,
+	FRAME_paine1,
+	FRAME_paine2,
+	FRAME_paine3,
+	FRAME_paine4,
+	FRAME_paine5,
+	FRAME_paine6,
+	FRAME_paine7,
+	FRAME_paine8,
+	FRAME_paine9,
+	FRAME_paine10,
+	FRAME_paine11,
+	FRAME_paine12,
+	FRAME_paine13,
+	FRAME_paine14,
+	FRAME_paine15,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_death8,
+	FRAME_death9,
+	FRAME_death10,
+	FRAME_death11,
+	FRAME_death12,
+	FRAME_death13,
+	FRAME_death14,
+	FRAME_bdeath1,
+	FRAME_bdeath2,
+	FRAME_bdeath3,
+	FRAME_bdeath4,
+	FRAME_bdeath5,
+	FRAME_bdeath6,
+	FRAME_bdeath7,
+	FRAME_bdeath8,
+	FRAME_bdeath9,
+	FRAME_bdeath10,
+	FRAME_pull1,
+	FRAME_pull2,
+	FRAME_pull3,
+	FRAME_pull4,
+	FRAME_pull5,
+	FRAME_pull6,
+	FRAME_pull7,
+	FRAME_pull8,
+	FRAME_pull9,
+	FRAME_pull10,
+	FRAME_pull11
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_oldone.cpp	2025-09-04 19:53:48
@@ -0,0 +1,645 @@
+
+/*
+==============================================================================
+
+QUAKE SHUB-NIGGURATH
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_oldone.h"
+
+static cached_soundindex sound_idle;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_death1;
+static cached_soundindex sound_death2;
+static cached_soundindex sound_spawn;
+static cached_soundindex sound_pain;
+
+constexpr const char* default_reinforcements = "monster_scrag 1;monster_fiend 3;monster_vore 5;monster_shambler 6";
+constexpr int32_t default_monster_slots_base = 6;
+
+void oldone_run(edict_t* self);
+
+//
+// SOUNDS
+//
+
+MONSTERINFO_IDLE(oldone_idle) (edict_t* self) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SIGHT(oldone_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+//
+// STAND
+//
+
+mframe_t oldone_frames_stand[] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},  // 10
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},  // 20
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},  // 30
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},  // 40
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(oldone_move_stand) = { FRAME_old1, FRAME_old46, oldone_frames_stand, nullptr };
+
+MONSTERINFO_STAND(oldone_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &oldone_move_stand);
+}
+
+mframe_t oldone_frames_walk[] =
+{
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},  // 10
+
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},  // 20
+
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},  // 30
+
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},  // 40
+
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk}
+};
+MMOVE_T(oldone_move_walk) = { FRAME_old1, FRAME_old46, oldone_frames_walk, nullptr };
+
+MONSTERINFO_WALK(oldone_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &oldone_move_walk);
+}
+
+mframe_t oldone_frames_run[] =
+{
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},  // 10
+
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},  // 20
+
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},  // 30
+
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},  // 40
+
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run}
+};
+MMOVE_T(oldone_move_run) = { FRAME_old1, FRAME_old46, oldone_frames_run, oldone_run };
+
+MONSTERINFO_RUN(oldone_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &oldone_move_run);
+}
+
+//
+// ATTACK
+//
+void oldoneCoopCheck(edict_t* self)
+{
+	// no more than 8 players in coop, so..
+	std::array<edict_t*, MAX_SPLIT_PLAYERS> targets;
+	uint32_t num_targets = 0;
+	int32_t  target;
+	edict_t* ent;
+	trace_t	 tr;
+
+	// if we're not in coop, this is a noop
+	// [Paril-KEX] might as well let this work in SP too, so he fires it
+	// if you get below him
+	//if (!coop->integer)
+	//	return;
+	// if we are, and we have recently fired, bail
+	if (self->monsterinfo.fire_wait > level.time)
+		return;
+
+	targets = {};
+
+	// cycle through players
+	for (uint32_t player = 1; player <= game.maxclients; player++)
+	{
+		ent = &g_edicts[player];
+		if (!ent->inuse)
+			continue;
+		if (!ent->client)
+			continue;
+		if (inback(self, ent) || below(self, ent))
+		{
+			tr = gi.traceline(self->s.origin, ent->s.origin, self, MASK_SOLID);
+			if (tr.fraction == 1.0f)
+				targets[num_targets++] = ent;
+		}
+	}
+
+	if (!num_targets)
+		return;
+
+	// get a number from 0 to (num_targets-1)
+	target = irandom(num_targets);
+
+	// save off the real enemy
+	ent = self->enemy;
+	// set the new guy as temporary enemy
+	self->enemy = targets[target];
+	// put the real enemy back
+	self->enemy = ent;
+
+	// we're done
+	return;
+}
+
+void oldoneSpawn(edict_t* self)
+{
+	vec3_t	 f, r, offset, startpoint, spawnpoint;
+	edict_t* ent;
+
+	offset = { 225, 0, -58 }; // real distance needed is (sqrt (56*56*2) + sqrt(16*16*2)) or 101.8
+	AngleVectors(self->s.angles, f, r, nullptr);
+
+	startpoint = M_ProjectFlashSource(self, offset, f, r);
+
+	if (self->monsterinfo.chosen_reinforcements[0] == 255)
+		return;
+
+	auto& reinforcement = self->monsterinfo.reinforcements.reinforcements[self->monsterinfo.chosen_reinforcements[0]];
+
+	if (FindSpawnPoint(startpoint, reinforcement.mins, reinforcement.maxs, spawnpoint, 32, false))
+	{
+		ent = CreateFlyMonster(spawnpoint, self->s.angles, reinforcement.mins, reinforcement.maxs, reinforcement.classname);
+
+		if (!ent)
+			return;
+
+		gi.sound(self, CHAN_BODY, sound_spawn, 1, ATTN_NONE, 0);
+
+		ent->nextthink = level.time;
+		ent->think(ent);
+
+		ent->monsterinfo.aiflags |= AI_SPAWNED_COMMANDER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
+		ent->monsterinfo.commander = self;
+		ent->monsterinfo.slots_from_commander = reinforcement.strength;
+		self->monsterinfo.monster_used += reinforcement.strength;
+
+		if ((self->enemy->inuse) && (self->enemy->health > 0))
+		{
+			ent->enemy = self->enemy;
+			FoundTarget(ent);
+		}
+	}
+}
+
+void oldone_prep_spawn(edict_t* self)
+{
+	oldoneCoopCheck(self);
+	self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+	self->timestamp = level.time;
+	self->yaw_speed = 10;
+}
+
+void oldone_spawn_check(edict_t* self)
+{
+	oldoneCoopCheck(self);
+	oldoneSpawn(self);
+
+	if (level.time > (self->timestamp + 2.0_sec)) // 0.5 seconds per flyer.  this gets three
+	{
+		self->monsterinfo.aiflags &= ~AI_MANUAL_STEERING;
+	}
+	else
+		self->monsterinfo.nextframe = FRAME_old8;
+}
+
+void oldone_ready_spawn(edict_t* self)
+{
+	float  current_yaw;
+	vec3_t offset, f, r, startpoint, spawnpoint;
+
+	oldoneCoopCheck(self);
+
+	current_yaw = anglemod(self->s.angles[YAW]);
+
+	if (fabsf(current_yaw - self->ideal_yaw) > 0.1f)
+	{
+		self->monsterinfo.aiflags |= AI_HOLD_FRAME;
+		self->timestamp += FRAME_TIME_S;
+		return;
+	}
+
+	self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+
+	int num_summoned;
+	self->monsterinfo.chosen_reinforcements = M_PickReinforcements(self, num_summoned, 1);
+
+	if (!num_summoned)
+		return;
+
+	auto& reinforcement = self->monsterinfo.reinforcements.reinforcements[self->monsterinfo.chosen_reinforcements[0]];
+
+	offset = { 105, 0, -58 };
+	AngleVectors(self->s.angles, f, r, nullptr);
+	startpoint = M_ProjectFlashSource(self, offset, f, r);
+	if (FindSpawnPoint(startpoint, reinforcement.mins, reinforcement.maxs, spawnpoint, 32, false))
+	{
+		float radius = (reinforcement.maxs - reinforcement.mins).length() * 0.5f;
+
+		SpawnGrow_Spawn(spawnpoint + (reinforcement.mins + reinforcement.maxs), radius, radius * 2.f);
+	}
+}
+
+void oldone_start_spawn(edict_t* self)
+{
+	int	   mytime;
+	float  enemy_yaw;
+	vec3_t temp;
+
+	oldoneCoopCheck(self);
+
+	if (!self->enemy)
+		return;
+
+	mytime = (int)((level.time - self->timestamp) / 0.5).seconds();
+
+	temp = self->enemy->s.origin - self->s.origin;
+	enemy_yaw = vectoyaw(temp);
+
+	// note that the offsets are based on a forward of 105 from the end angle
+	if (mytime == 0)
+		self->ideal_yaw = anglemod(enemy_yaw - 30);
+	else if (mytime == 1)
+		self->ideal_yaw = anglemod(enemy_yaw);
+	else if (mytime == 2)
+		self->ideal_yaw = anglemod(enemy_yaw + 30);
+}
+
+mframe_t oldone_frames_spawn[] =
+{
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, oldone_prep_spawn},
+	{ai_charge, 0, oldone_start_spawn},
+	{ai_charge, 0, oldone_ready_spawn},
+	{ai_charge},  // 10
+
+	{ai_charge},
+	{ai_charge, 0, oldone_spawn_check},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge}
+};
+MMOVE_T(oldone_move_spawn) = { FRAME_old1, FRAME_old18, oldone_frames_spawn, nullptr };
+
+MONSTERINFO_ATTACK(oldone_attack) (edict_t* self) -> void
+{
+	vec3_t vec;
+	float  range;
+	bool   enemy_inback, enemy_infront, enemy_below;
+
+	self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+
+	if ((!self->enemy) || (!self->enemy->inuse))
+		return;
+
+	enemy_inback = inback(self, self->enemy);
+	enemy_infront = infront(self, self->enemy);
+	enemy_below = below(self, self->enemy);
+
+	if (self->bad_area)
+	{
+		return;
+	}
+
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		M_SetAnimation(self, &oldone_move_spawn);
+		return;
+	}
+
+	if (!enemy_inback && !enemy_infront && !enemy_below) // to side and not under
+	{
+		return;
+	}
+
+	if (enemy_infront)
+	{
+		vec = self->enemy->s.origin - self->s.origin;
+		range = vec.length();
+
+		if (M_SlotsLeft(self) > 2)
+		{
+			if (frandom() <= 0.20f)
+				M_SetAnimation(self, &oldone_move_spawn);
+		}
+	}
+}
+
+//
+// PAIN
+//
+
+mframe_t oldone_frames_pain[] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(oldone_move_pain) = { FRAME_shake1, FRAME_shake10, oldone_frames_pain, oldone_run };
+
+PAIN(oldone_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	self->health += damage;
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 5_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	if (damage < 30)
+	{
+		gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &oldone_move_pain);
+	}
+}
+
+//
+// DEATH
+//
+
+void oldone_dead(edict_t* self)
+{
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, -8 };
+	monster_dead(self);
+}
+
+mframe_t oldone_frames_death1[] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(oldone_move_death) = { FRAME_shake1, FRAME_shake20, oldone_frames_death1, oldone_dead };
+
+DIE(oldone_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+			{ "models/objects/gibs/sm_meat/tris.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_death1, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	M_SetAnimation(self, &oldone_move_death);
+}
+
+
+void SP_monster_oldone(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_idle.assign("oldone/idle.wav");
+	sound_sight.assign("oldone/sight.wav");
+	sound_death1.assign("oldone/death.wav");
+	sound_death2.assign("oldone/pop2.wav");
+	sound_spawn.assign("");
+	sound_pain.assign("");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex("models/monsters/oldone/tris.md2");
+
+	self->mins = { -160, - 128, - 24 };
+	self->maxs = { 160, 128, 256 };
+
+	self->health = 40000 * st.health_multiplier;
+	self->gib_health = -50;
+	self->mass = 3000;
+
+	self->pain = oldone_pain;
+	self->die = oldone_die;
+
+	self->monsterinfo.stand = oldone_stand;
+	self->monsterinfo.walk = oldone_walk;
+	self->monsterinfo.run = oldone_run;
+	self->monsterinfo.dodge = nullptr;
+	self->monsterinfo.attack = oldone_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = oldone_sight;
+	self->monsterinfo.idle = oldone_idle;
+
+	gi.linkentity(self);
+
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	self->flags |= FL_NO_KNOCKBACK | FL_STATIONARY;
+	
+	stationarymonster_start(self, st);
+
+	self->monsterinfo.attack_finished = 0_ms;
+
+	const char* reinforcements = default_reinforcements;
+
+	if (!st.was_key_specified("monster_slots"))
+		self->monsterinfo.monster_slots = default_monster_slots_base;
+	if (st.was_key_specified("reinforcements"))
+		reinforcements = st.reinforcements;
+
+	if (self->monsterinfo.monster_slots && reinforcements && *reinforcements)
+	{
+		if (skill->integer)
+			self->monsterinfo.monster_slots += floor(self->monsterinfo.monster_slots * (skill->value / 2.f));
+		/* KONIG - doubles reinforcement scaling in coop */
+		if (coop->integer)
+		{
+			self->monsterinfo.monster_slots += floor(self->monsterinfo.monster_slots * (skill->value / 2.f));
+		}
+		M_SetupReinforcements(reinforcements, self->monsterinfo.reinforcements);
+	}
+
+}
--- /dev/null
+++ b/quake1/m_oldone.h	2025-09-04 19:53:48
@@ -0,0 +1,73 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_old1,
+	FRAME_old2,
+	FRAME_old3,
+	FRAME_old4,
+	FRAME_old5,
+	FRAME_old6,
+	FRAME_old7,
+	FRAME_old8,
+	FRAME_old9,
+	FRAME_old10,
+	FRAME_old11,
+	FRAME_old12,
+	FRAME_old13,
+	FRAME_old14,
+	FRAME_old15,
+	FRAME_old16,
+	FRAME_old17,
+	FRAME_old18,
+	FRAME_old19,
+	FRAME_old20,
+	FRAME_old21,
+	FRAME_old22,
+	FRAME_old23,
+	FRAME_old24,
+	FRAME_old25,
+	FRAME_old26,
+	FRAME_old27,
+	FRAME_old28,
+	FRAME_old29,
+	FRAME_old30,
+	FRAME_old31,
+	FRAME_old32,
+	FRAME_old33,
+	FRAME_old34,
+	FRAME_old35,
+	FRAME_old36,
+	FRAME_old37,
+	FRAME_old38,
+	FRAME_old39,
+	FRAME_old40,
+	FRAME_old41,
+	FRAME_old42,
+	FRAME_old43,
+	FRAME_old44,
+	FRAME_old45,
+	FRAME_old46,
+	FRAME_shake1,
+	FRAME_shake2,
+	FRAME_shake3,
+	FRAME_shake4,
+	FRAME_shake5,
+	FRAME_shake6,
+	FRAME_shake7,
+	FRAME_shake8,
+	FRAME_shake9,
+	FRAME_shake10,
+	FRAME_shake11,
+	FRAME_shake12,
+	FRAME_shake13,
+	FRAME_shake14,
+	FRAME_shake15,
+	FRAME_shake16,
+	FRAME_shake17,
+	FRAME_shake18,
+	FRAME_shake19,
+	FRAME_shake20
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_overlord.cpp	2025-09-04 19:53:48
@@ -0,0 +1,875 @@
+/*
+==============================================================================
+
+OVERLORD
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_overlord.h"
+
+static cached_soundindex	sound_sight;
+static cached_soundindex	sound_attack;
+static cached_soundindex	sound_melee;
+static cached_soundindex	sound_die;
+static cached_soundindex	sound_pain;
+
+static cached_soundindex sound_attack2;
+
+constexpr spawnflags_t SPAWNFLAG_OVERLORD_NO_TELEPORT = 8_spawnflag;
+
+// sqrt(64*64*2) + sqrt(16*16*2) => 113.1
+constexpr vec3_t spawnpoints[] = {
+	{ 30, 128, 0 },
+	{ 30, -128, 0 }
+};
+
+constexpr vec3_t wrath_mins = { -16, -16, -24 };
+constexpr vec3_t wrath_maxs = { 16, 16, 32 };
+
+//TODO
+// DUDE TELEPORTS! Forgot about that. Boss2-Titan will use that code.
+
+//
+// SOUNDS
+//
+
+MONSTERINFO_SIGHT(overlord_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+void overlord_attack_sound (edict_t *self)
+{
+	gi.sound (self, CHAN_VOICE, sound_attack, 1, ATTN_NORM, 0);
+}
+
+//
+// STAND
+//
+
+mframe_t overlord_frames_stand [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(overlord_move_stand) = { FRAME_s_wtwk01, FRAME_s_wtwk15, overlord_frames_stand, nullptr };
+
+MONSTERINFO_STAND(overlord_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &overlord_move_stand);
+}
+
+//
+// WALK
+//
+
+mframe_t overlord_frames_walk [] =
+{
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5}
+};
+MMOVE_T(overlord_move_walk) = { FRAME_s_wtwk01, FRAME_s_wtwk15, overlord_frames_walk, nullptr };
+
+MONSTERINFO_WALK(overlord_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &overlord_move_walk);
+}
+
+//
+// RUN
+//
+
+mframe_t overlord_frames_run [] =
+{
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10}
+};
+MMOVE_T(overlord_move_run) = { FRAME_s_wtwk01, FRAME_s_wtwk15, overlord_frames_run, nullptr };
+
+MONSTERINFO_RUN(overlord_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &overlord_move_run);
+}
+
+//
+// TELEPORT
+//
+
+void OverlordTeleport(edict_t* self)
+{
+	float chance;
+
+	if (self->spawnflags.has(SPAWNFLAG_OVERLORD_NO_TELEPORT))
+		return;
+
+	switch (skill->integer)
+	{
+	case 0:
+	case 1:
+		chance = frandom() * 2;
+		break;
+	case 2:
+		chance = frandom() * 3;
+		break;
+	case 3:
+		chance = frandom() * 4;
+		break;
+	default:
+		chance = frandom() * 2;
+		break;
+	}
+
+	if (chance <= 1)
+		return;
+
+	if (!TryRandomTeleportPosition(self, 128.0f)) {
+		return;
+	}
+}
+
+void overlord_surprise(edict_t* self)
+{
+	if (!self->enemy || !self->enemy->inuse || self->enemy->health <= 0)
+		return;
+
+	edict_t* target = self->enemy;
+
+	vec3_t forward, target_angles, behind_pos;
+	target_angles = target->s.angles;
+	target_angles[PITCH] = 0; // Ignore pitch to stay horizontal
+	AngleVectors(target_angles, forward, nullptr, nullptr);
+
+	// Adjust this distance for melee range
+	float back_distance = 64.0f;
+	behind_pos = target->s.origin + (forward * -back_distance);
+
+	// Raise the position if needed (since enemy is flying)
+	behind_pos[2] += 32;
+
+	// Check if the spot is clear
+	trace_t tr = gi.trace(
+		behind_pos,
+		self->mins,
+		self->maxs,
+		behind_pos,
+		self,
+		MASK_MONSTERSOLID
+	);
+
+	if (tr.startsolid || tr.allsolid || tr.fraction < 1.0f)
+		return; // Can't teleport  blocked
+
+	// Teleport effect - departure
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_TELEPORT_EFFECT);
+	gi.WritePosition(self->s.origin);
+	gi.multicast(self->s.origin, MULTICAST_PVS, false);
+
+	// Teleport to the cleared spot
+	self->s.origin = behind_pos;
+	gi.linkentity(self);
+
+	// Face the player
+	vec3_t dir;
+	dir = target->s.origin - self->s.origin;
+	self->s.angles = vectoangles(dir);
+
+	// Teleport effect - arrival
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_TELEPORT_EFFECT);
+	gi.WritePosition(self->s.origin);
+	gi.multicast(self->s.origin, MULTICAST_PVS, false);
+}
+
+//
+// ATTACK
+//
+
+void overlord_spawn(edict_t* self)
+{
+	vec3_t	 f, r, u, offset, startpoint, spawnpoint;
+	edict_t* ent, * designated_enemy;
+	int		 i;
+
+	AngleVectors(self->s.angles, f, r, u);
+
+	for (i = 0; i < 2; i++)
+	{
+		offset = spawnpoints[i];
+
+		startpoint = G_ProjectSource2(self->s.origin, offset, f, r, u);
+
+		if (FindSpawnPoint(startpoint, wrath_mins, wrath_maxs, spawnpoint, 64))
+		{
+			ent = CreateFlyMonster(spawnpoint, self->s.angles, wrath_mins, wrath_maxs, "monster_wrath");
+
+			if (!ent)
+				continue;
+
+			self->monsterinfo.monster_used++;
+			ent->monsterinfo.commander = self;
+			ent->monsterinfo.slots_from_commander = 1;
+
+			ent->nextthink = level.time;
+			ent->think(ent);
+
+			ent->monsterinfo.aiflags |= AI_SPAWNED_COMMANDER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
+
+			if (!coop->integer)
+			{
+				designated_enemy = self->enemy;
+			}
+			else
+			{
+				designated_enemy = PickCoopTarget(ent);
+				if (designated_enemy)
+				{
+					// try to avoid using my enemy
+					if (designated_enemy == self->enemy)
+					{
+						designated_enemy = PickCoopTarget(ent);
+						if (!designated_enemy)
+							designated_enemy = self->enemy;
+					}
+				}
+				else
+					designated_enemy = self->enemy;
+			}
+
+			if ((designated_enemy->inuse) && (designated_enemy->health > 0))
+			{
+				ent->enemy = designated_enemy;
+				FoundTarget(ent);
+				ent->monsterinfo.attack(ent);
+			}
+		}
+	}
+}
+
+void overlord_ready_spawn(edict_t* self)
+{
+	vec3_t f, r, u, offset, startpoint, spawnpoint;
+	int	   i;
+
+	AngleVectors(self->s.angles, f, r, u);
+
+	for (i = 0; i < 2; i++)
+	{
+		offset = spawnpoints[i];
+		startpoint = G_ProjectSource2(self->s.origin, offset, f, r, u);
+		if (FindSpawnPoint(startpoint, wrath_mins, wrath_maxs, spawnpoint, false))
+		{
+			float radius = (wrath_maxs - wrath_mins).length() * 0.5f;
+
+			SpawnGrow_Spawn(spawnpoint + (wrath_mins + wrath_maxs), radius, radius * 2.f);
+		}
+	}
+}
+
+void OverlordCalcSlots(edict_t* self)
+{
+	switch (skill->integer)
+	{
+	case 0:
+	case 1:
+		self->monsterinfo.monster_slots = 2;
+		break;
+	case 2:
+		self->monsterinfo.monster_slots = 3;
+		break;
+	case 3:
+		self->monsterinfo.monster_slots = 4;
+		break;
+	default:
+		self->monsterinfo.monster_slots = 2;
+		break;
+	}
+	if (coop->integer)
+	{
+		self->monsterinfo.monster_slots = min(6, self->monsterinfo.monster_slots + (skill->integer * (CountPlayers() - 1)));
+	}
+}
+
+void overlord_fire(edict_t* self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	vec;
+	trace_t trace;
+	int		rocketSpeed;
+	vec3_t target;
+	bool   blindfire = false;
+	vec3_t offset = { 0, 0, 10 };
+	int damage = 20;
+
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+	else
+		blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse)
+		return;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+
+	rocketSpeed = 450;
+
+	if (blindfire)
+		target = self->monsterinfo.blind_fire_target;
+	else
+		target = self->enemy->s.origin;
+
+
+	if (blindfire)
+	{
+		vec = target;
+		dir = vec - start;
+	}
+
+	else if (frandom() < 0.33f || (start[2] < self->enemy->absmin[2]))
+	{
+		vec = target;
+		vec[2] += self->enemy->viewheight;
+		dir = vec - start;
+	}
+	else
+	{
+		vec = target;
+		vec[2] = self->enemy->absmin[2] + 1;
+		dir = vec - start;
+	}
+
+	if ((!blindfire) && (frandom() < 0.35f))
+		PredictAim(self, self->enemy, start, rocketSpeed, false, 0.f, &dir, &vec);
+
+	dir.normalize();
+
+	trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+	if (blindfire)
+	{
+		if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+			fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 1);
+		else
+		{
+			vec = target;
+			vec += (right * -10);
+			dir = vec - start;
+			dir.normalize();
+			trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+			if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+				fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 1);
+			else
+			{
+				vec = target;
+				vec += (right * 10);
+				dir = vec - start;
+				dir.normalize();
+				trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+				if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+					fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 1);
+			}
+		}
+	}
+	else
+	{
+		if (trace.fraction > 0.5f || trace.ent->solid != SOLID_BSP)
+			fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.015f, 1);
+	}
+
+	gi.sound(self, CHAN_WEAPON | CHAN_RELIABLE, sound_attack2, 1, ATTN_NORM, 0);
+}
+
+void overlord_hit_left(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->mins[0], 8 };
+	if (fire_hit(self, aim, irandom(20, 30), 400))
+		gi.sound(self, CHAN_WEAPON, sound_melee, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_melee, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+void overlord_hit_right(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->maxs[0], 8 };
+	if (fire_hit(self, aim, irandom(20, 30), 400))
+		gi.sound(self, CHAN_WEAPON, sound_melee, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_melee, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+void overlord_hit_right_hard(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->maxs[0], 8 };
+	if (fire_hit(self, aim, irandom(40, 60), 400))
+		gi.sound(self, CHAN_WEAPON, sound_melee, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_melee, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+mframe_t overlord_frames_melee1[] = {
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, overlord_attack_sound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, overlord_hit_left},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, OverlordTeleport}
+};
+MMOVE_T(overlord_move_melee1) = { FRAME_s_wtaa01, FRAME_s_wtaa10, overlord_frames_melee1, overlord_run };
+
+mframe_t overlord_frames_melee2[] = {
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, overlord_attack_sound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, overlord_hit_right},
+	{ai_charge},
+	{ai_charge},
+
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, OverlordTeleport}
+};
+MMOVE_T(overlord_move_melee2) = { FRAME_s_wtab01, FRAME_s_wtab14, overlord_frames_melee2, overlord_run };
+
+mframe_t overlord_frames_melee3[] = {
+	{ai_charge, 0, overlord_surprise},
+	{ai_charge},
+	{ai_charge, 0, overlord_attack_sound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, overlord_hit_right_hard},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, OverlordTeleport}
+};
+MMOVE_T(overlord_move_melee3) = { FRAME_s_wtac01, FRAME_s_wtac14, overlord_frames_melee3, overlord_run };
+
+MONSTERINFO_MELEE(overlord_melee) (edict_t* self) -> void
+{
+	if (frandom() <= 0.20f && skill->integer >= 3)
+		M_SetAnimation(self, &overlord_move_melee3);
+	else if (frandom() >= 0.60f)
+		M_SetAnimation(self, &overlord_move_melee2);
+	else
+		M_SetAnimation(self, &overlord_move_melee1);
+}
+
+mframe_t overlord_frames_missile[] = {
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, overlord_attack_sound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, -1},
+	{ai_charge, -2},
+	{ai_charge, -3},
+	{ai_charge, -2, overlord_fire},
+
+	{ai_charge, -1},
+	{ai_charge, 0, OverlordTeleport}
+};
+MMOVE_T(overlord_move_missile) = { FRAME_s_wtba01, FRAME_s_wtba12, overlord_frames_missile, overlord_run };
+
+mframe_t overlord_frames_spawn[] = {
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, overlord_attack_sound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, -1, overlord_ready_spawn },
+	{ai_charge, -2},
+	{ai_charge, -3},
+	{ai_charge, -2, overlord_spawn },
+
+	{ai_charge, -1},
+	{ai_charge, 0, OverlordTeleport}
+};
+MMOVE_T(overlord_move_spawn) = { FRAME_s_wtba01, FRAME_s_wtba12, overlord_frames_spawn, overlord_run };
+
+MONSTERINFO_ATTACK(overlord_attack) (edict_t* self) -> void
+{
+	vec3_t offset = { 0, 0, 10 };
+	bool  blocked = false;
+
+	if (self->monsterinfo.aiflags & AI_BLOCKED)
+	{
+		blocked = true;
+		self->monsterinfo.aiflags &= ~AI_BLOCKED;
+	}
+
+	if (!M_CheckClearShot(self, offset))
+		return;
+
+	float r, chance;
+
+	OverlordCalcSlots(self);
+
+	// if we can't see the target, spawn stuff
+	if ((self->monsterinfo.attack_state == AS_BLIND) && (M_SlotsLeft(self) >= 2))
+	{
+		M_SetAnimation(self, &overlord_move_spawn);
+		return;
+	}
+
+	// accept bias towards spawning
+	if (blocked && (M_SlotsLeft(self) >= 2))
+	{
+		M_SetAnimation(self, &overlord_move_spawn);
+		return;
+	}
+
+
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		// setup shot probabilities
+		if (self->monsterinfo.blind_fire_delay < 1.0_sec)
+			chance = 1.0;
+		else if (self->monsterinfo.blind_fire_delay < 7.5_sec)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		r = frandom();
+
+		// minimum of 5.5 seconds, plus 0-1, after the shots are done
+		self->monsterinfo.blind_fire_delay += random_time(5.5_sec, 6.5_sec);
+
+		// don't shoot at the origin
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		// don't shoot if the dice say not to
+		if (r > chance)
+			return;
+
+		// turn on manual steering to signal both manual steering and blindfire
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+
+		if (M_SlotsLeft(self) >= 2)
+		{
+			if (frandom() <= 0.40f)
+				M_SetAnimation(self, &overlord_move_missile);
+			else
+				M_SetAnimation(self, &overlord_move_spawn);
+		}
+		else
+			M_SetAnimation(self, &overlord_move_missile);
+
+		self->monsterinfo.attack_finished = level.time + random_time(4_sec);
+		return;
+	}
+
+	float shindeiru = frandom();
+
+	if (M_SlotsLeft(self) >= 2)
+	{
+		if (shindeiru <= 0.20f && skill->integer >= 3)
+			M_SetAnimation(self, &overlord_move_melee3);
+		else if (shindeiru <= 0.60f)
+			M_SetAnimation(self, &overlord_move_missile);
+		else
+			M_SetAnimation(self, &overlord_move_spawn);
+	}
+	else
+	{
+	if (shindeiru <= 0.20f && skill->integer >= 3)
+		M_SetAnimation(self, &overlord_move_melee3);
+	else
+		M_SetAnimation(self, &overlord_move_missile);
+	}
+}
+
+//
+// PAIN
+//
+
+mframe_t overlord_frames_pain1 [] =
+{	
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move}
+};
+MMOVE_T(overlord_move_pain1) = { FRAME_s_wtpa01, FRAME_s_wtpa14, overlord_frames_pain1, overlord_run };
+
+mframe_t overlord_frames_pain2[] =
+{
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+
+		{ai_move}
+};
+MMOVE_T(overlord_move_pain2) = { FRAME_s_wtpb01, FRAME_s_wtpb11, overlord_frames_pain2, overlord_run };
+
+PAIN(overlord_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 2_sec;
+	
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+	
+	gi.sound (self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	if (frandom() >= 0.4f)
+		M_SetAnimation(self, &overlord_move_pain1);
+	else
+		M_SetAnimation(self, &overlord_move_pain2);
+}
+
+//
+// DEATH
+//
+
+void overlord_dead (edict_t * self)
+{
+	T_RadiusDamage(self, self, 60, nullptr, 105, DAMAGE_NONE, MOD_BARREL);
+
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_EXPLOSION1);
+	gi.WritePosition(self->s.origin);
+	gi.multicast(self->s.origin, MULTICAST_PHS, false);
+
+	self->s.skinnum /= 2;
+
+	ThrowGibs(self, 55, {
+		{ 2, "models/objects/gibs/bone/tris.md2" },
+		{ 2, "models/monsters/overlord/gibs/claw.md2" },
+		{ 2, "models/monsters/overlord/gibs/arm.md2" },
+		{ "models/monsters/overlord/gibs/ribs.md2" },
+		{ "models/monsters/overlord/gibs/bone.md2", GIB_HEAD }
+		});
+
+	self->touch = nullptr;
+}
+
+mframe_t overlord_frames_die [] =
+{	
+	{ai_move, 0, Q1BossExplode},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(overlord_move_die) = { FRAME_s_wtdt01, FRAME_s_wtdt17, overlord_frames_die, overlord_dead };
+
+void KillWraiths(edict_t* self)
+{
+	edict_t* ent = nullptr;
+
+	while (1)
+	{
+		ent = G_FindByString<&edict_t::classname>(ent, "monster_wrath");
+		if (!ent)
+			return;
+
+		if ((ent->inuse) && (ent->health > 0))
+			T_Damage(ent, self, self, vec3_origin, self->enemy->s.origin, vec3_origin, (ent->health + 1), 0, DAMAGE_NO_KNOCKBACK, MOD_UNKNOWN);
+	}
+}
+
+
+DIE(overlord_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+	KillWraiths(self);
+
+	M_SetAnimation(self, &overlord_move_die);
+}
+
+MONSTERINFO_CHECKATTACK(overlord_checkattack) (edict_t* self) -> bool
+{
+	if (!self->enemy)
+		return false;
+
+	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.8f, 0.8f, 0.f, 0.f);
+}
+
+static void overlord_set_fly_parameters(edict_t* self)
+{
+	self->monsterinfo.fly_thrusters = false;
+	self->monsterinfo.fly_acceleration = 20.f;
+	self->monsterinfo.fly_speed = 120.f;
+	self->monsterinfo.fly_min_distance = 200.f;
+	self->monsterinfo.fly_max_distance = 400.f;
+}
+
+/*QUAKED monster_overlord (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+model="models/monsters/overlord/tris.md2"
+*/
+void SP_monster_overlord (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_melee.assign("overlord/smash.wav");
+	sound_sight.assign("wrath/wsee.wav");
+	sound_attack.assign("wrath/watt.wav");
+	sound_die.assign("wrath/wdthc.wav");
+	sound_pain.assign("wrath/wpain.wav");
+
+
+	sound_attack2.assign("vore/attack2.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex ("models/monsters/overlord/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 32 };
+
+	self->health = max(3000, 3000 + 1250 * (skill->integer - 1)) * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_BODY;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = max(500, 500 + 150 * (skill->integer - 1));
+	self->mass = 750;
+	if (coop->integer)
+	{
+		self->health += (500 * skill->integer) + (500 * (CountPlayers() - 1));
+		self->monsterinfo.armor_power += (250 * skill->integer) + (250 * (CountPlayers() - 1));
+	}
+	self->pain = overlord_pain;
+	self->die = overlord_die;
+
+	self->monsterinfo.stand = overlord_stand;
+	self->monsterinfo.walk = overlord_walk;
+	self->monsterinfo.run = overlord_run;
+	self->monsterinfo.attack = overlord_attack;
+	self->monsterinfo.melee = overlord_melee;
+	self->monsterinfo.sight = overlord_sight;
+	self->monsterinfo.search = nullptr;
+	self->monsterinfo.checkattack = overlord_checkattack;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &overlord_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+	
+	self->flags |= FL_FLY;
+	if (!self->yaw_speed)
+		self->yaw_speed = 10;
+	self->viewheight = 10;
+
+	flymonster_start (self);
+
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+
+	overlord_set_fly_parameters(self);
+}
--- /dev/null
+++ b/quake1/m_overlord.h	2025-09-04 19:53:48
@@ -0,0 +1,115 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_s_wrtfrm,
+	FRAME_s_wtwk01,
+	FRAME_s_wtwk02,
+	FRAME_s_wtwk03,
+	FRAME_s_wtwk04,
+	FRAME_s_wtwk05,
+	FRAME_s_wtwk06,
+	FRAME_s_wtwk07,
+	FRAME_s_wtwk08,
+	FRAME_s_wtwk09,
+	FRAME_s_wtwk10,
+	FRAME_s_wtwk11,
+	FRAME_s_wtwk12,
+	FRAME_s_wtwk13,
+	FRAME_s_wtwk14,
+	FRAME_s_wtwk15,
+	FRAME_s_wtaa01,
+	FRAME_s_wtaa02,
+	FRAME_s_wtaa03,
+	FRAME_s_wtaa04,
+	FRAME_s_wtaa05,
+	FRAME_s_wtaa06,
+	FRAME_s_wtaa07,
+	FRAME_s_wtaa08,
+	FRAME_s_wtaa09,
+	FRAME_s_wtaa10,
+	FRAME_s_wtab01,
+	FRAME_s_wtab02,
+	FRAME_s_wtab03,
+	FRAME_s_wtab04,
+	FRAME_s_wtab05,
+	FRAME_s_wtab06,
+	FRAME_s_wtab07,
+	FRAME_s_wtab08,
+	FRAME_s_wtab09,
+	FRAME_s_wtab10,
+	FRAME_s_wtab11,
+	FRAME_s_wtab12,
+	FRAME_s_wtab13,
+	FRAME_s_wtab14,
+	FRAME_s_wtac01,
+	FRAME_s_wtac02,
+	FRAME_s_wtac03,
+	FRAME_s_wtac04,
+	FRAME_s_wtac05,
+	FRAME_s_wtac06,
+	FRAME_s_wtac07,
+	FRAME_s_wtac08,
+	FRAME_s_wtac09,
+	FRAME_s_wtac10,
+	FRAME_s_wtac11,
+	FRAME_s_wtac12,
+	FRAME_s_wtac13,
+	FRAME_s_wtac14,
+	FRAME_s_wtba01,
+	FRAME_s_wtba02,
+	FRAME_s_wtba03,
+	FRAME_s_wtba04,
+	FRAME_s_wtba05,
+	FRAME_s_wtba06,
+	FRAME_s_wtba07,
+	FRAME_s_wtba08,
+	FRAME_s_wtba09,
+	FRAME_s_wtba10,
+	FRAME_s_wtba11,
+	FRAME_s_wtba12,
+	FRAME_s_wtpa01,
+	FRAME_s_wtpa02,
+	FRAME_s_wtpa03,
+	FRAME_s_wtpa04,
+	FRAME_s_wtpa05,
+	FRAME_s_wtpa06,
+	FRAME_s_wtpa07,
+	FRAME_s_wtpa08,
+	FRAME_s_wtpa09,
+	FRAME_s_wtpa10,
+	FRAME_s_wtpa11,
+	FRAME_s_wtpa12,
+	FRAME_s_wtpa13,
+	FRAME_s_wtpa14,
+	FRAME_s_wtpb01,
+	FRAME_s_wtpb02,
+	FRAME_s_wtpb03,
+	FRAME_s_wtpb04,
+	FRAME_s_wtpb05,
+	FRAME_s_wtpb06,
+	FRAME_s_wtpb07,
+	FRAME_s_wtpb08,
+	FRAME_s_wtpb09,
+	FRAME_s_wtpb10,
+	FRAME_s_wtpb11,
+	FRAME_s_wtdt01,
+	FRAME_s_wtdt02,
+	FRAME_s_wtdt03,
+	FRAME_s_wtdt04,
+	FRAME_s_wtdt05,
+	FRAME_s_wtdt06,
+	FRAME_s_wtdt07,
+	FRAME_s_wtdt08,
+	FRAME_s_wtdt09,
+	FRAME_s_wtdt10,
+	FRAME_s_wtdt11,
+	FRAME_s_wtdt12,
+	FRAME_s_wtdt13,
+	FRAME_s_wtdt14,
+	FRAME_s_wtdt15,
+	FRAME_s_wtdt16,
+	FRAME_s_wtdt17
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_rotfish.cpp	2025-09-04 19:53:48
@@ -0,0 +1,308 @@
+/*
+==============================================================================
+
+QUAKE ROTFISH
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_rotfish.h"
+
+static cached_soundindex	sound_chomp;
+static cached_soundindex	sound_death;
+static cached_soundindex	sound_idle;
+
+void rotfish_stand(edict_t* self);
+
+void rotfish_idle (edict_t *self)
+{
+	if (frandom() < 0.5)
+		gi.sound (self, CHAN_AUTO, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+
+mframe_t rotfish_frames_stand [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};	
+MMOVE_T(rotfish_move_stand) = {FRAME_swim1, FRAME_swim18, rotfish_frames_stand, nullptr };
+
+MONSTERINFO_STAND(rotfish_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &rotfish_move_stand);
+}
+
+mframe_t rotfish_frrun_loop [] =
+{
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12}
+};	
+MMOVE_T(rotfish_move_run_loop) = {FRAME_swim1, FRAME_swim18, rotfish_frrun_loop, nullptr };
+
+MONSTERINFO_RUN(rotfish_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &rotfish_move_run_loop);
+}
+
+/* Standard Swimming */ 
+mframe_t rotfish_walk_loop [] =
+{
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8},
+	{ai_walk, 8}
+};	
+MMOVE_T(rotfish_move_walk_loop) = {FRAME_swim1, FRAME_swim18, rotfish_walk_loop, nullptr };
+
+MONSTERINFO_WALK(rotfish_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &rotfish_move_walk_loop);
+}
+
+mframe_t rotfish_frames_pain1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(rotfish_move_pain1) = {FRAME_pain1, FRAME_pain9, rotfish_frames_pain1, rotfish_run};
+
+void rotfish_bite (edict_t *self)
+{
+	vec3_t aim = { MELEE_DISTANCE, 0, 0 };
+	fire_hit(self, aim, 5, 0);
+}
+
+mframe_t rotfish_frames_attack [] =
+{
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 0,	rotfish_bite},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 0,	rotfish_bite},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 0,	rotfish_bite},
+	{ai_charge, 10},
+	{ai_charge, 10},
+	{ai_charge, 10},
+};
+MMOVE_T(rotfish_move_attack) = {FRAME_attack1, FRAME_attack18, rotfish_frames_attack, rotfish_run};
+
+MONSTERINFO_MELEE(rotfish_melee) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &rotfish_move_attack);
+}
+
+PAIN(rotfish_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 1_sec;
+		
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+	
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	M_SetAnimation(self, &rotfish_move_pain1);
+}
+
+MONSTERINFO_SETSKIN(rotfish_setskin) (edict_t* self) -> void
+{
+	/* KONIG - allow multiple skins */
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+void rotfish_dead(edict_t* self)
+{
+	self->mins = { -16, -16, -8 };
+	self->maxs = { 16, 16, 8 };
+	monster_dead(self);
+}
+
+mframe_t rotfish_frames_death [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(rotfish_move_death) = {FRAME_death1, FRAME_death21, rotfish_frames_death, rotfish_dead};
+
+MONSTERINFO_SIGHT(rotfish_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_NORM, 0);
+}
+
+DIE(rotfish_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	// check for gib
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ "models/objects/gibs/sm_meat/tris.md2" },
+			{ "models/objects/gibs/sm_meat/tris.md2", GIB_HEAD }
+			});
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	// regular death
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+	self->svflags |= SVF_DEADMONSTER;
+	M_SetAnimation(self, &rotfish_move_death);
+}
+
+static void rotfish_set_fly_parameters(edict_t* self)
+{
+	self->monsterinfo.fly_thrusters = false;
+	self->monsterinfo.fly_acceleration = 30.f;
+	self->monsterinfo.fly_speed = 110.f;
+	// only melee, so get in close
+	self->monsterinfo.fly_min_distance = 10.f;
+	self->monsterinfo.fly_max_distance = 10.f;
+}
+
+
+//
+// SPAWN
+//
+
+/*QUAKED monster_rotfish (1 .5 0) (-16 -16 -24) (16 16 24) Ambush Trigger_Spawn Sight
+model="models/monsters/fish/tris.md2"
+*/
+void SP_monster_rotfish (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_death.assign("fish/death.wav");	
+	sound_chomp.assign("fish/bite.wav");
+	sound_idle.assign("fish/idle.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex ("models/monsters/fish/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 24 };
+
+	self->health = 40 * st.health_multiplier;
+	self->gib_health = -20;
+	self->mass = 100;
+
+	self->pain = rotfish_pain;
+	self->die = rotfish_die;
+
+
+
+	self->monsterinfo.stand = rotfish_stand;
+	self->monsterinfo.walk = rotfish_walk;
+	self->monsterinfo.run = rotfish_run;
+	self->monsterinfo.melee = rotfish_melee;
+	self->monsterinfo.sight = rotfish_sight;
+	self->monsterinfo.setskin = rotfish_setskin;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &rotfish_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+	rotfish_set_fly_parameters(self);
+
+	swimmonster_start (self);
+}
--- /dev/null
+++ b/quake1/m_rotfish.h	2025-09-04 19:53:48
@@ -0,0 +1,73 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_attack1,
+	FRAME_attack2,
+	FRAME_attack3,
+	FRAME_attack4,
+	FRAME_attack5,
+	FRAME_attack6,
+	FRAME_attack7,
+	FRAME_attack8,
+	FRAME_attack9,
+	FRAME_attack10,
+	FRAME_attack11,
+	FRAME_attack12,
+	FRAME_attack13,
+	FRAME_attack14,
+	FRAME_attack15,
+	FRAME_attack16,
+	FRAME_attack17,
+	FRAME_attack18,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_death8,
+	FRAME_death9,
+	FRAME_death10,
+	FRAME_death11,
+	FRAME_death12,
+	FRAME_death13,
+	FRAME_death14,
+	FRAME_death15,
+	FRAME_death16,
+	FRAME_death17,
+	FRAME_death18,
+	FRAME_death19,
+	FRAME_death20,
+	FRAME_death21,
+	FRAME_swim1,
+	FRAME_swim2,
+	FRAME_swim3,
+	FRAME_swim4,
+	FRAME_swim5,
+	FRAME_swim6,
+	FRAME_swim7,
+	FRAME_swim8,
+	FRAME_swim9,
+	FRAME_swim10,
+	FRAME_swim11,
+	FRAME_swim12,
+	FRAME_swim13,
+	FRAME_swim14,
+	FRAME_swim15,
+	FRAME_swim16,
+	FRAME_swim17,
+	FRAME_swim18,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_pain4,
+	FRAME_pain5,
+	FRAME_pain6,
+	FRAME_pain7,
+	FRAME_pain8,
+	FRAME_pain9
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_scrag.cpp	2025-09-04 19:53:48
@@ -0,0 +1,346 @@
+/*
+==============================================================================
+
+QUAKE SCRAG
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_scrag.h"
+
+static cached_soundindex	sound_sight;
+static cached_soundindex	sound_idle1;
+static cached_soundindex	sound_idle2;
+static cached_soundindex	sound_attack;
+static cached_soundindex	sound_die;
+static cached_soundindex	sound_pain;
+static cached_soundindex	sound_hit;
+
+MONSTERINFO_SIGHT(scrag_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+void scrag_attack_sound (edict_t *self)
+{
+	gi.sound (self, CHAN_VOICE, sound_attack, 1, ATTN_NORM, 0); // WAS ATTN_IDLE
+}
+
+MONSTERINFO_SEARCH(scrag_search) (edict_t* self) -> void
+{
+	if (frandom() < 0.5f)
+		gi.sound (self, CHAN_VOICE, sound_idle1, 1, ATTN_IDLE, 0);
+	else
+		gi.sound (self, CHAN_VOICE, sound_idle2, 1, ATTN_IDLE, 0);
+}
+
+mframe_t scrag_frames_stand [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(scrag_move_stand) = { FRAME_hover1, FRAME_hover15, scrag_frames_stand, nullptr };
+
+MONSTERINFO_STAND(scrag_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &scrag_move_stand);
+}
+
+mframe_t scrag_frames_walk [] =
+{
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6}
+};
+MMOVE_T(scrag_move_walk) = { FRAME_hover1, FRAME_hover15, scrag_frames_walk, nullptr };
+
+MONSTERINFO_WALK(scrag_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &scrag_move_walk);
+}
+
+mframe_t scrag_frames_run [] =
+{
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12},
+	{ai_run, 12}
+};
+MMOVE_T(scrag_move_run) = { FRAME_fly1, FRAME_fly14, scrag_frames_run, nullptr };
+
+MONSTERINFO_RUN(scrag_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &scrag_move_run);
+}
+
+void ScragTeleport(edict_t* self)
+{
+	if (skill->integer <= 3 && frandom() >= 0.5f)
+		return;
+
+	if (!TryRandomTeleportPosition(self, 128.0f)) {
+		return;
+	}
+}
+
+MONSTERINFO_DODGE(scrag_dodge) (edict_t* self, edict_t* attacker, gtime_t eta, trace_t* tr, bool gravity) -> void
+{
+	if (self->health <= 0)
+		return;
+
+	if (!self->enemy)
+	{
+		self->enemy = attacker;
+		FoundTarget(self);
+		return;
+	}
+
+	if ((eta < FRAME_TIME_MS) || (eta > 5_sec))
+		return;
+
+	if (self->timestamp > level.time)
+		return;
+
+	self->timestamp = level.time + random_time(1_sec, 5_sec);
+
+	ScragTeleport(self);
+}
+
+mframe_t scrag_frames_pain [] =
+{	
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move}
+};
+MMOVE_T(scrag_move_pain) = { FRAME_pain1, FRAME_pain4, scrag_frames_pain, scrag_run };
+
+PAIN(scrag_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 2_sec;
+	
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+	
+	gi.sound (self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	M_SetAnimation(self, &scrag_move_pain);
+}
+
+void scrag_dead (edict_t * self)
+{
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, -8 };
+	monster_dead(self);
+}
+
+static void scrag_shrink(edict_t* self)
+{
+	self->maxs[2] = -4;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t scrag_frames_die [] =
+{	
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0, scrag_shrink},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(scrag_move_die) = { FRAME_death1, FRAME_death8, scrag_frames_die, scrag_dead };
+
+DIE(scrag_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 4, "models/objects/gibs/sm_meat/tris.md2" },
+			//{ "models/monsters/scrag/gibs/tail.md2", GIB_SKINNED },
+			//{ "models/monsters/scrag/gibs/chest.md2", GIB_SKINNED },
+			{ "models/objects/gibs/chest/tris.md2" },
+			{ "models/monsters/scrag/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	M_SetAnimation(self, &scrag_move_die);
+}
+
+MONSTERINFO_SETSKIN(scrag_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+void scrag_fire (edict_t *self)
+{
+	vec3_t		start;
+	vec3_t		forward, right;
+	vec3_t		end;
+	vec3_t		dir;
+	vec3_t		o = { 0, 0, 30 };
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, o, forward, right);
+
+	end = self->enemy->s.origin;
+	end[2] += self->enemy->viewheight;
+	dir = end - start;
+	dir.normalize();
+
+	fire_acid(self,start, dir, 10, 500);
+}
+
+mframe_t scrag_frames_attack [] = {
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, scrag_attack_sound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, -1,scrag_fire},
+	{ai_charge, -2},
+	{ai_charge, -3},
+	{ai_charge, -2}, // scrag_fire
+	{ai_charge, -1},
+	{ai_charge, 0, scrag_fire},
+	{ai_charge},
+	{ai_charge}
+};
+MMOVE_T(scrag_move_attack) = { FRAME_magatt1, FRAME_magatt13, scrag_frames_attack, scrag_run };
+
+MONSTERINFO_ATTACK(scrag_attack) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &scrag_move_attack);
+}
+
+static void scrag_set_fly_parameters(edict_t* self)
+{
+	self->monsterinfo.fly_thrusters = false;
+	self->monsterinfo.fly_acceleration = 20.f;
+	self->monsterinfo.fly_speed = 120.f;
+	self->monsterinfo.fly_min_distance = 200.f;
+	self->monsterinfo.fly_max_distance = 400.f;
+}
+
+/*QUAKED monster_scrag (1 .5 0) (-16 -16 -24) (16 16 40) Ambush Trigger_Spawn Sight
+model="models/monsters/scrag/tris.md2"
+*/
+void SP_monster_scrag (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_sight.assign("scrag/wsight.wav");
+	sound_idle1.assign("scrag/widle1.wav");
+	sound_idle2.assign("scrag/widle2.wav");
+	sound_attack.assign("scrag/wattack.wav");
+	sound_die.assign("scrag/wdeath.wav");
+	sound_pain.assign("scrag/wpain.wav");
+	sound_hit.assign("scrag/hit.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex ("models/monsters/scrag/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 40 };
+
+	self->health = 80 * st.health_multiplier;
+	self->gib_health = -40;
+	self->mass = 50;
+
+	self->pain = scrag_pain;
+	self->die = scrag_die;
+
+	self->monsterinfo.stand = scrag_stand;
+	self->monsterinfo.walk = scrag_walk;
+	self->monsterinfo.run = scrag_run;
+	self->monsterinfo.attack = scrag_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.dodge = scrag_dodge;
+	self->monsterinfo.sight = scrag_sight;
+	self->monsterinfo.search = scrag_search;
+	self->monsterinfo.setskin = scrag_setskin;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &scrag_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+	
+	self->flags |= FL_FLY;
+	if (!self->yaw_speed)
+		self->yaw_speed = 10;
+	self->viewheight = 10;
+
+	flymonster_start (self);
+
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+	scrag_set_fly_parameters(self);
+}
--- /dev/null
+++ b/quake1/m_scrag.h	2025-09-04 19:53:48
@@ -0,0 +1,61 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_hover1,
+	FRAME_hover2,
+	FRAME_hover3,
+	FRAME_hover4,
+	FRAME_hover5,
+	FRAME_hover6,
+	FRAME_hover7,
+	FRAME_hover8,
+	FRAME_hover9,
+	FRAME_hover10,
+	FRAME_hover11,
+	FRAME_hover12,
+	FRAME_hover13,
+	FRAME_hover14,
+	FRAME_hover15,
+	FRAME_fly1,
+	FRAME_fly2,
+	FRAME_fly3,
+	FRAME_fly4,
+	FRAME_fly5,
+	FRAME_fly6,
+	FRAME_fly7,
+	FRAME_fly8,
+	FRAME_fly9,
+	FRAME_fly10,
+	FRAME_fly11,
+	FRAME_fly12,
+	FRAME_fly13,
+	FRAME_fly14,
+	FRAME_magatt1,
+	FRAME_magatt2,
+	FRAME_magatt3,
+	FRAME_magatt4,
+	FRAME_magatt5,
+	FRAME_magatt6,
+	FRAME_magatt7,
+	FRAME_magatt8,
+	FRAME_magatt9,
+	FRAME_magatt10,
+	FRAME_magatt11,
+	FRAME_magatt12,
+	FRAME_magatt13,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_pain4,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_death8
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_shalrath.cpp	2025-09-04 19:53:48
@@ -0,0 +1,445 @@
+/*
+==============================================================================
+
+QUAKE SHALRATH
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_shalrath.h"
+
+static cached_soundindex sound_death;
+static cached_soundindex sound_gib;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_pain1;
+static cached_soundindex sound_attack;
+static cached_soundindex sound_attack2;
+static cached_soundindex sound_idle;
+
+void shalrath_stand(edict_t* self);
+
+// STAND
+MONSTERINFO_SEARCH(shalrath_search) (edict_t* self) -> void
+{
+	if (frandom() < 0.2)
+		gi.sound (self, CHAN_BODY, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+
+mframe_t shalrath_frames_stand [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(shalrath_move_stand) = {FRAME_stand1, FRAME_stand7, shalrath_frames_stand, shalrath_stand};
+
+MONSTERINFO_STAND(shalrath_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &shalrath_move_stand);
+}
+
+//
+// WALK
+//
+
+mframe_t shalrath_frames_walk [] =
+{
+	{ai_walk, 6},
+	{ai_walk, 4},
+	{ai_walk},
+	{ai_walk, 6},
+	{ai_walk, 5},
+
+	{ai_walk, 4},
+	{ai_walk, 5}
+};
+MMOVE_T(shalrath_move_walk) = {FRAME_walk1, FRAME_walk7, shalrath_frames_walk, NULL};
+
+MONSTERINFO_WALK(shalrath_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &shalrath_move_walk);
+}
+
+//
+// RUN
+//
+
+void shalrath_run (edict_t *self);
+
+mframe_t shalrath_frames_run [] =
+{
+	{ai_run, 6},
+	{ai_run, 4},
+	{ai_run},
+	{ai_run, 6},
+	{ai_run, 5},
+
+	{ai_run, 4},
+	{ai_run, 5}
+};
+MMOVE_T(shalrath_move_run) = {FRAME_walk1, FRAME_walk7, shalrath_frames_run, shalrath_run};
+
+MONSTERINFO_RUN(shalrath_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+	{
+		M_SetAnimation(self, &shalrath_move_stand);
+		return;
+	}
+	else
+		M_SetAnimation(self, &shalrath_move_run);
+}
+
+//
+// PAIN
+//
+
+mframe_t shalrath_frames_pain1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(shalrath_move_pain1) = {FRAME_pain1, FRAME_pain6, shalrath_frames_pain1, shalrath_run};
+
+mframe_t shalrath_frames_pain2[] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(shalrath_move_pain2) = { FRAME_paina1, FRAME_paina6, shalrath_frames_pain2, shalrath_run };
+
+PAIN(shalrath_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+	
+	self->pain_debounce_time = level.time + 3_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+
+	if (frandom() > 0.5f)
+		M_SetAnimation(self, &shalrath_move_pain1);
+	else
+		M_SetAnimation(self, &shalrath_move_pain2);
+}
+
+MONSTERINFO_SETSKIN(shalrath_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// ATTACK
+//
+
+void shalrath_fire (edict_t *self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	vec;
+	trace_t trace; // PMM - check target
+	int		rocketSpeed;
+	vec3_t target;
+	bool   blindfire = false;
+	vec3_t offset = { 0, 0, 10 };
+	int damage = 50;
+
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+	else
+		blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse)
+		return;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+
+	rocketSpeed = 600;
+
+	if (blindfire)
+		target = self->monsterinfo.blind_fire_target;
+	else
+		target = self->enemy->s.origin;
+
+
+	if (blindfire)
+	{
+		vec = target;
+		dir = vec - start;
+	}
+
+	else if (frandom() < 0.33f || (start[2] < self->enemy->absmin[2]))
+	{
+		vec = target;
+		vec[2] += self->enemy->viewheight;
+		dir = vec - start;
+	}
+	else
+	{
+		vec = target;
+		vec[2] = self->enemy->absmin[2] + 1;
+		dir = vec - start;
+	}
+
+	if ((!blindfire) && (frandom() < 0.35f))
+		PredictAim(self, self->enemy, start, rocketSpeed, false, 0.f, &dir, &vec);
+
+	dir.normalize();
+
+	trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+	if (blindfire)
+	{
+		if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+			fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 0);
+		else
+		{
+			vec = target;
+			vec += (right * -10);
+			dir = vec - start;
+			dir.normalize();
+			trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+			if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+				fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 0);
+			else
+			{
+				vec = target;
+				vec += (right * 10);
+				dir = vec - start;
+				dir.normalize();
+				trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+				if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+					fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 0);
+			}
+		}
+	}
+	else
+	{
+		if (trace.fraction > 0.5f || trace.ent->solid != SOLID_BSP)
+			fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.15f, 0);
+	}
+	
+	gi.sound(self, CHAN_WEAPON|CHAN_RELIABLE, sound_attack2, 1, ATTN_NORM, 0);
+}
+
+void shalrath_attack_snd (edict_t *self)
+{
+	gi.sound (self, CHAN_AUTO, sound_attack, 1, ATTN_NORM, 0);
+}
+
+mframe_t shalrath_frames_attack [] =
+{
+	{ai_charge, 0, shalrath_attack_snd},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+
+	{ai_charge},
+	{ai_charge, 0, shalrath_fire},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	
+	{ai_charge}
+};
+MMOVE_T(shalrath_move_attack) = {FRAME_throw1, FRAME_throw16, shalrath_frames_attack, shalrath_run};
+
+MONSTERINFO_ATTACK(shalrath_attack) (edict_t* self) -> void
+{
+	vec3_t offset = { 0, 0, 10 };
+
+	if (!M_CheckClearShot(self, offset))
+		return;
+
+	float r, chance;
+
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		// setup shot probabilities
+		if (self->monsterinfo.blind_fire_delay < 1.0_sec)
+			chance = 1.0;
+		else if (self->monsterinfo.blind_fire_delay < 7.5_sec)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		r = frandom();
+
+		// minimum of 5.5 seconds, plus 0-1, after the shots are done
+		self->monsterinfo.blind_fire_delay += random_time(5.5_sec, 6.5_sec);
+
+		// don't shoot at the origin
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		// don't shoot if the dice say not to
+		if (r > chance)
+			return;
+
+		// turn on manual steering to signal both manual steering and blindfire
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+		M_SetAnimation(self, &shalrath_move_attack);
+		self->monsterinfo.attack_finished = level.time + random_time(2_sec);
+		return;
+	}
+
+	M_SetAnimation(self, &shalrath_move_attack);
+}
+
+//
+// SIGHT
+//
+
+MONSTERINFO_SIGHT(shalrath_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+//
+// DEATH
+//
+
+void shalrath_dead (edict_t *self)
+{
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, -8 };
+	monster_dead(self);
+}
+
+mframe_t shalrath_frames_death1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(shalrath_move_death) = {FRAME_die1, FRAME_die17, shalrath_frames_death1, shalrath_dead};
+
+DIE(shalrath_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+			//{ "models/monsters/shalrath/gibs/chest.md2", },
+			//{ "models/monsters/shalrath/gibs/claw.md2", GIB_UPRIGHT },
+			{ "models/monsters/shalrath/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	// regular death
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	M_SetAnimation(self, &shalrath_move_death);
+}
+
+
+/*QUAKED monster_shalrath (1 .5 0) (-16 -16 -24) (16 16 40) Ambush Trigger_Spawn Sight
+model="models/monsters/shalrath/tris.md2"
+*/
+void SP_monster_shalrath (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+	
+	sound_sight.assign("vore/sight.wav");
+	sound_pain1.assign("vore/pain.wav");
+	sound_death.assign("vore/death.wav");
+	sound_attack.assign("vore/attack.wav");
+	sound_attack2.assign("vore/attack2.wav");
+	sound_idle.assign("vore/idle.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex ("models/monsters/shalrath/tris.md2");
+	self->mins = { -32, -32, -24 };
+	self->maxs = { 32, 32, 48 };
+
+	self->health = 400 * st.health_multiplier;
+	self->gib_health = -80;
+	self->mass = 125;
+
+	self->pain = shalrath_pain;
+	self->die = shalrath_die;
+
+
+
+	self->monsterinfo.stand = shalrath_stand;
+	self->monsterinfo.walk = shalrath_walk;
+	self->monsterinfo.run = shalrath_run;
+	self->monsterinfo.attack = shalrath_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = shalrath_sight;
+	self->monsterinfo.search = shalrath_search;
+	self->monsterinfo.setskin = shalrath_setskin;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &shalrath_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	walkmonster_start (self);
+}
--- /dev/null
+++ b/quake1/m_shalrath.h	2025-09-04 19:53:48
@@ -0,0 +1,67 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_stand1,
+	FRAME_stand2,
+	FRAME_stand3,
+	FRAME_stand4,
+	FRAME_stand5,
+	FRAME_stand6,
+	FRAME_stand7,
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_walk7,
+	FRAME_throw1,
+	FRAME_throw2,
+	FRAME_throw3,
+	FRAME_throw4,
+	FRAME_throw5,
+	FRAME_throw6,
+	FRAME_throw7,
+	FRAME_throw8,
+	FRAME_throw9,
+	FRAME_throw10,
+	FRAME_throw11,
+	FRAME_throw12,
+	FRAME_throw13,
+	FRAME_throw14,
+	FRAME_throw15,
+	FRAME_throw16,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_pain4,
+	FRAME_pain5,
+	FRAME_pain6,
+	FRAME_paina1,
+	FRAME_paina2,
+	FRAME_paina3,
+	FRAME_paina4,
+	FRAME_paina5,
+	FRAME_paina6,
+	FRAME_die1,
+	FRAME_die2,
+	FRAME_die3,
+	FRAME_die4,
+	FRAME_die5,
+	FRAME_die6,
+	FRAME_die7,
+	FRAME_die8,
+	FRAME_die9,
+	FRAME_die10,
+	FRAME_die11,
+	FRAME_die12,
+	FRAME_die13,
+	FRAME_die14,
+	FRAME_die15,
+	FRAME_die16,
+	FRAME_die17,
+	FRAME_base1
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_spike.cpp	2025-09-04 19:53:48
@@ -0,0 +1,330 @@
+/*
+==============================================================================
+
+QUAKE SPIKE MINE
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_spike.h"
+
+static cached_soundindex	sound_sight;
+static cached_soundindex	sound_idle;
+static cached_soundindex	sound_search;
+static cached_soundindex	sound_death;
+static cached_soundindex	sound_pain;
+
+//
+// SOUNDS
+//
+
+MONSTERINFO_SIGHT(spike_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_IDLE(spike_idle) (edict_t* self) -> void
+{
+	if (frandom() < 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+MONSTERINFO_SEARCH(spike_search) (edict_t* self) -> void
+{
+	if (frandom() < 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
+}
+
+//
+// STAND
+//
+
+mframe_t spike_frames_stand[] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(spike_move_stand) = { FRAME_spike1, FRAME_spike9, spike_frames_stand, nullptr };
+
+MONSTERINFO_STAND(spike_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &spike_move_stand);
+}
+
+//
+// WALK
+//
+
+
+mframe_t spike_frames_walk[] =
+{
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6},
+	{ai_walk, 6}
+};
+MMOVE_T(spike_move_walk) = { FRAME_spike1, FRAME_spike9, spike_frames_walk, nullptr };
+
+MONSTERINFO_WALK(spike_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &spike_move_walk);
+}
+
+//
+// RUN
+//
+
+void spike_explode(edict_t* self);
+
+void spike_check(edict_t* self)
+{
+	float dist;
+
+	// PMM - this needed because we could have gone away before we get here (blocked code)
+	if (!self->inuse)
+		return;
+
+	if ((!self->enemy) || (!self->enemy->inuse))
+	{
+		spike_explode(self);
+		return;
+	}
+
+	self->s.angles[0] = vectoangles(self->enemy->s.origin - self->s.origin).x;
+
+	self->goalentity = self->enemy;
+
+	dist = realrange(self, self->enemy);
+
+	if (dist < 90)
+		spike_explode(self);
+}
+
+mframe_t spike_frames_run[] =
+{
+	{ai_run, 12, spike_check},
+	{ai_run, 12, spike_check},
+	{ai_run, 12, spike_check},
+	{ai_run, 12, spike_check},
+	{ai_run, 12, spike_check},
+
+	{ai_run, 12, spike_check},
+	{ai_run, 12, spike_check},
+	{ai_run, 12, spike_check},
+	{ai_run, 12, spike_check}
+};
+MMOVE_T(spike_move_run) = { FRAME_spike1, FRAME_spike9, spike_frames_run, nullptr };
+
+MONSTERINFO_RUN(spike_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &spike_move_run);
+}
+
+//
+// ATTACK
+//
+
+MONSTERINFO_MELEE(spike_melee) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &spike_move_run);
+}
+
+//
+// PAIN
+//
+
+mframe_t spike_frames_pain[] =
+{
+		{ai_move, -1},
+		{ai_move, -1},
+		{ai_move, -1},
+		{ai_move, -1},
+		{ai_move, -1},
+
+		{ai_move, -1},
+		{ai_move, -1},
+		{ai_move, -1},
+		{ai_move, -1}
+};
+MMOVE_T(spike_move_pain) = { FRAME_spike1, FRAME_spike9, spike_frames_pain, spike_run };
+
+bool IsNailgun(const mod_t& mod)
+{
+	switch (mod.id)
+	{
+	case MOD_ETF_RIFLE:
+		return true;
+	default:
+		return false;
+	}
+}
+
+PAIN(spike_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (IsNailgun(mod))
+	{
+		T_Damage(self, self, self, vec3_origin, other->s.origin, vec3_origin, self->health + 10, 0, DAMAGE_NONE, MOD_EXPLOSIVE);
+	}
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	M_SetAnimation(self, &spike_move_pain);
+}
+
+//
+// DEATH
+//
+
+void spike_dead(edict_t* self)
+{
+	T_RadiusDamage(self, self, 120, nullptr, 150, DAMAGE_NONE, MOD_EXPLOSIVE);
+
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_EXPLOSION1);
+	gi.WritePosition(self->s.origin);
+	gi.multicast(self->s.origin, MULTICAST_PHS, false);
+
+	self->touch = nullptr;
+
+	ThrowGibs(self, 500, {
+		{ "models/objects/gibs/sm_meat/tris.md2", GIB_HEAD }
+		});
+}
+
+mframe_t spike_frames_explode[] =
+{
+	{ai_move}
+};
+MMOVE_T(spike_move_explode) = { FRAME_spike1, FRAME_spike1, spike_frames_explode, spike_dead };
+
+void spike_explode(edict_t* self)
+{
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	spike_dead(self);
+}
+
+DIE(spike_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	M_SetAnimation(self, &spike_move_explode);
+}
+
+//
+// SIDESTEP
+//
+
+MONSTERINFO_SIDESTEP(spike_sidestep) (edict_t* self) -> bool
+{
+	if (skill->integer <= 2)
+		return false; //don't sidestep if not nightmare
+
+	if (self->monsterinfo.active_move != &spike_move_run)
+		M_SetAnimation(self, &spike_move_run);
+
+	return true;
+}
+
+static void spike_set_fly_parameters(edict_t* self)
+{
+self->monsterinfo.fly_pinned = false;
+self->monsterinfo.fly_thrusters = true;
+self->monsterinfo.fly_position_time = 0_sec;
+self->monsterinfo.fly_acceleration = 20.f;
+self->monsterinfo.fly_speed = 210.f;
+self->monsterinfo.fly_min_distance = 0.f;
+self->monsterinfo.fly_max_distance = 10.f;
+}
+
+/*QUAKED monster_spike (1 .5 0) (-16 -16 -24) (16 16 40) Ambush Trigger_Spawn Sight NoJumping Kneeling
+model="models/monsters/spike/tris.md2"
+*/
+void SP_monster_spike(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_search.assign("spike/search.wav");
+	sound_death.assign("spike/death.wav");
+	sound_pain.assign("spike/pain.wav");
+	sound_idle.assign("spike/idle.wav");
+	sound_sight.assign("spike/sight.wav");
+
+	gi.modelindex("models/monsters/spike/head/tris.md2");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex("models/monsters/spikeball/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 40 };
+
+	self->health = 200 * st.health_multiplier;
+	self->gib_health = -80;
+	self->mass = 120;
+
+	self->pain = spike_pain;
+	self->die = spike_die;
+
+	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
+
+	self->monsterinfo.stand = spike_stand;
+	self->monsterinfo.walk = spike_walk;
+	self->monsterinfo.run = spike_run;
+	self->monsterinfo.sidestep = spike_sidestep;
+	self->monsterinfo.attack = nullptr;
+	self->monsterinfo.melee = spike_melee;
+	self->monsterinfo.sight = spike_sight;
+	self->monsterinfo.search = spike_search;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &spike_move_stand);
+
+	self->monsterinfo.combat_style = COMBAT_MELEE;
+
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	flymonster_start(self);
+
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+	spike_set_fly_parameters(self);
+}
--- /dev/null
+++ b/quake1/m_spike.h	2025-09-04 19:53:48
@@ -0,0 +1,16 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_spike1,
+	FRAME_spike2,
+	FRAME_spike3,
+	FRAME_spike4,
+	FRAME_spike5,
+	FRAME_spike6,
+	FRAME_spike7,
+	FRAME_spike8,
+	FRAME_spike9
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_sword.cpp	2025-09-04 19:53:48
@@ -0,0 +1,328 @@
+/*
+==============================================================================
+
+QUAKE FLOATING SWORD
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_sword.h"
+
+static cached_soundindex	sound_sword1;
+static cached_soundindex	sound_sword2;
+static cached_soundindex	sound_death;
+static cached_soundindex	sound_gib;
+static cached_soundindex	sound_pain;
+static cached_soundindex	sound_idle;
+static cached_soundindex	sound_sight;
+
+void sword_stand (edict_t *self);
+void sword_walk (edict_t *self);
+void sword_check_dist (edict_t *self);
+void sword_hit_left(edict_t* self);
+
+//
+// SOUNDS
+//
+
+MONSTERINFO_SIGHT(sword_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SEARCH(sword_search) (edict_t* self) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+void sword_sword_sound (edict_t *self)
+{
+	if (frandom() <= 0.5f)
+		gi.sound (self, CHAN_VOICE, sound_sword1, 1, ATTN_NORM, 0);
+	else
+		gi.sound (self, CHAN_VOICE, sound_sword2, 1, ATTN_NORM, 0);
+}
+
+//
+// STAND
+//
+
+mframe_t sword_frames_stand [] =
+{
+	{ai_stand},
+};
+MMOVE_T(sword_move_stand) = {FRAME_stand1, FRAME_stand1, sword_frames_stand, sword_stand};
+
+MONSTERINFO_STAND(sword_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &sword_move_stand);
+}
+
+//
+// WALK
+//
+
+mframe_t sword_frames_walk [] =
+{
+	{ai_walk,	0}
+};
+MMOVE_T(sword_move_walk) = { FRAME_stand1, FRAME_stand1, sword_frames_walk, sword_walk};
+
+MONSTERINFO_WALK(sword_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &sword_move_walk);
+}
+
+//
+// RUN
+//
+
+mframe_t sword_frames_run[] =
+{
+	{ai_run,	16},
+	{ai_run,	20},
+	{ai_run,	13},
+	{ai_run,	7},
+	{ai_run,	16},
+	{ai_run,	20},
+	{ai_run,	14},
+	{ai_run,	6,		sword_check_dist}
+};
+MMOVE_T(sword_move_run) = {FRAME_runb1, FRAME_runb8, sword_frames_run, nullptr };
+
+MONSTERINFO_RUN(sword_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		M_SetAnimation(self, &sword_move_stand);
+	else
+		M_SetAnimation(self, &sword_move_run);
+}
+
+//
+// ATTACK
+//
+
+mframe_t sword_frames_attack[] =
+{
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge,	0,	sword_hit_left},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge,	0,	sword_check_dist}
+};
+MMOVE_T(sword_move_attack) = { FRAME_attackb1, FRAME_attackb10, sword_frames_attack, sword_run };
+
+MONSTERINFO_MELEE(sword_melee) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &sword_move_attack);
+}
+
+void sword_check_dist(edict_t* self)
+{
+	if (!self->enemy || !self->enemy->inuse || self->enemy->health <= 0)
+		return;
+
+	if (range_to(self, self->enemy) <= RANGE_MELEE)
+	{
+		M_SetAnimation(self, &sword_move_attack);
+	}
+	else
+	{
+		M_SetAnimation(self, &sword_move_run);
+	}
+}
+
+void sword_hit_left(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->mins[0], 4 };
+	if (fire_hit(self, aim, irandom(1, 9), 100))
+		gi.sound(self, CHAN_WEAPON, sound_sword1, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_sword1, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+//
+// PAIN
+//
+
+mframe_t sword_frames_pain1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(sword_move_pain1) = { FRAME_runb1, FRAME_runb8, sword_frames_pain1, sword_run};
+
+PAIN(sword_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	if (frandom() < 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &sword_move_pain1);
+}
+
+//
+// DEATH
+//
+void sword_shrink(edict_t* self)
+{
+	self->maxs[2] = 0;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t sword_frames_death1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0,	sword_shrink},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(sword_move_death1) = { FRAME_death1, FRAME_death10, sword_frames_death1, monster_dead };
+
+
+mframe_t sword_frames_death2 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0,	sword_shrink},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(sword_move_death2) = { FRAME_deathb1, FRAME_deathb11, sword_frames_death2, monster_dead };
+
+DIE(sword_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	self->s.effects &= ~EF_HYPERBLASTER;
+
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/sm_metal/tris.md2", GIB_DEBRIS },
+			{ "models/objects/gibs/sm_metal/tris.md2", GIB_DEBRIS | GIB_HEAD }
+			});
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	if (frandom() < 0.5f)
+		M_SetAnimation(self, &sword_move_death1);
+	else
+		M_SetAnimation(self, &sword_move_death2);
+
+}
+
+static void sword_set_fly_parameters(edict_t* self)
+{
+	self->monsterinfo.fly_pinned = false;
+	self->monsterinfo.fly_thrusters = true;
+	self->monsterinfo.fly_position_time = 0_sec;
+	self->monsterinfo.fly_acceleration = 10.f;
+	self->monsterinfo.fly_speed = 180.f;
+	self->monsterinfo.fly_min_distance = 0.f;
+	self->monsterinfo.fly_max_distance = 10.f;
+}
+
+/*QUAKED monster_sword (1 .5 0) (-16 -16 -24) (16 16 40) Ambush Trigger_Spawn Sight NoJumping Kneeling
+model="models/monsters/sword/tris.md2"
+*/
+void SP_monster_sword (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_sword1.assign("sword/sword1.wav");
+	sound_sword2.assign("sword/sword2.wav");
+	sound_death.assign("sword/kdeath.wav");
+	sound_pain.assign("sword/khurt.wav");
+	sound_idle.assign("sword/idle.wav");
+	sound_sight.assign("sword/ksight.wav");
+	
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex("models/monsters/sword/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 40 };
+
+	self->health = 200 * st.health_multiplier;
+	self->gib_health = -80;
+	self->mass = 120;
+
+	self->pain = sword_pain;
+	self->die = sword_die;
+
+	self->s.effects |= EF_HYPERBLASTER;
+
+	self->monsterinfo.stand = sword_stand;
+	self->monsterinfo.walk = sword_walk;
+	self->monsterinfo.run = sword_run;
+	self->monsterinfo.dodge = M_MonsterDodge;
+	self->monsterinfo.attack = nullptr;
+	self->monsterinfo.melee = sword_melee;
+	self->monsterinfo.sight = sword_sight;
+	self->monsterinfo.search = sword_search;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &sword_move_stand);
+
+	self->monsterinfo.combat_style = COMBAT_MELEE;
+
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+	sword_set_fly_parameters(self);
+
+	flymonster_start(self);
+}
--- /dev/null
+++ b/quake1/m_sword.h	2025-09-04 19:53:48
@@ -0,0 +1,47 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_stand1,
+	FRAME_runb1,
+	FRAME_runb2,
+	FRAME_runb3,
+	FRAME_runb4,
+	FRAME_runb5,
+	FRAME_runb6,
+	FRAME_runb7,
+	FRAME_runb8,
+	FRAME_attackb1,
+	FRAME_attackb2,
+	FRAME_attackb3,
+	FRAME_attackb4,
+	FRAME_attackb5,
+	FRAME_attackb6,
+	FRAME_attackb7,
+	FRAME_attackb8,
+	FRAME_attackb9,
+	FRAME_attackb10,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_death8,
+	FRAME_death9,
+	FRAME_death10,
+	FRAME_deathb1,
+	FRAME_deathb2,
+	FRAME_deathb3,
+	FRAME_deathb4,
+	FRAME_deathb5,
+	FRAME_deathb6,
+	FRAME_deathb7,
+	FRAME_deathb8,
+	FRAME_deathb9,
+	FRAME_deathb10,
+	FRAME_deathb11
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_tarbaby.cpp	2025-09-04 19:53:48
@@ -0,0 +1,437 @@
+/*
+==============================================================================
+
+QUAKE TARBABY (BLOB)
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_tarbaby.h"
+
+constexpr spawnflags_t SPAWNFLAG_HELLSPAWN_BABY = 8_spawnflag;
+
+static cached_soundindex	sound_death;
+static cached_soundindex	sound_hit;
+static cached_soundindex	sound_land;
+static cached_soundindex	sound_sight;
+
+void tarbaby_stand (edict_t *self);
+void tarbaby_check_landing (edict_t *self);
+void tarbaby_fly (edict_t *self);
+void tarbaby_takeoff (edict_t *self);
+void tarbaby_die(edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod);
+
+MONSTERINFO_SIGHT(tarbaby_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+mframe_t tarbaby_frames_stand [] =
+{
+	{ai_stand}
+};
+MMOVE_T(tarbaby_move_stand) = {FRAME_walk1, FRAME_walk1, tarbaby_frames_stand, tarbaby_stand};
+
+MONSTERINFO_STAND(tarbaby_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &tarbaby_move_stand);
+}
+
+mframe_t tarbaby_frames_walk [] =
+{
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 2}
+};
+MMOVE_T(tarbaby_move_walk) = {FRAME_walk1, FRAME_walk25, tarbaby_frames_walk, nullptr };
+
+MONSTERINFO_WALK(tarbaby_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &tarbaby_move_walk);
+}
+
+
+mframe_t tarbaby_frames_run [] =
+{
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2},
+	{ai_run, 2}
+};
+MMOVE_T(tarbaby_move_run) = {FRAME_run1, FRAME_run25, tarbaby_frames_run, nullptr };
+
+MONSTERINFO_RUN(tarbaby_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &tarbaby_move_run);
+}
+
+
+mframe_t tarbaby_frames_fly [] =
+{
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	 tarbaby_check_landing}
+};
+MMOVE_T(tarbaby_move_fly) = {FRAME_fly1, FRAME_fly4, tarbaby_frames_fly, tarbaby_fly};
+
+void tarbaby_fly (edict_t *self)
+{
+	M_SetAnimation(self, &tarbaby_move_fly);
+}
+
+mframe_t tarbaby_frames_jump [] =
+{
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	 tarbaby_takeoff},
+	{ai_charge}
+};
+MMOVE_T(tarbaby_move_jump) = {FRAME_jump1, FRAME_jump6, tarbaby_frames_jump, tarbaby_fly};
+
+TOUCH(tarbaby_jump_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (self->health <= 0)
+	{
+		self->touch = nullptr;
+		return;
+	}
+
+	if (self->style == 1 && other->takedamage)
+	{
+		if (self->velocity.length() > 400)
+		{
+			vec3_t point;
+			vec3_t normal;
+			int	   damage;
+
+			normal = self->velocity;
+			normal.normalize();
+			point = self->s.origin + (normal * self->maxs[0]);
+			damage = (int)frandom(10, 20);
+			T_Damage(other, self, self, self->velocity, point, normal, damage, damage, DAMAGE_NONE, MOD_UNKNOWN);
+			gi.sound(self, CHAN_VOICE, sound_hit, 1, ATTN_NORM, 0);
+			self->style = 0;
+		}
+	}
+	else
+		gi.sound(self, CHAN_VOICE, sound_land, 1, ATTN_NORM, 0);
+
+	if (!M_CheckBottom(self))
+	{
+		if (self->groundentity)
+		{
+			M_SetAnimation(self, &tarbaby_move_run);
+			self->touch = nullptr;
+		}
+		return;
+	}
+
+	self->touch = nullptr;
+	M_SetAnimation(self, &tarbaby_move_jump);
+}
+
+void tarbaby_check_landing (edict_t *self)
+{
+	monster_jump_finished(self);
+
+	if (self->groundentity)
+	{
+		gi.sound(self, CHAN_WEAPON, sound_land, 1, ATTN_NORM, 0);
+		self->monsterinfo.attack_finished = 0_sec;
+
+		if (self->monsterinfo.unduck)
+			self->monsterinfo.unduck(self);
+		self->style = 0;
+	}
+
+	self->count++;
+	if ( self->count >= 4 )
+	{
+		M_SetAnimation(self, &tarbaby_move_jump);
+		self->monsterinfo.nextframe = FRAME_jump5;
+		tarbaby_takeoff (self);
+	}
+}
+
+void tarbaby_takeoff (edict_t *self)
+{
+	vec3_t forward;
+
+	self->movetype = MOVETYPE_BOUNCE;
+	self->s.origin[2] += 1;
+	AngleVectors(self->s.angles, forward, nullptr, nullptr);
+	self->velocity = forward * 600;
+	self->velocity[2] = 200;
+	self->groundentity = nullptr;
+	self->monsterinfo.aiflags |= AI_DUCKED;
+	self->monsterinfo.attack_finished = level.time + 3_sec;
+	self->count = 0;
+	self->style = 1;
+	self->touch = tarbaby_jump_touch;
+}
+
+MONSTERINFO_ATTACK(tarbaby_jump) (edict_t* self) -> void
+{
+	if (!self->enemy)
+		return;
+
+	M_SetAnimation(self, &tarbaby_move_jump);
+}
+
+void tarbaby_mitosis(edict_t* self)
+{
+	vec3_t	 f, r, u, offset, startpoint, spawnpoint;
+	edict_t* ent, * designated_enemy;
+	int		 i;
+
+	AngleVectors(self->s.angles, f, r, u);
+
+	for (i = 0; i < 2; i++)
+	{
+		vec3_t hbaby_mins = { -16, -16, -24 };
+		vec3_t hbaby_maxs = { 16, 16, 24 };
+
+
+		offset = { 32, 0, 0};
+
+		startpoint = G_ProjectSource2(self->s.origin, offset, f, r, u);
+
+		if (FindSpawnPoint(startpoint, hbaby_mins, hbaby_maxs, spawnpoint, 64))
+		{
+			ent = CreateGroundMonster(spawnpoint, self->s.angles, hbaby_mins, hbaby_maxs, "monster_tarbaby", 256);
+
+			if (!ent)
+				continue;
+
+			self->monsterinfo.monster_used++;
+			ent->monsterinfo.commander = self;
+			ent->monsterinfo.slots_from_commander = 1;
+
+			ent->nextthink = level.time;
+			ent->think(ent);
+
+			ent->health = 90;
+			ent->s.skinnum = 1;
+			ent->s.scale = 0.7f;
+
+			ent->monsterinfo.aiflags |= AI_SPAWNED_COMMANDER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
+
+			if (!coop->integer)
+			{
+				designated_enemy = self->enemy;
+			}
+			else
+			{
+				designated_enemy = PickCoopTarget(ent);
+				if (designated_enemy)
+				{
+					// try to avoid using my enemy
+					if (designated_enemy == self->enemy)
+					{
+						designated_enemy = PickCoopTarget(ent);
+						if (!designated_enemy)
+							designated_enemy = self->enemy;
+					}
+				}
+				else
+					designated_enemy = self->enemy;
+			}
+
+			if ((designated_enemy->inuse) && (designated_enemy->health > 0))
+			{
+				ent->enemy = designated_enemy;
+				FoundTarget(ent);
+				ent->monsterinfo.attack(ent);
+			}
+		}
+	}
+}
+
+
+PAIN(tarbaby_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	float chance;
+
+	if (!(skill->integer >= 1))
+		return;
+		
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	if (!(strcmp(self->classname, "monster_tarbaby_hell") == 0))
+		return;
+	else
+	{
+		if (self->spawnflags.has(SPAWNFLAG_HELLSPAWN_BABY))
+			return;
+	}
+
+	chance = frandom() * skill->integer;
+
+	if (chance > 0.75f)
+		tarbaby_mitosis(self);
+
+	self->pain_debounce_time = level.time + 3_sec;
+}
+
+void tarbaby_dead (edict_t *self)
+{
+	T_RadiusDamage(self, self, 120, nullptr, 150, DAMAGE_NONE, MOD_UNKNOWN);
+
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_EXPLOSION1);
+	gi.WritePosition(self->s.origin);
+	gi.multicast(self->s.origin, MULTICAST_PHS, false);
+
+	self->touch = nullptr;
+
+	ThrowGibs(self, 500, {
+		{ "models/objects/gibs/sm_meat/tris.md2", GIB_HEAD }
+		});
+}
+
+mframe_t tarbaby_frames_explode [] =
+{
+	{ai_move}
+};
+MMOVE_T(tarbaby_move_explode) = {FRAME_exp, FRAME_exp, tarbaby_frames_explode, tarbaby_dead};
+
+DIE(tarbaby_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	M_SetAnimation(self, &tarbaby_move_explode);
+}
+
+
+//
+// SPAWN
+//
+
+/*QUAKED monster_tarbaby (1 .5 0) (-16 -16 -24) (16 16 24) Ambush Trigger_Spawn Sight
+model="models/monsters/q1tarbaby/tris.md2"
+*/
+void SP_monster_tarbaby(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_death.assign("tarbaby/death1.wav");
+	sound_hit.assign("tarbaby/hit1.wav");
+	sound_land.assign("tarbaby/land1.wav");
+	sound_sight.assign("tarbaby/sight1.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex("models/monsters/tarbaby/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 24 };
+
+
+	if (strcmp(self->classname, "monster_tarbaby_hell") == 0)
+	{
+		if (!(self->spawnflags & SPAWNFLAG_HELLSPAWN_BABY))
+		{
+			self->health = 150 * st.health_multiplier;
+			self->s.skinnum = 2;
+		}
+		else
+		{
+			self->health = 90 * st.health_multiplier;
+			self->s.skinnum = 1;
+
+			if (!self->s.scale)
+				self->s.scale = 0.8f;
+		}
+	}
+	else
+	{
+		self->health = 120 * st.health_multiplier;
+	}
+
+	self->gib_health = 0;
+	self->mass = 100;
+
+	self->pain = tarbaby_pain;
+	self->die = tarbaby_die;
+
+
+
+	self->monsterinfo.stand = tarbaby_stand;
+	self->monsterinfo.walk = tarbaby_walk;
+	self->monsterinfo.run = tarbaby_run;
+	self->monsterinfo.dodge = nullptr;
+	self->monsterinfo.attack = tarbaby_jump;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = tarbaby_sight;
+	self->monsterinfo.search = nullptr;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &tarbaby_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	walkmonster_start (self);
+}
+
+void SP_monster_tarbaby_hell(edict_t* self)
+{
+	SP_monster_tarbaby(self);
+}
--- /dev/null
+++ b/quake1/m_tarbaby.h	2025-09-04 19:53:48
@@ -0,0 +1,68 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_walk7,
+	FRAME_walk8,
+	FRAME_walk9,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12,
+	FRAME_walk13,
+	FRAME_walk14,
+	FRAME_walk15,
+	FRAME_walk16,
+	FRAME_walk17,
+	FRAME_walk18,
+	FRAME_walk19,
+	FRAME_walk20,
+	FRAME_walk21,
+	FRAME_walk22,
+	FRAME_walk23,
+	FRAME_walk24,
+	FRAME_walk25,
+	FRAME_run1,
+	FRAME_run2,
+	FRAME_run3,
+	FRAME_run4,
+	FRAME_run5,
+	FRAME_run6,
+	FRAME_run7,
+	FRAME_run8,
+	FRAME_run9,
+	FRAME_run10,
+	FRAME_run11,
+	FRAME_run12,
+	FRAME_run13,
+	FRAME_run14,
+	FRAME_run15,
+	FRAME_run16,
+	FRAME_run17,
+	FRAME_run18,
+	FRAME_run19,
+	FRAME_run20,
+	FRAME_run21,
+	FRAME_run22,
+	FRAME_run23,
+	FRAME_run24,
+	FRAME_run25,
+	FRAME_jump1,
+	FRAME_jump2,
+	FRAME_jump3,
+	FRAME_jump4,
+	FRAME_jump5,
+	FRAME_jump6,
+	FRAME_fly1,
+	FRAME_fly2,
+	FRAME_fly3,
+	FRAME_fly4,
+	FRAME_exp
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_vore.cpp	2025-09-04 19:53:48
@@ -0,0 +1,760 @@
+/*
+==============================================================================
+
+QUAKE VORE
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_vore.h"
+
+static cached_soundindex sound_death;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_pain1;
+static cached_soundindex sound_attack;
+static cached_soundindex sound_attack2;
+static cached_soundindex sound_idle;
+
+constexpr spawnflags_t SPAWNFLAG_VORE_ONROOF = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_VORE_NOJUMPING = 16_spawnflag;
+
+void vore_walk(edict_t* self);
+void vore_dodge_jump(edict_t* self);
+void vore_jump_straightup(edict_t* self);
+void vore_jump_wait_land(edict_t* self);
+bool vore_ok_to_transition(edict_t* self);
+void vore_stand(edict_t* self);
+
+//
+//CEILING PREP
+//
+
+inline bool vore_on_ceiling(edict_t* ent)
+{
+	return (ent->gravityVector[2] > 0);
+}
+
+bool vore_ok_to_transition(edict_t* self)
+{
+	trace_t trace;
+	vec3_t	pt, start;
+	float	max_dist;
+	float	margin;
+	float	end_height;
+
+	if (vore_on_ceiling(self))
+	{
+		if (!self->groundentity)
+			return true;
+
+		max_dist = -384;
+		margin = self->mins[2] - 8;
+	}
+	else
+	{
+		max_dist = 256;
+		margin = self->maxs[2] + 8;
+	}
+
+	pt = self->s.origin;
+	pt[2] += max_dist;
+	trace = gi.trace(self->s.origin, self->mins, self->maxs, pt, self, MASK_MONSTERSOLID);
+
+	if (trace.fraction == 1.0f ||
+		!(trace.contents & CONTENTS_SOLID) ||
+		(trace.ent != world))
+	{
+		if (vore_on_ceiling(self))
+		{
+			if (trace.plane.normal[2] < 0.9f)
+				return false;
+		}
+		else
+		{
+			if (trace.plane.normal[2] > -0.9f)
+				return false;
+		}
+	}
+
+	end_height = trace.endpos[2];
+
+	pt[0] = self->absmin[0];
+	pt[1] = self->absmin[1];
+	pt[2] = trace.endpos[2] + margin;
+	start = pt;
+	start[2] = self->s.origin[2];
+	trace = gi.traceline(start, pt, self, MASK_MONSTERSOLID);
+	if (trace.fraction == 1.0f || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
+		return false;
+	if (fabsf(end_height + margin - trace.endpos[2]) > 8)
+		return false;
+
+	pt[0] = self->absmax[0];
+	pt[1] = self->absmin[1];
+	start = pt;
+	start[2] = self->s.origin[2];
+	trace = gi.traceline(start, pt, self, MASK_MONSTERSOLID);
+	if (trace.fraction == 1.0f || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
+		return false;
+	if (fabsf(end_height + margin - trace.endpos[2]) > 8)
+		return false;
+
+	pt[0] = self->absmax[0];
+	pt[1] = self->absmax[1];
+	start = pt;
+	start[2] = self->s.origin[2];
+	trace = gi.traceline(start, pt, self, MASK_MONSTERSOLID);
+	if (trace.fraction == 1.0f || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
+		return false;
+	if (fabsf(end_height + margin - trace.endpos[2]) > 8)
+		return false;
+
+	pt[0] = self->absmin[0];
+	pt[1] = self->absmax[1];
+	start = pt;
+	start[2] = self->s.origin[2];
+	trace = gi.traceline(start, pt, self, MASK_MONSTERSOLID);
+	if (trace.fraction == 1.0f || !(trace.contents & CONTENTS_SOLID) || (trace.ent != world))
+		return false;
+	if (fabsf(end_height + margin - trace.endpos[2]) > 8)
+		return false;
+
+	return true;
+}
+
+//
+//SOUNDS
+//
+
+MONSTERINFO_SEARCH(vore_search) (edict_t* self) -> void
+{
+	if (frandom() < 0.2f)
+		gi.sound (self, CHAN_BODY, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+MONSTERINFO_SIGHT(vore_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+//
+//STAND
+//
+
+mframe_t vore_frames_stand [] =
+{
+	{ai_stand}
+};
+MMOVE_T(vore_move_stand) = {FRAME_walk1, FRAME_walk1, vore_frames_stand, nullptr };
+
+MONSTERINFO_STAND(vore_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &vore_move_stand);
+}
+
+//
+// WALK
+//
+
+mframe_t vore_frames_walk [] =
+{
+	{ai_walk, 6},
+	{ai_walk, 4},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk, 5},
+	{ai_walk, 6},
+	{ai_walk, 5},
+	{ai_walk},
+	{ai_walk, 4},
+	{ai_walk, 5}
+};
+MMOVE_T(vore_move_walk) = {FRAME_walk1, FRAME_walk12, vore_frames_walk, nullptr };
+
+MONSTERINFO_WALK(vore_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &vore_move_walk);
+}
+
+
+//
+// RUN
+//
+
+void vore_run (edict_t *self);
+
+mframe_t vore_frames_run [] =
+{
+	{ai_run, 6},
+	{ai_run, 4},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run, 5},
+	{ai_run, 6},
+	{ai_run, 5},
+	{ai_run},
+	{ai_run, 4},
+	{ai_run, 5}
+};
+MMOVE_T(vore_move_run) = {FRAME_walk1, FRAME_walk12, vore_frames_run, vore_run};
+
+MONSTERINFO_RUN(vore_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+	{
+		M_SetAnimation(self, &vore_move_stand);
+		return;
+	}
+	else
+		M_SetAnimation(self, &vore_move_run);
+}
+
+//
+// ATTACK
+//
+
+void vore_fire(edict_t* self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	vec;
+	trace_t trace;
+	int		rocketSpeed;
+	vec3_t target;
+	bool   blindfire = false;
+	vec3_t offset = { 0, 0, 10 };
+	int damage = 40;
+
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+	else
+		blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse)
+		return;
+
+	if (vore_on_ceiling(self))
+	{
+		offset = { 0, 0, -10 };
+	}
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+
+	rocketSpeed = 350;
+
+	if (blindfire)
+		target = self->monsterinfo.blind_fire_target;
+	else
+		target = self->enemy->s.origin;
+
+	if (blindfire)
+	{
+		vec = target;
+		dir = vec - start;
+	}
+
+	else if (frandom() < 0.33f || (start[2] < self->enemy->absmin[2]))
+	{
+		vec = target;
+		vec[2] += self->enemy->viewheight;
+		dir = vec - start;
+	}
+	else
+	{
+		vec = target;
+		vec[2] = self->enemy->absmin[2] + 1;
+		dir = vec - start;
+	}
+
+	if ((!blindfire) && (frandom() < 0.35f))
+		PredictAim(self, self->enemy, start, rocketSpeed, false, 0.f, &dir, &vec);
+
+	dir.normalize();
+
+	trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+	if (blindfire)
+	{
+		if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+			fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 0);
+		else
+		{
+			vec = target;
+			vec += (right * -10);
+			dir = vec - start;
+			dir.normalize();
+			trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+			if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+				fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 0);
+			else
+			{
+				vec = target;
+				vec += (right * 10);
+				dir = vec - start;
+				dir.normalize();
+				trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+				if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+					fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 0);
+			}
+		}
+	}
+	else
+	{
+		if (trace.fraction > 0.5f || trace.ent->solid != SOLID_BSP)
+			fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.15f, 0);
+	}
+
+	gi.sound(self, CHAN_WEAPON | CHAN_RELIABLE, sound_attack2, 1, ATTN_NORM, 0);
+}
+
+void vore_attack_snd(edict_t* self)
+{
+	gi.sound(self, CHAN_AUTO, sound_attack, 1, ATTN_NORM, 0);
+}
+
+mframe_t vore_frames_attack[] =
+{
+	{ai_charge, 0, vore_attack_snd},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, vore_fire},
+	{ai_charge}
+};
+MMOVE_T(vore_move_attack) = { FRAME_attack1, FRAME_attack11, vore_frames_attack, vore_run };
+
+MONSTERINFO_ATTACK(vore_attack) (edict_t* self) -> void
+{
+	vec3_t offset;
+
+	if (vore_on_ceiling(self))
+		offset = { 0, 0, -10 };
+	else
+		offset = { 0, 0, 10 };
+
+	if (!M_CheckClearShot(self, offset))
+		return;
+
+	float r, chance;
+
+	monster_done_dodge(self);
+
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		if (self->monsterinfo.blind_fire_delay < 1.0_sec)
+			chance = 1.0;
+		else if (self->monsterinfo.blind_fire_delay < 7.5_sec)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		r = frandom();
+
+		self->monsterinfo.blind_fire_delay += random_time(5.5_sec, 6.5_sec);
+
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		if (r > chance)
+			return;
+
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+		M_SetAnimation(self, &vore_move_attack);
+		self->monsterinfo.attack_finished = level.time + random_time(2_sec);
+		return;
+	}
+
+	M_SetAnimation(self, &vore_move_attack);
+}
+
+//
+// DODGE
+// 
+
+void vore_jump_straightup(edict_t* self)
+{
+	if (self->deadflag)
+		return;
+
+	if (vore_on_ceiling(self))
+	{
+		if (vore_ok_to_transition(self))
+		{
+			self->gravityVector[2] = -1;
+			self->s.angles[2] += 180.0f;
+			if (self->s.angles[2] > 360.0f)
+				self->s.angles[2] -= 360.0f;
+			self->groundentity = nullptr;
+		}
+	}
+	else if (self->groundentity)
+	{
+		self->velocity[0] += crandom() * 5;
+		self->velocity[1] += crandom() * 5;
+		self->velocity[2] += -400 * self->gravityVector[2];
+		if (vore_ok_to_transition(self))
+		{
+			self->gravityVector[2] = 1;
+			self->s.angles[2] = 180.0;
+			self->groundentity = nullptr;
+		}
+	}
+}
+
+mframe_t vore_frames_jump_straightup[] = {
+	{ ai_move, 1, vore_jump_straightup },
+	{ ai_move, 1, vore_jump_wait_land },
+	{ ai_move, -1, monster_footstep },
+	{ ai_move, -1 }
+};
+MMOVE_T(vore_move_jump_straightup) = { FRAME_walk5, FRAME_walk8, vore_frames_jump_straightup, vore_run };
+
+void vore_dodge_jump(edict_t* self)
+{
+	M_SetAnimation(self, &vore_move_jump_straightup);
+}
+
+MONSTERINFO_DODGE(vore_dodge) (edict_t* self, edict_t* attacker, gtime_t eta, trace_t* tr, bool gravity) -> void
+{
+	if (!self->groundentity || self->health <= 0)
+		return;
+
+	if (!self->enemy)
+	{
+		self->enemy = attacker;
+		FoundTarget(self);
+		return;
+	}
+
+	if ((eta < FRAME_TIME_MS) || (eta > 5_sec))
+		return;
+
+	if (self->timestamp > level.time)
+		return;
+
+	self->timestamp = level.time + random_time(1_sec, 5_sec);
+
+	vore_dodge_jump(self);
+}
+
+void vore_jump_down(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 100);
+	self->velocity += (up * 300);
+}
+
+void vore_jump_up(edict_t* self)
+{
+	vec3_t forward, up;
+
+	AngleVectors(self->s.angles, forward, nullptr, up);
+	self->velocity += (forward * 200);
+	self->velocity += (up * 450);
+}
+
+void vore_jump_wait_land(edict_t* self)
+{
+	if ((frandom() < 0.4f) && (level.time >= self->monsterinfo.attack_finished))
+	{
+		self->monsterinfo.attack_finished = level.time + 300_ms;
+		vore_attack(self);
+	}
+
+	if (self->groundentity == nullptr)
+	{
+		self->gravity = 1.3f;
+		self->monsterinfo.nextframe = self->s.frame;
+
+		if (monster_jump_finished(self))
+		{
+			self->gravity = 1;
+			self->monsterinfo.nextframe = self->s.frame + 1;
+		}
+	}
+	else
+	{
+		self->gravity = 1;
+		self->monsterinfo.nextframe = self->s.frame + 1;
+	}
+}
+
+mframe_t vore_frames_jump_up[] = {
+	{ ai_move, -8 },
+	{ ai_move, -8 },
+	{ ai_move, -8 },
+	{ ai_move, -8 },
+
+	{ ai_move, 0, vore_jump_up },
+	{ ai_move, 0, vore_jump_wait_land },
+	{ ai_move, 0, monster_footstep }
+};
+MMOVE_T(vore_move_jump_up) = { FRAME_walk5, FRAME_walk11, vore_frames_jump_up, vore_run };
+
+mframe_t vore_frames_jump_down[] = {
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move, 0, vore_jump_down },
+	{ ai_move, 0, vore_jump_wait_land },
+	{ ai_move, 0, monster_footstep }
+};
+MMOVE_T(vore_move_jump_down) = { FRAME_walk5, FRAME_walk11, vore_frames_jump_down, vore_run };
+
+void vore_jump(edict_t* self, blocked_jump_result_t result)
+{
+	if (!self->enemy)
+		return;
+
+	if (result == blocked_jump_result_t::JUMP_JUMP_UP)
+		M_SetAnimation(self, &vore_move_jump_up);
+	else
+		M_SetAnimation(self, &vore_move_jump_down);
+}
+
+// 
+// Blocked
+// 
+
+MONSTERINFO_BLOCKED(vore_blocked) (edict_t* self, float dist) -> bool
+{
+	if (!has_valid_enemy(self))
+		return false;
+
+	bool onCeiling = vore_on_ceiling(self);
+
+	if (!onCeiling)
+	{
+		if (auto result = blocked_checkjump(self, dist); result != blocked_jump_result_t::NO_JUMP)
+		{
+			if (result != blocked_jump_result_t::JUMP_TURN)
+				vore_jump(self, result);
+			return true;
+		}
+
+		if (blocked_checkplat(self, dist))
+			return true;
+	}
+	else
+	{
+		if (vore_ok_to_transition(self))
+		{
+			self->gravityVector[2] = -1;
+			self->s.angles[2] += 180.0f;
+			if (self->s.angles[2] > 360.0f)
+				self->s.angles[2] -= 360.0f;
+			self->groundentity = nullptr;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+MONSTERINFO_PHYSCHANGED(vore_physics_change) (edict_t* self) -> void
+{
+	if (vore_on_ceiling(self) && !self->groundentity)
+	{
+		self->mins = { -32, -32, -32 };
+		self->maxs = { 32, 32, 16 };
+
+		self->gravityVector[2] = -1;
+		self->s.angles[2] += 180.0f;
+		if (self->s.angles[2] > 360.0f)
+			self->s.angles[2] -= 360.0f;
+	}
+	else
+	{
+		self->mins = { -32, -32, -24 };
+		self->maxs = { 32, 32, 32 };
+	}
+}
+
+//
+// PAIN
+//
+
+mframe_t vore_frames_pain1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(vore_move_pain1) = {FRAME_pain1, FRAME_pain5, vore_frames_pain1, vore_run};
+
+PAIN(vore_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	gi.sound (self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+
+	M_SetAnimation(self, &vore_move_pain1);
+}
+
+MONSTERINFO_SETSKIN(vore_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// DEATH
+//
+
+void vore_dead (edict_t *self)
+{
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, -8 };
+	monster_dead(self);
+}
+
+static void vore_shrink(edict_t* self)
+{
+	self->maxs[2] = -4;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t vore_frames_death1 [] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0, vore_shrink},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(vore_move_death) = { FRAME_death1, FRAME_death7, vore_frames_death1, vore_dead };
+
+DIE(vore_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	self->movetype = MOVETYPE_TOSS;
+	self->s.angles[2] = 0;
+	self->gravityVector = { 0, 0, -1 };
+
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+			//{ "models/monsters/vore/gibs/chest.md2", },
+			//{ "models/monsters/vore/gibs/claw.md2", GIB_UPRIGHT },
+			{ "models/monsters/vore/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_death, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	M_SetAnimation(self, &vore_move_death);
+}
+
+
+//
+// SPAWN
+//
+
+/*QUAKED monster_vore (1 .5 0) (-16 -16 -24) (16 16 40) Ambush Trigger_Spawn Sight
+model="models/monsters/vore/tris.md2"
+*/
+void SP_monster_vore(edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+	
+	sound_sight.assign("vore/sight.wav");
+	sound_pain1.assign("vore/pain.wav");
+	sound_death.assign("vore/death.wav");
+	sound_attack.assign("vore/attack.wav");
+	sound_attack2.assign("vore/attack2.wav");
+	sound_idle.assign("vore/idle.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+
+	self->s.modelindex = gi.modelindex ("models/monsters/vore/tris.md2");
+
+	self->mins = { -32, -32, -24 };
+	self->maxs = { 32, 32, 32 };
+	
+	self->health = 600 * st.health_multiplier;
+	self->gib_health = -90;
+	self->mass = 125;
+
+	self->pain = vore_pain;
+	self->die = vore_die;
+
+	self->monsterinfo.sight = vore_sight;
+	self->monsterinfo.search = vore_search;
+
+	self->monsterinfo.stand = vore_stand;
+	self->monsterinfo.walk = vore_walk;
+	self->monsterinfo.run = vore_run;
+
+	self->monsterinfo.attack = vore_attack;
+	self->monsterinfo.melee = nullptr;
+
+	self->monsterinfo.setskin = vore_setskin;
+	self->monsterinfo.dodge = vore_dodge;
+	self->monsterinfo.blocked = vore_blocked;
+	self->monsterinfo.physics_change = vore_physics_change;
+
+	gi.linkentity (self);
+
+	if (self->spawnflags.has(SPAWNFLAG_VORE_ONROOF))
+	{
+		self->s.angles[2] = 180;
+		self->gravityVector[2] = 1;
+	}
+
+	self->monsterinfo.can_jump = !self->spawnflags.has(SPAWNFLAG_VORE_NOJUMPING);
+	self->monsterinfo.drop_height = 256;
+	self->monsterinfo.jump_height = 68;
+
+	M_SetAnimation(self, &vore_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	walkmonster_start (self);
+}
--- /dev/null
+++ b/quake1/m_vore.h	2025-09-04 19:53:48
@@ -0,0 +1,42 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_attack1,
+	FRAME_attack2,
+	FRAME_attack3,
+	FRAME_attack4,
+	FRAME_attack5,
+	FRAME_attack6,
+	FRAME_attack7,
+	FRAME_attack8,
+	FRAME_attack9,
+	FRAME_attack10,
+	FRAME_attack11,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_pain4,
+	FRAME_pain5,
+	FRAME_death1,
+	FRAME_death2,
+	FRAME_death3,
+	FRAME_death4,
+	FRAME_death5,
+	FRAME_death6,
+	FRAME_death7,
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_walk7,
+	FRAME_walk8,
+	FRAME_walk9,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_wrath.cpp	2025-09-04 19:53:48
@@ -0,0 +1,469 @@
+/*
+==============================================================================
+
+QUAKE WRATH
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_wrath.h"
+
+static cached_soundindex	sound_sight;
+static cached_soundindex	sound_attack;
+static cached_soundindex	sound_die;
+static cached_soundindex	sound_pain;
+
+static cached_soundindex sound_attack2;
+
+MONSTERINFO_SIGHT(wrath_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound (self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+void wrath_attack_sound (edict_t *self)
+{
+	gi.sound (self, CHAN_VOICE, sound_attack, 1, ATTN_NORM, 0);
+}
+
+mframe_t wrath_frames_stand [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(wrath_move_stand) = { FRAME_wrthwk01, FRAME_wrthwk12, wrath_frames_stand, nullptr };
+
+MONSTERINFO_STAND(wrath_stand) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &wrath_move_stand);
+}
+
+mframe_t wrath_frames_walk [] =
+{
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+
+	{ai_walk, 5},
+	{ai_walk, 5}
+};
+MMOVE_T(wrath_move_walk) = { FRAME_wrthwk01, FRAME_wrthwk12, wrath_frames_walk, nullptr };
+
+MONSTERINFO_WALK(wrath_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &wrath_move_walk);
+}
+
+mframe_t wrath_frames_run [] =
+{
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+
+	{ai_run, 10},
+	{ai_run, 10}
+};
+MMOVE_T(wrath_move_run) = { FRAME_wrthwk01, FRAME_wrthwk12, wrath_frames_run, nullptr };
+
+MONSTERINFO_RUN(wrath_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &wrath_move_run);
+}
+
+mframe_t wrath_frames_pain1 [] =
+{	
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+
+		{ai_move}
+};
+MMOVE_T(wrath_move_pain1) = { FRAME_wrthpa01, FRAME_wrthpa06, wrath_frames_pain1, wrath_run };
+
+mframe_t wrath_frames_pain2[] =
+{
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+		{ai_move},
+
+		{ai_move}
+};
+MMOVE_T(wrath_move_pain2) = { FRAME_wrthpb01, FRAME_wrthpb11, wrath_frames_pain2, wrath_run };
+
+PAIN(wrath_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 2_sec;
+	
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+	
+	gi.sound (self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+
+	if (frandom() >= 0.4f)
+		M_SetAnimation(self, &wrath_move_pain1);
+	else
+		M_SetAnimation(self, &wrath_move_pain2);
+}
+
+void wrath_dead (edict_t * self)
+{
+	T_RadiusDamage(self, self, 60, nullptr, 105, DAMAGE_NONE, MOD_BARREL);
+
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_EXPLOSION1);
+	gi.WritePosition(self->s.origin);
+	gi.multicast(self->s.origin, MULTICAST_PHS, false);
+
+	self->s.skinnum /= 2;
+
+	ThrowGibs(self, 55, {
+		{ 2, "models/objects/gibs/bone/tris.md2" },
+		{ 4, "models/monsters/wrath/gibs/claw.md2" },
+		{ 4, "models/monsters/wrath/gibs/arm.md2" },
+		{ "models/monsters/overlord/gibs/ribs.md2" },
+		{ "models/monsters/wrath/gibs/bone.md2", GIB_HEAD }
+		});
+
+	self->touch = nullptr;
+}
+
+mframe_t wrath_frames_die [] =
+{	
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(wrath_move_die) = { FRAME_wrthdt01, FRAME_wrthdt15, wrath_frames_die, wrath_dead };
+
+DIE(wrath_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+
+	M_SetAnimation(self, &wrath_move_die);
+}
+
+void wrath_fire (edict_t *self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	vec;
+	trace_t trace;
+	int		rocketSpeed;
+	vec3_t target;
+	bool   blindfire = false;
+	vec3_t offset = { 0, 0, 10 };
+	int damage = 20;
+
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+	else
+		blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse)
+		return;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+
+	rocketSpeed = 400;
+
+	if (blindfire)
+		target = self->monsterinfo.blind_fire_target;
+	else
+		target = self->enemy->s.origin;
+
+
+	if (blindfire)
+	{
+		vec = target;
+		dir = vec - start;
+	}
+
+	else if (frandom() < 0.33f || (start[2] < self->enemy->absmin[2]))
+	{
+		vec = target;
+		vec[2] += self->enemy->viewheight;
+		dir = vec - start;
+	}
+	else
+	{
+		vec = target;
+		vec[2] = self->enemy->absmin[2] + 1;
+		dir = vec - start;
+	}
+
+	if ((!blindfire) && (frandom() < 0.35f))
+		PredictAim(self, self->enemy, start, rocketSpeed, false, 0.f, &dir, &vec);
+
+	dir.normalize();
+
+	trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+	if (blindfire)
+	{
+		if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+			fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 1);
+		else
+		{
+			vec = target;
+			vec += (right * -10);
+			dir = vec - start;
+			dir.normalize();
+			trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+			if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+				fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 1);
+			else
+			{
+				vec = target;
+				vec += (right * 10);
+				dir = vec - start;
+				dir.normalize();
+				trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+				if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+					fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.075f, 1);
+			}
+		}
+	}
+	else
+	{
+		if (trace.fraction > 0.5f || trace.ent->solid != SOLID_BSP)
+			fire_vorepod(self, start, dir, damage, rocketSpeed, (float)damage, damage, 0.15f, 1);
+	}
+
+	gi.sound(self, CHAN_WEAPON | CHAN_RELIABLE, sound_attack2, 1, ATTN_NORM, 0);
+}
+
+mframe_t wrath_frames_attack1 [] = {
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, wrath_attack_sound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, -1},
+	{ai_charge, -2},
+
+	{ai_charge, -3},
+	{ai_charge, -2, wrath_fire},
+	{ai_charge, -1},
+	{ai_charge}
+};
+MMOVE_T(wrath_move_attack1) = { FRAME_wrthaa01, FRAME_wrthaa14, wrath_frames_attack1, wrath_run };
+
+mframe_t wrath_frames_attack2[] = {
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, wrath_attack_sound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, -1},
+	{ai_charge, -2},
+	{ai_charge, -3},
+	{ai_charge, -2, wrath_fire},
+	{ai_charge, -1},
+
+	{ai_charge},
+	{ai_charge},
+	{ai_charge}
+};
+MMOVE_T(wrath_move_attack2) = { FRAME_wrthab01, FRAME_wrthab13, wrath_frames_attack2, wrath_run };
+
+mframe_t wrath_frames_attack3[] = {
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0, wrath_attack_sound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, -1},
+	{ai_charge, -2},
+	{ai_charge, -3},
+	{ai_charge, -2, wrath_fire},
+
+	{ai_charge, -1},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge}
+};
+MMOVE_T(wrath_move_attack3) = { FRAME_wrthac01, FRAME_wrthac15, wrath_frames_attack3, wrath_run };
+
+MONSTERINFO_ATTACK(wrath_attack) (edict_t* self) -> void
+{
+	vec3_t offset = { 0, 0, 10 };
+
+	if (!M_CheckClearShot(self, offset))
+		return;
+
+	float r, chance;
+
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		// setup shot probabilities
+		if (self->monsterinfo.blind_fire_delay < 1.0_sec)
+			chance = 1.0;
+		else if (self->monsterinfo.blind_fire_delay < 7.5_sec)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		r = frandom();
+
+		// minimum of 5.5 seconds, plus 0-1, after the shots are done
+		self->monsterinfo.blind_fire_delay += random_time(5.5_sec, 6.5_sec);
+
+		// don't shoot at the origin
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		// don't shoot if the dice say not to
+		if (r > chance)
+			return;
+
+		// turn on manual steering to signal both manual steering and blindfire
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+
+		if (frandom() > 0.33f)
+			M_SetAnimation(self, &wrath_move_attack1);
+		else if (frandom() > 0.66f)
+			M_SetAnimation(self, &wrath_move_attack2);
+		else
+			M_SetAnimation(self, &wrath_move_attack3);	
+
+		self->monsterinfo.attack_finished = level.time + random_time(2_sec);
+		return;
+	}
+
+	if (frandom() > 0.33f)
+		M_SetAnimation(self, &wrath_move_attack1);
+	else if (frandom() > 0.66f)
+		M_SetAnimation(self, &wrath_move_attack2);
+	else
+		M_SetAnimation(self, &wrath_move_attack3);		
+}
+
+static void wrath_set_fly_parameters(edict_t* self)
+{
+	self->monsterinfo.fly_thrusters = false;
+	self->monsterinfo.fly_acceleration = 20.f;
+	self->monsterinfo.fly_speed = 120.f;
+	self->monsterinfo.fly_min_distance = 200.f;
+	self->monsterinfo.fly_max_distance = 400.f;
+}
+
+/*QUAKED monster_wrath (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+model="models/monsters/wrath/tris.md2"
+*/
+void SP_monster_wrath (edict_t *self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_sight.assign("wrath/wsee.wav");
+	sound_attack.assign("wrath/watt.wav");
+	sound_die.assign("wrath/wdthc.wav");
+	sound_pain.assign("wrath/wpain.wav");
+
+
+	sound_attack2.assign("vore/attack2.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex ("models/monsters/wrath/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 32 };
+
+	self->health = 400 * st.health_multiplier;
+	self->mass = 400;
+
+	self->pain = wrath_pain;
+	self->die = wrath_die;
+
+
+
+	self->monsterinfo.stand = wrath_stand;
+	self->monsterinfo.walk = wrath_walk;
+	self->monsterinfo.run = wrath_run;
+	self->monsterinfo.attack = wrath_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = wrath_sight;
+	self->monsterinfo.search = nullptr;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &wrath_move_stand);
+	self->monsterinfo.scale = MODEL_SCALE;
+	
+	self->flags |= FL_FLY;
+	if (!self->yaw_speed)
+		self->yaw_speed = 10;
+	self->viewheight = 10;
+
+	flymonster_start (self);
+
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+	wrath_set_fly_parameters(self);
+}
--- /dev/null
+++ b/quake1/m_wrath.h	2025-09-04 19:53:48
@@ -0,0 +1,94 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_wrthfrme,
+	FRAME_wrthwk01,
+	FRAME_wrthwk02,
+	FRAME_wrthwk03,
+	FRAME_wrthwk04,
+	FRAME_wrthwk05,
+	FRAME_wrthwk06,
+	FRAME_wrthwk07,
+	FRAME_wrthwk08,
+	FRAME_wrthwk09,
+	FRAME_wrthwk10,
+	FRAME_wrthwk11,
+	FRAME_wrthwk12,
+	FRAME_wrthaa01,
+	FRAME_wrthaa02,
+	FRAME_wrthaa03,
+	FRAME_wrthaa04,
+	FRAME_wrthaa05,
+	FRAME_wrthaa06,
+	FRAME_wrthaa07,
+	FRAME_wrthaa08,
+	FRAME_wrthaa09,
+	FRAME_wrthaa10,
+	FRAME_wrthaa11,
+	FRAME_wrthaa12,
+	FRAME_wrthaa13,
+	FRAME_wrthaa14,
+	FRAME_wrthab01,
+	FRAME_wrthab02,
+	FRAME_wrthab03,
+	FRAME_wrthab04,
+	FRAME_wrthab05,
+	FRAME_wrthab06,
+	FRAME_wrthab07,
+	FRAME_wrthab08,
+	FRAME_wrthab09,
+	FRAME_wrthab10,
+	FRAME_wrthab11,
+	FRAME_wrthab12,
+	FRAME_wrthab13,
+	FRAME_wrthac01,
+	FRAME_wrthac02,
+	FRAME_wrthac03,
+	FRAME_wrthac04,
+	FRAME_wrthac05,
+	FRAME_wrthac06,
+	FRAME_wrthac07,
+	FRAME_wrthac08,
+	FRAME_wrthac09,
+	FRAME_wrthac10,
+	FRAME_wrthac11,
+	FRAME_wrthac12,
+	FRAME_wrthac13,
+	FRAME_wrthac14,
+	FRAME_wrthac15,
+	FRAME_wrthpa01,
+	FRAME_wrthpa02,
+	FRAME_wrthpa03,
+	FRAME_wrthpa04,
+	FRAME_wrthpa05,
+	FRAME_wrthpa06,
+	FRAME_wrthpb01,
+	FRAME_wrthpb02,
+	FRAME_wrthpb03,
+	FRAME_wrthpb04,
+	FRAME_wrthpb05,
+	FRAME_wrthpb06,
+	FRAME_wrthpb07,
+	FRAME_wrthpb08,
+	FRAME_wrthpb09,
+	FRAME_wrthpb10,
+	FRAME_wrthpb11,
+	FRAME_wrthdt01,
+	FRAME_wrthdt02,
+	FRAME_wrthdt03,
+	FRAME_wrthdt04,
+	FRAME_wrthdt05,
+	FRAME_wrthdt06,
+	FRAME_wrthdt07,
+	FRAME_wrthdt08,
+	FRAME_wrthdt09,
+	FRAME_wrthdt10,
+	FRAME_wrthdt11,
+	FRAME_wrthdt12,
+	FRAME_wrthdt13,
+	FRAME_wrthdt14,
+	FRAME_wrthdt15
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_wyvern.cpp	2025-09-04 19:53:48
@@ -0,0 +1,597 @@
+/*
+==============================================================================
+
+QUAKE WYVERN
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_wyvern.h"
+
+static cached_soundindex	sound_sight1;
+static cached_soundindex	sound_sight2;
+static cached_soundindex	sound_search1;
+static cached_soundindex	sound_search2;
+static cached_soundindex	sound_search3;
+static cached_soundindex	sound_attack;
+static cached_soundindex	sound_die1;
+static cached_soundindex	sound_die2;
+static cached_soundindex	sound_pain1;
+static cached_soundindex	sound_pain2;
+static cached_soundindex	sound_flame;
+
+void wyvern_reattack(edict_t* self);
+
+MONSTERINFO_SIGHT(wyvern_sight) (edict_t* self, edict_t* other) -> void
+{
+	if (frandom() > 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_sight2, 1, ATTN_NONE, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_sight1, 1, ATTN_NONE, 0);
+}
+
+MONSTERINFO_SEARCH(wyvern_search) (edict_t* self) -> void
+{
+	if (frandom() > 0.66f)
+		gi.sound(self, CHAN_VOICE, sound_search3, 1, ATTN_NONE, 0);
+	else if (frandom() > 0.33f)
+		gi.sound(self, CHAN_VOICE, sound_search2, 1, ATTN_NONE, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_search1, 1, ATTN_NONE, 0);
+}
+
+//================
+// HOVER
+//================
+mframe_t wyvern_frames_hover [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(wyvern_move_hover) = {FRAME_fly1, FRAME_fly8, wyvern_frames_hover, nullptr };
+
+MONSTERINFO_STAND(wyvern_hover) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &wyvern_move_hover);
+}
+
+//================
+// WALK
+//================
+mframe_t wyvern_frames_walk [] =
+{
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5},
+
+	{ai_walk, 5},
+	{ai_walk, 5},
+	{ai_walk, 5}
+};
+MMOVE_T(wyvern_move_walk) = {FRAME_fly1, FRAME_fly8, wyvern_frames_walk, nullptr };
+
+
+MONSTERINFO_WALK(wyvern_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &wyvern_move_walk);
+}
+
+//================
+// FLY
+//================
+mframe_t wyvern_frames_run[] =
+{
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10},
+
+	{ai_run, 10},
+	{ai_run, 10},
+	{ai_run, 10}
+};
+MMOVE_T(wyvern_move_run) = { FRAME_fly1, FRAME_fly8, wyvern_frames_run, nullptr };
+
+
+MONSTERINFO_RUN(wyvern_run) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &wyvern_move_run);
+}
+
+//================
+// PAIN
+//================
+mframe_t wyvern_frames_pain1 [] =
+{	
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move }
+};
+MMOVE_T(wyvern_move_pain1) = {FRAME_pain1, FRAME_pain6, wyvern_frames_pain1, wyvern_run };
+
+mframe_t wyvern_frames_pain2[] =
+{
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move }
+};
+MMOVE_T(wyvern_move_pain2) = { FRAME_painb1, FRAME_painb6, wyvern_frames_pain2, wyvern_run };
+
+mframe_t wyvern_frames_pain3[] =
+{
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+	{ ai_move },
+
+	{ ai_move }
+};
+MMOVE_T(wyvern_move_pain3) = { FRAME_painc1, FRAME_painc6, wyvern_frames_pain3, wyvern_run };
+
+PAIN(wyvern_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 1_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	if (damage < 30)
+	{
+		gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &wyvern_move_pain1);
+	}
+	else
+	{
+		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+		if (frandom() >= 0.5)
+			M_SetAnimation(self, &wyvern_move_pain2);
+		else
+			M_SetAnimation(self, &wyvern_move_pain3);
+	}
+}
+
+MONSTERINFO_SETSKIN(wyvern_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//================
+// DEAD
+//================
+static void wyvern_gib(edict_t* self)
+{
+	gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+	self->s.skinnum /= 2;
+
+	ThrowGibs(self, 1000, {
+		{ 2, "models/objects/gibs/bone/tris.md2" },
+		{ 4, "models/objects/gibs/sm_meat/tris.md2" },
+		{ "models/monsters/wyvern/gibs/tail.md2", GIB_SKINNED | GIB_HEAD },
+		{ "models/monsters/wyvern/gibs/rwing.md2", GIB_SKINNED },
+		{ "models/monsters/wyvern/gibs/lwing.md2", GIB_SKINNED },
+		//{ "models/monsters/wyvern/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+		});
+}
+
+THINK(wyvern_deadthink) (edict_t* self) -> void
+{
+	if (!self->groundentity && level.time < self->timestamp)
+	{
+		self->nextthink = level.time + FRAME_TIME_S;
+		return;
+	}
+
+	return;
+}
+
+void wyvern_dead(edict_t * self)
+{
+	self->mins = { -144, -136, -36 };
+	self->maxs = { 88, 128, 24 };
+	self->movetype = MOVETYPE_TOSS;
+	self->think = wyvern_deadthink;
+	self->nextthink = level.time + FRAME_TIME_S;
+	self->timestamp = level.time + 15_sec;
+	gi.linkentity(self);
+
+	wyvern_gib(self);
+}
+
+mframe_t wyvern_frames_die1 [] =
+{	
+	{ai_move, 0, Q1BossExplode},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(wyvern_move_die1) = {FRAME_die1, FRAME_die13, wyvern_frames_die1, wyvern_dead};
+
+mframe_t wyvern_frames_die2[] =
+{
+	{ai_move, 0, Q1BossExplode},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+
+	{ai_move}
+};
+MMOVE_T(wyvern_move_die2) = { FRAME_dieb1, FRAME_dieb6, wyvern_frames_die2, wyvern_dead };
+
+DIE(wyvern_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		wyvern_gib(self);
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	if (frandom() > 0.5f)
+	{
+		gi.sound(self, CHAN_VOICE, sound_die1, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &wyvern_move_die1);
+	}
+	else
+	{
+		gi.sound(self, CHAN_VOICE, sound_die2, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &wyvern_move_die2);
+	}
+	self->deadflag = true;
+	self->takedamage = true;
+}
+
+//================
+// ATTACK
+//================
+
+void wyvern_fireball (edict_t *self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	vec;
+	trace_t trace; // PMM - check target
+	vec3_t target;
+	bool   blindfire = false;
+	vec3_t		offset = { 73, 0, -22 };
+	int speed = 750;
+	int damage = 100;
+
+	if (self->monsterinfo.aiflags & AI_MANUAL_STEERING)
+		blindfire = true;
+	else
+		blindfire = false;
+
+	if (!self->enemy || !self->enemy->inuse)
+		return;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+
+	if (blindfire)
+		target = self->monsterinfo.blind_fire_target;
+	else
+		target = self->enemy->s.origin;
+
+
+	if (blindfire)
+	{
+		vec = target;
+		dir = vec - start;
+	}
+
+	else if (frandom() < 0.33f || (start[2] < self->enemy->absmin[2]))
+	{
+		vec = target;
+		vec[2] += self->enemy->viewheight;
+		dir = vec - start;
+	}
+	else
+	{
+		vec = target;
+		vec[2] = self->enemy->absmin[2] + 1;
+		dir = vec - start;
+	}
+
+	if ((!blindfire) && (frandom() < 0.35f))
+		PredictAim(self, self->enemy, start, 750, false, 0.f, &dir, &vec);
+
+	dir.normalize();
+
+	trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+	if (blindfire)
+	{
+		if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+			fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+		else
+		{
+			vec = target;
+			vec += (right * -10);
+			dir = vec - start;
+			dir.normalize();
+			trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+			if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+				fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+			else
+			{
+				vec = target;
+				vec += (right * 10);
+				dir = vec - start;
+				dir.normalize();
+				trace = gi.traceline(start, vec, self, MASK_PROJECTILE);
+				if (!(trace.startsolid || trace.allsolid || (trace.fraction < 0.5f)))
+					fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+			}
+		}
+	}
+	else
+	{
+		if (trace.fraction > 0.5f || trace.ent->solid != SOLID_BSP)
+			fire_lavaball(self, start, dir, damage, speed, (float)damage, damage);
+	}
+	gi.sound(self, CHAN_VOICE, sound_attack, 1, ATTN_NORM, 0);
+}
+
+void wyvern_firebreath(edict_t* self)
+{
+	vec3_t					offset = { 73, 0, -22 };
+	vec3_t					 start;
+	vec3_t					 forward, right, up;
+	vec3_t					 aim;
+	vec3_t					 dir;
+	vec3_t					 end;
+	float					 r, u;
+	vec3_t					 aim_good;
+	int						fireCount;
+
+	fireCount = min(3, 1 * (skill->integer + 1));
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+
+	end = self->enemy->s.origin;
+	end[2] += self->enemy->viewheight;
+	aim = end - start;
+	aim_good = end;
+
+	dir = vectoangles(aim);
+	AngleVectors(dir, forward, right, up);
+
+	while (fireCount > 0)
+	{
+		r = crandom() * 2000;
+		u = crandom() * 1000;
+
+		end = start + (forward * 8192);
+		end += (right * r);
+		end += (up * u);
+
+		aim = end - start;
+		aim.normalize();
+
+		fire_flame(self, start, aim, 12, 500);
+		gi.sound(self, CHAN_VOICE, sound_attack, 1, ATTN_NORM, 0);
+
+		fireCount -= 1;
+	}
+}
+
+mframe_t wyvern_frames_attack1 [] =
+{
+	{ai_charge, 45},
+	{ai_charge, 30},
+	{ai_charge, 15},					
+	{ai_charge,  0},				
+	{ai_charge,  0},			
+	{ai_charge,  0,	wyvern_fireball},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 15, wyvern_reattack}
+};
+MMOVE_T(wyvern_move_attack1) = { FRAME_attack1, FRAME_attack9, wyvern_frames_attack1, nullptr };
+
+mframe_t wyvern_frames_attack2[] =
+{
+	{ai_charge, 0},
+	{ai_charge, 0},
+	{ai_charge, 0, wyvern_firebreath},
+	{ai_charge,  0, wyvern_firebreath},
+	{ai_charge,  0, wyvern_firebreath},
+	{ai_charge,  0, wyvern_firebreath},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 15, wyvern_reattack}
+};
+MMOVE_T(wyvern_move_attack2) = { FRAME_attack1, FRAME_attack9, wyvern_frames_attack2, nullptr };
+
+MONSTERINFO_ATTACK(wyvern_attack) (edict_t* self) -> void
+{
+
+	if (!M_CheckClearShot(self, { 0, 96, 32 }))
+		return;
+
+	float r, chance;
+
+	if (self->monsterinfo.attack_state == AS_BLIND)
+	{
+		// setup shot probabilities
+		if (self->monsterinfo.blind_fire_delay < 1.0_sec)
+			chance = 1.0;
+		else if (self->monsterinfo.blind_fire_delay < 7.5_sec)
+			chance = 0.4f;
+		else
+			chance = 0.1f;
+
+		r = frandom();
+
+		// minimum of 5.5 seconds, plus 0-1, after the shots are done
+		self->monsterinfo.blind_fire_delay += random_time(5.5_sec, 6.5_sec);
+
+		// don't shoot at the origin
+		if (!self->monsterinfo.blind_fire_target)
+			return;
+
+		// don't shoot if the dice say not to
+		if (r > chance)
+			return;
+
+		// turn on manual steering to signal both manual steering and blindfire
+		self->monsterinfo.aiflags |= AI_MANUAL_STEERING;
+		M_SetAnimation(self, &wyvern_move_attack1);
+		self->monsterinfo.attack_finished = level.time + random_time(2_sec);
+		return;
+	}
+	else
+	{
+		if (range_to(self, self->enemy) <= (RANGE_NEAR) && frandom() >= 0.5f)
+			M_SetAnimation(self, &wyvern_move_attack2);
+		else if (range_to(self, self->enemy) <= (RANGE_NEAR/3))
+			M_SetAnimation(self, &wyvern_move_attack2);
+		else
+			M_SetAnimation(self, &wyvern_move_attack1);
+	}
+}
+
+void wyvern_reattack(edict_t* self)
+{
+	if (self->enemy->health > 0)
+		if (visible(self, self->enemy))
+			if (frandom() <= 0.6f)
+			{
+				M_SetAnimation(self, &wyvern_move_attack1);
+				return;
+			}
+	wyvern_run(self);
+}
+
+MONSTERINFO_CHECKATTACK(wyvern_checkattack) (edict_t* self) -> bool
+{
+	if (!self->enemy)
+		return false;
+
+	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.8f, 0.8f, 0.f, 0.f);
+}
+
+static void wyvern_set_fly_parameters(edict_t* self)
+{
+	self->monsterinfo.fly_thrusters = false;
+	self->monsterinfo.fly_acceleration = 20.f;
+	self->monsterinfo.fly_speed = 120.f;
+	self->monsterinfo.fly_min_distance = 550.f;
+	self->monsterinfo.fly_max_distance = 750.f;
+}
+
+/*QUAKED monster_wyvern(1 .5 0) (-16 - 16 - 24) (16 16 32) Ambush Trigger_Spawn Sight
+model="models/monsters/wyvern/tris.md2"
+*/
+
+void SP_monster_wyvern(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_sight1.assign("wyvern/sight1.wav");
+	sound_sight2.assign("wyvern/sight2.wav");
+	sound_search1.assign("wyvern/idle1.wav");
+	sound_search2.assign("wyvern/idle2.wav");
+	sound_search3.assign("wyvern/idlefly.wav");
+	sound_pain1.assign("wyvern/pain1.wav");
+	sound_pain2.assign("wyvern/pain2.wav");
+	sound_die1.assign("wyvern/death.wav");
+	sound_die2.assign("wyvern/death2.wav");
+	sound_attack.assign("wyvern/fire.wav");
+	sound_flame.assign("hknight/attack1.wav");
+	
+	self->s.modelindex = gi.modelindex ("models/monsters/wyvern/tris.md2");
+
+	self->mins = { -48, -64, -36 };
+	self->maxs = { 48, 64, 24 };
+	
+	self->movetype = MOVETYPE_FLY;
+	self->solid = SOLID_BBOX;
+
+	self->health = max(2000, 2000 + 1000 * (skill->integer - 1)) * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_BODY;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = max(350, 350 + 100 * (skill->integer - 1));
+	self->gib_health = -500;
+	self->mass = 500;
+	if (coop->integer)
+	{
+		self->health += (250 * (CountPlayers() - 1));
+		self->monsterinfo.armor_power += (100 * (CountPlayers() - 1));
+	}
+
+	self->pain = wyvern_pain;
+	self->die = wyvern_die;
+
+	self->yaw_speed = 20;
+	
+	self->monsterinfo.stand = wyvern_hover;
+	self->monsterinfo.walk = wyvern_walk;
+	self->monsterinfo.run = wyvern_run;
+	self->monsterinfo.attack = wyvern_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = wyvern_sight;
+	self->monsterinfo.search = wyvern_search;
+	self->monsterinfo.setskin = wyvern_setskin;
+	self->monsterinfo.checkattack = wyvern_checkattack;
+	
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &wyvern_move_hover);	
+	self->monsterinfo.scale = MODEL_SCALE;
+	
+	flymonster_start(self);
+
+	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
+	wyvern_set_fly_parameters(self);
+}
--- /dev/null
+++ b/quake1/m_wyvern.h	2025-09-04 19:53:48
@@ -0,0 +1,76 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_fly1,
+	FRAME_fly2,
+	FRAME_fly3,
+	FRAME_fly4,
+	FRAME_fly5,
+	FRAME_fly6,
+	FRAME_fly7,
+	FRAME_fly8,
+	FRAME_attack1,
+	FRAME_attack2,
+	FRAME_attack3,
+	FRAME_attack4,
+	FRAME_attack5,
+	FRAME_attack6,
+	FRAME_attack7,
+	FRAME_attack8,
+	FRAME_attack9,
+	FRAME_pain1,
+	FRAME_pain2,
+	FRAME_pain3,
+	FRAME_pain4,
+	FRAME_pain5,
+	FRAME_pain6,
+	FRAME_painb1,
+	FRAME_painb2,
+	FRAME_painb3,
+	FRAME_painb4,
+	FRAME_painb5,
+	FRAME_painb6,
+	FRAME_painc1,
+	FRAME_painc2,
+	FRAME_painc3,
+	FRAME_painc4,
+	FRAME_painc5,
+	FRAME_painc6,
+	FRAME_die1,
+	FRAME_die2,
+	FRAME_die3,
+	FRAME_die4,
+	FRAME_die5,
+	FRAME_die6,
+	FRAME_die7,
+	FRAME_die8,
+	FRAME_die9,
+	FRAME_die10,
+	FRAME_die11,
+	FRAME_die12,
+	FRAME_die13,
+	FRAME_dieb1,
+	FRAME_dieb2,
+	FRAME_dieb3,
+	FRAME_dieb4,
+	FRAME_dieb5,
+	FRAME_dieb6,
+	FRAME_implode1,
+	FRAME_implode2,
+	FRAME_implode3,
+	FRAME_implode4,
+	FRAME_implode5,
+	FRAME_implode6,
+	FRAME_implode7,
+	FRAME_implode8,
+	FRAME_spawn1,
+	FRAME_spawn2,
+	FRAME_spawn3,
+	FRAME_spawn4,
+	FRAME_spawn5,
+	FRAME_spawn6,
+	FRAME_spawn7
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/quake1/m_zombie.cpp	2025-09-04 19:53:48
@@ -0,0 +1,765 @@
+/*
+==============================================================================
+
+QUAKE ZOMBIE
+
+==============================================================================
+*/
+
+
+#include "../g_local.h"
+#include "m_zombie.h"
+
+
+static int  sound_idleC;
+static int	sound_idle;
+static int	sound_idle2;
+static int	sound_pain;
+static int	sound_pain2;
+static int  sound_fall;
+static int  sound_gib;
+static int  sound_shot;
+
+void zombie_down(edict_t* self);
+void zombie_fallagain(edict_t* self);
+void zombie_pain2(edict_t* self);
+void zombie_idle3(edict_t* self);
+void zombie_run(edict_t* self);
+void zombie_attack(edict_t* self);
+
+//
+// CRUCIFIED
+//
+
+void zombie_Cidle(edict_t* self)
+{
+	if (frandom() < 0.1)
+		gi.sound(self, CHAN_VOICE, sound_idleC, 1, ATTN_IDLE, 0);
+}
+
+mframe_t zombie_frames_pain5[] =
+{
+	{ ai_move, 0, zombie_pain2 },
+	{ ai_move, -8},
+	{ ai_move, -5},
+	{ ai_move, -3},
+	{ ai_move, -1},
+	{ ai_move, -2},
+	{ ai_move, -1},
+	{ ai_move, -1},
+	{ ai_move, -2},
+	{ ai_move, 0, zombie_down},		//10
+	{ ai_move},
+	{ ai_move, 0, zombie_idle3},
+	{ ai_move, 0, zombie_fallagain},
+	{ ai_move},
+	{ ai_move},				//15
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},	
+	{ ai_move},				//20
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move, 5},
+	{ ai_move, 3},
+	{ ai_move, 1},
+	{ ai_move, -1},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move}			//30
+};
+MMOVE_T(zombie_move_pain5) = { FRAME_paine1, FRAME_paine30, zombie_frames_pain5, zombie_run };
+
+//
+// SOUNDS
+//
+
+void zombie_idle3(edict_t* self)
+{
+	trace_t tr;
+
+	self->health = self->max_health;
+	self->solid = SOLID_BBOX;
+	self->count = 0;
+	gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+	// Check if player is standing on top
+	tr = gi.trace(self->s.origin, self->mins, self->maxs, self->s.origin, self, CONTENTS_PLAYERCLIP | CONTENTS_MONSTER);
+	if (tr.ent && tr.ent->solid != SOLID_BSP)
+	{
+		self->solid = SOLID_NOT;
+		self->count = 1;
+		self->s.frame = FRAME_paine11;
+		self->nextthink += 5_sec;
+		self->pain_debounce_time = level.time + 3_sec;
+	}
+}
+
+void zombie_idle(edict_t* self)
+{
+	if (frandom() > 0.8)
+		gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+
+	if (self->solid == SOLID_NOT)
+		self->solid = SOLID_BBOX;
+}
+
+void zombie_idle2(edict_t* self)
+{
+	if (frandom() > 0.2)
+		gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_idle2, 1, ATTN_IDLE, 0);
+}
+
+MONSTERINFO_SIGHT(zombie_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_NORM, 0);
+
+	if (!self->style && (skill->integer > 0) && (range_to(self, self->enemy) >= RANGE_MID))
+		zombie_attack(self);
+}
+
+void zombie_pain1(edict_t* self)
+{
+	gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+	self->health = self->max_health / 2; //reduce health every revival to make killing easier eventually
+	self->max_health = self->health;
+}
+
+void zombie_pain2(edict_t* self)
+{
+	gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+	self->health = self->max_health / 2; //reduce health every revival to make killing easier eventually
+	self->max_health = self->health;
+}
+
+void zombie_fall(edict_t* self)
+{
+	gi.sound(self, CHAN_VOICE, sound_fall, 1, ATTN_NORM, 0);
+	self->health = self->max_health;
+}
+
+//
+// STAND
+//
+
+mframe_t zombie_frames_stand[] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(zombie_move_stand) = { FRAME_stand1, FRAME_stand15, zombie_frames_stand, nullptr };
+
+MONSTERINFO_STAND(zombie_stand) (edict_t* self) -> void
+{
+	self->solid = SOLID_BBOX;
+	self->count = 0;
+	M_SetAnimation(self, &zombie_move_stand);
+}
+
+
+//Crucified
+void zombie_crucify(edict_t* self);
+
+mframe_t zombie_frames_cruc[] =
+{
+	{ai_stand},
+	{ai_stand, 0, zombie_Cidle},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+};
+MMOVE_T(zombie_crucified) = { FRAME_cruc_1, FRAME_cruc_6, zombie_frames_cruc, zombie_crucify };
+
+void zombie_crucify(edict_t* self)
+{
+	M_SetAnimation(self, &zombie_crucified);
+}
+
+//
+// WALK
+//
+
+mframe_t zombie_frames_walk[] =
+{
+	{ai_walk},
+	{ai_walk, 2},
+	{ai_walk, 3},
+	{ai_walk, 2},
+	{ai_walk, 1},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk, 2},
+	{ai_walk, 2},
+	{ai_walk, 1},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk, 0,  zombie_idle}
+};
+MMOVE_T(zombie_move_walk) = { FRAME_walk1, FRAME_walk19, zombie_frames_walk, nullptr };
+
+MONSTERINFO_WALK(zombie_walk) (edict_t* self) -> void
+{
+	self->solid = SOLID_BBOX;
+	self->count = 0;
+	M_SetAnimation(self, &zombie_move_walk);
+}
+
+//
+// RUN
+//
+
+mframe_t zombie_frames_run[] =
+{
+	{ai_run, 1},
+	{ai_run, 1},
+	{ai_run},
+	{ai_run, 1},
+	{ai_run, 2},
+	{ai_run, 3},
+	{ai_run, 4},
+	{ai_run, 4},
+	{ai_run, 2},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run, 2},
+	{ai_run, 4},
+	{ai_run, 6},
+	{ai_run, 7},
+	{ai_run, 3},
+	{ai_run, 8, zombie_idle2}
+};
+MMOVE_T(zombie_move_run) = { FRAME_run1, FRAME_run18, zombie_frames_run, zombie_run };
+
+MONSTERINFO_RUN(zombie_run) (edict_t* self) -> void
+{
+	self->solid = SOLID_BBOX;
+	self->count = 0;
+
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+	{
+		M_SetAnimation(self, &zombie_move_stand);
+		return;
+	}
+	else
+		M_SetAnimation(self, &zombie_move_run);
+}
+
+
+//
+// ATTACK
+//
+void zombie_firegib(edict_t* self, vec3_t offset)
+{
+	vec3_t	start;
+	vec3_t	forward, right;
+	vec3_t	target;
+	vec3_t	aim;
+	int damage;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	start = M_ProjectFlashSource(self, offset, forward, right);
+
+	target = self->enemy->s.origin;
+
+	if (range_to(self, self->enemy) <= RANGE_MELEE)
+	{
+		target[2] += self->enemy->viewheight;
+	}
+	else if (range_to(self, self->enemy) <= RANGE_NEAR)
+	{
+		target = target + (self->enemy->velocity * -0.04);
+		target[2] += (self->enemy->viewheight * 0.9);
+	}
+	else if (range_to(self, self->enemy) <= RANGE_MID)
+	{
+		target = target + (self->enemy->velocity * -0.08);
+		target[2] += (self->enemy->viewheight * 0.8);
+	}
+	else
+	{
+		target = target + (self->enemy->velocity * -0.01);
+		target[2] += (rand() & self->enemy->viewheight);
+	}
+
+	aim = target - start;
+	aim.normalized();
+
+	if (strcmp(self->classname, "monster_mummy") == 0)
+	{
+		damage = 40;
+	}
+	else
+	{
+		damage = 10;
+	}
+
+	gi.sound(self, CHAN_WEAPON | CHAN_RELIABLE, sound_shot, 1.0, ATTN_NORM, 0);
+
+	if (M_CalculatePitchToFire(self, target, start, aim, 500, 2.5f, false))
+		fire_gib(self, start, aim, damage, 500, (crandom_open() * 10.0f), frandom() * 10.f);
+	else
+		fire_gib(self, start, aim, damage, 500, (crandom_open() * 10.0f), frandom() * 10.f);
+
+}
+
+void zombie_firegib1(edict_t* self)
+{
+	vec3_t offset;
+	offset[0] = -8;
+	offset[1] = -18;
+	offset[2] = 30;
+
+	zombie_firegib(self, offset);
+}
+
+void zombie_firegib2(edict_t* self)
+{
+	vec3_t offset;
+	offset[0] = -8;
+	offset[1] = -18;
+	offset[2] = 30;
+	zombie_firegib(self, offset);
+}
+
+void zombie_firegib3(edict_t* self)
+{
+	vec3_t offset;
+	offset[0] = -8;
+	offset[1] = 22;
+	offset[2] = 30;
+	zombie_firegib(self, offset);
+}
+
+mframe_t zombie_frames_attack1[] =
+{
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge, 0, zombie_firegib1}
+};
+MMOVE_T(zombie_move_attack1) = { FRAME_atta1, FRAME_atta13, zombie_frames_attack1, zombie_run };
+
+mframe_t zombie_frames_attack2[] =
+{
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge, 0, zombie_firegib2}
+};
+MMOVE_T(zombie_move_attack2) = { FRAME_attb1, FRAME_attb14, zombie_frames_attack2, zombie_run };
+
+
+mframe_t zombie_frames_attack3[] =
+{
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge},
+	{ ai_charge, 0, zombie_firegib3}
+};
+MMOVE_T(zombie_move_attack3) = { FRAME_attc1, FRAME_attc12, zombie_frames_attack3, zombie_run };
+
+
+MONSTERINFO_ATTACK(zombie_attack) (edict_t* self) -> void
+{
+	float r = frandom();
+
+	if (self->style)
+		return;
+
+	self->solid = SOLID_BBOX;
+	self->count = 0;
+
+	if (r < 0.3)
+		M_SetAnimation(self, &zombie_move_attack1);
+	else if (r < 0.6)
+		M_SetAnimation(self, &zombie_move_attack2);
+	else
+		M_SetAnimation(self, &zombie_move_attack3);
+}
+
+//
+// PAIN
+//
+
+mframe_t zombie_frames_pain1[] =
+{
+	{ ai_move, 0, zombie_pain1},
+	{ ai_move, 3},
+	{ ai_move, 1},
+	{ ai_move, -1},
+	{ ai_move, -3},
+	{ ai_move, -1},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move}
+};
+MMOVE_T(zombie_move_pain1) = { FRAME_paina1, FRAME_paina12, zombie_frames_pain1, zombie_run };
+
+mframe_t zombie_frames_pain2[] =
+{
+	{ ai_move, 0, zombie_pain2},
+	{ ai_move, -2},
+	{ ai_move, -8},
+	{ ai_move, -6},
+	{ ai_move, -2},
+	{ ai_move, 0},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move, 0, zombie_fall},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move, 1},
+	{ ai_move},
+	{ ai_move}
+};
+MMOVE_T(zombie_move_pain2) = { FRAME_painb1, FRAME_painb28, zombie_frames_pain2, zombie_run };
+
+mframe_t zombie_frames_pain3[] =
+{
+	{ ai_move, 0, zombie_pain2},
+	{ ai_move},
+	{ ai_move, -3},
+	{ ai_move, -1},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move, 1},
+	{ ai_move, 1},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move}
+};
+MMOVE_T(zombie_move_pain3) = { FRAME_painc1, FRAME_painc18, zombie_frames_pain3, zombie_run };
+
+mframe_t zombie_frames_pain4[] =
+{
+	{ ai_move, 0, zombie_pain1},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move, 0},
+	{ ai_move, 0},
+	{ ai_move, 0},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move, -1},
+	{ ai_move},
+	{ ai_move},
+	{ ai_move}
+};
+MMOVE_T(zombie_move_pain4) = { FRAME_paind1, FRAME_paind13, zombie_frames_pain4, zombie_run };
+
+// fall and stand up functions
+
+void zombie_down(edict_t* self)
+{
+	self->solid = SOLID_NOT;
+	zombie_fall(self);
+	self->nextthink += 5_sec;
+}
+
+PAIN(zombie_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	float	r;
+
+	self->health = self->max_health;
+	
+	if (gtime_t::from_sec(self->wait) > level.time)
+
+	{
+		self->dmg += damage;
+		if (self->dmg > 30)
+		{
+			M_SetAnimation(self, &zombie_move_pain5);
+			self->pain_debounce_time = level.time + 3_sec;
+			self->dmg = 0;
+			self->wait = 0;
+			self->solid = SOLID_NOT;
+			self->count = 1;
+			return;
+		}
+	}
+	else
+	{
+		gtime_t::from_sec(self->wait) = level.time + 1_sec;
+		self->dmg = damage;
+	}
+
+	if (damage < 15)
+		return;
+
+	if (damage >= 25)
+	{
+		M_SetAnimation(self, &zombie_move_pain5);
+		self->pain_debounce_time = level.time + 3_sec;
+		self->count = 1;
+		return;
+	}
+
+	if (self->pain_debounce_time > level.time)
+		return;
+
+	r = frandom();
+
+	if (r < 0.25)
+	{
+		self->pain_debounce_time = level.time + 1.0_sec;
+		gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &zombie_move_pain1);
+	}
+	else if (r < 0.5)
+	{
+		self->pain_debounce_time = level.time + 1.5_sec;
+		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &zombie_move_pain2);
+	}
+	else if (r < 0.75)
+	{
+		self->pain_debounce_time = level.time + 1.1_sec;
+		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &zombie_move_pain3);
+	}
+	else
+	{
+		self->pain_debounce_time = level.time + 1.0_sec;
+		M_SetAnimation(self, &zombie_move_pain4);
+	}
+}
+
+void zombie_fallagain(edict_t* self)
+{
+	if (self->pain_debounce_time > level.time)
+	{
+		M_SetAnimation(self, &zombie_move_pain5);
+	}
+}
+
+//
+// DEATH
+//
+
+DIE(zombie_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	int		n;
+
+	gi.sound(self, CHAN_VOICE, sound_gib, 1, ATTN_NORM, 0);
+
+	ThrowGibs(self, 1000, {
+		{ 2, "models/objects/gibs/bone/tris.md2" },
+		{ 4, "models/objects/gibs/sm_meat/tris.md2" },
+		{ "models/monsters/zombie/gibs/head.md2", GIB_HEAD }
+		});
+
+	self->deadflag = true;
+	self->takedamage = true;
+}
+
+MONSTERINFO_CHECKATTACK(mummy_checkattack) (edict_t* self) -> bool
+{
+	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.8f, 0.8f, 0.f, 0.f);
+}
+
+/*QUAKED monster_zombie (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+model="models/monsters/zombie/tris.md2"
+"sounds"  1 makes the zombie crucified
+*/
+
+void SP_misc_zombie_crucified(edict_t* self);
+void SP_monster_zombie(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (self->sounds) // change to different entity because crucified code here is broken
+	{
+		SP_misc_zombie_crucified(self);
+		return;
+	}
+
+	if (deathmatch->value)
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_idleC = gi.soundindex("zombie/idle_w2.wav");
+	sound_idle = gi.soundindex("zombie/z_idle.wav");
+	sound_idle2 = gi.soundindex("zombie/z_idle1.wav");
+	sound_pain = gi.soundindex("zombie/z_pain.wav");
+	sound_pain2 = gi.soundindex("zombie/z_pain1.wav");
+	sound_fall = gi.soundindex("zombie/z_fall.wav");
+	sound_gib = gi.soundindex("zombie/z_gib.wav");
+	sound_shot = gi.soundindex("zombie/z_shot1.wav");
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->s.modelindex = gi.modelindex("models/monsters/zombie/tris.md2");
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 32 };
+
+	self->health = 60 * st.health_multiplier;
+	self->gib_health = 0;
+	self->mass = 100;
+	self->count = 0;
+	self->max_health = self->health;	// save custom health
+
+	self->pain = zombie_pain;
+	self->die = zombie_die;
+
+	self->monsterinfo.stand = zombie_stand;
+	self->monsterinfo.walk = zombie_walk;
+	self->monsterinfo.run = zombie_run;
+	self->monsterinfo.attack = zombie_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = zombie_sight;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &zombie_move_stand);
+	walkmonster_start(self);
+	self->monsterinfo.scale = MODEL_SCALE;
+}
+
+//======================================================================
+// CRUCIFIED ZOMBIE
+//======================================================================
+
+void misc_zombie_crucified_think(edict_t* self)
+{
+	float r1;
+
+	if (++self->s.frame < 198) // was FRAME_death4_22
+		self->nextthink = level.time + FRAME_TIME_S;
+	else
+	{
+		self->s.frame = 192;
+		self->nextthink = level.time + FRAME_TIME_S;
+	}
+	r1 = frandom();
+	if (r1 <= .017)
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("q1zombie/idle_w2.wav"), 1, ATTN_IDLE, 0);
+	}
+}
+
+/*QUAKED misc_zombie_crucified (1 .5 0) (-16 -16 -24) (16 16 32)
+model="models/monsters/q1zombie/"
+frame="192"
+*/
+void SP_misc_zombie_crucified(edict_t* self)
+{
+	// precache
+	gi.soundindex("q1zombie/idle_w2.wav");
+
+	self->movetype = MOVETYPE_NONE;
+	self->solid = SOLID_NOT;
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 32 };
+	self->s.modelindex = gi.modelindex("models/monsters/q1zombie/tris.md2");
+	self->s.frame = 192;
+
+	gi.linkentity(self);
+
+	self->think = misc_zombie_crucified_think;
+	self->nextthink = level.time + FRAME_TIME_S;
+}
+
+/*QUAKED monster_mummy (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+model="models/monsters/zombie/tris.md2"
+"sounds"  1 makes the zombie crucified
+*/
+void SP_monster_mummy(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	SP_monster_zombie(self);
+
+	self->s.skinnum = 1;
+	self->health = max(1500, 1500 + 1000 * (skill->integer - 1)) * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_BODY;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = max(350, 350 + 100 * (skill->integer - 1));
+	if (coop->integer)
+	{
+		self->health += (250 * (CountPlayers() - 1));
+		self->monsterinfo.armor_power += (100 * (CountPlayers() - 1));
+	}
+	self->max_health = self->health;
+
+	self->monsterinfo.checkattack = mummy_checkattack;
+}
--- /dev/null
+++ b/quake1/m_zombie.h	2025-09-04 19:53:48
@@ -0,0 +1,206 @@
+// Generated by ModelEd
+// ZOMBIE
+
+enum
+{
+	FRAME_stand1,
+	FRAME_stand2,
+	FRAME_stand3,
+	FRAME_stand4,
+	FRAME_stand5,
+	FRAME_stand6,
+	FRAME_stand7,
+	FRAME_stand8,
+	FRAME_stand9,
+	FRAME_stand10,
+	FRAME_stand11,
+	FRAME_stand12,
+	FRAME_stand13,
+	FRAME_stand14,
+	FRAME_stand15,
+	FRAME_walk1,
+	FRAME_walk2,
+	FRAME_walk3,
+	FRAME_walk4,
+	FRAME_walk5,
+	FRAME_walk6,
+	FRAME_walk7,
+	FRAME_walk8,
+	FRAME_walk9,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12,
+	FRAME_walk13,
+	FRAME_walk14,
+	FRAME_walk15,
+	FRAME_walk16,
+	FRAME_walk17,
+	FRAME_walk18,
+	FRAME_walk19,
+	FRAME_run1,
+	FRAME_run2,
+	FRAME_run3,
+	FRAME_run4,
+	FRAME_run5,
+	FRAME_run6,
+	FRAME_run7,
+	FRAME_run8,
+	FRAME_run9,
+	FRAME_run10,
+	FRAME_run11,
+	FRAME_run12,
+	FRAME_run13,
+	FRAME_run14,
+	FRAME_run15,
+	FRAME_run16,
+	FRAME_run17,
+	FRAME_run18,
+	FRAME_atta1,
+	FRAME_atta2,
+	FRAME_atta3,
+	FRAME_atta4,
+	FRAME_atta5,
+	FRAME_atta6,
+	FRAME_atta7,
+	FRAME_atta8,
+	FRAME_atta9,
+	FRAME_atta10,
+	FRAME_atta11,
+	FRAME_atta12,
+	FRAME_atta13,
+	FRAME_attb1,
+	FRAME_attb2,
+	FRAME_attb3,
+	FRAME_attb4,
+	FRAME_attb5,
+	FRAME_attb6,
+	FRAME_attb7,
+	FRAME_attb8,
+	FRAME_attb9,
+	FRAME_attb10,
+	FRAME_attb11,
+	FRAME_attb12,
+	FRAME_attb13,
+	FRAME_attb14,
+	FRAME_attc1,
+	FRAME_attc2,
+	FRAME_attc3,
+	FRAME_attc4,
+	FRAME_attc5,
+	FRAME_attc6,
+	FRAME_attc7,
+	FRAME_attc8,
+	FRAME_attc9,
+	FRAME_attc10,
+	FRAME_attc11,
+	FRAME_attc12,
+	FRAME_paina1,
+	FRAME_paina2,
+	FRAME_paina3,
+	FRAME_paina4,
+	FRAME_paina5,
+	FRAME_paina6,
+	FRAME_paina7,
+	FRAME_paina8,
+	FRAME_paina9,
+	FRAME_paina10,
+	FRAME_paina11,
+	FRAME_paina12,
+	FRAME_painb1,
+	FRAME_painb2,
+	FRAME_painb3,
+	FRAME_painb4,
+	FRAME_painb5,
+	FRAME_painb6,
+	FRAME_painb7,
+	FRAME_painb8,
+	FRAME_painb9,
+	FRAME_painb10,
+	FRAME_painb11,
+	FRAME_painb12,
+	FRAME_painb13,
+	FRAME_painb14,
+	FRAME_painb15,
+	FRAME_painb16,
+	FRAME_painb17,
+	FRAME_painb18,
+	FRAME_painb19,
+	FRAME_painb20,
+	FRAME_painb21,
+	FRAME_painb22,
+	FRAME_painb23,
+	FRAME_painb24,
+	FRAME_painb25,
+	FRAME_painb26,
+	FRAME_painb27,
+	FRAME_painb28,
+	FRAME_painc1,
+	FRAME_painc2,
+	FRAME_painc3,
+	FRAME_painc4,
+	FRAME_painc5,
+	FRAME_painc6,
+	FRAME_painc7,
+	FRAME_painc8,
+	FRAME_painc9,
+	FRAME_painc10,
+	FRAME_painc11,
+	FRAME_painc12,
+	FRAME_painc13,
+	FRAME_painc14,
+	FRAME_painc15,
+	FRAME_painc16,
+	FRAME_painc17,
+	FRAME_painc18,
+	FRAME_paind1,
+	FRAME_paind2,
+	FRAME_paind3,
+	FRAME_paind4,
+	FRAME_paind5,
+	FRAME_paind6,
+	FRAME_paind7,
+	FRAME_paind8,
+	FRAME_paind9,
+	FRAME_paind10,
+	FRAME_paind11,
+	FRAME_paind12,
+	FRAME_paind13,
+	FRAME_paine1,
+	FRAME_paine2,
+	FRAME_paine3,
+	FRAME_paine4,
+	FRAME_paine5,
+	FRAME_paine6,
+	FRAME_paine7,
+	FRAME_paine8,
+	FRAME_paine9,
+	FRAME_paine10,
+	FRAME_paine11,
+	FRAME_paine12,
+	FRAME_paine13,
+	FRAME_paine14,
+	FRAME_paine15,
+	FRAME_paine16,
+	FRAME_paine17,
+	FRAME_paine18,
+	FRAME_paine19,
+	FRAME_paine20,
+	FRAME_paine21,
+	FRAME_paine22,
+	FRAME_paine23,
+	FRAME_paine24,
+	FRAME_paine25,
+	FRAME_paine26,
+	FRAME_paine27,
+	FRAME_paine28,
+	FRAME_paine29,
+	FRAME_paine30,
+	FRAME_cruc_1,
+	FRAME_cruc_2,
+	FRAME_cruc_3,
+	FRAME_cruc_4,
+	FRAME_cruc_5,
+	FRAME_cruc_6
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- a/rogue/g_rogue_func.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_func.cpp	2025-09-04 19:53:48
@@ -54,18 +54,18 @@
 		if (!ent->spawnflags.has(SPAWNFLAGS_PLAT2_TOGGLE))
 		{
 			ent->think = plat2_go_down;
-			ent->nextthink = level.time + 5_sec;
+			ent->nextthink = level.time + gtime_t::from_sec(ent->wait * 2.5f);
 		}
 		if (deathmatch->integer)
-			ent->last_move_time = level.time - 1_sec;
+			ent->last_move_time = level.time - gtime_t::from_sec(ent->wait * 0.5f);
 		else
-			ent->last_move_time = level.time - 2_sec;
+			ent->last_move_time = level.time - gtime_t::from_sec(ent->wait);
 	}
 	else if (!(ent->spawnflags & SPAWNFLAGS_PLAT2_TOP) && !ent->spawnflags.has(SPAWNFLAGS_PLAT2_TOGGLE))
 	{
 		ent->plat2flags = PLAT2_NONE;
 		ent->think = plat2_go_down;
-		ent->nextthink = level.time + 2_sec;
+		ent->nextthink = level.time + gtime_t::from_sec(ent->wait);
 		ent->last_move_time = level.time;
 	}
 	else
@@ -93,18 +93,18 @@
 		if (!(ent->spawnflags & SPAWNFLAGS_PLAT2_TOGGLE))
 		{
 			ent->think = plat2_go_up;
-			ent->nextthink = level.time + 5_sec;
+			ent->nextthink = level.time + gtime_t::from_sec(ent->wait * 2.5f);
 		}
 		if (deathmatch->integer)
-			ent->last_move_time = level.time - 1_sec;
+			ent->last_move_time = level.time - gtime_t::from_sec(ent->wait * 0.5f);
 		else
-			ent->last_move_time = level.time - 2_sec;
+			ent->last_move_time = level.time - gtime_t::from_sec(ent->wait);
 	}
 	else if (ent->spawnflags.has(SPAWNFLAGS_PLAT2_TOP) && !ent->spawnflags.has(SPAWNFLAGS_PLAT2_TOGGLE))
 	{
 		ent->plat2flags = PLAT2_NONE;
 		ent->think = plat2_go_up;
-		ent->nextthink = level.time + 2_sec;
+		ent->nextthink = level.time + gtime_t::from_sec(ent->wait);
 		ent->last_move_time = level.time;
 	}
 	else
@@ -164,7 +164,7 @@
 	if (ent->plat2flags & PLAT2_MOVING)
 		return;
 
-	if ((ent->last_move_time + 2_sec) > level.time)
+	if ((ent->last_move_time + gtime_t::from_sec(ent->wait)) > level.time)
 		return;
 
 	platCenter = (trigger->absmin[2] + trigger->absmax[2]) / 2;
@@ -338,6 +338,8 @@
 */
 void SP_func_plat2(edict_t *ent)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	edict_t *trigger;
 
 	ent->s.angles = {};
@@ -373,9 +375,6 @@
 	// PMM Added to kill things it's being blocked by
 	if (!ent->dmg)
 		ent->dmg = 2;
-
-	//	if (!st.lip)
-	//		st.lip = 8;
 
 	// pos1 is the top position, pos2 is the bottom
 	ent->pos1 = ent->s.origin;
@@ -426,5 +425,8 @@
 	ent->moveinfo.end_origin = ent->pos2;
 	ent->moveinfo.end_angles = ent->s.angles;
 
+	if (!ent->wait)
+		ent->wait = 2.0f;
+
 	G_SetMoveinfoSounds(ent, "plats/pt1_strt.wav", "plats/pt1_mid.wav", "plats/pt1_end.wav");
 }
--- a/rogue/g_rogue_items.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_items.cpp	2025-09-04 19:53:48
@@ -204,11 +204,16 @@
 		self->velocity = forward * 100;
 		self->velocity[2] = 300;
 	}
-
-	if (self->item->id != IT_KEY_POWER_CUBE && self->item->id != IT_KEY_EXPLOSIVE_CHARGES) // leave them be on key_power_cube..
-		self->spawnflags &= SPAWNFLAG_ITEM_NO_TOUCH;
-
-	droptofloor(self);
+	
+	if (!self->spawnflags.has(SPAWNFLAG_ITEM_NO_DROP))
+	{
+		if (self->item->id != IT_KEY_POWER_CUBE && self->item->id != IT_KEY_EXPLOSIVE_CHARGES) // leave them be on key_power_cube..
+			self->spawnflags &= SPAWNFLAG_ITEM_NO_TOUCH;
+	}
+	else
+		self->spawnflags &= ~SPAWNFLAG_ITEM_TRIGGER_SPAWN;
+
+    droptofloor(self);
 }
 
 //=================
--- a/rogue/g_rogue_monster.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_monster.cpp	2025-09-04 19:53:48
@@ -85,11 +85,11 @@
 		stationarymonster_triggered_start(self);
 }
 
-void stationarymonster_start(edict_t *self)
+void stationarymonster_start(edict_t *self, const spawn_temp_t &st)
 {
 	self->flags |= FL_STATIONARY;
 	self->think = stationarymonster_start_go;
-	monster_start(self);
+	monster_start(self, st);
 
 	// fix viewheight
 	self->viewheight = 0;
--- a/rogue/g_rogue_newdm.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_newdm.cpp	2025-09-04 19:53:48
@@ -13,7 +13,6 @@
 //=================
 constexpr item_flags_t IF_TYPE_MASK = (IF_WEAPON | IF_AMMO | IF_POWERUP | IF_ARMOR | IF_KEY);
 
-void ED_CallSpawn(edict_t *ent);
 bool Pickup_Health(edict_t *ent, edict_t *other);
 bool Pickup_Armor(edict_t *ent, edict_t *other);
 bool Pickup_PowerArmor(edict_t *ent, edict_t *other);
--- a/rogue/g_rogue_newweap.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_newweap.cpp	2025-09-04 19:53:48
@@ -86,11 +86,11 @@
 constexpr float	  PROX_BOUND_SIZE = 96;
 constexpr float	  PROX_DAMAGE_RADIUS = 192;
 constexpr int32_t PROX_HEALTH = 20;
-constexpr int32_t PROX_DAMAGE = 90;
+constexpr int32_t PROX_DAMAGE = 60;
+constexpr float   PROX_DAMAGE_OPEN_MULTIPLIER = 1.5f; // expands 60 to 90 when it opens
 
 //===============
-//===============
-THINK(Prox_Explode) (edict_t *ent) -> void
+static void Prox_ExplodeReal(edict_t *ent, edict_t *other, vec3_t normal)
 {
 	vec3_t	 origin;
 	edict_t *owner;
@@ -108,14 +108,20 @@
 		PlayerNoise(owner, ent->s.origin, PNOISE_IMPACT);
 	}
 
+	if (other)
+	{
+		vec3_t dir = other->s.origin - ent->s.origin;
+		T_Damage(other, ent, owner, dir, ent->s.origin, normal, ent->dmg, ent->dmg, DAMAGE_NONE, MOD_PROX);
+	}
+
 	// play quad sound if appopriate
-	if (ent->dmg > PROX_DAMAGE)
+	if (ent->dmg > PROX_DAMAGE * PROX_DAMAGE_OPEN_MULTIPLIER)
 		gi.sound(ent, CHAN_ITEM, gi.soundindex("items/damage3.wav"), 1, ATTN_NORM, 0);
 
 	ent->takedamage = false;
-	T_RadiusDamage(ent, owner, (float) ent->dmg, ent, PROX_DAMAGE_RADIUS, DAMAGE_NONE, MOD_PROX);
-
-	origin = ent->s.origin + (ent->velocity * -0.02f);
+	T_RadiusDamage(ent, owner, (float) ent->dmg, other, PROX_DAMAGE_RADIUS, DAMAGE_NONE, MOD_PROX);
+
+	origin = ent->s.origin + normal;
 	gi.WriteByte(svc_temp_entity);
 	if (ent->groundentity)
 		gi.WriteByte(TE_GRENADE_EXPLOSION);
@@ -125,6 +131,11 @@
 	gi.multicast(ent->s.origin, MULTICAST_PHS, false);
 
 	G_FreeEdict(ent);
+}
+
+THINK(Prox_Explode) (edict_t *ent) -> void
+{
+	Prox_ExplodeReal(ent, nullptr, (ent->velocity * -0.02f));
 }
 
 //===============
@@ -252,7 +263,7 @@
 			ent->wait = (level.time + PROX_TIME_TO_LIVE).seconds();
 		else
 		{
-			switch (ent->dmg / PROX_DAMAGE)
+			switch ((int) (ent->dmg / (PROX_DAMAGE * PROX_DAMAGE_OPEN_MULTIPLIER)))
 			{
 			case 1:
 				ent->wait = (level.time + PROX_TIME_TO_LIVE).seconds();
@@ -278,7 +289,10 @@
 	else
 	{
 		if (ent->s.frame == 0)
+		{
 			gi.sound(ent, CHAN_VOICE, gi.soundindex("weapons/proxopen.wav"), 1, ATTN_NORM, 0);
+			ent->dmg *= PROX_DAMAGE_OPEN_MULTIPLIER;
+		}
 		ent->s.frame++;
 		ent->think = prox_open;
 		ent->nextthink = level.time + 10_hz;
@@ -320,7 +334,7 @@
 	if (!tr.plane.normal || (other->svflags & SVF_MONSTER) || other->client || (other->flags & FL_DAMAGEABLE))
 	{
 		if (other != ent->teammaster)
-			Prox_Explode(ent);
+			Prox_ExplodeReal(ent, other, tr.plane.normal);
 
 		return;
 	}
@@ -631,7 +645,7 @@
 		G_FreeEdict(self);
 }
 
-static void Nuke_Explode(edict_t *ent)
+void Nuke_Explode(edict_t *ent)
 {
 
 	if (ent->teammaster->client)
--- a/rogue/g_rogue_spawn.cpp	2023-10-03 19:43:06
+++ b/rogue/g_rogue_spawn.cpp	2025-09-04 19:53:48
@@ -30,9 +30,7 @@
 //
 edict_t *CreateMonster(const vec3_t &origin, const vec3_t &angles, const char *classname)
 {
-	edict_t *newEnt;
-
-	newEnt = G_Spawn();
+	edict_t *newEnt = G_Spawn();
 
 	newEnt->s.origin = origin;
 	newEnt->s.angles = angles;
--- a/rogue/m_rogue_carrier.cpp	2023-10-03 19:43:06
+++ b/rogue/m_rogue_carrier.cpp	2025-09-04 19:53:48
@@ -28,8 +28,6 @@
 bool inback(edict_t *self, edict_t *other);
 bool below(edict_t *self, edict_t *other);
 void drawbbox(edict_t *self);
-
-void ED_CallSpawn(edict_t *ent);
 
 static cached_soundindex sound_pain1;
 static cached_soundindex sound_pain2;
@@ -43,10 +41,10 @@
 
 float orig_yaw_speed;
 
-void M_SetupReinforcements(const char *reinforcements, reinforcement_list_t &list);
-std::array<uint8_t, MAX_REINFORCEMENTS> M_PickReinforcements(edict_t *self, int32_t &num_chosen, int32_t max_slots);
-
 extern const mmove_t flyer_move_attack2, flyer_move_attack3, flyer_move_kamikaze;
+
+/* KONIG - universal boss powerup copy */
+void BossPowerups(edict_t* self);
 
 void carrier_run(edict_t *self);
 void carrier_dead(edict_t *self);
@@ -356,9 +354,9 @@
 		ent->nextthink = level.time;
 		ent->think(ent);
 
-		ent->monsterinfo.aiflags |= AI_SPAWNED_CARRIER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
+		ent->monsterinfo.aiflags |= AI_SPAWNED_COMMANDER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
 		ent->monsterinfo.commander = self;
-		ent->monsterinfo.monster_slots = reinforcement.strength;
+		ent->monsterinfo.slots_from_commander = reinforcement.strength;
 		self->monsterinfo.monster_used += reinforcement.strength;
 
 		if ((self->enemy->inuse) && (self->enemy->health > 0))
@@ -954,10 +952,11 @@
 
 MONSTERINFO_SETSKIN(carrier_setskin) (edict_t *self) -> void
 {
+	/* KONIG - set for multiple skins*/
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
+		self->s.skinnum |= 1;
 	else
-		self->s.skinnum = 0;
+		self->s.skinnum &= ~1;
 }
 
 void carrier_dead(edict_t *self)
@@ -1021,6 +1020,8 @@
 			return true;
 		}
 	}
+	/* KONIG - universal boss powerup copy */
+	BossPowerups(self);
 
 	return M_CheckAttack_Base(self, 0.4f, 0.8f, 0.8f, 0.8f, 0.5f, 0.f);
 }
@@ -1055,6 +1056,8 @@
  */
 void SP_monster_carrier(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1093,10 +1096,17 @@
 	self->maxs = { 56, 56, 44 };
 
 	// 2000 - 4000 health
+	/* KONIG - add body armor; new coop scaling*/
 	self->health = max(2000, 2000 + 1000 * (skill->integer - 1)) * st.health_multiplier;
-	// add health in coop (500 * skill)
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_BODY;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = max(250, 250 + 100 * (skill->integer - 1));
 	if (coop->integer)
-		self->health += 500 * skill->integer;
+	{
+		self->health += (250 * (CountPlayers() - 1));
+		self->monsterinfo.armor_power += (100 * (CountPlayers() - 1));
+	}
 
 	self->gib_health = -200;
 	self->mass = 1000;
@@ -1148,6 +1158,6 @@
 	self->monsterinfo.fly_acceleration = 5.f;
 	self->monsterinfo.fly_speed = 50.f;
 	self->monsterinfo.fly_above = true;
-	self->monsterinfo.fly_min_distance = 1000.f;
-	self->monsterinfo.fly_max_distance = 1000.f;
-}
+	self->monsterinfo.fly_min_distance = 500.f;
+	self->monsterinfo.fly_max_distance = 600.f;
+}
--- a/rogue/m_rogue_stalker.cpp	2023-10-03 19:43:06
+++ b/rogue/m_rogue_stalker.cpp	2025-09-04 19:53:48
@@ -58,7 +58,7 @@
 	else
 	{
 		// her stalkers are just better
-		if (self->monsterinfo.aiflags & AI_SPAWNED_WIDOW)
+		if (self->monsterinfo.commander && self->monsterinfo.commander->inuse && !strncmp(self->monsterinfo.commander->classname, "monster_widow", 13))
 			max_dist = 256;
 		else
 			max_dist = 180;
@@ -427,10 +427,11 @@
 
 MONSTERINFO_SETSKIN(stalker_setskin) (edict_t *self) -> void
 {
+	/* KONIG - set for multiple skins*/
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
-	else
-		self->s.skinnum = 0;
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 // ******************
@@ -974,6 +975,8 @@
 
 void SP_monster_stalker(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- a/rogue/m_rogue_turret.cpp	2023-10-03 19:43:06
+++ b/rogue/m_rogue_turret.cpp	2025-09-04 19:53:48
@@ -297,6 +297,11 @@
 
 MONSTERINFO_STAND(turret_stand) (edict_t *self) -> void
 {
+	if (self->waterlevel <= WATER_WAIST)
+		self->flags |= FL_SWIM;
+	else
+		self->flags &= FL_SWIM;
+
 	M_SetAnimation(self, &turret_move_stand);
 	if (self->target_ent)
 	{
@@ -368,10 +373,9 @@
 //  ATTACK
 // **********************
 
-constexpr int32_t TURRET_BLASTER_DAMAGE = 8;
-constexpr int32_t TURRET_BULLET_DAMAGE = 2;
-// unused
-// constexpr int32_t TURRET_HEAT_DAMAGE	= 4;
+constexpr int32_t TURRET_BLASTER_DAMAGE	= 8;
+constexpr int32_t TURRET_BULLET_DAMAGE	= 2;
+constexpr int32_t TURRET_HEAT_DAMAGE	= 4;
 
 void TurretFire(edict_t *self)
 {
@@ -428,7 +432,7 @@
 		{
 			// on harder difficulties, randomly fire directly at enemy
 			// more often; makes them more unpredictable
-			if (self->spawnflags.has(SPAWNFLAG_TURRET_MACHINEGUN))
+			if (self->spawnflags.has(SPAWNFLAG_TURRET_MACHINEGUN) || self->spawnflags.has(SPAWNFLAG_TURRET_HEATBEAM))
 				PredictAim(self, self->enemy, start, 0, true, 0.3f, &dir, nullptr);
 			else if (frandom() < skill->integer / 5.f)
 				PredictAim(self, self->enemy, start, (float) rocketSpeed, true, (frandom(3.f - skill->integer) / 3.f) - frandom(0.05f * (3.f - skill->integer)), &dir, nullptr);
@@ -461,6 +465,28 @@
 					if (self->monsterinfo.duck_wait_time < level.time)
 						self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
 				}
+			}/* KONIG - adding Heatbeam */
+			else if (self->spawnflags.has(SPAWNFLAG_TURRET_HEATBEAM))
+			{
+				if (!(self->monsterinfo.aiflags & AI_HOLD_FRAME))
+				{
+					self->monsterinfo.aiflags |= AI_HOLD_FRAME;
+					self->monsterinfo.duck_wait_time = level.time + 2_sec + gtime_t::from_sec(frandom(skill->value));
+					self->monsterinfo.next_duck_time = level.time + 1_sec;
+					gi.sound(self, CHAN_VOICE, gi.soundindex("weapons/bfg__l1a.wav"), 1, ATTN_NORM, 0);
+				}
+				else
+				{
+					if (self->monsterinfo.next_duck_time < level.time &&
+						self->monsterinfo.melee_debounce_time <= level.time)
+					{
+						monster_fire_heatbeam(self, start, dir, vec3_origin, TURRET_HEAT_DAMAGE, 10, MZ2_TURRET_ROCKET);
+						self->monsterinfo.melee_debounce_time = level.time + 10_hz;
+					}
+
+					if (self->monsterinfo.duck_wait_time < level.time)
+						self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+				}
 			}
 			else if (self->spawnflags.has(SPAWNFLAG_TURRET_ROCKET))
 			{
@@ -729,7 +755,7 @@
 
 	gi.linkentity(ent);
 
-	stationarymonster_start(ent);
+	stationarymonster_start(ent, spawn_temp_t::empty);
 
 	if (ent->spawnflags.has(SPAWNFLAG_TURRET_MACHINEGUN))
 	{
@@ -738,6 +764,10 @@
 	else if (ent->spawnflags.has(SPAWNFLAG_TURRET_ROCKET))
 	{
 		ent->s.skinnum = 2;
+	}/* KONIG - adding Heatbeam */
+	else if (ent->spawnflags.has(SPAWNFLAG_TURRET_HEATBEAM))
+	{
+		ent->s.skinnum = 3;
 	}
 
 	// but we do want the death to count
@@ -916,6 +946,7 @@
 */
 void SP_monster_turret(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
 	int angle;
 
 	if ( !M_AllowSpawn( self ) ) {
@@ -951,12 +982,6 @@
 	// map designer didn't specify weapon type. set it now.
 	if (!self->spawnflags.has(SPAWNFLAG_TURRET_WEAPONCHOICE))
 		self->spawnflags |= SPAWNFLAG_TURRET_BLASTER;
-
-	if (self->spawnflags.has(SPAWNFLAG_TURRET_HEATBEAM))
-	{
-		self->spawnflags &= ~SPAWNFLAG_TURRET_HEATBEAM;
-		self->spawnflags |= SPAWNFLAG_TURRET_BLASTER;
-	}
 
 	if (!self->spawnflags.has(SPAWNFLAG_TURRET_WALL_UNIT))
 	{
@@ -1030,7 +1055,7 @@
 	}
 	else
 	{
-		stationarymonster_start(self);
+		stationarymonster_start(self, ED_GetSpawnTemp());
 	}
 
 	if (self->spawnflags.has(SPAWNFLAG_TURRET_MACHINEGUN))
@@ -1051,6 +1076,15 @@
 
 		self->spawnflags &= ~SPAWNFLAG_TURRET_WEAPONCHOICE;
 		self->spawnflags |= SPAWNFLAG_TURRET_ROCKET;
+	}/* KONIG - adding Heatbeam */
+	else if (self->spawnflags.has(SPAWNFLAG_TURRET_HEATBEAM))
+	{
+		gi.soundindex("weapons/bfg__l1a.wav");
+		gi.modelindex("models/proj/beam/tris.md2");
+		self->s.skinnum = 3;
+
+		self->spawnflags &= ~SPAWNFLAG_TURRET_WEAPONCHOICE;
+		self->spawnflags |= SPAWNFLAG_TURRET_HEATBEAM;
 	}
 	else
 	{
--- a/rogue/m_rogue_widow.cpp	2023-10-03 19:43:06
+++ b/rogue/m_rogue_widow.cpp	2025-09-04 19:53:48
@@ -274,11 +274,12 @@
 
 			self->monsterinfo.monster_used++;
 			ent->monsterinfo.commander = self;
+			ent->monsterinfo.slots_from_commander = 1;
 
 			ent->nextthink = level.time;
 			ent->think(ent);
 
-			ent->monsterinfo.aiflags |= AI_SPAWNED_WIDOW | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
+			ent->monsterinfo.aiflags |= AI_SPAWNED_COMMANDER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
 
 			if (!coop->integer)
 			{
@@ -970,10 +971,11 @@
 
 MONSTERINFO_SETSKIN(widow_setskin) (edict_t *self) -> void
 {
+	/* KONIG - set for multiple skins*/
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
+		self->s.skinnum |= 1;
 	else
-		self->s.skinnum = 0;
+		self->s.skinnum &= ~1;
 }
 
 void widow_dead(edict_t *self)
@@ -1026,6 +1028,9 @@
 	// I don't like this, but it works
 	if (self->monsterinfo.power_armor_power <= 0)
 		self->monsterinfo.power_armor_power += 250 * skill->integer;
+	/* KONIG - extra in coop */
+	if (coop->integer)
+		self->monsterinfo.power_armor_power += ((25 * skill->integer) + (25 * (CountPlayers() - 1)));
 }
 
 void WidowRespondPowerup(edict_t *self, edict_t *other)
@@ -1243,6 +1248,8 @@
  */
 void SP_monster_widow(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1259,18 +1266,19 @@
 	self->mins = { -40, -40, 0 };
 	self->maxs = { 40, 40, 144 };
 
-	self->health = (2000 + 1000 * skill->integer) * st.health_multiplier;
-	if (coop->integer)
-		self->health += 500 * skill->integer;
+	/* KONIG - minor rebalance to scaling */
+	self->health = max(2000, 2000 + 1250 * (skill->integer - 1)) * st.health_multiplier;
 	self->gib_health = -5000;
 	self->mass = 1500;
 
-	if (skill->integer == 3)
-	{
-		if (!st.was_key_specified("power_armor_type"))
-			self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
-		if (!st.was_key_specified("power_armor_power"))
-			self->monsterinfo.power_armor_power = 500;
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = max(500, 500 + 150 * (skill->integer - 1));
+	if (coop->integer)
+	{
+		self->health += (500 * skill->integer) + (500 * (CountPlayers() - 1));
+		self->monsterinfo.power_armor_power += (250 * skill->integer) + (250 * (CountPlayers() - 1));
 	}
 
 	self->yaw_speed = 30;
--- a/rogue/m_rogue_widow2.cpp	2023-10-03 19:43:06
+++ b/rogue/m_rogue_widow2.cpp	2025-09-04 19:53:48
@@ -36,7 +36,7 @@
 
 bool infront(edict_t *self, edict_t *other);
 void WidowCalcSlots(edict_t *self);
-void WidowPowerups(edict_t *self);
+unsigned int widow2_damage_multiplier;
 
 void widow2_run(edict_t *self);
 void widow2_dead(edict_t *self);
@@ -111,7 +111,7 @@
 		target[2] += self->enemy->viewheight - 10;
 		forward = target - start;
 		forward.normalize();
-		monster_fire_heatbeam(self, start, forward, vec3_origin, 10, 50, flashnum);
+		monster_fire_heatbeam(self, start, forward, vec3_origin, 10 * widow2_damage_multiplier, 50, flashnum);
 	}
 	else if ((self->s.frame >= FRAME_spawn04) && (self->s.frame <= FRAME_spawn14))
 	{
@@ -127,7 +127,7 @@
 		vec[YAW] -= sweep_angles[flashnum - MZ2_WIDOW2_BEAM_SWEEP_1];
 
 		AngleVectors(vec, forward, nullptr, nullptr);
-		monster_fire_heatbeam(self, start, forward, vec3_origin, 10, 50, flashnum);
+		monster_fire_heatbeam(self, start, forward, vec3_origin, 10 * widow2_damage_multiplier, 50, flashnum);
 	}
 	else
 	{
@@ -140,7 +140,7 @@
 		forward = target - start;
 		forward.normalize();
 
-		monster_fire_heatbeam(self, start, forward, vec3_origin, 10, 50, MZ2_WIDOW2_BEAM_SWEEP_1);
+		monster_fire_heatbeam(self, start, forward, vec3_origin, 10 * widow2_damage_multiplier, 50, MZ2_WIDOW2_BEAM_SWEEP_1);
 	}
 }
 
@@ -167,11 +167,12 @@
 
 			self->monsterinfo.monster_used++;
 			ent->monsterinfo.commander = self;
+			ent->monsterinfo.slots_from_commander = 1;
 
 			ent->nextthink = level.time;
 			ent->think(ent);
 
-			ent->monsterinfo.aiflags |= AI_SPAWNED_WIDOW | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
+			ent->monsterinfo.aiflags |= AI_SPAWNED_COMMANDER | AI_DO_NOT_COUNT | AI_IGNORE_SHOTS;
 
 			if (!coop->integer)
 			{
@@ -310,12 +311,12 @@
 		dir = self->pos1 - start;
 		dir.normalize();
 
-		monster_fire_tracker(self, start, dir, 20, 500, self->enemy, MZ2_WIDOW_DISRUPTOR);
+		monster_fire_tracker(self, start, dir, 20 * widow2_damage_multiplier, 500, self->enemy, MZ2_WIDOW_DISRUPTOR);
 	}
 	else
 	{
 		PredictAim(self, self->enemy, start, 1200, true, 0, &dir, nullptr);
-		monster_fire_tracker(self, start, dir, 20, 1200, nullptr, MZ2_WIDOW_DISRUPTOR);
+		monster_fire_tracker(self, start, dir, 20 * widow2_damage_multiplier, 1200, nullptr, MZ2_WIDOW_DISRUPTOR);
 	}
 
 	widow2_step(self);
@@ -511,11 +512,11 @@
 	// 70 + 32
 	aim = { 150, 0, 4 };
 	if (self->s.frame != FRAME_tongs07)
-		fire_hit(self, aim, irandom(20, 26), 0);
+		fire_hit(self, aim, irandom(20, 26) * widow2_damage_multiplier, 0);
 	else if (self->enemy->groundentity)
-		fire_hit(self, aim, irandom(20, 26), 500);
+		fire_hit(self, aim, irandom(20, 26) * widow2_damage_multiplier, 500);
 	else // not as much kick if they're in the air .. makes it harder to land on her head
-		fire_hit(self, aim, irandom(20, 26), 250);
+		fire_hit(self, aim, irandom(20, 26) * widow2_damage_multiplier, 250);
 }
 
 void Widow2Toss(edict_t *self)
@@ -873,10 +874,11 @@
 
 MONSTERINFO_SETSKIN(widow2_setskin) (edict_t *self) -> void
 {
+	/* KONIG - set for multiple skins*/
 	if (self->health < (self->max_health / 2))
-		self->s.skinnum = 1;
-	else
-		self->s.skinnum = 0;
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
 }
 
 void widow2_dead(edict_t *self)
@@ -950,12 +952,120 @@
 	M_SetAnimation(self, &widow2_move_death);
 }
 
+void Widow2GoinQuad(edict_t* self, gtime_t time)
+{
+	self->monsterinfo.quad_time = time;
+	widow2_damage_multiplier = 4;
+}
+
+void Widow2Double(edict_t* self, gtime_t time)
+{
+	self->monsterinfo.double_time = time;
+	widow2_damage_multiplier = 2;
+}
+
+void Widow2Pent(edict_t* self, gtime_t time)
+{
+	self->monsterinfo.invincible_time = time;
+}
+
+void Widow2PowerArmor(edict_t* self)
+{
+	self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+	// I don't like this, but it works
+	if (self->monsterinfo.power_armor_power <= 0)
+		self->monsterinfo.power_armor_power += 250 * skill->integer;
+	if (coop->integer)
+		self->monsterinfo.power_armor_power += ((25 * skill->integer) + (25 * (CountPlayers() - 1)));
+}
+
+void Widow2RespondPowerup(edict_t* self, edict_t* other)
+{
+	if (other->s.effects & EF_QUAD)
+	{
+		Widow2PowerArmor(self);
+		if (skill->integer >= 1)
+			Widow2GoinQuad(self, other->client->quad_time);
+	}
+	else if (other->s.effects & EF_DOUBLE)
+	{
+		Widow2PowerArmor(self);
+		if (skill->integer >= 1)
+			Widow2Double(self, other->client->double_time);
+	}
+	else
+		widow2_damage_multiplier = 1;
+
+	if (other->s.effects & EF_PENT)
+	{
+		if (skill->integer >= 2)
+			Widow2Pent(self, other->client->invincible_time);
+		else if (skill->integer == 1)
+			Widow2PowerArmor(self);
+	}
+}
+
+void Widow2Powerups(edict_t* self)
+{
+	edict_t* ent;
+
+	if (!coop->integer)
+	{
+		Widow2RespondPowerup(self, self->enemy);
+	}
+	else
+	{
+		// in coop, check for pents, then quads, then doubles
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			if (ent->s.effects & EF_PENT)
+			{
+				Widow2RespondPowerup(self, ent);
+				return;
+			}
+		}
+
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			if (ent->s.effects & EF_QUAD)
+			{
+				Widow2RespondPowerup(self, ent);
+				return;
+			}
+		}
+
+		for (uint32_t player = 1; player <= game.maxclients; player++)
+		{
+			ent = &g_edicts[player];
+			if (!ent->inuse)
+				continue;
+			if (!ent->client)
+				continue;
+			if (ent->s.effects & EF_DOUBLE)
+			{
+				Widow2RespondPowerup(self, ent);
+				return;
+			}
+		}
+	}
+}
+
 MONSTERINFO_CHECKATTACK(Widow2_CheckAttack) (edict_t *self) -> bool
 {
 	if (!self->enemy)
 		return false;
 
-	WidowPowerups(self);
+	Widow2Powerups(self);
 
 	if ((frandom() < 0.8f) && (M_SlotsLeft(self) >= 2) && (realrange(self, self->enemy) > 150))
 	{
@@ -1002,6 +1112,8 @@
  */
 void SP_monster_widow2(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1022,26 +1134,19 @@
 	self->mins = { -70, -70, 0 };
 	self->maxs = { 70, 70, 144 };
 
-	self->health = (2000 + 800 + 1000 * skill->integer) * st.health_multiplier;
+	/* KONIG - rebalanced health and armor; power armor -> body armor for ETF efficiency */
+	self->health = max(2500, 2500 + 1250 * (skill->integer - 1)) * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_BODY;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = max(500, 500 + 150 * (skill->integer - 1));
 	if (coop->integer)
-		self->health += 500 * skill->integer;
-	//	self->health = 1;
+	{
+		self->health += (500 * skill->integer) + (500 * (CountPlayers() - 1));
+		self->monsterinfo.armor_power += (250 * skill->integer) + (250 * (CountPlayers() - 1));
+	}
 	self->gib_health = -900;
 	self->mass = 2500;
-
-	/*	if (skill->integer == 2)
-		{
-			self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
-			self->monsterinfo.power_armor_power = 500;
-		}
-		else */
-	if (skill->integer == 3)
-	{
-		if (!st.was_key_specified("power_armor_type"))
-			self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
-		if (!st.was_key_specified("power_armor_power"))
-			self->monsterinfo.power_armor_power = 750;
-	}
 
 	self->yaw_speed = 30;
 
--- a/rogue/p_rogue_weapon.cpp	2023-10-03 19:43:06
+++ b/rogue/p_rogue_weapon.cpp	2025-09-04 19:53:48
@@ -247,7 +247,7 @@
 	G_RemoveAmmo(self);
 }
 
-void Weapon_Disintegrator(edict_t *ent)
+void Weapon_Disruptor(edict_t *ent)
 {
 	constexpr int pause_frames[] = { 14, 19, 23, 0 };
 	constexpr int fire_frames[] = { 5, 0 };
--- a/rogue/rogue_dm_tag.cpp	2023-10-03 19:43:06
+++ b/rogue/rogue_dm_tag.cpp	2025-09-04 19:53:48
@@ -293,5 +293,5 @@
 	self->classname = "dm_tag_token";
 	self->model = "models/items/tagtoken/tris.md2";
 	self->count = 1;
-	SpawnItem(self, GetItemByIndex(IT_ITEM_TAG_TOKEN));
-}
+	SpawnItem(self, GetItemByIndex(IT_ITEM_TAG_TOKEN), ED_GetSpawnTemp());
+}
--- a/vcpkg.json	2023-10-03 19:43:06
+++ b/vcpkg.json	2025-09-04 19:53:48
@@ -5,5 +5,6 @@
   "dependencies": [
     "fmt",
     "jsoncpp"
-  ]
+  ],
+  "builtin-baseline": "e590c2b30c08caf1dd8d612ec602a003f9784b7d"
 }
--- a/xatrix/g_xatrix_items.cpp	2023-10-03 19:43:06
+++ b/xatrix/g_xatrix_items.cpp	2025-09-04 19:53:48
@@ -13,7 +13,7 @@
 	}
 
 	self->model = "models/objects/trapfx/tris.md2";
-	SpawnItem(self, GetItemByIndex(IT_HEALTH_SMALL));
+	SpawnItem(self, GetItemByIndex(IT_HEALTH_SMALL), ED_GetSpawnTemp());
 	self->spawnflags |= SPAWNFLAG_ITEM_DROPPED;
 	self->style = HEALTH_IGNORE_MAX;
 	self->classname = "item_foodcube";
--- a/xatrix/g_xatrix_misc.cpp	2023-10-03 19:43:06
+++ b/xatrix/g_xatrix_misc.cpp	2025-09-04 19:53:48
@@ -137,6 +137,29 @@
  */
 extern void target_killplayers_use(edict_t *self, edict_t *other, edict_t *activator);
 
+void Nuke_Explode(edict_t* self);
+
+static THINK(misc_nuke_think) (edict_t* self) -> void {
+	Nuke_Explode(self);
+}
+
+static USE(misc_nuke_use) (edict_t* self, edict_t* other, edict_t* activator) -> void {
+	edict_t* nuke;
+
+	nuke = G_Spawn();
+	nuke->s.origin = self->s.origin;
+	nuke->clipmask = MASK_PROJECTILE;
+	nuke->solid = SOLID_NOT;
+	nuke->mins = { -1, -1, 1 };
+	nuke->maxs = { 1, 1, 1 };
+	nuke->owner = self;
+	nuke->teammaster = self;
+	nuke->nextthink = level.time + FRAME_TIME_S;
+	nuke->dmg = 800;
+	nuke->dmg_radius = 8192;
+	nuke->think = misc_nuke_think;
+}
+
 void SP_misc_nuke(edict_t *ent)
 {
 	ent->use = target_killplayers_use;
--- a/xatrix/g_xatrix_monster.cpp	2023-10-03 19:43:06
+++ b/xatrix/g_xatrix_monster.cpp	2025-09-04 19:53:48
@@ -97,8 +97,6 @@
 	gi.linkentity(self);
 }
 
-constexpr spawnflags_t SPAWNFLAG_DABEAM_SECONDARY = 1_spawnflag;
-
 THINK(beam_think) (edict_t *self) -> void
 {
 	if (self->spawnflags.has(SPAWNFLAG_DABEAM_SECONDARY))
@@ -137,6 +135,8 @@
 	}
 
 	beam_ptr->nextthink = level.time + 200_ms;
+	beam_ptr->spawnflags &= ~SPAWNFLAG_DABEAM_SPAWNED;
 	update_func(beam_ptr);
 	dabeam_update(beam_ptr, true);
+	beam_ptr->spawnflags |= SPAWNFLAG_DABEAM_SPAWNED;
 }
--- a/xatrix/g_xatrix_weapon.cpp	2023-10-03 19:43:06
+++ b/xatrix/g_xatrix_weapon.cpp	2025-09-04 19:53:48
@@ -135,51 +135,61 @@
 
 THINK(heat_think) (edict_t *self) -> void
 {
-	edict_t *target = nullptr;
 	edict_t *acquire = nullptr;
-	vec3_t	 vec;
-	vec3_t	 oldang;
-	float	 len;
 	float	 oldlen = 0;
-	float	 dot, olddot = 1;
+	float	 olddot = 1;
 
 	vec3_t fwd = AngleVectors(self->s.angles).forward;
 
-	// acquire new target
-	while ((target = findradius(target, self->s.origin, 1024)) != nullptr)
-	{
-		if (self->owner == target)
-			continue;
-		if (!target->client)
-			continue;
-		if (target->health <= 0)
-			continue;
-		if (!visible(self, target))
-			continue;
-		//if (!infront(self, target))
-		//	continue;
-
-		vec = self->s.origin - target->s.origin;
-		len = vec.length();
-
-		dot = vec.normalized().dot(fwd);
-
-		// targets that require us to turn less are preferred
-		if (dot >= olddot)
-			continue;
-
-		if (acquire == nullptr || dot < olddot || len < oldlen)
-		{
-			acquire = target;
-			oldlen = len;
-			olddot = dot;
+	// try to stay on current target if possible
+	if (self->enemy)
+	{
+		acquire = self->enemy;
+
+		if (acquire->health <= 0 ||
+			!visible(self, acquire))
+		{
+			self->enemy = acquire = nullptr;
+		}
+	}
+
+	if (!acquire)
+	{
+		edict_t *target = nullptr;
+
+		// acquire new target
+		while ((target = findradius(target, self->s.origin, 1024)) != nullptr)
+		{
+			if (self->owner == target)
+				continue;
+			if (!target->client)
+				continue;
+			if (target->health <= 0)
+				continue;
+			if (!visible(self, target))
+				continue;
+
+			vec3_t vec = self->s.origin - target->s.origin;
+			float len = vec.length();
+
+			float dot = vec.normalized().dot(fwd);
+
+			// targets that require us to turn less are preferred
+			if (dot >= olddot)
+				continue;
+
+			if (acquire == nullptr || dot < olddot || len < oldlen)
+			{
+				acquire = target;
+				oldlen = len;
+				olddot = dot;
+			}
 		}
 	}
 
 	if (acquire != nullptr)
 	{
-		oldang = self->s.angles;
-		vec = (acquire->s.origin - self->s.origin).normalized();
+		vec3_t vec = (acquire->s.origin - self->s.origin).normalized();
 		float t = self->accel;
 
 		float d = self->movedir.dot(vec);
@@ -190,7 +200,7 @@
 		self->movedir = slerp(self->movedir, vec, t).normalized();
 		self->s.angles = vectoangles(self->movedir);
 
-		if (!self->enemy)
+		if (self->enemy != acquire)
 		{
 			gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/railgr1a.wav"), 1.f, 0.25f, 0);
 			self->enemy = acquire;
@@ -233,6 +243,12 @@
 	heat->dmg_radius = damage_radius;
 	heat->s.sound = gi.soundindex("weapons/rockfly.wav");
 
+	if (visible(heat, self->enemy))
+	{
+		heat->enemy = self->enemy;
+		gi.sound(heat, CHAN_WEAPON, gi.soundindex("weapons/railgr1a.wav"), 1.f, 0.25f, 0);
+	}
+
 	gi.linkentity(heat);
 }
 
@@ -259,11 +275,11 @@
 		PlayerNoise(ent->owner, ent->s.origin, PNOISE_IMPACT);
 
 	// calculate position for the explosion entity
-	origin = ent->s.origin + (ent->velocity * -0.02f);
+	origin = ent->s.origin + tr.plane.normal;
 
 	if (other->takedamage)
 	{
-		T_Damage(other, ent, ent->owner, ent->velocity, ent->s.origin, tr.plane.normal, ent->dmg, 0, DAMAGE_ENERGY, MOD_PHALANX);
+		T_Damage(other, ent, ent->owner, ent->velocity, ent->s.origin, tr.plane.normal, ent->dmg, ent->dmg, DAMAGE_ENERGY, MOD_PHALANX);
 	}
 
 	T_RadiusDamage(ent, ent->owner, (float) ent->radius_dmg, other, ent->dmg_radius, DAMAGE_ENERGY, MOD_PHALANX);
@@ -502,7 +518,7 @@
 
 		if (len < 48)
 		{
-			if (best->mass < 400)
+			if (best->mass <= 400)
 			{
 				ent->takedamage = false;
 				ent->solid = SOLID_NOT;
--- a/xatrix/m_xatrix_fixbot.cpp	2023-10-03 19:43:06
+++ b/xatrix/m_xatrix_fixbot.cpp	2025-09-04 19:53:48
@@ -55,51 +55,14 @@
 	self->nextthink = level.time + 1_ms;
 }
 
-void ED_CallSpawn(edict_t *ent);
+edict_t *healFindMonster(edict_t *self, float radius);
 
 edict_t *fixbot_FindDeadMonster(edict_t *self)
 {
-	edict_t *ent = nullptr;
-	edict_t *best = nullptr;
-
-	while ((ent = findradius(ent, self->s.origin, 1024)) != nullptr)
-	{
-		if (ent == self)
-			continue;
-		if (!(ent->svflags & SVF_MONSTER))
-			continue;
-		if (ent->monsterinfo.aiflags & AI_GOOD_GUY)
-			continue;
-		// check to make sure we haven't bailed on this guy already
-		if ((ent->monsterinfo.badMedic1 == self) || (ent->monsterinfo.badMedic2 == self))
-			continue;
-		if (ent->monsterinfo.healer)
-			// FIXME - this is correcting a bug that is somewhere else
-			// if the healer is a monster, and it's in medic mode .. continue .. otherwise
-			//   we will override the healer, if it passes all the other tests
-			if ((ent->monsterinfo.healer->inuse) && (ent->monsterinfo.healer->health > 0) &&
-				(ent->monsterinfo.healer->svflags & SVF_MONSTER) && (ent->monsterinfo.healer->monsterinfo.aiflags & AI_MEDIC))
-				continue;
-		if (ent->health > 0)
-			continue;
-		if ((ent->nextthink) && (ent->think != monster_dead_think))
-			continue;
-		if (!visible(self, ent))
-			continue;
-		if (!best)
-		{
-			best = ent;
-			continue;
-		}
-		if (ent->max_health <= best->max_health)
-			continue;
-		best = ent;
-	}
-
-	return best;
-}
-
-static void fixbot_set_fly_parameters(edict_t *self, bool heal, bool weld)
+	return healFindMonster(self, 1024);
+}
+
+static void fixbot_set_fly_parameters(edict_t *self, bool heal, bool weld, bool roam)
 {
 	self->monsterinfo.fly_position_time = 0_sec;
 	self->monsterinfo.fly_acceleration = 5.f;
@@ -112,10 +75,10 @@
 		self->monsterinfo.fly_max_distance = 100.f;
 		self->monsterinfo.fly_thrusters = true;
 	}
-	else if (weld)
-	{
-		self->monsterinfo.fly_min_distance = 24.f;
-		self->monsterinfo.fly_max_distance = 24.f;
+	else if (weld || roam)
+	{
+		self->monsterinfo.fly_min_distance = 16.f;
+		self->monsterinfo.fly_max_distance = 16.f;
 	}
 	else
 	{
@@ -139,7 +102,7 @@
 			self->enemy->monsterinfo.healer = self;
 			self->monsterinfo.aiflags |= AI_MEDIC;
 			FoundTarget(self);
-			fixbot_set_fly_parameters(self, true, false);
+			fixbot_set_fly_parameters(self, true, false, false);
 			return (1);
 		}
 	}
@@ -204,33 +167,37 @@
 	M_SetAnimation(self, &fixbot_move_takeoff);
 }
 
+
+constexpr spawnflags_t SPAWNFLAG_FIXBOT_FLAGS = SPAWNFLAG_FIXBOT_FIXIT | SPAWNFLAG_FIXBOT_TAKEOFF | SPAWNFLAG_FIXBOT_LANDING | SPAWNFLAG_FIXBOT_WORKING;
+
 void change_to_roam(edict_t *self)
 {
 
 	if (fixbot_search(self))
 		return;
 
+	fixbot_set_fly_parameters(self, false, false, true);
 	M_SetAnimation(self, &fixbot_move_roamgoal);
 
 	if (self->spawnflags.has(SPAWNFLAG_FIXBOT_LANDING))
 	{
 		landing_goal(self);
 		M_SetAnimation(self, &fixbot_move_landing);
-		self->spawnflags &= ~SPAWNFLAG_FIXBOT_LANDING;
-		self->spawnflags = SPAWNFLAG_FIXBOT_WORKING;
+		self->spawnflags &= ~SPAWNFLAG_FIXBOT_FLAGS;
+		self->spawnflags |= SPAWNFLAG_FIXBOT_WORKING;
 	}
 	if (self->spawnflags.has(SPAWNFLAG_FIXBOT_TAKEOFF))
 	{
 		takeoff_goal(self);
 		M_SetAnimation(self, &fixbot_move_takeoff);
-		self->spawnflags &= ~SPAWNFLAG_FIXBOT_TAKEOFF;
-		self->spawnflags = SPAWNFLAG_FIXBOT_WORKING;
+		self->spawnflags &= ~SPAWNFLAG_FIXBOT_FLAGS;
+		self->spawnflags |= SPAWNFLAG_FIXBOT_WORKING;
 	}
 	if (self->spawnflags.has(SPAWNFLAG_FIXBOT_FIXIT))
 	{
 		M_SetAnimation(self, &fixbot_move_roamgoal);
-		self->spawnflags &= ~SPAWNFLAG_FIXBOT_FIXIT;
-		self->spawnflags = SPAWNFLAG_FIXBOT_WORKING;
+		self->spawnflags &= ~SPAWNFLAG_FIXBOT_FLAGS;
+		self->spawnflags |= SPAWNFLAG_FIXBOT_WORKING;
 	}
 	if (!self->spawnflags)
 	{
@@ -321,9 +288,9 @@
 					vec = self->s.origin - self->goalentity->s.origin;
 					len = vec.normalize();
 
-					fixbot_set_fly_parameters(self, false, true);
-
-					if (len < 32)
+					fixbot_set_fly_parameters(self, false, true, false);
+
+					if (len < 86.0f)
 					{
 						M_SetAnimation(self, &fixbot_move_weld_start);
 						return;
@@ -343,7 +310,7 @@
 	vec = self->s.origin - self->goalentity->s.origin;
 	len = vec.length();
 
-	if (len < 32)
+	if (len < 86.0f)
 	{
 		if (strcmp(self->goalentity->classname, "object_repair") == 0)
 		{
@@ -357,27 +324,6 @@
 			M_SetAnimation(self, &fixbot_move_stand);
 		}
 		return;
-	}
-
-	vec = self->s.origin - self->s.old_origin;
-	len = vec.length();
-
-	/*
-	  bot is stuck get new goalentity
-	*/
-	if (len == 0)
-	{
-		if (strcmp(self->goalentity->classname, "object_repair") == 0)
-		{
-			M_SetAnimation(self, &fixbot_move_stand);
-		}
-		else
-		{
-			self->goalentity->nextthink = level.time + 100_ms;
-			self->goalentity->think = G_FreeEdict;
-			self->goalentity = self->enemy = nullptr;
-			M_SetAnimation(self, &fixbot_move_stand);
-		}
 	}
 }
 
@@ -919,7 +865,8 @@
 MMOVE_T(fixbot_move_attack1) = { FRAME_shoot_01, FRAME_shoot_06, fixbot_frames_attack1, nullptr };
 #endif
 
-void abortHeal(edict_t *self, bool change_frame, bool gib, bool mark);
+void abortHeal(edict_t *self, bool gib, bool mark);
+bool finishHeal(edict_t *self);
 
 PRETHINK(fixbot_laser_update) (edict_t *laser) -> void
 {
@@ -955,114 +902,33 @@
 		return;
 	}
 
-	monster_fire_dabeam(self, -1, false, fixbot_laser_update);
-
-	if (self->enemy->health > (self->enemy->mass / 10))
-	{
-		vec3_t maxs;
-		self->enemy->spawnflags = SPAWNFLAG_NONE;
-		self->enemy->monsterinfo.aiflags &= AI_STINKY | AI_SPAWNED_MASK;
-		self->enemy->target = nullptr;
-		self->enemy->targetname = nullptr;
-		self->enemy->combattarget = nullptr;
-		self->enemy->deathtarget = nullptr;
-		self->enemy->healthtarget = nullptr;
-		self->enemy->itemtarget = nullptr;
-		self->enemy->monsterinfo.healer = self;
-
-		maxs = self->enemy->maxs;
-		maxs[2] += 48; // compensate for change when they die
-
-		trace_t tr = gi.trace(self->enemy->s.origin, self->enemy->mins, maxs, self->enemy->s.origin, self->enemy, MASK_MONSTERSOLID);
-		if (tr.startsolid || tr.allsolid)
+	// fire the beam until they're within res range
+	bool firedLaser = false;
+
+	if (self->enemy->health < (self->enemy->mass / 10))
+	{
+		firedLaser = true;
+		monster_fire_dabeam(self, -1, false, fixbot_laser_update);
+	}
+
+	if (self->enemy->health >= (self->enemy->mass / 10))
+	{
+		// we have enough health now; if we didn't fire
+		// a laser, just make a fake one
+		if (!firedLaser)
+			monster_fire_dabeam(self, 0, false, fixbot_laser_update);
+		else
+			self->monsterinfo.fly_position_time = {};
+		
+		// change our fly parameter slightly so we back away
+		self->monsterinfo.fly_min_distance = self->monsterinfo.fly_max_distance = 200.f;
+
+		// don't revive if we are too close
+		if ((self->s.origin - self->enemy->s.origin).length() > 86.f)
 		{
-			abortHeal(self, false, true, false);
-			return;
+			finishHeal(self);
+			M_SetAnimation(self, &fixbot_move_stand);
 		}
-		else if (tr.ent != world)
-		{
-			abortHeal(self, false, true, false);
-			return;
-		}
-		else
-		{
-			self->enemy->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT;
-
-			// backup & restore health stuff, because of multipliers
-			int32_t old_max_health = self->enemy->max_health;
-			item_id_t old_power_armor_type = self->enemy->monsterinfo.initial_power_armor_type;
-			int32_t old_power_armor_power = self->enemy->monsterinfo.max_power_armor_power;
-			int32_t old_base_health = self->enemy->monsterinfo.base_health;
-			int32_t old_health_scaling = self->enemy->monsterinfo.health_scaling;
-			auto reinforcements = self->enemy->monsterinfo.reinforcements;
-			int32_t monster_slots = self->enemy->monsterinfo.monster_slots;
-			int32_t monster_used = self->enemy->monsterinfo.monster_used;
-			int32_t old_gib_health = self->enemy->gib_health;
-
-			st = {};
-			st.keys_specified.emplace("reinforcements");
-			st.reinforcements = "";
-
-			ED_CallSpawn(self->enemy);
-
-			self->enemy->monsterinfo.reinforcements = reinforcements;
-			self->enemy->monsterinfo.monster_slots = monster_slots;
-			self->enemy->monsterinfo.monster_used = monster_used;
-
-			self->enemy->gib_health = old_gib_health / 2;
-			self->enemy->health = self->enemy->max_health = old_max_health;
-			self->enemy->monsterinfo.power_armor_power = self->enemy->monsterinfo.max_power_armor_power = old_power_armor_power;
-			self->enemy->monsterinfo.power_armor_type = self->enemy->monsterinfo.initial_power_armor_type = old_power_armor_type;
-			self->enemy->monsterinfo.base_health = old_base_health;
-			self->enemy->monsterinfo.health_scaling = old_health_scaling;
-
-			if (self->enemy->monsterinfo.setskin)
-				self->enemy->monsterinfo.setskin(self->enemy);
-
-			if (self->enemy->think)
-			{
-				self->enemy->nextthink = level.time;
-				self->enemy->think(self->enemy);
-			}
-			self->enemy->monsterinfo.aiflags &= ~AI_RESURRECTING;
-			self->enemy->monsterinfo.aiflags |= AI_IGNORE_SHOTS | AI_DO_NOT_COUNT;
-			// turn off flies
-			self->enemy->s.effects &= ~EF_FLIES;
-			self->enemy->monsterinfo.healer = nullptr;
-
-			// clean up target, if we have one and it's legit
-			if (self->enemy && self->enemy->inuse)
-			{
-				cleanupHealTarget(self->enemy);
-
-				if ((self->oldenemy) && (self->oldenemy->inuse) && (self->oldenemy->health > 0))
-				{
-					self->enemy->enemy = self->oldenemy;
-					FoundTarget(self->enemy);
-				}
-				else
-				{
-					self->enemy->enemy = nullptr;
-					if (!FindTarget(self->enemy))
-					{
-						// no valid enemy, so stop acting
-						self->enemy->monsterinfo.pausetime = HOLD_FOREVER;
-						self->enemy->monsterinfo.stand(self->enemy);
-					}
-					self->enemy = nullptr;
-					self->oldenemy = nullptr;
-					if (!FindTarget(self))
-					{
-						// no valid enemy, so stop acting
-						self->monsterinfo.pausetime = HOLD_FOREVER;
-						self->monsterinfo.stand(self);
-						return;
-					}
-				}
-			}
-		}
-
-		M_SetAnimation(self, &fixbot_move_stand);
 	}
 	else
 		self->enemy->monsterinfo.aiflags |= AI_RESURRECTING;
@@ -1132,7 +998,10 @@
 			M_SetAnimation(self, &fixbot_move_weld_end);
 		}
 		else
-			self->goalentity->health -= 10;
+		{
+			if (!(self->spawnflags.has(SPAWNFLAG_MONSTER_SCENIC)))
+				self->goalentity->health -= 10;
+		}
 	}
 	else
 	{
@@ -1206,6 +1075,14 @@
 	if (!self->enemy)
 		return;
 
+	if (self->spawnflags.has(SPAWNFLAG_MONSTER_SCENIC))
+	{
+		if (self->timestamp >= level.time)
+			return;
+
+		self->timestamp = level.time + random_time(450_ms, 1500_ms);
+	}
+
 	vec[0] = 24.0;
 	vec[1] = -0.8f;
 	vec[2] = -10.0;
@@ -1258,7 +1135,22 @@
 	dir = end - start;
 	dir.normalize();
 
-	monster_fire_blaster(self, start, dir, 15, 1000, MZ2_HOVER_BLASTER_1, EF_BLASTER);
+	/* KONIG - laser instead of blaster for fixbot2*/
+	if (self->style == 1)
+	{
+		// PMM - changed to wait from pausetime to not interfere with dodge code
+		if (!(self->monsterinfo.aiflags & AI_HOLD_FRAME))
+			self->monsterinfo.fire_wait = level.time + random_time(300_ms, 1.1_sec);
+
+		monster_fire_dabeam(self, 1, false, fixbot_laser_update);
+
+		if (level.time >= self->monsterinfo.fire_wait)
+			self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+		else
+			self->monsterinfo.aiflags |= AI_HOLD_FRAME;
+	}
+	else
+		monster_fire_blaster(self, start, dir, 15, 1000, MZ2_HOVER_BLASTER_1, EF_BLASTER);
 }
 
 MONSTERINFO_STAND(fixbot_stand) (edict_t *self) -> void
@@ -1315,7 +1207,7 @@
 	}
 	else
 	{
-		fixbot_set_fly_parameters(self, false, false);
+		fixbot_set_fly_parameters(self, false, false, false);
 		M_SetAnimation(self, &fixbot_move_attack2);
 	}
 }
@@ -1325,7 +1217,7 @@
 	if (level.time < self->pain_debounce_time)
 		return;
 
-	fixbot_set_fly_parameters(self, false, false);
+	fixbot_set_fly_parameters(self, false, false, false);
 	self->pain_debounce_time = level.time + 3_sec;
 	gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
 
@@ -1336,7 +1228,7 @@
 	else
 		M_SetAnimation(self, &fixbot_move_paina);
 
-	abortHeal(self, false, false, false);
+	abortHeal(self, false, false);
 }
 
 void fixbot_dead(edict_t *self)
@@ -1361,6 +1253,8 @@
  */
 void SP_monster_fixbot(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
@@ -1397,7 +1291,20 @@
 	M_SetAnimation(self, &fixbot_move_stand);
 	self->monsterinfo.scale = MODEL_SCALE;
 	self->monsterinfo.aiflags |= AI_ALTERNATE_FLY;
-	fixbot_set_fly_parameters(self, false, false);
+	fixbot_set_fly_parameters(self, false, false, false);
 
 	flymonster_start(self);
 }
+
+/*QUAKED monster_fixbot2 (1 .5 0) (-32 -32 -24) (32 32 24) Ambush Trigger_Spawn Fixit Takeoff Landing
+*/
+/*KONIG - Repair Bot from Q4 as Fixbot Beta*/
+void SP_monster_fixbot2(edict_t* self)
+{
+	SP_monster_fixbot(self);
+
+	self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	self->monsterinfo.armor_power = 50;
+	self->style = 1;
+	self->s.skinnum = 1;
+}
--- a/xatrix/m_xatrix_gekk.cpp	2023-10-03 19:43:06
+++ b/xatrix/m_xatrix_gekk.cpp	2025-09-04 19:53:48
@@ -661,63 +661,6 @@
 	}
 }
 
-TOUCH(loogie_touch) (edict_t *self, edict_t *other, const trace_t &tr, bool other_touching_self) -> void
-{
-
-	if (other == self->owner)
-		return;
-
-	if (tr.surface && (tr.surface->flags & SURF_SKY))
-	{
-		G_FreeEdict(self);
-		return;
-	}
-
-	if (self->owner->client)
-		PlayerNoise(self->owner, self->s.origin, PNOISE_IMPACT);
-
-	if (other->takedamage)
-		T_Damage(other, self, self->owner, self->velocity, self->s.origin, tr.plane.normal, self->dmg, 1, DAMAGE_ENERGY, MOD_GEKK);
-	
-	gi.sound(self, CHAN_AUTO, loogie_hit, 1.0f, ATTN_NORM, 0);
-
-	G_FreeEdict(self);
-};
-
-void fire_loogie(edict_t *self, const vec3_t &start, const vec3_t &dir, int damage, int speed)
-{
-	edict_t *loogie;
-	trace_t	 tr;
-
-	loogie = G_Spawn();
-	loogie->s.origin = start;
-	loogie->s.old_origin = start;
-	loogie->s.angles = vectoangles(dir);
-	loogie->velocity = dir * speed;
-	loogie->movetype = MOVETYPE_FLYMISSILE;
-	loogie->clipmask = MASK_PROJECTILE;
-	loogie->solid = SOLID_BBOX;
-	// Paril: this was originally the wrong effect,
-	// but it makes it look more acid-y.
-	loogie->s.effects |= EF_BLASTER;
-	loogie->s.renderfx |= RF_FULLBRIGHT;
-	loogie->s.modelindex = gi.modelindex("models/objects/loogy/tris.md2");
-	loogie->owner = self;
-	loogie->touch = loogie_touch;
-	loogie->nextthink = level.time + 2_sec;
-	loogie->think = G_FreeEdict;
-	loogie->dmg = damage;
-	loogie->svflags |= SVF_PROJECTILE;
-	gi.linkentity(loogie);
-
-	tr = gi.traceline(self->s.origin, loogie->s.origin, loogie, MASK_PROJECTILE);
-	if (tr.fraction < 1.0f)
-	{
-		loogie->s.origin = tr.endpos + (tr.plane.normal * 1.f);
-		loogie->touch(loogie, tr.ent, tr, false);
-	}
-}
-
 void loogie(edict_t *self)
 {
 	vec3_t start;
@@ -739,7 +682,7 @@
 	dir = end - start;
 	dir.normalize();
 
-	fire_loogie(self, start, dir, 5, 550);
+	fire_acid(self, start, dir, 5, 550);
 
 	gi.sound(self, CHAN_BODY, sound_speet, 1.0f, ATTN_NORM, 0);
 }
@@ -1584,6 +1527,8 @@
  */
 void SP_monster_gekk(edict_t *self)
 {
+	const spawn_temp_t &st = ED_GetSpawnTemp();
+
 	if ( !M_AllowSpawn( self ) ) {
 		G_FreeEdict( self );
 		return;
--- /dev/null
+++ b/zaero/g_zaero_func.cpp	2025-09-04 19:53:48
@@ -0,0 +1,79 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+
+void barrier_think(edict_t* self)
+{
+	if (!self)
+	{
+		return;
+	}
+
+	if (self->timeout > level.time)
+	{
+		self->svflags &= ~SVF_NOCLIENT;
+	}
+	else
+	{
+		self->svflags |= SVF_NOCLIENT;
+	}
+
+	self->nextthink = level.time + FRAME_TIME_S;
+}
+
+PAIN(barrier_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (!self)
+	{
+		return;
+	}
+
+	self->timeout = level.time + FRAME_TIME_S * 2;
+	if (self->damage_debounce_time < level.time)
+	{
+		gi.sound(self, CHAN_AUTO, gi.soundindex("weapons/lashit.wav"), 1, ATTN_NORM, 0);
+		self->damage_debounce_time = level.time + FRAME_TIME_S * 2;
+	}
+}
+
+TOUCH(barrier_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (!self || !other)
+	{
+		return;
+	}
+
+	if (other == world)
+		return;
+
+	self->timeout = level.time + FRAME_TIME_S * 2;
+	if (self->touch_debounce_time < level.time)
+	{
+		gi.sound(self, CHAN_AUTO, gi.soundindex("weapons/lashit.wav"), 1, ATTN_NORM, 0);
+		self->touch_debounce_time = level.time + FRAME_TIME_S * 2;
+	}
+
+}
+
+void SP_func_barrier(edict_t* self)
+{
+	if (!self)
+	{
+		return;
+	}
+
+	self->solid = SOLID_BBOX;
+	self->movetype = MOVETYPE_NONE;
+	self->s.modelindex = gi.modelindex("models/objects/wall/tris.md2");
+	self->svflags = SVF_NOCLIENT;
+	self->s.effects = EF_BFG;
+
+	self->think = barrier_think;
+	self->nextthink = level.time + FRAME_TIME_S;
+	self->touch = barrier_touch;
+	self->health = 1;
+	self->takedamage = false;
+	self->pain = barrier_pain;
+
+	gi.linkentity(self);
+}
--- /dev/null
+++ b/zaero/g_zaero_misc.cpp	2025-09-04 19:53:48
@@ -0,0 +1,256 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+
+void barrel_touch(edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self);
+void barrel_start(edict_t* self);
+
+void setupCrate(edict_t* self)
+{
+	if (deathmatch->integer)
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	self->solid = SOLID_BBOX;
+	self->movetype = MOVETYPE_FALLFLOAT;
+
+	if (!self->mass)
+		self->mass = 400;
+
+	self->touch = barrel_touch;
+	self->think = barrel_start;
+	self->nextthink = level.time + FRAME_TIME_S;
+
+	gi.linkentity(self);
+}
+
+/*QUAKED misc_crate (1 .5 0) ( -32 -32 0) (32 32 64 )
+model="models/objects/crate/crate64.md2"
+*/
+void SP_misc_crate(edict_t* self)
+{
+	if (!self->mass)
+		self->mass = 400;
+
+	self->model = "models/objects/crate/crate64.md2";
+	self->s.modelindex = gi.modelindex(self->model);
+	self->mins = { -32, -32, 0 };
+	self->maxs = { 32, 32, 64 };
+
+	setupCrate(self);
+}
+
+/*QUAKED misc_crate_medium (1 .5 0) ( -24 -24 0) (24 24 48 )
+model="models/objects/crate/crate48.md2"
+*/
+void SP_misc_crate_medium(edict_t* self)
+{
+	if (!self->mass)
+		self->mass = 150;
+
+	self->model = "models/objects/crate/crate48.md2";
+	self->s.modelindex = gi.modelindex(self->model);
+	self->mins = { -24, -24, 0 };
+	self->maxs = { 24, 24, 48 };
+
+	setupCrate(self);
+}
+
+/*QUAKED misc_crate_small (1 .5 0) ( -16 -16 0) (16 16 32 )
+model="models/objects/crate/crate32.md2"
+*/
+void SP_misc_crate_small(edict_t* self)
+{
+	if (!self->mass)
+		self->mass = 50;
+
+	self->model = "models/objects/crate/crate32.md2";
+	self->s.modelindex = gi.modelindex(self->model);
+	self->mins = { -16, -16, 0 };
+	self->maxs = { 16, 16, 32 };
+
+	setupCrate(self);
+}
+
+/*QUAKED misc_crate_seat (1 .5 0) ( -16 -16 0) (16 16 40 )
+model="models/objects/seat/tris.md2"
+*/
+void SP_misc_seat(edict_t* self)
+{
+	if (deathmatch->integer)
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	self->solid = SOLID_BBOX;
+	self->movetype = MOVETYPE_STEP;
+
+	if (!self->mass)
+		self->mass = 50;
+
+	self->model = "models/objects/seat/tris.md2";
+	self->s.modelindex = gi.modelindex(self->model);
+	self->mins = { -16, -16, 0 };
+	self->maxs = { 16, 16, 40 };
+
+	self->touch = barrel_touch;
+	self->think = barrel_start;
+	self->nextthink = level.time + FRAME_TIME_S;
+
+	gi.linkentity(self);
+}
+
+/*QUAKED misc_commdish (0 .5 .8) (-16 -16 0) (16 16 40)
+model="models/objects/commdish/tris.md2"
+*/
+THINK(commdish_think) (edict_t* ent) -> void
+{
+	ent->s.frame++;
+
+	if (ent->s.frame >= 98)
+	{
+		ent->s.frame = 98;
+	}
+	else
+	{
+		ent->nextthink = level.time + FRAME_TIME_S;
+	}
+}
+
+THINK(commdish_start) (edict_t* self) -> void
+{
+	M_droptofloor(self);
+	self->nextthink = level.time + FRAME_TIME_S;
+}
+
+USE(commdish_use) (edict_t* self, edict_t* other, edict_t* activator) -> void
+{
+	self->think = commdish_think;
+	self->use = nullptr;
+	gi.sound(self, CHAN_AUTO, gi.soundindex("misc/commdish.wav"), 1, ATTN_NORM, 0);
+	self->nextthink = level.time + FRAME_TIME_S;
+}
+
+void SP_misc_commdish(edict_t* ent)
+{
+	if (deathmatch->value)
+	{	// auto-remove for deathmatch
+		G_FreeEdict(ent);
+		return;
+	}
+
+	ent->solid = SOLID_BBOX;
+	ent->movetype = MOVETYPE_STEP;
+
+	ent->mins = { -100, -100, 0 };
+	ent->maxs = { 100, 100, 275 };
+	ent->s.modelindex = gi.modelindex("models/objects/satdish/tris.md2");
+
+	ent->monsterinfo.aiflags = AI_NOSTEP;
+
+	ent->think = commdish_start;
+	ent->nextthink = level.time + 20_hz;
+	ent->use = commdish_use;
+
+	gi.linkentity(ent);
+}
+
+//ZAERO CUT
+
+/*QUAKED misc_bulldog_s (1 .5 0) (-116 -56 -32) (40 56 16)
+This is a ship from ZAERO for the flybys.
+It is trigger_spawned, so you must have something use it for it to show up.
+There must be a path for it to follow once it is activated.
+
+"speed"		How fast it should fly
+*/
+USE(misc_bulldog_use) (edict_t* self, edict_t* other, edict_t* activator) -> void
+{
+	self->svflags &= ~SVF_NOCLIENT;
+	self->use = train_use;
+	train_use(self, other, activator);
+}
+
+void SP_misc_bulldog_s(edict_t* ent)
+{
+	if (!ent->target)
+	{
+		gi.Com_PrintFmt("{} without a target\n", *ent);
+		G_FreeEdict(ent);
+		return;
+	}
+
+	if (!ent->speed)
+		ent->speed = 300;
+
+	ent->movetype = MOVETYPE_PUSH;
+	ent->solid = SOLID_NOT;
+	ent->s.modelindex = gi.modelindex("models/ships/bulldog_s/main/tris.md2");
+	ent->s.modelindex2 = gi.modelindex("models/ships/bulldog_s/left/tris.md2");
+	ent->s.modelindex3 = gi.modelindex("models/ships/bulldog_s/right/tris.md2");
+	ent->mins = { -116, -56, -32 };
+	ent->maxs = { 40, 56, 16 };
+
+	ent->think = func_train_find;
+	ent->nextthink = level.time + 10_hz;
+	ent->use = misc_bulldog_use;
+	ent->svflags |= SVF_NOCLIENT;
+	ent->moveinfo.accel = ent->moveinfo.decel = ent->moveinfo.speed = ent->speed;
+
+	gi.linkentity(ent);
+}
+
+/*QUAKED misc_bulldog_, (1 .5 0) (-224 -112 -32) (80 112 64)
+This is a larger ship from ZAERO for the flybys.
+It is trigger_spawned, so you must have something use it for it to show up.
+There must be a path for it to follow once it is activated.
+
+"speed"		How fast it should fly
+*/
+void SP_misc_bulldog_m(edict_t* ent)
+{
+	if (!ent->target)
+	{
+		gi.Com_PrintFmt("{} without a target\n", *ent);
+		G_FreeEdict(ent);
+		return;
+	}
+
+	if (!ent->speed)
+		ent->speed = 300;
+
+	ent->movetype = MOVETYPE_PUSH;
+	ent->solid = SOLID_NOT;
+	ent->s.modelindex = gi.modelindex("models/ships/bulldog_m/main/tris.md2");
+	ent->s.modelindex2 = gi.modelindex("models/ships/bulldog_m/left/tris.md2");
+	ent->s.modelindex3 = gi.modelindex("models/ships/bulldog_m/right/tris.md2");
+	ent->mins = { -224, -112, -32 };
+	ent->maxs = { 80, 112, 64 };
+
+	ent->think = func_train_find;
+	ent->nextthink = level.time + 10_hz;
+	ent->use = misc_bulldog_use;
+	ent->svflags |= SVF_NOCLIENT;
+	ent->moveinfo.accel = ent->moveinfo.decel = ent->moveinfo.speed = ent->speed;
+
+	gi.linkentity(ent);
+}
+
+
+/*QUAKED misc_bulldog_l (1 .5 0) (-432 -120 -32) (144 120 96)
+This is a large stationary bulldog
+*/
+void SP_misc_bulldog_l(edict_t* ent)
+{
+	ent->movetype = MOVETYPE_NONE;
+	ent->solid = SOLID_BBOX;
+	ent->mins = { -432, -120, -32 };
+	ent->maxs = { 144, 120, 96 };
+	ent->s.modelindex = gi.modelindex("models/ships/bulldog_l/main/tris.md2");
+	ent->s.modelindex2 = gi.modelindex("models/ships/bulldog_l/left/tris.md2");
+	ent->s.modelindex3 = gi.modelindex("models/ships/bulldog_l/right/tris.md2");
+	gi.linkentity(ent);
+}
--- /dev/null
+++ b/zaero/g_zaero_monster.cpp	2025-09-04 19:53:48
@@ -0,0 +1,3 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
--- /dev/null
+++ b/zaero/g_zaero_phys.cpp	2025-09-04 19:53:48
@@ -0,0 +1,189 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+
+void SV_Physics_Step(edict_t* ent);
+
+/*
+=============
+SV_Physics_FallFloat
+=============
+*/
+
+void SV_Physics_FallFloat(edict_t* ent)
+{
+	float gravVal;
+	bool wasonground = false;
+	bool hitsound = false;
+
+	if (!ent)
+	{
+		return;
+	}
+
+	gravVal = ent->gravity * sv_gravity->value * gi.frame_time_s;
+
+	// check velocity
+	SV_CheckVelocity(ent);
+
+	wasonground = (ent->groundentity == nullptr);
+	if (ent->velocity[2] < sv_gravity->value * -0.1)
+		hitsound = true;
+
+	if (!ent->waterlevel)
+	{
+		vec3_t min, max;
+		trace_t tr;
+		vec3_t end;
+		vec3_t normal;
+		vec3_t gravity;
+
+		min = ent->mins;
+		max = ent->maxs;
+
+		end = ent->s.origin;
+		end[2] -= 0.25; // down 4
+
+		tr = gi.trace(ent->s.origin, min, max, end, ent, MASK_SHOT);
+		if (tr.plane.normal[2] > 0.7) // on solid ground
+		{
+			ent->groundentity = tr.ent;
+			ent->s.origin = tr.endpos;
+			ent->velocity = { 0, 0, 0 };
+		}
+		else if (tr.fraction < 1.0 && tr.plane.normal[2] <= 0.7) // on steep slope
+		{
+			normal = tr.plane.normal;
+			gravity = { 0, 0, -gravVal };
+			ent->velocity = gravity + (normal * gravVal);
+			ent->groundentity = nullptr;
+		}
+		else // in freefall
+		{
+			ent->velocity[2] -= gravVal;
+			ent->groundentity = nullptr;
+		}
+	}
+	else
+	{
+		// where's the midpoint? above or below the water?
+		const double WATER_MASS = 500.0;
+		vec3_t accel;
+		float percentBelow = 0.0;
+		float massOfObject = 0.0;
+		float massOfVolumeWater = 0.0;
+		float massOfWater = 0.0;
+		float massDiff = 0.0;
+		double i = 0.0;
+		vec3_t volume;
+
+		// TODO if we're not grounded on the bottom of the lake...
+
+		// calculate massPerCubicMetre
+		volume = ent->size * (1.0 / 32.0);
+		massOfObject = ent->mass;
+		massOfVolumeWater = WATER_MASS * (volume[0] * volume[1] * volume[2]);
+
+		// how much of ourself is actually in the water?
+		percentBelow = 1.0;
+		for (i = 0.0; i <= 1.0; i += 0.05)
+		{
+			vec3_t midpoint;
+			int watertype;
+
+			midpoint = ent->s.origin + ent->mins;
+			midpoint = midpoint + (ent->maxs * i);
+			watertype = gi.pointcontents(midpoint);
+
+			if (!(watertype & MASK_WATER))
+			{
+				percentBelow = i - 0.05;
+				break;
+			}
+		}
+		if (percentBelow < 0.05) // safety net
+			percentBelow = 0.0;
+		massOfWater = percentBelow * massOfVolumeWater;
+		massDiff = massOfWater - massOfObject; // difference between
+		accel = {};
+		accel = { 0, 0, gravVal * (massDiff / massOfVolumeWater) };
+		ent->velocity = ent->velocity * 0.7;
+		if (accel.length() > 4)
+			ent->velocity = accel + ent->velocity;
+	}
+
+	if (ent->velocity[0] || ent->velocity[1] || ent->velocity[2])
+	{
+		bool isinwater = false;
+		bool wasinwater = false;
+		vec3_t old_origin;
+		old_origin = ent->s.origin;
+
+		SV_FlyMove(ent, gi.frame_time_s, MASK_SHOT);
+
+		gi.linkentity(ent);
+		G_TouchTriggers(ent);
+
+		if (ent->groundentity)
+			if (!wasonground)
+				if (hitsound)
+					gi.sound(ent, CHAN_AUTO, gi.soundindex("world/land.wav"), 1, 1, 0);
+
+		// check for water transition
+		wasinwater = (ent->watertype & MASK_WATER);
+		ent->watertype = gi.pointcontents(ent->s.origin);
+		isinwater = ent->watertype & MASK_WATER;
+
+		if (isinwater)
+			ent->waterlevel = WATER_FEET;
+		else
+			ent->waterlevel = WATER_NONE;
+
+		if (!wasinwater && isinwater)
+			gi.positioned_sound(old_origin, g_edicts, CHAN_AUTO, gi.soundindex("misc/h2ohit1.wav"), 1, 1, 0);
+		else if (wasinwater && !isinwater)
+			gi.positioned_sound(ent->s.origin, g_edicts, CHAN_AUTO, gi.soundindex("misc/h2ohit1.wav"), 1, 1, 0);
+	}
+
+	// relink
+	gi.linkentity(ent);
+
+	// regular thinking
+	SV_RunThink(ent);
+}
+
+/*
+=============
+SV_Physics_Ride
+=============
+*/
+
+void adjustRiders(edict_t* ent)
+{
+	int i = 0;
+
+	if (!ent)
+	{
+		return;
+	}
+
+	// make sure the offsets are constant
+	for (i = 0; i < 2; i++)
+	{
+		if (ent->rideWith[i] != nullptr)
+			ent->rideWith[i]->s.origin = ent->s.origin + ent->rideWithOffset[i];
+	}
+}
+
+void SV_Physics_Ride(edict_t* ent)
+{
+	if (!ent)
+	{
+		return;
+	}
+
+	// base ourself on the step
+	SV_Physics_Step(ent);
+
+	adjustRiders(ent);
+}
--- /dev/null
+++ b/zaero/g_zaero_weapon.cpp	2025-09-04 19:53:48
@@ -0,0 +1,243 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
+
+constexpr float FLASH_RANGE = 256;
+void FoundTarget(edict_t* self);
+
+/*
+=================
+angleToward
+=================
+*/
+
+void angleToward(edict_t* self, vec3_t point, float speed)
+{
+	vec3_t forward;
+	float yaw = 0.0;
+	float vel = 0.0;
+	vec3_t delta;
+	vec3_t destAngles;
+
+	if (!self)
+	{
+		return;
+	}
+
+	delta = point - self->s.origin;
+	destAngles = vectoangles(delta);
+	self->ideal_yaw = destAngles[YAW];
+	self->yaw_speed = speed;
+	M_ChangeYaw(self);
+	yaw = self->s.angles[YAW];
+	self->ideal_yaw = destAngles[PITCH];
+	self->s.angles[YAW] = self->s.angles[PITCH];
+	M_ChangeYaw(self);
+	self->s.angles[PITCH] = self->s.angles[YAW];
+	self->s.angles[YAW] = yaw;
+	AngleVectors(self->s.angles, forward, nullptr, nullptr);
+	vel = self->velocity.length();
+	self->velocity = forward * vel;
+}
+
+/*
+=================
+fire_flare
+=================
+*/
+
+void flare_flash(edict_t* ent)
+{
+	edict_t* target;
+	float dist;
+	float ratio;
+	vec3_t delta;
+
+	target = nullptr;
+
+	while (1)
+	{
+		target = findradius(target, ent->s.origin, FLASH_RANGE);
+		if (target == nullptr)
+			break;
+		if (!target->client && !(target->svflags & SVF_MONSTER))
+			continue;
+		if (target->deadflag)
+			continue;
+		if (!visible(ent, target))
+			continue;
+
+		delta = ent->s.origin - target->s.origin;
+		dist = delta.lengthSquared();
+		ratio = 1 - (dist / FLASH_RANGE);
+		if (ratio < 0)
+			ratio = 0;
+
+		if (target->client)
+		{
+			target->client->flashTime += ratio * 25;
+			if (target->client->flashTime > 25)
+				target->client->flashTime = 25;
+			target->client->flashBase = 30;
+		}
+		else if ((target->svflags & SVF_MONSTER) && strcmp(target->classname, "monster_zboss") != 0)
+		{
+			target->monsterinfo.flashTime =
+				std::max(target->monsterinfo.flashTime, ratio * 150); // a little bit more advantageous
+			target->monsterinfo.flashBase = 50;
+			if (target->enemy == nullptr)
+			{
+				target->enemy = ent->owner;
+				FoundTarget(target);
+			}
+		}
+	}
+}
+
+THINK(flare_think) (edict_t* self) -> void
+{
+	if (level.time > self->timestamp)
+	{
+		self->s.effects &= ~EF_ROCKET;
+		self->think = G_FreeEdict;
+		self->nextthink = level.time + 4_sec;
+		self->s.frame = 0;
+		self->s.sound = 0;
+		return;
+	}
+
+	self->s.frame++;
+
+	if (self->s.frame > 14)
+		self->s.frame = 5;
+
+	self->s.sound = gi.soundindex("weapons/flare/flarehis.wav");
+
+	flare_flash(self);
+
+	self->nextthink = level.time + 10_hz;
+}
+
+void fire_flare(edict_t* self, const vec3_t& start, const vec3_t& aimdir, int damage, int speed, float damage_radius, int radius_damage,
+	float right_adjust, float up_adjust)
+{
+	edict_t* flare;
+	vec3_t   dir;
+	vec3_t   forward, right, up;
+
+	dir = vectoangles(aimdir);
+	AngleVectors(dir, forward, right, up);
+
+	flare = G_Spawn();
+	flare->s.origin = start;
+	flare->velocity = aimdir * speed;
+
+	if (up_adjust)
+	{
+		float gravityAdjustment = level.gravity / 800.f;
+		flare->velocity += up * up_adjust * gravityAdjustment;
+	}
+
+	if (right_adjust)
+		flare->velocity += right * right_adjust;
+
+	flare->movetype = MOVETYPE_BOUNCE;
+	flare->clipmask = MASK_SHOT;
+
+	if (self->client && !G_ShouldPlayersCollide(true))
+		flare->clipmask &= ~CONTENTS_PLAYER;
+
+	flare->solid = SOLID_BBOX;
+	flare->svflags |= SVF_PROJECTILE;
+	flare->flags |= (FL_DODGE | FL_TRAP);
+	flare->s.effects |= EF_ROCKET;
+	flare->speed = speed;
+	flare->mins = { -4, -4, -4 };
+	flare->maxs = { 4, 4, 4 };
+	flare->s.modelindex = gi.modelindex("models/objects/flare/tris.md2");
+	flare->owner = self;
+	flare->timestamp = level.time + gtime_t::from_sec(8000.f / speed);
+	flare->nextthink = level.time + 1_sec;
+	flare->think = flare_think;
+	flare->dmg = damage;
+	flare->radius_dmg = radius_damage;
+	flare->dmg_radius = damage_radius;
+	flare->classname = "flare";
+
+	gi.linkentity(flare);
+}
+
+/*
+=================
+fire_empnuke
+=================
+*/
+
+bool EMPNukeCheck(edict_t* ent, vec3_t pos)
+{
+	edict_t* check = nullptr;
+
+	while ((check = G_FindByString<&edict_t::classname>(check, "EMPNukeCenter")) != nullptr)
+	{
+		vec3_t v;
+
+		if (check->owner != ent)
+		{
+			v = check->s.origin - pos;
+
+			if (v.length() <= check->dmg)
+			{
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+THINK(empnukeFinish) (edict_t* ent) -> void
+{
+	G_FreeEdict(ent);
+}
+
+THINK(empBlastAnim) (edict_t* ent) -> void
+{
+	ent->s.frame++;
+	ent->s.skinnum++;
+
+	if (ent->s.frame > 5)
+	{
+		ent->svflags |= SVF_NOCLIENT;
+		ent->s.modelindex = 0;
+		ent->s.frame = 0;
+		ent->s.skinnum = 0;
+
+		ent->think = empnukeFinish;
+		ent->nextthink = level.time + 10_sec;
+	}
+	else
+	{
+		ent->nextthink = level.time + 10_hz;
+	}
+}
+
+void fire_empnuke(edict_t* ent, vec3_t center, int radius)
+{
+	edict_t* empnuke;
+
+	gi.sound(ent, CHAN_VOICE, gi.soundindex("items/empnuke/emp_trg.wav"), 1, ATTN_NORM, 0);
+
+	empnuke = G_Spawn();
+	empnuke->owner = ent;
+	empnuke->dmg = radius;
+	empnuke->s.origin = center;
+	empnuke->classname = "EMPNukeCenter";
+	empnuke->movetype = MOVETYPE_NONE;
+	empnuke->s.modelindex = gi.modelindex("models/objects/b_explode/tris.md2");
+	empnuke->s.skinnum = 0;
+
+	empnuke->think = empBlastAnim;
+	// Setting nextthink to FRAME_TIME_MS makes the EMP animation barely visible. 10_hz appears to work the best.
+	empnuke->nextthink = level.time + 10_hz;
+	gi.linkentity(empnuke);
+}
--- /dev/null
+++ b/zaero/m_zaero_acannon.cpp	2025-09-04 19:53:48
@@ -0,0 +1,947 @@
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+autocannon
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_zaero_acannon.h"
+
+// spawnflags
+constexpr spawnflags_t SPAWNFLAG_AUTOCANNON_START_OFF = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_AUTOCANNON_BERSERK = 16_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_AUTOCANNON_BERSERK_TOGGLE = 32_spawnflag;
+
+void angleToward(edict_t* self, vec3_t point, float speed);
+
+// models
+const char* models[] = {	nullptr, 
+					"models/objects/acannon/chain/tris.md2",
+					"models/objects/acannon/rocket/tris.md2",
+					"models/objects/acannon/laser/tris.md2",
+					"models/objects/acannon/laser/tris.md2" };
+const char* floorModels[] = {	nullptr, 
+					nullptr,
+					"models/objects/acannon/rocket2/tris.md2",
+					"models/objects/acannon/laser2/tris.md2",
+					"models/objects/acannon/laser2/tris.md2" };
+
+// pitch extents
+const int acPitchExtents[2][2] = {	{0,60}, // max, min
+									{-60,0} 
+								};
+
+// frames filler/chain/rocket/laser
+const int acIdleStart[] = { 0, 0, 0, 0, 0 };
+const int acIdleEnd[] = { 0, 0, 0, 0, 0 };
+const int acActStart[] = { 0, 1, 1, 1, 1 };
+const int acActEnd[] = { 0, 9, 9, 9, 9 };
+const int acActiveStart[] = { 0, 10, 10, 10, 10 };
+const int acActiveEnd[] = { 0, 10, 10, 10, 10 };
+
+typedef struct ac_anim_frame_s
+{
+	bool last;
+	bool fire;
+	int frame;
+} ac_anim_frame_t;
+
+typedef struct ac_anim_s
+{
+	int firstNonPause;
+	ac_anim_frame_t frames[32];
+} ac_anim_t;
+
+ac_anim_t acFiringFrames[5] = 
+{
+	// dummy
+	{
+		0,
+		{ { true, false, -1 } }
+	},
+
+	// chaingun
+	{
+		6,
+		{
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			// start of firing sequence
+			{ false, true, 11 },
+			{ false, false, 12 },
+			{ false, true, 13 },
+			{ false, false, 14 },
+			{ false, true, 15 },
+			{ false, false, 16 },
+			{ false, true, 17 },
+			{ false, false, 18 },
+			{ false, true, 19 },
+			{ false, false, 20 },
+			{ false, true, 21 },
+			{ true, false, 2 },
+		}
+	},
+
+	// rockets
+	{
+		6,
+		{
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			// start of firing sequence
+			{ false, true, 11 },
+			{ false, false, 11 },
+			{ false, false, 12 },
+			{ false, false, 12 },
+			{ false, false, 13 },
+			{ false, false, 13 },
+			{ false, false, 14 },
+			{ false, false, 14 },
+			{ false, false, 15 },
+			{ false, false, 15 },
+			{ false, false, 16 },
+			{ true, false, 16 },
+		}
+	},
+
+	// laser
+	{
+		6,
+		{
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			// start of firing sequence
+			{ false, true, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ true, false, 11 },
+		}
+	},
+
+	// slow laser
+	{
+		6,
+		{
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			// start of firing sequence
+			{ false, true, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ false, false, 11 },
+			{ true, false, 11 },
+		}
+	}
+};
+
+vec3_t fireOffset[5] = {	{0,0,0},
+							{24,-4,0},
+							{0,-4,0},
+							{24,-5,0},
+							{24,-5,0} };
+const int acDeactStart[] = { 0, 23, 23, 23, 23 };
+const int acDeactEnd[] = { 0, 31, 31, 31, 31 };
+const bool turretIdle[] = { false, false, true, true }; // collapse when idle?
+
+// turret animations
+const int turretIdleStart = 0;
+const int turretIdleEnd = 0;
+const int turretActStart = 1;
+const int turretActEnd = 9;
+const int turretActiveStart = 10;
+const int turretActiveEnd = 10;
+const int turretDeactStart = 23;
+const int turretDeactEnd = 31;
+
+// bullet params
+#define AC_BULLET_DMG	4.0
+#define AC_BULLET_KICK	2.0
+// rocket params
+#define AC_ROCKET_DMG	100
+#define AC_ROCKET_SPEED	650
+#define AC_ROCKET_RADIUS_DMG	120
+#define AC_ROCKET_DMG_RADIUS	120
+// blaster params
+#define AC_BLASTER_DMG		20
+#define AC_BLASTER_SPEED	1000
+
+void autocannon_fire(edict_t *self)
+{
+	vec3_t forward, right, start;
+
+	// fire straight ahead
+	AngleVectors (self->s.angles, forward, right, nullptr);
+	if (self->onFloor)
+		right = -right;
+	start = self->s.origin + (forward * 24);
+	start = G_ProjectSource (self->s.origin, fireOffset[self->style], forward, right);
+
+	if(EMPNukeCheck(self, start))
+	{
+		gi.sound (self, CHAN_AUTO, gi.soundindex("items/empnuke/emp_missfire.wav"), 1, ATTN_NORM, 0);
+		return;
+	}
+
+	// what to fire?
+	switch(self->style)
+	{
+	case 1:
+	default:
+		fire_bullet(self, start, forward, AC_BULLET_DMG, AC_BULLET_KICK, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MOD_AUTOCANNON);
+		gi.WriteByte (svc_muzzleflash);
+		gi.WriteShort (self - g_edicts);
+		gi.WriteByte (MZ_CHAINGUN2);
+		gi.multicast (self->s.origin, MULTICAST_PVS, false);
+		break;
+	case 2:
+		fire_rocket(self, start, forward, AC_ROCKET_DMG, AC_ROCKET_SPEED, AC_ROCKET_RADIUS_DMG, AC_ROCKET_DMG_RADIUS);
+		gi.WriteByte (svc_muzzleflash);
+		gi.WriteShort (self - g_edicts);
+		gi.WriteByte (MZ_ROCKET);
+		gi.multicast (self->s.origin, MULTICAST_PVS, false);
+		break;
+	case 3:
+	case 4:
+		fire_blaster (self, start, forward, AC_BLASTER_DMG, AC_BLASTER_SPEED, EF_HYPERBLASTER, MOD_BLASTER);
+		gi.WriteByte (svc_muzzleflash);
+		gi.WriteShort (self - g_edicts);
+		gi.WriteByte (MZ_HYPERBLASTER);
+		gi.multicast (self->s.origin, MULTICAST_PVS, false);
+		break;
+	}
+}
+
+bool angleBetween(float *ang, float *min, float *max)
+{
+	// directly between?
+	if (*ang > *min && *ang < *max)
+		return true;
+
+	// make positive
+	while(*min < 0)
+		*min += 360.0;
+	while(*ang < *min)
+		*ang += 360.0;
+	while(*max < *min)
+		*max += 360.0;
+
+	if (*ang > *min && *ang < *max)
+		return true;
+	else
+		return false;
+}
+
+float mod180(float val)
+{
+	while(val > 180)
+		val -= 360.0;
+	while(val < -180)
+		val += 360.0;
+	return val;
+}
+
+bool canShoot(edict_t *self, edict_t *e)
+{
+	vec3_t delta;
+	vec3_t dangles;
+
+	delta = e->s.origin - self->s.origin;
+	dangles = vectoangles(delta);
+	dangles[PITCH] = mod180(dangles[PITCH]);
+	
+	if ((!self->onFloor && dangles[PITCH] < 0) ||
+		(self->onFloor && dangles[PITCH] > 0)) // facing up or down
+		return false;
+
+
+	if (self->monsterinfo.linkcount > 0)
+	{
+		float ideal_yaw = self->monsterinfo.attack_angle_yaw;
+		float max_yaw = anglemod(ideal_yaw + self->monsterinfo.linkcount);
+		float min_yaw = anglemod(ideal_yaw - self->monsterinfo.linkcount);
+		
+		if (!angleBetween(&dangles[YAW], &min_yaw, &max_yaw))
+			return false;
+	}
+	
+	return true;
+}
+
+bool autocannonInfront (edict_t *self, edict_t *other)
+{
+	vec3_t vec;
+	vec3_t angle;
+	float dot;
+	float min = -30.0;
+	float max = 30.0;
+
+	// what's the yaw distance between the 2?
+	vec = other->s.origin - self->s.origin;
+	angle = vectoangles(vec);
+	dot = angle[YAW] - self->s.angles[YAW];
+
+	if (angleBetween(&dot, &min, &max))
+		return true;
+	return false;
+}
+
+void autocannon_findenemy(edict_t *self)
+{
+	edict_t *e = nullptr;
+
+	// can we still use our enemy?
+	if (self->enemy)
+	{
+		if (!canShoot(self, self->enemy))
+		{
+			self->oldenemy = nullptr;
+			self->enemy = nullptr;
+		}
+		else if (!visible(self, self->enemy))
+		{
+			self->oldenemy = self->enemy;
+			self->enemy = nullptr;
+		}
+		else if (self->enemy->flags & FL_NOTARGET)
+		{
+			self->oldenemy = nullptr;
+			self->enemy = nullptr;
+		}
+		else if (self->enemy->health <= 0)
+		{
+			self->oldenemy = nullptr;
+			self->enemy = nullptr;
+		}
+	}
+
+	while(self->enemy == nullptr)
+	{
+		e = findradius(e, self->s.origin, 2048);
+		if (e == nullptr)
+		{
+			if (self->oldenemy == nullptr)
+				return;
+
+			if (level.time > self->timeout)
+			{
+				self->oldenemy = nullptr;
+				return;
+			}
+			self->enemy = self->oldenemy;
+			break;
+		}
+
+
+		if (self->spawnflags.has(SPAWNFLAG_AUTOCANNON_BERSERK))
+		{
+			// attack clients and monsters
+			if (!e->client && !(e->svflags & SVF_MONSTER))
+				continue;
+		}
+		else
+		{
+			// only attack clients
+			if (!e->client)
+				continue;
+		}
+
+		// don't target dead stuff
+		if (e->health <= 0)
+			continue;
+
+		// don't target notarget stuff
+		if (e->flags & FL_NOTARGET)
+			continue;
+
+		// don't target other autocannons
+		if (strcmp(e->classname, "autocannon") == 0)
+			continue;
+		
+		if (strcmp(e->classname, "autocannon_floor") == 0)
+			continue;
+
+		// also don't target turrets
+		if (strcmp(e->classname, "monster_turret") == 0)
+			continue;
+
+		// don't target self
+		if (e == self)
+			continue;
+		
+		// can it be seen?
+		if (!visible(self, e))
+			continue;
+
+		if (!autocannonInfront(self, e))
+			continue;
+
+		if (canShoot(self, e))
+			self->enemy = e;
+	}
+}
+
+void autocannon_turn(edict_t *self)
+{
+	vec3_t old_angles;
+
+	old_angles = self->s.angles;
+
+	if (!self->enemy)
+	{
+		if (self->monsterinfo.linkcount > 0)
+		{
+			int ideal_yaw = self->monsterinfo.attack_angle_yaw;
+			int max_yaw = anglemod(ideal_yaw + self->monsterinfo.linkcount);
+			int min_yaw = anglemod(ideal_yaw - self->monsterinfo.linkcount);
+
+			while (max_yaw < min_yaw)
+				max_yaw += 360.0;
+		
+			self->s.angles[YAW] += (self->monsterinfo.lefty ? -6.0 : 6.0);
+			
+			// back and forth
+			if (self->s.angles[YAW] > max_yaw)
+			{
+				self->monsterinfo.lefty = 1;
+				self->s.angles[YAW] = max_yaw;
+			}
+			else if (self->s.angles[YAW] < min_yaw)
+			{
+				self->monsterinfo.lefty = 0;
+				self->s.angles[YAW] = min_yaw;
+			}
+		}
+		else
+		{
+			self->s.angles[YAW] = anglemod(self->s.angles[YAW] + 6.0);
+		}
+
+		// angle pitch towards 5 to 10...
+		if (!self->onFloor)
+		{
+			if (self->s.angles[PITCH] > 10)
+				self->s.angles[PITCH] -= 4;
+			else if (self->s.angles[PITCH] < 5)
+				self->s.angles[PITCH] += 4;
+		}
+		else
+		{
+			if (self->s.angles[PITCH] < -10)
+				self->s.angles[PITCH] += 4;
+			else if (self->s.angles[PITCH] > -5)
+				self->s.angles[PITCH] -= 4;
+		}
+	}
+	else
+	{
+		// look toward enemy mid point
+		if (visible(self, self->enemy))
+		{
+			vec3_t offset, dest;
+			offset = self->enemy->mins;
+			offset = offset + self->enemy->maxs;
+			offset = offset * 0.65;
+			dest = self->enemy->s.origin + offset;
+			angleToward(self, dest, 6.0);
+			self->monsterinfo.last_sighting = dest;
+			self->timeout = level.time + 2.0_sec;
+
+			// restrict our range of movement if need be
+			if (self->monsterinfo.linkcount > 0)
+			{
+				float amax = anglemod(self->monsterinfo.attack_angle_yaw + self->monsterinfo.linkcount);
+				float amin = anglemod(self->monsterinfo.attack_angle_yaw - self->monsterinfo.linkcount);
+				self->s.angles[YAW] = anglemod(self->s.angles[YAW]);
+				if (!angleBetween(&self->s.angles[YAW], &amin, &amax))
+				{
+					// which is closer?
+					if (self->s.angles[YAW] - amax < amin - self->s.angles[YAW])
+						self->s.angles[YAW] = amin;
+					else
+						self->s.angles[YAW] = amax;
+				}
+			}
+
+		}
+		else // not visible now, so head toward last known spot
+			angleToward(self, self->monsterinfo.last_sighting, 6.0);
+	}
+	
+	// get our angles between 180 and -180
+	while(self->s.angles[PITCH] > 180)
+		self->s.angles[PITCH] -= 360.0;
+	while(self->s.angles[PITCH] < -180)
+		self->s.angles[PITCH] += 360;
+
+	// outside of the pitch extents?
+	if (self->s.angles[PITCH] > acPitchExtents[self->onFloor][1])
+		self->s.angles[PITCH] = acPitchExtents[self->onFloor][1];
+	else if (self->s.angles[PITCH] < acPitchExtents[self->onFloor][0])
+		self->s.angles[PITCH] = acPitchExtents[self->onFloor][0];
+	
+	// make sure the turret's angles match the gun's
+	self->chain->s.angles[YAW] = self->s.angles[YAW];
+	self->chain->s.angles[PITCH] = 0;
+
+	// setup the sound
+	if (self->s.angles == old_angles)
+		self->chain->s.sound = 0;
+	else
+		self->chain->s.sound = gi.soundindex("objects/acannon/ac_idle.wav");
+}
+
+THINK(autocannon_think) (edict_t *self) -> void
+{
+	ac_anim_frame_t frame;
+	ac_anim_t anim;
+	bool lefty = 0;
+	edict_t *old_enemy;
+
+	self->nextthink = level.time + 0.1_sec;
+
+	// get an enemy
+	old_enemy = self->enemy;
+	autocannon_findenemy(self);
+	if (self->enemy != nullptr && old_enemy != self->enemy)
+		gi.sound(self, CHAN_VOICE, gi.soundindex("objects/acannon/ac_act.wav"), 1, ATTN_NORM, 0);
+
+	// turn whereever
+	lefty = self->monsterinfo.lefty;
+	if (level.time > gtime_t::from_sec(self->delay))
+	{
+		autocannon_turn(self);
+		if (self->monsterinfo.lefty != lefty)
+			gtime_t::from_sec(self->delay) = level.time + 1.0_sec;
+	}
+
+	anim = acFiringFrames[self->style];
+	frame = anim.frames[self->seq];
+		
+	// ok, we don't have an enemy
+	if (self->enemy == nullptr)
+	{
+		if (self->seq == 0)
+		{
+			// get into idle animation
+			self->s.frame++;
+			if (self->s.frame > acActiveEnd[self->style] ||
+				self->s.frame < acActiveStart[self->style])
+				self->s.frame = acActiveStart[self->style];
+			return; // done, we want to wait here
+		}
+
+		// set the frame
+		self->s.frame = frame.frame;
+
+		// fire
+		if (frame.fire)
+			autocannon_fire(self);
+	
+		// if we're not done with the firing sequence, we need to finish it off
+		if (frame.last) // end of the loop or firing frame?
+			self->seq = 0;
+		else
+			self->seq++;
+
+		return;
+	}
+
+	// we have an enemy but he's not infront, go to the beginning of the firing sequence
+	if (!autocannonInfront(self, self->enemy))
+	{
+		self->s.frame = frame.frame;
+		if (self->seq == anim.firstNonPause)
+			return; // done, we want to wait here
+
+		if (frame.last) // end of the loop or firing frame?
+			self->seq = anim.firstNonPause;
+		else
+			self->seq++;
+
+		return;
+	}
+
+
+	// we have an enemy, AND he's visible
+	// let's kick his ass
+	self->s.frame = frame.frame;
+	if (frame.fire)
+		autocannon_fire(self);
+	
+	if (frame.last) // end of the loop?
+		self->seq = anim.firstNonPause;
+	else
+		self->seq++;
+}
+
+THINK(autocannon_explode) (edict_t *ent) -> void
+{
+	vec3_t origin;
+
+	if (!ent)
+	{
+		return;
+	}
+
+	T_RadiusDamage(ent, ent, 150, ent->enemy, 384, DAMAGE_NONE, MOD_TRIPBOMB);
+
+	origin = ent->s.origin + (ent->velocity * -0.02);
+	gi.WriteByte (svc_temp_entity);
+	if (ent->waterlevel)
+	{
+		if (ent->groundentity)
+			gi.WriteByte (TE_GRENADE_EXPLOSION_WATER);
+		else
+			gi.WriteByte (TE_ROCKET_EXPLOSION_WATER);
+	}
+	else
+	{
+		if (ent->groundentity)
+			gi.WriteByte (TE_GRENADE_EXPLOSION);
+		else
+			gi.WriteByte (TE_ROCKET_EXPLOSION);
+	}
+	gi.WritePosition (origin);
+	gi.multicast (ent->s.origin, MULTICAST_PHS, false);
+
+	// set the pain skin
+	ent->chain->chain->s.skinnum = 1; // pain
+	ent->chain->chain->rideWith[0] = nullptr;
+	ent->chain->chain->rideWith[1] = nullptr;
+	G_FreeEdict(ent->chain);
+	G_FreeEdict(ent);
+}
+
+DIE(autocannon_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	// explode
+	self->takedamage = false;
+	self->think = autocannon_explode;
+	self->nextthink = level.time + 0.1_sec;
+}
+
+PAIN(autocannon_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	// keep the enemy
+	if (other->client || other->svflags & SVF_MONSTER)
+		self->enemy = other;
+}
+
+THINK(autocannon_activate) (edict_t *self) -> void
+{
+	self->active = 1;
+	self->nextthink = level.time + 0.1_sec;
+
+	// go thru the activation frames
+	if (self->s.frame >= acActStart[self->style] &&
+		self->s.frame < acActEnd[self->style])
+	{
+		if (self->s.frame == acActStart[self->style])
+		{
+			//gi.sound(self, CHAN_VOICE, gi.soundindex("objects/acannon/ac_out.wav"), 1, ATTN_NORM, 0);
+		}
+		// continue
+		self->s.frame++;
+		self->chain->s.frame++;
+	}
+	else if (self->s.frame == acActEnd[self->style])
+	{
+		self->s.frame = acActiveStart[self->style];
+		self->chain->s.frame = turretActiveStart;
+		self->think = autocannon_think;
+		self->active = 2;
+	}
+	else
+	{
+		self->s.frame = acActStart[self->style];
+		self->chain->s.frame = turretActStart;
+	}
+}
+
+THINK(autocannon_deactivate) (edict_t *self) -> void
+{
+	self->active = 3;
+	self->nextthink = level.time + 0.1_sec;
+	
+	// go thru the deactivation frames
+	if (self->s.angles[PITCH] != 0)
+	{
+		if (self->s.angles[PITCH] > 0)
+		{
+			self->s.angles[PITCH] -= 5;
+			if (self->s.angles[PITCH] < 0)
+				self->s.angles[PITCH] = 0;
+		}
+		else
+		{
+			self->s.angles[PITCH] += 5;
+			if (self->s.angles[PITCH] > 0)
+				self->s.angles[PITCH] = 0;
+		}
+	}
+	else if (self->s.frame >= acDeactStart[self->style] &&
+		self->s.frame < acDeactEnd[self->style])
+	{
+		self->chain->s.sound = 0;
+
+		// continue
+		self->s.frame++;
+		self->chain->s.frame++;
+	}
+	else if (self->s.frame == acDeactEnd[self->style])
+	{
+		self->s.frame = acIdleStart[self->style];
+		self->chain->s.frame = turretIdleStart;
+		self->think = nullptr;
+		self->nextthink = 0_sec;
+		self->chain->s.sound = 0;
+		self->active = 0;
+	}
+	else
+	{
+		self->s.frame = acDeactStart[self->style];
+		self->chain->s.frame = turretDeactStart;
+	}
+}
+
+void autocannon_act(edict_t *self)
+{
+	if (self->active == 0)
+	{
+		if (acActStart[self->style] != -1)
+			self->think = autocannon_activate;
+		else
+		{
+			self->s.frame = acActiveStart[self->style];
+			self->chain->s.frame = turretActiveStart;
+			self->think = autocannon_think;
+			self->active = 2;
+		}
+		self->nextthink = level.time + 0.1_sec;
+	}
+	else if (self->active == 2)
+	{
+		if (acDeactStart[self->style] != -1)
+		{
+			self->nextthink = level.time + 0.1_sec;
+			self->think = autocannon_deactivate;
+		}
+		else
+		{
+			if (turretIdle[self->style])
+				self->chain->s.frame = turretIdleStart;
+			else
+				self->chain->s.frame = turretActiveStart;
+			self->s.frame = acActiveStart[self->style];
+			self->think = nullptr;
+			self->active = 0;
+			self->nextthink = 0_sec;
+		}
+	}
+}
+
+USE(autocannon_use) (edict_t *self, edict_t *other, edict_t *activator) -> void
+{
+	// on/off or berserk toggle?
+	if (self->spawnflags.has(SPAWNFLAG_AUTOCANNON_BERSERK_TOGGLE))
+	{
+		if (self->spawnflags.has(SPAWNFLAG_AUTOCANNON_BERSERK))
+			self->spawnflags &= ~SPAWNFLAG_AUTOCANNON_BERSERK;
+		else
+			self->spawnflags |= SPAWNFLAG_AUTOCANNON_BERSERK;
+	}
+	else
+		autocannon_act(self);
+}
+
+THINK(autocannon_usestub) (edict_t *self) -> void
+{
+	// stub
+	autocannon_act(self);
+}
+
+
+/*QUAKED monster_autocannon (1 .5 0) (-16 -16 -16) (16 16 16) Ambush Trigger_Spawn Sight StartOff Berserk Berserk_Toggle
+model="models/objects/acannon/base/tris.md2"
+
+The automated defense turret that mounts on ceilings.
+Check the weapon you want it to use: blaster, machinegun, rocket.
+Default weapon is machinegun.
+
+"style"		Which weapon to use; 1=machinegun, 1=blaster, 2=fast blaster, 3=rockets
+*/
+void SP_monster_autocannon(edict_t* self)
+{
+	edict_t *base, *turret;
+	vec3_t offset;
+
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	if (self->style > 4 || self->style < 1)
+		self->style = 1;
+
+	// if we're on hard or nightmare, use fast lasers
+	if (skill->integer >= 2 && self->style == 4)
+		self->style = 3;
+
+	// precache some sounds and models
+	gi.soundindex("objects/acannon/ac_idle.wav");
+	gi.soundindex("objects/acannon/ac_act.wav");
+	gi.modelindex("models/objects/rocket/tris.md2");
+	gi.modelindex("models/objects/laser/tris.md2");
+
+	// create the base
+	base = G_Spawn();
+	base->classname = "autocannon base";
+	base->solid = SOLID_BBOX;
+	base->s.origin = self->s.origin;
+	if (!self->onFloor)
+		base->movetype = MOVETYPE_NONE;
+	else
+		base->movetype = MOVETYPE_RIDE; // make the base MOVETYPE_RIDE so that it can ride on trains
+
+	if (!self->onFloor)
+		base->s.modelindex = gi.modelindex("models/objects/acannon/base/tris.md2");
+	else
+		base->s.modelindex = gi.modelindex("models/objects/acannon/base2/tris.md2");
+	gi.linkentity(base);
+
+	// create the turret
+	turret = G_Spawn();
+	turret->solid = SOLID_BBOX;
+	turret->movetype = MOVETYPE_NONE;
+	turret->chain = base;
+	turret->s.origin = self->s.origin;
+	if (!self->onFloor)
+		turret->s.modelindex = gi.modelindex("models/objects/acannon/turret/tris.md2");
+	else
+		turret->s.modelindex = gi.modelindex("models/objects/acannon/turret2/tris.md2");
+	if (turretIdle[self->style])
+		turret->s.frame = turretIdleStart;
+	else
+		turret->s.frame = turretActiveStart;
+	turret->s.angles[YAW] = self->s.angles[YAW];
+	turret->s.angles[PITCH] = 0;
+	gi.linkentity(turret);
+	
+	// fill in the details about ourself
+	self->solid = SOLID_BBOX;
+	self->movetype = MOVETYPE_NONE;
+	if (!self->onFloor)
+		offset = { 0, 0, -20 };
+	else
+		offset = { 0, 0, 20 };
+	self->s.origin = self->s.origin + offset;
+
+	// set the bounding box
+	if (!self->onFloor)
+	{
+		self->mins = { -12, -12, -28 };
+		self->maxs = { 12, 12, 16 };
+	}
+	else
+	{
+		self->mins = { -12, -12, -16 };
+		self->maxs = { 12, 12, 28 };
+	}
+	self->chain = turret;
+	if (!self->onFloor)
+		self->s.modelindex = gi.modelindex(models[self->style]);
+	else
+		self->s.modelindex = gi.modelindex(floorModels[self->style]);
+	self->s.frame = acIdleStart[self->style];
+	self->active = 0;
+	self->monsterinfo.lefty = 0;
+	self->monsterinfo.attack_angle_yaw = self->s.angles[YAW]; // used for centre of back-and-forth "search"
+	self->seq = 0;
+	if (st.lip)
+		self->monsterinfo.linkcount = (st.lip > 0 ? st.lip : 0);
+
+	self->health = 100 * st.health_multiplier;
+
+	if (!st.was_key_specified("power_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("power_power"))
+		self->monsterinfo.armor_power = 50;
+
+	// enable/disable? ... berserk/not
+	if (self->targetname)
+		self->use = autocannon_use;
+	
+	if (self->spawnflags.has(SPAWNFLAG_AUTOCANNON_BERSERK_TOGGLE) || !(self->spawnflags.has(SPAWNFLAG_AUTOCANNON_START_OFF)))
+	{
+		self->think = autocannon_usestub;
+		self->nextthink = level.time + 0.1_sec;
+	}
+
+	self->takedamage = true;
+	self->die = autocannon_die;
+	self->pain = autocannon_pain;
+
+	// last but not least, setup the "rideWith" information
+	base->rideWith[0] = turret;
+	base->rideWithOffset[0] = turret->s.origin - base->s.origin;
+	base->rideWith[1] = self;
+	base->rideWithOffset[1] = self->s.origin - base->s.origin;
+
+
+	self->flags |= FL_MECHANICAL;
+
+	gi.linkentity(self);
+}
+
+/*QUAKED monster_autocannon_floor (1 .5 0) (-16 -16 -16) (16 16 16) Ambush Trigger_Spawn Sight StartOff Berserk Berserk_Toggle
+model="models/objects/acannon/base2/tris.md2"
+
+The automated defense turret that mounts on floors.
+Check the weapon you want it to use: blaster, rocket.
+Default weapon is machinegun.
+
+"style"		Which weapon to use; 1=blaster, 2=fast blaster, 3=rockets
+*/
+void SP_monster_autocannon_floor(edict_t* self) 
+{
+	//no machinegun autocannon model, become blaster
+	if (self->style == 1)
+		self->style = 4;
+
+	if (self->style < 1 || self->style > 4)
+		self->style = 2;
+
+	self->onFloor = 1; // signify floor mounted
+
+	SP_monster_autocannon(self);
+}
--- /dev/null
+++ b/zaero/m_zaero_acannon.h	2025-09-04 19:53:48
@@ -0,0 +1,39 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_idle01,
+	FRAME_activate01,
+	FRAME_activate02,
+	FRAME_activate03,
+	FRAME_activate04,
+	FRAME_activate05,
+	FRAME_activate06,
+	FRAME_activate07,
+	FRAME_activate08,
+	FRAME_activate09,
+	FRAME_active01,
+	FRAME_fire01,
+	FRAME_fire02,
+	FRAME_fire03,
+	FRAME_fire04,
+	FRAME_fire05,
+	FRAME_fire06,
+	FRAME_fire07, //rocket fire201
+	FRAME_fire08,
+	FRAME_fire09,
+	FRAME_fire10,
+	FRAME_fire11,
+	FRAME_fire12, //rocket fire206
+	FRAME_deactivate01,
+	FRAME_deactivate02,
+	FRAME_deactivate03,
+	FRAME_deactivate04,
+	FRAME_deactivate05,
+	FRAME_deactivate06,
+	FRAME_deactivate07,
+	FRAME_deactivate08,
+	FRAME_deactivate09
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/zaero/m_zaero_bossz.cpp	2025-09-04 19:53:48
@@ -0,0 +1,1991 @@
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+z-sentien
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_zaero_bossz.h"
+#include "../m_flash.h"
+
+static cached_soundindex	sound_pain1;
+static cached_soundindex	sound_pain2;
+static cached_soundindex	sound_pain3;
+static cached_soundindex	sound_die1;
+static cached_soundindex	sound_die2;
+static cached_soundindex	sound_hookimpact;
+static cached_soundindex	sound_sight;
+static cached_soundindex	sound_hooklaunch;
+static cached_soundindex	sound_hookfly;
+static cached_soundindex	sound_swing;
+static cached_soundindex	sound_idle1;
+static cached_soundindex	sound_idle2;
+static cached_soundindex	sound_walk;
+static cached_soundindex	sound_raisegun;
+static cached_soundindex	sound_lowergun;
+static cached_soundindex	sound_switchattacks;
+static cached_soundindex	sound_plamsaballfly;
+static cached_soundindex	sound_plamsaballexplode;
+static cached_soundindex	sound_plamsaballfire;
+static cached_soundindex	sound_taunt1;
+static cached_soundindex	sound_taunt2;
+static cached_soundindex	sound_taunt3;
+
+void fire_empnuke(edict_t* ent, vec3_t center, int radius);
+void SV_AddGravity(edict_t* ent);
+
+void zboss_stand(edict_t* self);
+void zboss_run(edict_t* self);
+void zboss_run2(edict_t* self);
+void zboss_walk(edict_t* self);
+void zboss_walk2(edict_t* self);
+void zboss_chooseNextAttack(edict_t* self);
+void zboss_reelInGrapple(edict_t* self);
+void zboss_posthook(edict_t* self);
+void HookDragThink(edict_t* self);
+void zboss_attack(edict_t* self);
+
+void zboss_walksound(edict_t* self)
+{
+	gi.sound(self, CHAN_BODY, sound_walk, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SIGHT(zboss_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+
+MONSTERINFO_IDLE(zboss_idle) (edict_t* self) -> void
+{
+	float r = frandom();
+
+	if (frandom() < 0.10)
+	{
+		if (r < 0.33)
+		{
+			gi.sound(self, CHAN_VOICE, sound_taunt1, 1, ATTN_NORM, 0);
+		}
+		else if (r < 0.66)
+		{
+			gi.sound(self, CHAN_VOICE, sound_taunt2, 1, ATTN_NORM, 0);
+		}
+		else
+		{
+			gi.sound(self, CHAN_VOICE, sound_taunt3, 1, ATTN_NORM, 0);
+		}
+	}
+}
+
+//
+// STAND
+//
+
+mframe_t zboss_frames_stand1[] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},  // 9
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},  // 19
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},  // 29
+
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(zboss_movestand1) = { FRAME_idle101, FRAME_idle132, zboss_frames_stand1, zboss_stand };
+
+mframe_t zboss_frames_stand2[] =
+{
+	{ai_stand}, // 32
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, // 41
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, // 51
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}	 // 56
+};
+MMOVE_T(zboss_movestand2) = { FRAME_idle201, FRAME_idle225, zboss_frames_stand2, zboss_stand };
+
+
+void zboss_standidle(edict_t* self)
+{
+	if (!self)
+	{
+		return;
+	}
+
+	if (frandom() < 0.8)
+	{
+		gi.sound(self, CHAN_VOICE, sound_idle1, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &zboss_movestand1);
+	}
+	else
+	{
+		gi.sound(self, CHAN_VOICE, sound_idle2, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &zboss_movestand2);
+	}
+}
+
+//
+// Post WALK/RUN leading into ilde.
+//
+
+mframe_t zboss_frames_postwalk[] =
+{
+	{ai_walk,  3}, // 177
+	{ai_walk,  3},
+	{ai_walk,  3},
+	{ai_walk,  3},
+	{ai_walk,  3},
+	{ai_walk,  3},
+	{ai_walk,  3},
+	{ai_walk,  3} // 184
+};
+MMOVE_T(zboss_move_postwalk) = { FRAME_walk401, FRAME_walk408, zboss_frames_postwalk, zboss_standidle };
+
+
+void zboss_postWalkRun(edict_t* self)
+{
+	M_SetAnimation(self, &zboss_move_postwalk);
+}
+
+//
+// WALK
+//
+
+mframe_t zboss_frames_prewalk[] =
+{
+	{ai_walk,  3}, //154
+	{ai_walk,  3},
+	{ai_walk,  3},
+	{ai_walk,  3},
+	{ai_walk,  3},
+	{ai_walk,  3},
+	{ai_walk,  3} // 160
+};
+MMOVE_T(zboss_move_prewalk) = { FRAME_walk101, FRAME_walk107, zboss_frames_prewalk, zboss_walk2 };
+
+mframe_t zboss_frames_walk[] =
+{
+	{ai_walk,  2},	//161
+	{ai_walk,  3},
+	{ai_walk,  3},
+	{ai_walk,  4},
+	{ai_walk,  4},
+	{ai_walk,  4},
+	{ai_walk,  4},
+	{ai_walk,  3, zboss_walksound},
+	{ai_walk,  4},
+	{ai_walk,  4},	// 170
+	{ai_walk,  4},
+	{ai_walk,  4},
+	{ai_walk,  3},
+	{ai_walk,  2},
+	{ai_walk,  2},
+	{ai_walk,  3, zboss_walksound }						// 176
+};
+MMOVE_T(zboss_move_walk) = { FRAME_walk201, FRAME_walk307, zboss_frames_walk, zboss_walk2 };
+
+MONSTERINFO_WALK(zboss_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &zboss_move_prewalk);
+}
+
+void zboss_walk2(edict_t* self)
+{
+	M_SetAnimation(self, &zboss_move_walk);
+}
+
+//
+// RUN
+//
+
+mframe_t zboss_frames_prerun[] =
+{
+	{ai_run,  3}, //154
+	{ai_run,  3},
+	{ai_run,  3},
+	{ai_run,  3},
+	{ai_run,  3},
+	{ai_run,  3},
+	{ai_run,  3} // 160
+};
+MMOVE_T(zboss_move_prerun) = { FRAME_walk101, FRAME_walk107, zboss_frames_prerun, zboss_run2 };
+
+mframe_t zboss_frames_run[] =
+{
+	{ai_run,  2},	//161
+	{ai_run,  3},
+	{ai_run,  3},
+	{ai_run,  4},
+	{ai_run,  4},
+	{ai_run,  4},
+	{ai_run,  4},
+	{ai_run,  3, zboss_walksound},
+	{ai_run,  4},
+	{ai_run,  4},	// 170
+	{ai_run,  4},
+	{ai_run,  4},
+	{ai_run,  3},
+	{ai_run,  2},
+	{ai_run,  2},
+	{ai_run,  3, zboss_walksound}					// 176
+};
+MMOVE_T(zboss_move_run) = { FRAME_walk201, FRAME_walk307, zboss_frames_run, nullptr };
+
+MONSTERINFO_RUN(zboss_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		zboss_stand(self);
+	else
+		M_SetAnimation(self, &zboss_move_prerun);
+}
+
+void zboss_run2(edict_t* self)
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		zboss_stand(self);
+	else
+		M_SetAnimation(self, &zboss_move_run);
+}
+
+//
+// main stand function
+//
+
+MONSTERINFO_STAND(zboss_stand) (edict_t* self) -> void
+{
+	if (self->monsterinfo.active_move == &zboss_move_prewalk ||
+		self->monsterinfo.active_move == &zboss_move_walk ||
+		self->monsterinfo.active_move == &zboss_move_prerun ||
+		self->monsterinfo.active_move == &zboss_move_run)
+	{
+		zboss_postWalkRun(self);
+	}
+	else
+	{
+		zboss_standidle(self);
+	}
+}
+
+//
+// PAIN
+//
+
+mframe_t zboss_frames_pain1[] =
+{
+	{ai_move},	 // 185
+	{ai_move},
+	{ai_move}	 // 187
+};
+MMOVE_T(zboss_move_pain1) = { FRAME_pain101, FRAME_pain103, zboss_frames_pain1, zboss_run };
+
+mframe_t zboss_frames_pain2[] =
+{
+	{ai_move},	 // 188
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}	 // 192
+};
+MMOVE_T(zboss_move_pain2) = { FRAME_pain201, FRAME_pain205, zboss_frames_pain2, zboss_run };
+
+mframe_t zboss_frames_pain3[] =
+{
+	{ai_move},	// 193
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},	// 202
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},	// 212
+
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move} // 217
+};
+MMOVE_T(zboss_move_pain3) = { FRAME_pain301, FRAME_pain325, zboss_frames_pain3, zboss_run };
+
+PAIN(zboss_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 5_sec;
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	if (self->proboscus)
+		return;		// while hook is out.
+
+	if (self->bossFireCount && self->bossFireTimeout < level.time)
+		self->bossFireCount = 0;
+
+	if (self->bossFireCount > 40 && self->bossFireTimeout > level.time)
+	{
+		// that's it, we are pissed...
+		if (range_to(self, self->enemy) <= RANGE_MELEE)
+		{
+			fire_empnuke(self, self->s.origin, 1024);
+		}
+
+		zboss_attack(self);
+		self->bossFireCount = 0;
+		self->bossFireTimeout = 0_sec;
+		return;
+	}
+
+	self->bossFireCount++;
+	self->bossFireTimeout = level.time + 1_sec;
+
+	if (self->health < (self->max_health / 4) && (range_to(self, self->enemy) <= RANGE_MELEE))
+		fire_empnuke(self, self->s.origin, 1024);
+
+
+	if (damage >= 150)
+	{
+		M_SetAnimation(self, &zboss_move_pain3);
+		gi.sound(self, CHAN_VOICE, sound_pain3, 1, ATTN_NORM, 0);
+	}
+	else if (damage >= 80)
+	{
+		M_SetAnimation(self, &zboss_move_pain2);
+		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+	}
+	else
+	{
+		M_SetAnimation(self, &zboss_move_pain1);
+		gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+	}
+}
+
+MONSTERINFO_SETSKIN(zboss_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 4))
+		self->s.skinnum |= 2;
+	else if (self->health < (self->max_health / 2))
+		self->s.skinnum &= ~1;
+	else
+		self->s.skinnum &= ~2;
+}
+
+//
+// MELEE
+//
+
+void zboss_swing(edict_t* self)
+{
+	static	vec3_t	aim = { MELEE_DISTANCE, 0, -24 };
+	fire_hit(self, aim, (15 + (rand() % 6)), 800);
+}
+
+mframe_t zboss_frames_attack2c[] =
+{
+	{ai_charge},						// 110
+	{ai_charge, 0,	zboss_swing},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	zboss_idle},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	zboss_swing},
+	{ai_charge}						// 118
+};
+MMOVE_T(zboss_move_attack2c) = { FRAME_attak2c01, FRAME_attak2c09, zboss_frames_attack2c, zboss_posthook };
+
+void zboss_melee2(edict_t* self)
+{
+	M_SetAnimation(self, &zboss_move_attack2c);
+	gi.sound(self, CHAN_WEAPON, sound_swing, 1, ATTN_NORM, 0);
+}
+
+mframe_t zboss_frames_premelee[] =
+{
+	{ai_charge},	// 57
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	zboss_idle},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge}	// 66
+};
+MMOVE_T(zboss_move_premelee) = { FRAME_rhook01, FRAME_rhook10, zboss_frames_premelee, zboss_melee2 };
+
+MONSTERINFO_MELEE(zboss_melee) (edict_t* self) -> void
+{
+	gi.sound(self, CHAN_BODY, sound_raisegun, 1, ATTN_NORM, 0);
+	M_SetAnimation(self, &zboss_move_premelee);
+}
+
+//
+// ATTACK
+//
+
+
+// Rocket attack
+
+mframe_t zboss_frames_attack1b[] =
+{
+	{ai_charge},	// 92
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge}	// 98
+};
+MMOVE_T(zboss_move_attack1b) = { FRAME_attak1b01, FRAME_attak1b07, zboss_frames_attack1b, zboss_chooseNextAttack };
+
+
+void zboss_reloadRockets(edict_t* self)
+{
+	self->monsterinfo.aiflags &= ~AI_ONESHOTTARGET;
+	M_SetAnimation(self, &zboss_move_attack1b);
+}
+
+
+static vec3_t	rocketoffset[] =
+{
+	{-5, -50, 33},
+	{-5, -39, 27},
+	{-5, -39, 39},
+	{-5, -44, 27},
+	{-5, -44, 39},
+	{-5, -48, 29},
+	{-5, -48, 29},
+};
+
+void FireFlare(edict_t* self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	vec;
+
+	int offset = (self->s.frame - 71) / 3;
+
+	AngleVectors(self->s.angles, forward, right, NULL);
+
+	start = G_ProjectSource(self->s.origin, rocketoffset[offset], forward, right);
+
+	if (self->monsterinfo.aiflags & AI_ONESHOTTARGET)
+	{
+		vec = self->monsterinfo.shottarget;
+	}
+	else
+	{
+		vec = self->enemy->s.origin, vec;
+		vec[2] += self->enemy->viewheight;
+	}
+
+	dir = vec - start;
+	dir.normalize();
+
+	fire_flare(self, start, dir, 10, 1000, 10, 10, (crandom_open() * 10.0f), (200 + crandom_open() * 10.0f));
+
+	// play shooting sound
+	gi.sound(self, CHAN_WEAPON, gi.soundindex("weapons/flare/shoot.wav"), 1, ATTN_NORM, 0);
+}
+
+void FireRocket(edict_t* self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	vec;
+
+	if (EMPNukeCheck(self, self->s.origin))
+	{
+		gi.sound(self, CHAN_AUTO, gi.soundindex("items/empnuke/emp_missfire.wav"), 1, ATTN_NORM, 0);
+		return;
+	}
+
+	int offset = (self->s.frame - 71) / 3;
+
+	AngleVectors(self->s.angles, forward, right, NULL);
+
+	start = G_ProjectSource(self->s.origin, rocketoffset[offset], forward, right);
+
+	if (self->monsterinfo.aiflags & AI_ONESHOTTARGET)
+	{
+		vec = self->monsterinfo.shottarget;
+	}
+	else
+	{
+		vec = self->enemy->s.origin, vec;
+		vec[2] += self->enemy->viewheight;
+	}
+
+	vec[0] += (100 - (200 * frandom()));
+	vec[1] += (100 - (200 * frandom()));
+	vec[2] += (40 - (80 * frandom()));
+
+	dir = vec - start;
+	dir.normalize();
+
+	fire_rocket(self, start, dir, 70, 500, 70 + 20, 70);
+
+	gi.WriteByte(svc_muzzleflash2);
+	gi.WriteShort(self - g_edicts);
+	gi.WriteByte(MZ2_BOSS2_ROCKET_1);
+	gi.multicast(start, MULTICAST_PVS, false);
+}
+
+mframe_t zboss_frames_attack1a[] =
+{
+	{ai_charge, 0,	FireFlare},	 // 71
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	FireRocket},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	FireRocket},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	FireRocket},
+	{ai_charge, 0,	zboss_idle},
+	{ai_charge},
+	{ai_charge, 0,	FireFlare},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	FireRocket},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	FireRocket},
+	{ai_charge},
+	{ai_charge}				 // 91
+};
+MMOVE_T(zboss_move_attack1a) = { FRAME_attak1a01, FRAME_attak1a21, zboss_frames_attack1a, zboss_reloadRockets };
+
+// hook
+
+void zboss_reelInGrapple2(edict_t* self)
+{
+	vec3_t	vec, dir;
+	float length;
+	edict_t* enemy;
+	vec3_t hookoffset = { -5, -24, 34 };
+	vec3_t forward, right;
+
+	enemy = self->proboscus->enemy;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+	vec = G_ProjectSource(self->s.origin, hookoffset, forward, right);
+	dir = vec - self->proboscus->s.origin;
+	length = dir.length();
+
+	if (length <= 80 || (self->proboscus->think == HookDragThink && self->proboscus->powerarmor_time < level.time))
+	{
+		G_FreeEdict(self->proboscus);
+		self->proboscus = nullptr;
+
+		self->s.modelindex3 = gi.modelindex("models/monsters/bossz/grapple/tris.md2");
+
+		if (enemy)
+		{
+			enemy->velocity = {};
+			zboss_melee2(self);
+		}
+		else
+		{
+			zboss_chooseNextAttack(self);
+		}
+	}
+	else
+	{
+		zboss_reelInGrapple(self);
+	}
+}
+
+mframe_t zboss_frames_attack2b[] =
+{
+	{ai_charge},		 // 107
+	{ai_charge},
+	{ai_charge}		 // 109
+};
+MMOVE_T(zboss_move_attack2b) = { FRAME_attak2b01, FRAME_attak2b03, zboss_frames_attack2b, zboss_reelInGrapple2 };
+
+
+
+#if 0
+
+THINK(hook_reset) (edict_t* self) -> void
+{
+	self->owner->proboscus = nullptr;
+	G_FreeEdict(self->proboscus);
+	G_FreeEdict(self);
+}
+
+
+DIE(hook_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (mod.id == MOD_CRUSH)
+		hook_reset(self);
+}
+
+static void hook_retract(edict_t* self)
+{
+	// start retract animation
+	if (self->owner->monsterinfo.active_move == &parasite_move_fire_proboscis)
+		self->owner->monsterinfo.nextframe = FRAME_drain12;
+
+	// mark as retracting
+	self->movetype = MOVETYPE_NONE;
+	self->solid = SOLID_NOT;
+	// come back real hard
+	if (self->style != 2)
+		self->speed *= 2.0f;
+	self->style = 2;
+	gi.linkentity(self);
+}
+
+
+TOUCH(hook_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	// owner isn't trying to probe any more, don't touch anything
+	if (self->owner->monsterinfo.active_move != &parasite_move_fire_proboscis)
+		return;
+
+	vec3_t p;
+
+	// hit what we want to succ
+	if ((other->svflags & SVF_PLAYER) || other == self->owner->enemy)
+	{
+		if (tr.startsolid)
+			p = tr.endpos;
+		else
+			p = tr.endpos - ((self->s.origin - tr.endpos).normalized() * 12);
+
+		self->owner->monsterinfo.nextframe = FRAME_drain06;
+		self->movetype = MOVETYPE_NONE;
+		self->solid = SOLID_NOT;
+		self->style = 1;
+		// stick to this guy
+		self->move_origin = p - other->s.origin;
+		self->enemy = other;
+		self->s.alpha = 0.35f;
+		gi.sound(self, CHAN_WEAPON, sound_suck, 1, ATTN_NORM, 0);
+	}
+	else
+	{
+		p = tr.endpos + tr.plane.normal;
+		// hit monster, don't suck but do small damage
+		// and retract immediately
+		if (other->svflags & (SVF_MONSTER | SVF_DEADMONSTER))
+			hook_retract(self);
+		else
+		{
+			// hit wall; stick to it and do break animation
+			self->owner->monsterinfo.active_move = &parasite_move_break;
+			self->movetype = MOVETYPE_NONE;
+			self->solid = SOLID_NOT;
+			self->style = 1;
+			self->owner->s.angles[YAW] = self->s.angles[YAW];
+		}
+	}
+
+	if (other->takedamage)
+		T_Damage(other, self, self->owner, tr.plane.normal, tr.endpos, tr.plane.normal, 5, 0, DAMAGE_NONE, MOD_UNKNOWN);
+
+	gi.positioned_sound(tr.endpos, self->owner, CHAN_AUTO, sound_impact, 1, ATTN_NORM, 0);
+
+	self->s.origin = p;
+	self->nextthink = level.time + FRAME_TIME_S; // start doing stuff on next frame
+	gi.linkentity(self);
+}
+
+THINK(hook_think) (edict_t* self) -> void
+{
+	self->nextthink = level.time + FRAME_TIME_S; // start doing stuff on next frame
+
+	// retracting; keep pulling until we hit the parasite
+	if (self->style == 2)
+	{
+		vec3_t start = parasite_get_proboscis_start(self->owner);
+		vec3_t dir = (self->s.origin - start);
+		float dist = dir.normalize();
+
+		if (dist <= (self->speed * 2) * gi.frame_time_s)
+		{
+			// reached target; free self on next frame, let parasite know
+			self->style = 3;
+			self->think = hook_reset;
+			self->s.origin = start;
+			gi.linkentity(self);
+			return;
+		}
+
+		// pull us in
+		self->s.origin -= dir * (self->speed * gi.frame_time_s);
+		gi.linkentity(self);
+	}
+	// stuck on target; do damage, suck health
+	// and check if target goes away
+	else if (self->style == 1)
+	{
+		if (!self->enemy)
+		{
+			// stuck in wall
+		}
+		else if (!self->enemy->inuse || self->enemy->health <= 0 || !self->enemy->takedamage)
+		{
+			// target gone, retract early
+			hook_retract(self);
+		}
+		else
+		{
+			// update our position
+			self->s.origin = self->enemy->s.origin + self->move_origin;
+
+			vec3_t start = parasite_get_proboscis_start(self->owner);
+
+			self->s.angles = vectoangles((self->s.origin - start).normalized());
+
+			// see if we got cut by the world
+			trace_t tr = gi.traceline(start, self->s.origin, nullptr, MASK_SOLID);
+
+			if (tr.fraction != 1.0f)
+			{
+				// blocked, so retract
+				hook_retract(self);
+				self->s.origin = self->s.old_origin;
+			}
+			else
+			{
+				// succ & drain
+				if (self->timestamp <= level.time)
+				{
+					T_Damage(self->enemy, self, self->owner, tr.plane.normal, tr.endpos, tr.plane.normal, 2, 0, DAMAGE_NONE, MOD_UNKNOWN);
+					self->owner->health = min(self->owner->max_health, self->owner->health + 2);
+					self->owner->monsterinfo.setskin(self->owner);
+					self->timestamp = level.time + 10_hz;
+				}
+			}
+
+			gi.linkentity(self);
+		}
+	}
+	// flying
+	else if (self->style == 0)
+	{
+		// owner gone away?
+		if (!self->owner->enemy || !self->owner->enemy->inuse || self->owner->enemy->health <= 0)
+		{
+			hook_retract(self);
+			return;
+		}
+
+		// if we're well behind our target and missed by 2x velocity,
+		// be smart enough to pull in automatically
+		vec3_t to_target = (self->s.origin - self->owner->enemy->s.origin);
+		float dist_to_target = to_target.normalize();
+
+		if (dist_to_target > (self->speed * 2) / 15.f)
+		{
+			vec3_t from_owner = (self->s.origin - self->owner->s.origin).normalized();
+			float dot = to_target.dot(from_owner);
+
+			if (dot > 0.f)
+			{
+				hook_retract(self);
+				return;
+			}
+		}
+	}
+}
+
+PRETHINK(hook_segment_draw) (edict_t* self) -> void
+{
+	vec3_t start = { -5, -24, 34 };
+
+	self->s.origin = start;
+	self->s.old_origin = self->owner->s.origin - ((self->owner->s.origin - start).normalized() * 8.f);
+	gi.linkentity(self);
+}
+
+
+void fire_hook(edict_t* self)
+{
+	vec3_t start, dir;
+	float speed = 1250;
+	vec3_t f, r, start;
+	vec3_t offset;
+
+	AngleVectors(self->s.angles, f, r, nullptr);
+	offset = { -5, -24, 34 };
+	start = M_ProjectFlashSource(self, offset, f, r);
+
+	PredictAim(self, self->enemy, start, speed, false, crandom_open() * 0.1f, &dir, nullptr);
+
+	edict_t* tip = G_Spawn();
+	tip->s.angles = vectoangles(dir);
+	tip->s.modelindex = gi.modelindex("models/monsters/parasite/tip/tris.md2");
+	tip->movetype = MOVETYPE_FLYMISSILE;
+	tip->owner = self;
+	self->proboscus = tip;
+	tip->clipmask = MASK_PROJECTILE & ~CONTENTS_DEADMONSTER;
+	tip->s.origin = tip->s.old_origin = start;
+	tip->speed = speed;
+	tip->velocity = dir * speed;
+	tip->solid = SOLID_BBOX;
+	tip->takedamage = true;
+	tip->flags |= FL_NO_DAMAGE_EFFECTS | FL_NO_KNOCKBACK;
+	tip->die = hook_die;
+	tip->touch = hook_touch;
+	tip->think = hook_think;
+	tip->nextthink = level.time + FRAME_TIME_S; // start doing stuff on next frame
+	tip->svflags |= SVF_PROJECTILE;
+
+	edict_t* segment = G_Spawn();
+	segment->s.modelindex = gi.modelindex("models/monsters/parasite/segment/tris.md2");
+	segment->s.renderfx = RF_BEAM;
+	segment->postthink = hook_segment_draw;
+
+	tip->proboscus = segment;
+	segment->owner = tip;
+
+	trace_t tr = gi.traceline(tip->s.origin, tip->s.origin + (tip->velocity * gi.frame_time_s), self, tip->clipmask);
+	if (tr.startsolid)
+	{
+		tr.plane.normal = -dir;
+		tr.endpos = start;
+		tip->touch(tip, tr.ent, tr, false);
+	}
+	else if (tr.fraction < 1.0f)
+		tip->touch(tip, tr.ent, tr, false);
+
+	segment->s.origin = start;
+	segment->s.old_origin = tip->s.origin + ((tip->s.origin - start).normalized() * 8.f);
+
+	gi.linkentity(tip);
+	gi.linkentity(segment);
+}
+#endif
+
+
+
+
+
+
+
+
+
+
+THINK(HookDragThink) (edict_t* self) -> void
+{
+	vec3_t	dir, vec;
+	float	speed;
+	vec3_t	hookoffset = { -5, -24, 34 };
+	vec3_t	forward, right;
+
+	if (self->enemy && self->enemy->health > 0)
+	{
+		self->s.origin = self->enemy->s.origin;
+	}
+
+	dir = self->owner->s.origin - self->s.origin;
+
+	AngleVectors(self->owner->s.angles, forward, right, nullptr);
+	vec = G_ProjectSource(self->owner->s.origin, hookoffset, forward, right);
+
+	dir = vec - self->s.origin;
+	speed = dir.length();
+	dir.normalize();
+
+	speed = 1500;
+	self->velocity = dir * speed;
+
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_MEDIC_CABLE_ATTACK);
+	gi.WriteShort(self - g_edicts);
+	gi.WritePosition(self->s.origin);
+	gi.WritePosition(vec);
+	gi.multicast(self->s.origin, MULTICAST_PVS, false);
+
+	self->nextthink = level.time + 0.1_sec;
+}
+
+TOUCH(hook_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (other == self->owner)
+		return;
+
+	if (other->takedamage)
+	{
+		gi.sound(self, CHAN_WEAPON, sound_hookimpact, 1, ATTN_NORM, 0);
+		T_Damage(other, self, self->owner, self->velocity, self->s.origin, tr.plane.normal, 1, 0, DAMAGE_NONE, MOD_ROCKET);
+	}
+
+	if (other->client && other->health > 0)
+	{ // alive... Let's drag the bastard back...
+		self->enemy = other;
+		vec3_t forward;
+		self->s.origin[2] += 1;
+		AngleVectors(self->s.angles, forward, nullptr, nullptr);
+		self->enemy->velocity = forward * -1200;
+	}
+
+	self->powerarmor_time = level.time + 15_sec;
+	self->velocity = {};
+	self->nextthink = level.time + 0.1_sec;
+	self->think = HookDragThink;
+	self->s.frame = 283;
+}
+
+
+THINK(hook_think) (edict_t* self) -> void
+{
+	vec3_t	vec;
+	vec3_t	hookoffset = { -3, -24, 34 };
+	vec3_t	forward, right;
+
+	if (self->powerarmor_time < level.time)
+	{
+		self->powerarmor_time = level.time + 15_sec;
+		self->velocity = {};
+		self->enemy = nullptr;
+		self->think = HookDragThink;
+		self->s.frame = 283;
+	}
+
+
+	AngleVectors(self->owner->s.angles, forward, right, nullptr);
+	vec = G_ProjectSource(self->owner->s.origin, hookoffset, forward, right);
+
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_MEDIC_CABLE_ATTACK);
+	gi.WriteShort(self - g_edicts);
+	gi.WritePosition(self->s.origin);
+	gi.WritePosition(vec);
+	gi.multicast(self->s.origin, MULTICAST_PVS, false);
+
+	self->nextthink = level.time + 0.1_sec;
+}
+
+void fire_hook(edict_t* self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	vec;
+	vec3_t	hookoffset = { -1, -24, 34 };
+	edict_t* hook;
+	float speed;
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+
+	start = G_ProjectSource(self->s.origin, hookoffset, forward, right);
+	vec = self->enemy->s.origin;
+	vec[2] += self->enemy->viewheight;
+	dir = vec - start;
+	dir.normalize();
+
+	self->s.modelindex3 = 0;
+
+	speed = 2000;
+
+	gi.sound(self, CHAN_WEAPON, sound_hooklaunch, 1, ATTN_NORM, 0);
+
+	self->proboscus = hook = G_Spawn();
+	hook->s.origin = start;
+	hook->movedir = dir;
+	hook->s.angles = vectoangles(dir);
+	hook->velocity = dir * speed;
+	hook->movetype = MOVETYPE_FLYMISSILE;
+	hook->clipmask = MASK_SHOT;
+	hook->solid = SOLID_BBOX;
+	hook->mins = {};
+	hook->maxs = {};
+	hook->s.modelindex = gi.modelindex("models/monsters/bossz/grapple/tris.md2");
+	hook->s.frame = 282;
+	hook->owner = self;
+	hook->touch = hook_touch;
+	hook->powerarmor_time = level.time + 8000_ms / speed;
+	hook->nextthink = level.time + 0.4_sec;
+	hook->think = hook_think;
+	hook->s.sound = sound_hookfly; // replace...
+	hook->classname = "bosshook";
+
+	gi.linkentity(hook);
+}
+
+void zboss_reelInGrapple(edict_t* self)
+{
+	M_SetAnimation(self, &zboss_move_attack2b);
+}
+
+mframe_t zboss_frames_attack2a[] =
+{
+	{ai_charge},			 // 99
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	zboss_idle},
+	{ai_charge},
+	{ai_charge, 0,	fire_hook},	 // 104
+	{ai_charge},
+	{ai_charge}			 // 106
+};
+MMOVE_T(zboss_move_attack2a) = { FRAME_attak2a01, FRAME_attak2a08, zboss_frames_attack2a, zboss_reelInGrapple };
+
+mframe_t zboss_frames_posthook[] =
+{
+	{ai_charge},	 // 136
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge}	 // 141
+};
+MMOVE_T(zboss_move_posthook) = { FRAME_lhook01, FRAME_lhook06, zboss_frames_posthook, zboss_run };
+
+void zboss_posthook(edict_t* self)
+{
+	M_SetAnimation(self, &zboss_move_posthook);
+}
+
+void zboss_chooseHookRocket(edict_t* self)
+{
+	if (frandom() < 0.2 && !(self->monsterinfo.aiflags & AI_ONESHOTTARGET))
+	{
+		M_SetAnimation(self, &zboss_move_attack2a);
+	}
+	else
+	{
+		M_SetAnimation(self, &zboss_move_attack1a);
+	}
+}
+
+mframe_t zboss_frames_prehook[] =
+{
+	{ai_charge},	// 57
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge}	// 66
+};
+MMOVE_T(zboss_move_prehook) = { FRAME_rhook01, FRAME_rhook10, zboss_frames_prehook, zboss_chooseHookRocket };
+
+// Plasma Cannon
+
+THINK(PlasmaballBlastAnim) (edict_t* ent) -> void
+{
+	ent->s.frame++;
+	ent->s.skinnum++;
+
+	if (ent->s.frame > 1)
+	{
+		G_FreeEdict(ent);
+		return;
+	}
+	else
+	{
+		ent->nextthink = level.time + 0.1_sec;
+	}
+}
+
+THINK(Plasmaball_Explode) (edict_t* ent) -> void
+{
+	//FIXME: if we are onground then raise our Z just a bit since we are a point?
+	if (ent->enemy)
+	{
+		float	points;
+		vec3_t	v;
+		vec3_t	dir;
+
+		v =ent->enemy->mins + ent->enemy->maxs;
+		v = ent->enemy->s.origin + (v * 0.5);
+		v = ent->s.origin - v;
+		points = ent->dmg - 0.5 * v.length();
+		dir = ent->enemy->s.origin - ent->s.origin;
+		T_Damage(ent->enemy, ent, ent->owner, dir, ent->s.origin, vec3_origin, (int)points, (int)points, DAMAGE_RADIUS, MOD_UNKNOWN);
+	}
+
+	T_RadiusDamage(ent, ent->owner, ent->dmg, ent->enemy, ent->dmg_radius, DAMAGE_ENERGY, MOD_UNKNOWN);
+
+	ent->s.origin = ent->s.origin + (ent->velocity * -0.02);
+	ent->velocity = {};
+
+	ent->movetype = MOVETYPE_NONE;
+	ent->s.modelindex = gi.modelindex("models/objects/b_explode/tris.md2");
+	ent->s.effects &= ~EF_BFG & ~EF_ANIM_ALLFAST;
+	ent->s.frame = 0;
+	ent->s.skinnum = 6;
+
+	gi.sound(ent, CHAN_AUTO, sound_plamsaballexplode, 1, ATTN_NORM, 0);
+
+	ent->think = PlasmaballBlastAnim;
+	ent->nextthink = level.time + 0.1_sec;
+}
+
+TOUCH(Plasmaball_Touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (tr.surface && (tr.surface->flags & SURF_SKY))
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	self->enemy = other;
+	Plasmaball_Explode(self);
+}
+
+void fire_plasmacannon(edict_t* self, vec3_t start, vec3_t aimdir, int damage, int speed, float damage_radius, float distance)
+{
+	edict_t* plasmaball;
+	vec3_t	dir;
+	vec3_t	forward, right, up;
+
+	dir = vectoangles(aimdir);
+	AngleVectors(dir, forward, right, up);
+
+	plasmaball = G_Spawn();
+	plasmaball->s.origin = start;
+	plasmaball->velocity = aimdir * speed;
+	plasmaball->velocity = plasmaball->velocity + (up * ((distance - 500) + crandom() * 10.0));
+	plasmaball->velocity = plasmaball->velocity + (right * (crandom() * 10.0));
+	plasmaball->avelocity = { 300, 300, 300 };
+	plasmaball->movetype = MOVETYPE_BOUNCE;
+	plasmaball->clipmask = MASK_SHOT;
+	plasmaball->solid = SOLID_BBOX;
+	plasmaball->mins = {};
+	plasmaball->maxs = {};
+	plasmaball->s.modelindex = gi.modelindex("sprites/plasma1.sp2");
+	plasmaball->s.effects = EF_BFG | EF_ANIM_ALLFAST;
+	plasmaball->owner = self;
+	plasmaball->touch = Plasmaball_Touch;
+	plasmaball->nextthink = level.time + 2.5_sec;
+	plasmaball->think = Plasmaball_Explode;
+	plasmaball->dmg = damage;
+	plasmaball->dmg_radius = damage_radius;
+	plasmaball->classname = "plasmaball";
+	plasmaball->s.sound = sound_plamsaballfly;
+
+	gi.sound(self, CHAN_AUTO, sound_plamsaballfire, 1, ATTN_NORM, 0);
+	gi.linkentity(plasmaball);
+}
+
+
+static vec3_t cannonoffset[] =
+{
+	{-19, -44, 30},
+	{-14, -33, 32},
+	{-4 , -45, 32},
+	{-2 , -34, 32},
+	{  7, -49, 32},
+	{  6, -36, 34},
+	{  6, -36, 34},
+};
+
+void FireCannon(edict_t* self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	dir;
+	vec3_t	vec;
+	float distance;
+
+	int offset = (self->s.frame - 119) / 2;
+
+	if (EMPNukeCheck(self, self->s.origin))
+	{
+		gi.sound(self, CHAN_AUTO, gi.soundindex("items/empnuke/emp_missfire.wav"), 1, ATTN_NORM, 0);
+		return;
+	}
+	
+	AngleVectors(self->s.angles, forward, right, nullptr);
+
+	start = G_ProjectSource(self->s.origin, cannonoffset[offset], forward, right);
+
+	if (self->monsterinfo.aiflags & AI_ONESHOTTARGET)
+	{
+		vec = self->monsterinfo.shottarget;
+	}
+	else
+	{
+		vec = self->enemy->s.origin;
+		vec[2] += self->enemy->viewheight;
+	}
+
+	if (self->timeout)
+	{
+		if (self->seq)
+		{
+			right = -right;
+		}
+		vec = vec + (right * self->timeout.seconds());
+
+	}
+	self->timeout -= 50_sec;
+
+	dir = vec - start;
+	dir.normalize();
+
+	vec = self->enemy->s.origin - self->s.origin;
+	distance = vec.length();
+
+	if (distance < 700)
+	{
+		distance = 700;
+	}
+
+	if (skill->integer < 2)
+	{
+		fire_plasmacannon(self, start, dir, 90, 700, 90 + 40, distance);
+	}
+	else if (skill->integer < 3)
+	{
+		fire_plasmacannon(self, start, dir, 90, (int)(distance * 1.2), 90 + 40, distance);
+	}
+	else
+	{
+		fire_plasmacannon(self, start, dir, 90, (int)(distance * 1.6), 90 + 40, distance);
+	}
+}
+
+mframe_t zboss_frames_attack3[] =
+{
+	{ai_charge, 0,	FireCannon},	// 119
+	{ai_charge},
+	{ai_charge, 0,	FireCannon},	// 121
+	{ai_charge},
+	{ai_charge, 0,	FireCannon},	// 123
+	{ai_charge},
+	{ai_charge, 0,	FireCannon},	// 125
+	{ai_charge, 0,	zboss_idle},
+	{ai_charge, 0,	FireCannon},	// 127
+	{ai_charge},
+	{ai_charge, 0,	FireCannon},	// 129
+	{ai_charge},
+	{ai_charge, 0,	FireCannon},	// 131
+	{ai_charge}				// 132
+};
+MMOVE_T(zboss_move_attack3) = { FRAME_attak301, FRAME_attak314, zboss_frames_attack3, zboss_chooseNextAttack };
+
+
+void zboss_fireCannons(edict_t* self)
+{
+	M_SetAnimation(self, &zboss_move_attack3);
+
+	self->seq = 0;
+	self->timeout = 150_sec;
+}
+
+mframe_t zboss_frames_precannon[] =
+{
+	{ai_charge},	// 67
+	{ai_charge},
+	{ai_charge},
+	{ai_charge}	// 70
+};
+MMOVE_T(zboss_move_precannon) = { FRAME_rcannon01, FRAME_rcannon04, zboss_frames_precannon, zboss_fireCannons };
+
+mframe_t zboss_frames_postcannon[] =
+{
+	{ai_charge},	// 133
+	{ai_charge},
+	{ai_charge}	// 135
+};
+MMOVE_T(zboss_move_postcannon) = { FRAME_lcannon01, FRAME_lcannon03, zboss_frames_postcannon, zboss_run };
+
+
+void zboss_postcannon(edict_t* self)
+{
+	M_SetAnimation(self, &zboss_move_postcannon);
+}
+
+// switching in mid attack...
+
+mframe_t zboss_frames_h2c[] =
+{
+	{ai_charge},	// 142
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge}	// 147
+};
+MMOVE_T(zboss_move_h2c) = { FRAME_h2c01, FRAME_h2c06, zboss_frames_h2c, zboss_fireCannons };
+
+
+mframe_t zboss_frames_c2h[] =
+{
+	{ai_charge},	// 148
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	zboss_idle},
+	{ai_charge},
+	{ai_charge}	// 153
+};
+MMOVE_T(zboss_move_c2h) = { FRAME_c2h01, FRAME_c2h06, zboss_frames_c2h, zboss_chooseHookRocket };
+
+void zboss_chooseNextAttack(edict_t* self)
+{
+	if (self->enemy == nullptr)
+		return;
+
+	self->monsterinfo.aiflags &= ~AI_ONESHOTTARGET;
+
+	if (frandom() < 0.5 && self->enemy)
+	{
+		if (frandom() < 0.4)
+		{
+			if (self->monsterinfo.active_move == &zboss_move_attack3)
+			{
+				gi.sound(self, CHAN_BODY, sound_switchattacks, 1, ATTN_NORM, 0);
+				M_SetAnimation(self, &zboss_move_c2h);
+			}
+			else
+			{
+				zboss_chooseHookRocket(self);
+			}
+		}
+		else
+		{
+			if (self->monsterinfo.active_move == &zboss_move_attack3)
+			{
+				zboss_fireCannons(self);
+			}
+			else
+			{
+				gi.sound(self, CHAN_BODY, sound_switchattacks, 1, ATTN_NORM, 0);
+				M_SetAnimation(self, &zboss_move_h2c);
+			}
+		}
+	}
+	else
+	{
+		gi.sound(self, CHAN_BODY, sound_lowergun, 1, ATTN_NORM, 0);
+
+		if (self->monsterinfo.active_move == &zboss_move_attack3)
+		{
+			zboss_postcannon(self);
+		}
+		else
+		{
+			zboss_posthook(self);
+		}
+	}
+}
+
+MONSTERINFO_ATTACK(zboss_attack) (edict_t* self) -> void
+{
+	if (self->enemy == nullptr)
+		return;
+
+	gi.sound(self, CHAN_BODY, sound_raisegun, 1, ATTN_NORM, 0);
+
+	if (frandom() < 0.4)
+	{
+		M_SetAnimation(self, &zboss_move_prehook);
+	}
+	else
+	{
+		M_SetAnimation(self, &zboss_move_precannon);
+	}
+}
+
+/*
+===
+Death Stuff Starts
+===
+*/
+static void zboss_gib(edict_t* self)
+{
+	gi.WriteByte(svc_temp_entity);
+	gi.WriteByte(TE_EXPLOSION1_BIG);
+	gi.WritePosition(self->s.origin);
+	gi.multicast(self->s.origin, MULTICAST_PHS, false);
+
+	self->s.sound = 0;
+	self->s.skinnum /= 2;
+
+	ThrowGibs(self, 500, {
+		{ 2, "models/objects/gibs/bone/tris.md2" },
+		{ 3, "models/objects/gibs/sm_meat/tris.md2" },
+		{ 6, "models/objects/gibs/sm_metal/tris.md2", GIB_METALLIC },
+		{ 3, "models/objects/gibs/gear/tris.md2", GIB_METALLIC },
+		{ "models/objects/gibs/chest/tris.md2" },
+		{ "models/objects/gibs/head2/tris.md2", GIB_HEAD }
+		});
+}
+
+void zboss_dead(edict_t* self)
+{
+	// no blowy on deady
+	if (self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
+	{
+		self->deadflag = false;
+		self->takedamage = true;
+		return;
+	}
+
+	zboss_gib(self);
+}
+
+mframe_t zboss_frames_death1[] =
+{
+	{ai_move, 0, BossExplode},	// 218
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},	// 227
+
+	{ai_move}, // 228
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}	// 236
+};
+MMOVE_T(zboss_move_death1) = { FRAME_death101, FRAME_death119, zboss_frames_death1, zboss_dead };
+
+void fire_deadrocket1(edict_t* self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	rocketoffset = { -26, -26, 25 };
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+
+	start = G_ProjectSource(self->s.origin, rocketoffset, forward, right);
+
+	fire_rocket(self, start, forward, 70, 500, 70 + 20, 70);
+
+	gi.WriteByte(svc_muzzleflash2);
+	gi.WriteShort(self - g_edicts);
+	gi.WriteByte(MZ2_BOSS2_ROCKET_1);
+	gi.multicast(start, MULTICAST_PVS, false);
+}
+
+void fire_deadrocket2(edict_t* self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	rocketoffset = { -16, -21, 20 };
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+
+	start = G_ProjectSource(self->s.origin, rocketoffset, forward, right);
+
+	forward[1] += 10;
+	fire_rocket(self, start, forward, 70, 500, 70 + 20, 70);
+
+	gi.WriteByte(svc_muzzleflash2);
+	gi.WriteShort(self - g_edicts);
+	gi.WriteByte(MZ2_BOSS2_ROCKET_1);
+	gi.multicast(start, MULTICAST_PVS, false);
+}
+
+void fire_deadrocket3(edict_t* self)
+{
+	vec3_t	forward, right, up;
+	vec3_t	start;
+	vec3_t	rocketoffset = { -17, -20, 30 };
+
+	AngleVectors(self->s.angles, forward, right, up);
+
+	start = G_ProjectSource(self->s.origin, rocketoffset, forward, right);
+
+	fire_rocket(self, start, up, 70, 500, 70 + 20, 70);
+
+	gi.WriteByte(svc_muzzleflash2);
+	gi.WriteShort(self - g_edicts);
+	gi.WriteByte(MZ2_BOSS2_ROCKET_1);
+	gi.multicast(start, MULTICAST_PVS, false);
+}
+
+void fire_deadrocket4(edict_t* self)
+{
+
+	vec3_t	forward, right, up;
+	vec3_t	start;
+	vec3_t	rocketoffset = { -8, -16, 17 };
+
+	AngleVectors(self->s.angles, forward, right, up);
+
+	start = G_ProjectSource(self->s.origin, rocketoffset, forward, right);
+
+	fire_rocket(self, start, up, 70, 500, 70 + 20, 70);
+
+	gi.WriteByte(svc_muzzleflash2);
+	gi.WriteShort(self - g_edicts);
+	gi.WriteByte(MZ2_BOSS2_ROCKET_1);
+	gi.multicast(start, MULTICAST_PVS, false);
+}
+
+void fire_deadrocket5(edict_t* self)
+{
+	vec3_t	forward, right, up;
+	vec3_t	start;
+	vec3_t	rocketoffset = { -10, -16, 30 };
+
+	AngleVectors(self->s.angles, forward, right, up);
+
+	start = G_ProjectSource(self->s.origin, rocketoffset, forward, right);
+	forward = -forward;
+
+	fire_rocket(self, start, forward, 70, 500, 70 + 20, 70);
+
+	gi.WriteByte(svc_muzzleflash2);
+	gi.WriteShort(self - g_edicts);
+	gi.WriteByte(MZ2_BOSS2_ROCKET_1);
+	gi.multicast(start, MULTICAST_PVS, false);
+}
+
+void fire_deadrocket6(edict_t* self)
+{
+	vec3_t	forward, right, up;
+	vec3_t	start;
+	vec3_t	rocketoffset = { 0, -18, 25 };
+
+	AngleVectors(self->s.angles, forward, right, up);
+
+	start = G_ProjectSource(self->s.origin, rocketoffset, forward, right);
+	forward = -forward;
+	forward[1] -= 10;
+
+	fire_rocket(self, start, forward, 70, 500, 70 + 20, 70);
+
+	gi.WriteByte(svc_muzzleflash2);
+	gi.WriteShort(self - g_edicts);
+	gi.WriteByte(MZ2_BOSS2_ROCKET_1);
+	gi.multicast(start, MULTICAST_PVS, false);
+}
+
+void fire_deadrocket7(edict_t* self)
+{
+	vec3_t	forward, right, up;
+	vec3_t	start;
+	vec3_t	rocketoffset = { 17, -27, 30 };
+
+	AngleVectors(self->s.angles, forward, right, up);
+
+	start = G_ProjectSource(self->s.origin, rocketoffset, forward, right);
+	forward = -forward;
+	forward[1] -= 10;
+
+	fire_rocket(self, start, forward, 70, 500, 70 + 20, 70);
+
+	gi.WriteByte(svc_muzzleflash2);
+	gi.WriteShort(self - g_edicts);
+	gi.WriteByte(MZ2_BOSS2_ROCKET_1);
+	gi.multicast(start, MULTICAST_PVS, false);
+}
+
+void FireDeadCannon1(edict_t* self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	cannonoffset = { 9, -46, 33 };
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+
+	start = G_ProjectSource(self->s.origin, cannonoffset, forward, right);
+
+	fire_plasmacannon(self, start, forward, 90, 700, 90 + 40, 700);
+
+	gi.WriteByte(svc_muzzleflash2);
+	gi.WriteShort(self - g_edicts);
+	gi.WriteByte(MZ2_GUNNER_GRENADE_1);
+	gi.multicast(start, MULTICAST_PVS, false);
+}
+
+void FireDeadCannon2(edict_t* self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	cannonoffset = { 3, -31, 37 };
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+
+	start = G_ProjectSource(self->s.origin, cannonoffset, forward, right);
+
+	fire_plasmacannon(self, start, forward, 90, 700, 90 + 40, 700);
+
+	gi.WriteByte(svc_muzzleflash2);
+	gi.WriteShort(self - g_edicts);
+	gi.WriteByte(MZ2_GUNNER_GRENADE_1);
+	gi.multicast(start, MULTICAST_PVS, false);
+}
+
+void FireDeadCannon3(edict_t* self)
+{
+	vec3_t	forward, right;
+	vec3_t	start;
+	vec3_t	cannonoffset = { -21, -19, 24 };
+
+	AngleVectors(self->s.angles, forward, right, nullptr);
+
+	start = G_ProjectSource(self->s.origin, cannonoffset, forward, right);
+
+	fire_plasmacannon(self, start, forward, 90, 700, 90 + 40, 700);
+
+	gi.WriteByte(svc_muzzleflash2);
+	gi.WriteShort(self - g_edicts);
+	gi.WriteByte(MZ2_GUNNER_GRENADE_1);
+	gi.multicast(start, MULTICAST_PVS, false);
+}
+
+TOUCH(deadhook_touch) (edict_t* ent, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (other == ent->owner)
+		return;
+
+	if (other->takedamage)
+	{
+		gi.sound(ent, CHAN_WEAPON, sound_hookimpact, 1, ATTN_NORM, 0);
+		T_Damage(other, ent, ent->owner, ent->velocity, ent->s.origin, tr.plane.normal, 10, 0, DAMAGE_NONE, MOD_ROCKET);
+	}
+
+	G_FreeEdict(ent);
+}
+
+void fire_deadhook(edict_t* self)
+{
+	vec3_t	forward, right, up;
+	vec3_t	start;
+	vec3_t	hookoffset = { -35, 8, 28 };
+	edict_t* hook;
+	float speed;
+
+	if (self->s.modelindex3 == 0)  // hook already out...
+		return;
+
+	AngleVectors(self->s.angles, forward, right, up);
+
+	start = G_ProjectSource(self->s.origin, hookoffset, forward, right);
+
+	self->s.modelindex3 = 0;
+
+	speed = 500;
+
+	gi.sound(self, CHAN_WEAPON, sound_hooklaunch, 1, ATTN_NORM, 0);
+
+	hook = G_Spawn();
+	hook->s.origin = start;
+	hook->movedir = up;
+	hook->s.angles = vectoangles(up);
+	hook->velocity = up * speed;
+	hook->movetype = MOVETYPE_FLYMISSILE;
+	hook->clipmask = MASK_SHOT;
+	hook->solid = SOLID_BBOX;
+	hook->mins = {};
+	hook->maxs = {};
+	hook->s.modelindex = gi.modelindex("models/monsters/bossz/grapple/tris.md2");
+	hook->s.frame = 282;
+	hook->owner = self;
+	hook->touch = deadhook_touch;
+	hook->nextthink = level.time + 8000_ms / speed;
+	hook->think = G_FreeEdict;
+	hook->s.sound = sound_hookfly; // replace...
+	hook->classname = "bosshook";
+
+	gi.linkentity(hook);
+}
+
+mframe_t zboss_frames_death2[] =
+{
+	{ai_move},							// 237
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},							// 246
+
+	{ai_move},							// 247
+	{ai_move},
+	{ai_move, 0,	fire_deadrocket1},	// 249
+	{ai_move, 0,	fire_deadrocket2},	// 250
+	{ai_move, 0,	fire_deadrocket3},	// 251
+	{ai_move, 0,	fire_deadrocket4},	// 252
+	{ai_move, 0,	fire_deadrocket5},	// 253
+	{ai_move, 0,	fire_deadrocket6},	// 254
+	{ai_move, 0,	fire_deadrocket7},	// 255
+	{ai_move},						  // 256
+
+	{ai_move, 0,	FireDeadCannon1},  // 257
+	{ai_move, 0,	FireDeadCannon2},	// 258
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0,	FireDeadCannon3},	// 264
+	{ai_move, 0, BossExplode},
+	{ai_move},							// 266
+
+	{ai_move},							// 267
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},							// 276
+
+	{ai_move},							// 277
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0,	fire_deadhook}	// 281
+};
+MMOVE_T(zboss_move_death2) = { FRAME_death200, FRAME_death245, zboss_frames_death2, zboss_dead };
+
+DIE(zboss_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+
+	if (self->proboscus)
+	{
+		G_FreeEdict(self->proboscus);
+		self->proboscus = nullptr;
+	}
+
+	if (self->spawnflags.has(SPAWNFLAG_MONSTER_DEAD))
+	{
+		// check for gib
+		if (M_CheckGib(self, mod))
+		{
+			zboss_gib(self);
+			self->deadflag = true;
+			return;
+		}
+
+		if (self->deadflag)
+			return;
+	}
+	else
+	{
+		self->deadflag = true;
+		self->takedamage = false;
+	}
+
+	if (frandom() < 0.5)
+	{
+		gi.sound(self, CHAN_VOICE, sound_die1, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &zboss_move_death1);
+	}
+	else
+	{
+		gi.sound(self, CHAN_VOICE, sound_die2, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &zboss_move_death2);
+	}
+}
+
+
+/*
+===
+End Death Stuff
+===
+*/
+
+/*QUAKED monster_zboss (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+*/
+void SP_monster_zboss(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	sound_pain1.assign("bossz/bpain1.wav");
+	sound_pain2.assign("bossz/bpain2.wav");
+	sound_pain3.assign("bossz/bpain3.wav");
+	sound_die1.assign("bossz/bdeth1.wav");
+	sound_die2.assign("bossz/bdeth2.wav");
+	sound_hooklaunch.assign("bossz/bhlaunch.wav");
+	sound_hookimpact.assign("bossz/bhimpact.wav");
+	sound_hookfly.assign("bossz/bhfly.wav");
+	sound_sight.assign("bossz/bsight1.wav");
+	sound_swing.assign("bossz/bswing.wav");
+	sound_idle1.assign("bossz/bidle1.wav");
+	sound_idle2.assign("bossz/bidle2.wav");
+	sound_walk.assign("bossz/bwalk.wav");
+	sound_raisegun.assign("bossz/braisegun.wav");
+	sound_lowergun.assign("bossz/blowergun.wav");
+	sound_switchattacks.assign("bossz/bswitch.wav");
+	sound_plamsaballfly.assign("bossz/bpbfly.wav");
+	sound_plamsaballexplode.assign("bossz/bpbexplode.wav");
+	sound_plamsaballfire.assign("bossz/bpbfire.wav");
+	sound_taunt1.assign("bossz/btaunt1.wav");
+	sound_taunt2.assign("bossz/btaunt2.wav");
+	sound_taunt3.assign("bossz/btaunt3.wav");
+
+	gi.modelindex("sprites/plasma1.sp2");
+	gi.modelindex("models/objects/b_explode/tris.md2");
+	gi.soundindex("items/empnuke/emp_trg.wav");
+
+	self->s.modelindex = gi.modelindex("models/monsters/bossz/mech/tris.md2");
+	self->s.modelindex2 = gi.modelindex("models/monsters/bossz/pilot/tris.md2");
+	self->s.modelindex3 = gi.modelindex("models/monsters/bossz/grapple/tris.md2");
+	self->mins = { -24, -24, -30 };
+	self->maxs = { 24, 24, 74 };
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->health = max(4500, 4500 + 1250 * (skill->integer - 1)) * st.health_multiplier;
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_BODY;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = max(500, 500 + 150 * (skill->integer - 1));
+	if (!st.was_key_specified("power_armor_type"))
+		self->monsterinfo.power_armor_type = IT_ITEM_POWER_SHIELD;
+	if (!st.was_key_specified("power_armor_power"))
+		self->monsterinfo.power_armor_power = max(500, 500 + 150 * (skill->integer - 1));
+	if (coop->integer)
+	{
+		self->health += (500 * skill->integer) + (500 * (CountPlayers() - 1));
+		self->monsterinfo.armor_power += (250 * skill->integer) + (250 * (CountPlayers() - 1));
+		self->monsterinfo.power_armor_power += (250 * skill->integer) + (250 * (CountPlayers() - 1));
+	}
+
+	self->gib_health = -700;
+	self->mass = 1000;
+
+	self->pain = zboss_pain;
+	self->die = zboss_die;
+
+	self->monsterinfo.stand = zboss_stand;
+	self->monsterinfo.walk = zboss_walk;
+	self->monsterinfo.run = zboss_run;
+	self->monsterinfo.attack = zboss_attack;
+	self->monsterinfo.melee = zboss_melee;
+	self->monsterinfo.sight = zboss_sight;
+	self->monsterinfo.idle = zboss_idle;
+	self->monsterinfo.setskin = zboss_setskin;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &zboss_movestand1);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	walkmonster_start(self);
+
+	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
+}
+
+/*QUAKED target_zboss_target
+*/
+
+USE(trigger_zboss) (edict_t* self, edict_t* other, edict_t* activator) -> void
+{
+	edict_t* boss = NULL;
+
+	while ((boss = G_FindByString<&edict_t::targetname>(boss, self->target)) != nullptr)
+	{
+		if (boss->health > 0)
+		{
+			boss->monsterinfo.shottarget = self->s.origin;
+			boss->monsterinfo.aiflags |= AI_ONESHOTTARGET;
+			boss->monsterinfo.attack(boss);
+		}
+	}
+}
+
+void SP_target_zboss(edict_t* self)
+{
+	if (!self->target)
+	{
+		G_FreeEdict(self);
+		return;
+	}
+
+	self->movetype = MOVETYPE_NONE;
+	self->svflags |= SVF_NOCLIENT;
+
+	self->solid = SOLID_NOT;
+	self->use = trigger_zboss;
+
+	gi.linkentity(self);
+}
--- /dev/null
+++ b/zaero/m_zaero_bossz.h	2025-09-04 19:53:48
@@ -0,0 +1,290 @@
+// Licensed under the GNU General Public License 2.0.
+
+enum
+{
+	FRAME_idle101,
+	FRAME_idle102,
+	FRAME_idle103,
+	FRAME_idle104,
+	FRAME_idle105,
+	FRAME_idle106,
+	FRAME_idle107,
+	FRAME_idle108,
+	FRAME_idle109,
+	FRAME_idle110,
+	FRAME_idle111,
+	FRAME_idle112,
+	FRAME_idle113,
+	FRAME_idle114,
+	FRAME_idle115,
+	FRAME_idle116,
+	FRAME_idle117,
+	FRAME_idle118,
+	FRAME_idle119,
+	FRAME_idle120,
+	FRAME_idle121,
+	FRAME_idle122,
+	FRAME_idle123,
+	FRAME_idle124,
+	FRAME_idle125,
+	FRAME_idle126,
+	FRAME_idle127,
+	FRAME_idle128,
+	FRAME_idle129,
+	FRAME_idle130,
+	FRAME_idle131,
+	FRAME_idle132,
+	FRAME_idle201,
+	FRAME_idle202,
+	FRAME_idle203,
+	FRAME_idle204,
+	FRAME_idle205,
+	FRAME_idle206,
+	FRAME_idle207,
+	FRAME_idle208,
+	FRAME_idle209,
+	FRAME_idle210,
+	FRAME_idle211,
+	FRAME_idle212,
+	FRAME_idle213,
+	FRAME_idle214,
+	FRAME_idle215,
+	FRAME_idle216,
+	FRAME_idle217,
+	FRAME_idle218,
+	FRAME_idle219,
+	FRAME_idle220,
+	FRAME_idle221,
+	FRAME_idle222,
+	FRAME_idle223,
+	FRAME_idle224,
+	FRAME_idle225,
+	FRAME_rhook01,
+	FRAME_rhook02,
+	FRAME_rhook03,
+	FRAME_rhook04,
+	FRAME_rhook05,
+	FRAME_rhook06,
+	FRAME_rhook07,
+	FRAME_rhook08,
+	FRAME_rhook09,
+	FRAME_rhook10,
+	FRAME_rcannon01,
+	FRAME_rcannon02,
+	FRAME_rcannon03,
+	FRAME_rcannon04,
+	FRAME_attak1a01,
+	FRAME_attak1a02,
+	FRAME_attak1a03,
+	FRAME_attak1a04,
+	FRAME_attak1a05,
+	FRAME_attak1a06,
+	FRAME_attak1a07,
+	FRAME_attak1a08,
+	FRAME_attak1a09,
+	FRAME_attak1a10,
+	FRAME_attak1a11,
+	FRAME_attak1a12,
+	FRAME_attak1a13,
+	FRAME_attak1a14,
+	FRAME_attak1a15,
+	FRAME_attak1a16,
+	FRAME_attak1a17,
+	FRAME_attak1a18,
+	FRAME_attak1a19,
+	FRAME_attak1a20,
+	FRAME_attak1a21,
+	FRAME_attak1b01,
+	FRAME_attak1b02,
+	FRAME_attak1b03,
+	FRAME_attak1b04,
+	FRAME_attak1b05,
+	FRAME_attak1b06,
+	FRAME_attak1b07,
+	FRAME_attak2a01,
+	FRAME_attak2a02,
+	FRAME_attak2a03,
+	FRAME_attak2a04,
+	FRAME_attak2a05,
+	FRAME_attak2a06,
+	FRAME_attak2a07,
+	FRAME_attak2a08,
+	FRAME_attak2b01,
+	FRAME_attak2b02,
+	FRAME_attak2b03,
+	FRAME_attak2c01,
+	FRAME_attak2c02,
+	FRAME_attak2c03,
+	FRAME_attak2c04,
+	FRAME_attak2c05,
+	FRAME_attak2c06,
+	FRAME_attak2c07,
+	FRAME_attak2c08,
+	FRAME_attak2c09,
+	FRAME_attak301,
+	FRAME_attak302,
+	FRAME_attak303,
+	FRAME_attak304,
+	FRAME_attak305,
+	FRAME_attak306,
+	FRAME_attak307,
+	FRAME_attak308,
+	FRAME_attak309,
+	FRAME_attak310,
+	FRAME_attak311,
+	FRAME_attak312,
+	FRAME_attak313,
+	FRAME_attak314,
+	FRAME_lcannon01,
+	FRAME_lcannon02,
+	FRAME_lcannon03,
+	FRAME_lhook01,
+	FRAME_lhook02,
+	FRAME_lhook03,
+	FRAME_lhook04,
+	FRAME_lhook05,
+	FRAME_lhook06,
+	FRAME_h2c01,
+	FRAME_h2c02,
+	FRAME_h2c03,
+	FRAME_h2c04,
+	FRAME_h2c05,
+	FRAME_h2c06,
+	FRAME_c2h01,
+	FRAME_c2h02,
+	FRAME_c2h03,
+	FRAME_c2h04,
+	FRAME_c2h05,
+	FRAME_c2h06,
+	FRAME_walk101,
+	FRAME_walk102,
+	FRAME_walk103,
+	FRAME_walk104,
+	FRAME_walk105,
+	FRAME_walk106,
+	FRAME_walk107,
+	FRAME_walk201,
+	FRAME_walk202,
+	FRAME_walk203,
+	FRAME_walk204,
+	FRAME_walk205,
+	FRAME_walk206,
+	FRAME_walk207,
+	FRAME_walk208,
+	FRAME_walk209,
+	FRAME_walk301,
+	FRAME_walk302,
+	FRAME_walk303,
+	FRAME_walk304,
+	FRAME_walk305,
+	FRAME_walk306,
+	FRAME_walk307,
+	FRAME_walk401,
+	FRAME_walk402,
+	FRAME_walk403,
+	FRAME_walk404,
+	FRAME_walk405,
+	FRAME_walk406,
+	FRAME_walk407,
+	FRAME_walk408,
+	FRAME_pain101,
+	FRAME_pain102,
+	FRAME_pain103,
+	FRAME_pain201,
+	FRAME_pain202,
+	FRAME_pain203,
+	FRAME_pain204,
+	FRAME_pain205,
+	FRAME_pain301,
+	FRAME_pain302,
+	FRAME_pain303,
+	FRAME_pain304,
+	FRAME_pain305,
+	FRAME_pain306,
+	FRAME_pain307,
+	FRAME_pain308,
+	FRAME_pain309,
+	FRAME_pain310,
+	FRAME_pain311,
+	FRAME_pain312,
+	FRAME_pain313,
+	FRAME_pain314,
+	FRAME_pain315,
+	FRAME_pain316,
+	FRAME_pain317,
+	FRAME_pain318,
+	FRAME_pain319,
+	FRAME_pain320,
+	FRAME_pain321,
+	FRAME_pain322,
+	FRAME_pain323,
+	FRAME_pain324,
+	FRAME_pain325,
+	FRAME_death101,
+	FRAME_death102,
+	FRAME_death103,
+	FRAME_death104,
+	FRAME_death105,
+	FRAME_death106,
+	FRAME_death107,
+	FRAME_death108,
+	FRAME_death109,
+	FRAME_death110,
+	FRAME_death111,
+	FRAME_death112,
+	FRAME_death113,
+	FRAME_death114,
+	FRAME_death115,
+	FRAME_death116,
+	FRAME_death117,
+	FRAME_death118,
+	FRAME_death119,
+	FRAME_death200,
+	FRAME_death201,
+	FRAME_death202,
+	FRAME_death203,
+	FRAME_death204,
+	FRAME_death205,
+	FRAME_death206,
+	FRAME_death207,
+	FRAME_death208,
+	FRAME_death209,
+	FRAME_death210,
+	FRAME_death211,
+	FRAME_death212,
+	FRAME_death213,
+	FRAME_death214,
+	FRAME_death215,
+	FRAME_death216,
+	FRAME_death217,
+	FRAME_death218,
+	FRAME_death219,
+	FRAME_death220,
+	FRAME_death221,
+	FRAME_death222,
+	FRAME_death223,
+	FRAME_death224,
+	FRAME_death225,
+	FRAME_death226,
+	FRAME_death227,
+	FRAME_death228,
+	FRAME_death229,
+	FRAME_death230,
+	FRAME_death231,
+	FRAME_death232,
+	FRAME_death233,
+	FRAME_death234,
+	FRAME_death235,
+	FRAME_death236,
+	FRAME_death237,
+	FRAME_death238,
+	FRAME_death239,
+	FRAME_death240,
+	FRAME_death241,
+	FRAME_death242,
+	FRAME_death243,
+	FRAME_death244,
+	FRAME_death245
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/zaero/m_zaero_handler.cpp	2025-09-04 19:53:48
@@ -0,0 +1,464 @@
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+handler
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_zaero_handler.h"
+
+constexpr spawnflags_t SPAWNFLAG_HANDLER_HOLD_DELAY = 8_spawnflag;
+constexpr spawnflags_t SPAWNFLAG_HANDLER_ONE_ENTITY = 16_spawnflag;
+
+static cached_soundindex sound_idle;
+static cached_soundindex sound_idle1;
+static cached_soundindex sound_idle2;
+static cached_soundindex sound_attack;
+static cached_soundindex sound_pain;
+static cached_soundindex sound_sit;
+static cached_soundindex sound_stand;
+
+void SP_monster_hound(edict_t *self);
+void SP_monster_infantry(edict_t *self);
+void handler_standWhatNext(edict_t* self);
+void handler_standSitWhatNext (edict_t *self);
+
+void hound_createHound(edict_t *self, float healthPercent);
+void handler_ConvertToInfantry(edict_t *self);
+void hound_precache();
+
+void hound_sight (edict_t *self, edict_t *other);
+void infantry_sight (edict_t *self, edict_t *other);
+
+MONSTERINFO_SIGHT(handler_sight) (edict_t* self, edict_t* other) -> void
+{
+	hound_sight(self, other);
+	infantry_sight(self, other);
+}
+
+MONSTERINFO_SEARCH(handler_search) (edict_t* self) -> void
+{
+	if (brandom())
+		gi.sound(self, CHAN_VOICE, sound_idle1, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_idle2, 1, ATTN_NORM, 0);
+}
+
+//
+// STAND
+//
+
+mframe_t handler_frames_stand1 [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand}
+};
+MMOVE_T(handler_stand1) = { FRAME_idle101, FRAME_idle131, handler_frames_stand1, nullptr };
+
+void handler_scratch(edict_t *self)
+{
+	gi.sound(self, CHAN_VOICE, sound_idle, 1, ATTN_IDLE, 0);
+}
+
+mframe_t handler_frames_stand2 [] =
+{
+	{ai_stand, 0, handler_scratch},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(handler_stand2) = { FRAME_idle201, FRAME_idle230, handler_frames_stand2, nullptr };
+
+mframe_t handler_frames_stand3 [] =
+{
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(handler_stand3) = { FRAME_idle301, FRAME_idle330, handler_frames_stand3, nullptr };
+
+mframe_t handler_frames_stand4 [] =
+{
+	{ai_stand}, //standup
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+
+	{ai_stand}
+};
+MMOVE_T(handler_stand4) = { FRAME_stand01, FRAME_stand11, handler_frames_stand4, handler_standWhatNext};
+
+mframe_t handler_frames_stand5 [] =
+{
+	{ai_stand}, //sitdown
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(handler_stand5) = { FRAME_sit01, FRAME_sit10, handler_frames_stand5, nullptr };
+
+void handler_standWhatNext (edict_t *self)
+{
+	if(frandom() < 0.90)
+		M_SetAnimation(self, &handler_stand3);
+	else 
+		M_SetAnimation(self, &handler_stand5);
+}
+
+
+void handler_standSitWhatNext (edict_t *self)
+{
+	M_SetAnimation(self, &handler_stand4);
+}
+
+
+MONSTERINFO_STAND(handler_stand) (edict_t* self) -> void
+{
+	float r;
+
+	r = frandom();
+
+	if (r < 0.70)
+		M_SetAnimation(self, &handler_stand1);
+	else if (r < 0.85)
+		M_SetAnimation(self, &handler_stand2);
+	else
+		M_SetAnimation(self, &handler_stand5);
+}
+
+//
+// PAIN
+//
+
+PAIN(handler_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_pain, 1, ATTN_NORM, 0);
+}
+
+//
+// ATTACK and MELEE
+//
+
+void handler_createHound(edict_t *self)
+{
+	self->s.modelindex2 = 0;
+	hound_createHound(self, (self->health / 175.0));
+}
+
+
+void CheckIdleLoop(edict_t *self)
+{
+	if (self->spawnflags.has(SPAWNFLAG_HANDLER_HOLD_DELAY))
+		self->count = 2;
+	else
+		return;
+
+	if (self->count)
+		self->count--;
+	else
+		self->spawnflags &= ~SPAWNFLAG_HANDLER_HOLD_DELAY;
+
+	self->monsterinfo.nextframe = FRAME_restrain07;
+}
+
+void CheckForEnemy(edict_t *self)
+{
+	if(self->enemy && (self->enemy->client || (self->enemy->svflags & SVF_MONSTER)))
+		return;
+	else //no enemy
+		M_SetAnimation(self, &handler_stand1);
+}
+
+mframe_t handler_frames_walk[] =
+{
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk},
+	{ai_walk}
+};
+MMOVE_T(handler_move_walk) = { FRAME_idle301, FRAME_idle330, handler_frames_walk, nullptr };
+
+MONSTERINFO_WALK(handler_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &handler_move_walk);
+}
+
+mframe_t handler_frames_run [] = {
+	{ai_run, 0},
+	{ai_run, 0, CheckForEnemy},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+
+	{ai_run},
+	{ai_run, 0, handler_createHound},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run},
+	{ai_run}
+};
+MMOVE_T(handler_move_run) = { FRAME_restrain01, FRAME_restrain18, handler_frames_run, handler_ConvertToInfantry};
+
+MONSTERINFO_RUN(handler_run) (edict_t* self) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_attack, 1, ATTN_NORM, 0);
+
+	M_SetAnimation(self, &handler_move_run);
+}
+
+mframe_t handler_frames_attack[] = {
+	{ai_run, 0},
+	{ai_run, 0, CheckForEnemy},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+
+	{ai_charge},
+	{ai_charge, 0, handler_createHound},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge}
+};
+MMOVE_T(handler_move_attack) = { FRAME_restrain01, FRAME_restrain18, handler_frames_attack, handler_ConvertToInfantry };
+
+MONSTERINFO_ATTACK(handler_attack) (edict_t *self) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_attack, 1, ATTN_NORM, 0);
+
+	M_SetAnimation(self, &handler_move_attack);
+}
+
+//
+// DEATH
+//
+DIE(handler_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	self->health = 1; // can't die while together...
+}
+
+void HandlerPrecache(void)
+{
+	hound_precache();
+
+	sound_attack.assign("guard/hhattack.wav");
+	sound_idle.assign("guard/hhscratch.wav");
+	sound_sit.assign("guard/hhsitdown.wav");
+	sound_stand.assign("guard/hhstandup.wav");
+	sound_idle1.assign("infantry/infidle1.wav");
+	sound_idle2.assign("hound/hsearch1.wav");
+
+	gi.modelindex("models/monsters/infantry/tris.md2");
+}
+
+/*QUAKED monster_handler (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+*/
+void SP_monster_handler(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	HandlerPrecache();
+
+	self->s.modelindex = gi.modelindex("models/monsters/guard/handler/tris.md2");
+	self->s.modelindex2 = gi.modelindex("models/monsters/guard/hound/tris.md2");
+
+	/*
+		Handler
+		X = -36 to 3
+		Y = -3  to 27
+		Z = -24 to 28
+
+		Hound
+		X = -12 to 11
+		Y = -30 to 30
+		Z = -24  to 8
+	*/
+
+	self->mins = { -32, -32, -24 };
+	self->maxs = { 24, 32, 28 };
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	self->health = 275 * st.health_multiplier;
+	self->gib_health = -65;
+	self->mass = 450;
+
+	self->pain = handler_pain;
+	self->die = handler_die;
+
+	self->monsterinfo.stand = handler_stand;
+	self->monsterinfo.walk = handler_walk;
+	self->monsterinfo.run = handler_run;
+	self->monsterinfo.dodge = nullptr;
+	self->monsterinfo.attack = handler_attack;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = handler_sight;
+	self->monsterinfo.search = handler_search;
+
+	gi.linkentity (self);
+
+	M_SetAnimation(self, &handler_stand1);
+
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	if (!self->spawnflags.has(SPAWNFLAG_HANDLER_ONE_ENTITY))
+	{
+		level.total_monsters++; // add one for the hound which is created later :)
+	}
+
+	walkmonster_start (self);
+}
+
--- /dev/null
+++ b/zaero/m_zaero_handler.h	2025-09-04 19:53:48
@@ -0,0 +1,189 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+// G:\quake2\baseq2\models/monsters/handler
+
+enum
+{
+	FRAME_idle101,
+	FRAME_idle102,
+	FRAME_idle103,
+	FRAME_idle104,
+	FRAME_idle105,
+	FRAME_idle106,
+	FRAME_idle107,
+	FRAME_idle108,
+	FRAME_idle109,
+	FRAME_idle110,
+	FRAME_idle111,
+	FRAME_idle112,
+	FRAME_idle113,
+	FRAME_idle114,
+	FRAME_idle115,
+	FRAME_idle116,
+	FRAME_idle117,
+	FRAME_idle118,
+	FRAME_idle119,
+	FRAME_idle120,
+	FRAME_idle121,
+	FRAME_idle122,
+	FRAME_idle123,
+	FRAME_idle124,
+	FRAME_idle125,
+	FRAME_idle126,
+	FRAME_idle127,
+	FRAME_idle128,
+	FRAME_idle129,
+	FRAME_idle130,
+	FRAME_idle131,
+	FRAME_idle201,
+	FRAME_idle202,
+	FRAME_idle203,
+	FRAME_idle204,
+	FRAME_idle205,
+	FRAME_idle206,
+	FRAME_idle207,
+	FRAME_idle208,
+	FRAME_idle209,
+	FRAME_idle210,
+	FRAME_idle211,
+	FRAME_idle212,
+	FRAME_idle213,
+	FRAME_idle214,
+	FRAME_idle215,
+	FRAME_idle216,
+	FRAME_idle217,
+	FRAME_idle218,
+	FRAME_idle219,
+	FRAME_idle220,
+	FRAME_idle221,
+	FRAME_idle222,
+	FRAME_idle223,
+	FRAME_idle224,
+	FRAME_idle225,
+	FRAME_idle226,
+	FRAME_idle227,
+	FRAME_idle228,
+	FRAME_idle229,
+	FRAME_idle230,
+	FRAME_idle301,
+	FRAME_idle302,
+	FRAME_idle303,
+	FRAME_idle304,
+	FRAME_idle305,
+	FRAME_idle306,
+	FRAME_idle307,
+	FRAME_idle308,
+	FRAME_idle309,
+	FRAME_idle310,
+	FRAME_idle311,
+	FRAME_idle312,
+	FRAME_idle313,
+	FRAME_idle314,
+	FRAME_idle315,
+	FRAME_idle316,
+	FRAME_idle317,
+	FRAME_idle318,
+	FRAME_idle319,
+	FRAME_idle320,
+	FRAME_idle321,
+	FRAME_idle322,
+	FRAME_idle323,
+	FRAME_idle324,
+	FRAME_idle325,
+	FRAME_idle326,
+	FRAME_idle327,
+	FRAME_idle328,
+	FRAME_idle329,
+	FRAME_idle330,
+	FRAME_walk01,
+	FRAME_walk02,
+	FRAME_walk03,
+	FRAME_walk04,
+	FRAME_walk05,
+	FRAME_walk06,
+	FRAME_walk07,
+	FRAME_walk08,
+	FRAME_walk09,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12,
+	FRAME_walk13,
+	FRAME_walk14,
+	FRAME_walk15,
+	FRAME_walk16,
+	FRAME_walk17,
+	FRAME_walk18,
+	FRAME_walk19,
+	FRAME_walk20,
+	FRAME_walk21,
+	FRAME_walk22,
+	FRAME_walk23,
+	FRAME_walk24,
+	FRAME_walk25,
+	FRAME_walk26,
+	FRAME_walk27,
+	FRAME_walk28,
+	FRAME_walk29,
+	FRAME_walk30,
+	FRAME_walk31,
+	FRAME_walk32,
+	FRAME_stand01,
+	FRAME_stand02,
+	FRAME_stand03,
+	FRAME_stand04,
+	FRAME_stand05,
+	FRAME_stand06,
+	FRAME_stand07,
+	FRAME_stand08,
+	FRAME_stand09,
+	FRAME_stand10,
+	FRAME_stand11,
+	FRAME_sit01,
+	FRAME_sit02,
+	FRAME_sit03,
+	FRAME_sit04,
+	FRAME_sit05,
+	FRAME_sit06,
+	FRAME_sit07,
+	FRAME_sit08,
+	FRAME_sit09,
+	FRAME_sit10,
+	FRAME_restrain01,
+	FRAME_restrain02,
+	FRAME_restrain03,
+	FRAME_restrain04,
+	FRAME_restrain05,
+	FRAME_restrain06,
+	FRAME_restrain07,
+	FRAME_restrain08,
+	FRAME_restrain09,
+	FRAME_restrain10,
+	FRAME_restrain11,
+	FRAME_restrain12,
+	FRAME_restrain13,
+	FRAME_restrain14,
+	FRAME_restrain15,
+	FRAME_restrain16,
+	FRAME_restrain17,
+	FRAME_restrain18,
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
+
+/*
+	Hound constants
+#define FRAME_stand1start	    0
+#define FRAME_stand1end		    30
+#define FRAME_stand2start	    31
+#define FRAME_stand2end		    59
+#define FRAME_stand3start	    60
+#define FRAME_stand3end		    89
+#define FRAME_stand4start	    90
+#define FRAME_stand4end		    100
+#define FRAME_stand5start	    101
+#define FRAME_stand5end		    110
+
+#define FRAME_attack1Start    111
+#define FRAME_attack1Sep	    122
+#define FRAME_attack1End	    128
+*/
--- /dev/null
+++ b/zaero/m_zaero_hound.cpp	2025-09-04 19:53:48
@@ -0,0 +1,651 @@
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+hound
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_zaero_hound.h"
+
+constexpr spawnflags_t SPAWNFLAG_HOUND_NOJUMPING = 8_spawnflag;
+
+static cached_soundindex sound_pain1;
+static cached_soundindex sound_pain2;
+static cached_soundindex sound_die;
+static cached_soundindex sound_launch;
+static cached_soundindex sound_impact;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_search;
+static cached_soundindex sound_bite;
+static cached_soundindex sound_bitemiss;
+static cached_soundindex sound_jump;
+
+///
+/// SOUNDS
+/// 
+
+void hound_launch(edict_t* self)
+{
+	gi.sound(self, CHAN_WEAPON, sound_launch, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SIGHT(hound_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_SEARCH(hound_search) (edict_t* self) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_search, 1, ATTN_NORM, 0);
+}
+
+//
+// STAND
+//
+
+mframe_t hound_frames_stand1[] = {
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},  // 10
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}
+};
+MMOVE_T(hound_stand1) = { FRAME_idle401, FRAME_idle419, hound_frames_stand1, nullptr };
+
+mframe_t hound_frames_stand2[] = {
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, // 10
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, // 20
+
+	{ai_stand}
+};
+MMOVE_T(hound_stand2) = { FRAME_idle501, FRAME_idle521, hound_frames_stand2, nullptr };
+
+MONSTERINFO_STAND(hound_stand) (edict_t* self) -> void
+{
+	if (frandom() < 0.8f)
+	{
+		M_SetAnimation(self, &hound_stand1);
+	}
+	else
+	{
+		M_SetAnimation(self, &hound_stand2);
+	}
+}
+
+//
+// WALK
+//
+
+mframe_t hound_frames_walk[] =
+{
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7},
+	{ai_walk,  7}
+};
+MMOVE_T(hound_move_walk) = { FRAME_walk01, FRAME_walk08, hound_frames_walk, nullptr };
+
+MONSTERINFO_WALK(hound_walk) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &hound_move_walk);
+}
+
+
+//
+// RUN
+//
+
+mframe_t hound_frames_run[] =
+{
+	{ai_run, 60},
+	{ai_run, 60},
+	{ai_run, 40},
+	{ai_run, 30},
+	{ai_run, 30},
+	{ai_run, 30},
+	{ai_run, 40}
+};
+MMOVE_T(hound_move_run) = { FRAME_run01, FRAME_run07, hound_frames_run, nullptr };
+
+MONSTERINFO_RUN(hound_run) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+		hound_stand(self);
+	else
+		M_SetAnimation(self, &hound_move_run);
+}
+
+//
+// MELEE
+//
+
+void hound_bite(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->maxs[0], 8 };
+	if (fire_hit(self, aim, irandom(5, 9), 100))
+		gi.sound(self, CHAN_WEAPON, sound_bite, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_bitemiss, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+void hound_bite2(edict_t* self)
+{
+	vec3_t aim = { MELEE_DISTANCE, self->maxs[0], 8 };
+	if (fire_hit(self, aim, irandom(5, 9), 100))
+		gi.sound(self, CHAN_WEAPON, sound_bite, 1, ATTN_NORM, 0);
+	else
+	{
+		gi.sound(self, CHAN_WEAPON, sound_bitemiss, 1, ATTN_NORM, 0);
+		self->monsterinfo.melee_debounce_time = level.time + 1.5_sec;
+	}
+}
+
+mframe_t hound_frames_attack1[] =
+{
+	{ai_charge, 0,	hound_launch},
+	{ai_charge},
+	{ai_charge, 0,	hound_bite},
+	{ai_charge, 0,	hound_bite2}
+};
+MMOVE_T(hound_move_attack1) = { FRAME_attack101, FRAME_attack104, hound_frames_attack1, hound_run };
+
+mframe_t hound_frames_attack2[] =
+{
+	{ai_charge, 0,	hound_launch},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge},
+	{ai_charge, 0,	hound_bite},
+	{ai_charge, 0,	hound_bite2},
+	{ai_charge, 0,	hound_bite2},
+	{ai_charge, 0,	hound_bite2},
+	{ai_charge},
+	{ai_charge},
+};
+MMOVE_T(hound_move_attack2) = { FRAME_attack201, FRAME_attack214, hound_frames_attack2, hound_run };
+
+MONSTERINFO_MELEE(hound_melee) (edict_t* self) -> void
+{
+	if (frandom() < 0.6f)
+	{
+		M_SetAnimation(self, &hound_move_attack1);
+	}
+	else
+	{
+		M_SetAnimation(self, &hound_move_attack2);
+	}
+}
+
+//
+// ATTACK
+//
+
+TOUCH(hound_jump_touch) (edict_t* self, edict_t* other, const trace_t& tr, bool other_touching_self) -> void
+{
+	if (self->health <= 0)
+	{
+		self->touch = nullptr;
+		return;
+	}
+
+	if (self->style == 1 && other->takedamage)
+	{
+		if (self->velocity.length() > 400)
+		{
+			vec3_t	point;
+			vec3_t	normal;
+			int		damage;
+
+			normal = self->velocity;
+			normal.normalize();
+			point = self->s.origin + (normal * self->maxs[0]);
+			damage = (int)frandom(30, 40);
+			T_Damage(other, self, self, self->velocity, point, normal, damage, damage, DAMAGE_NONE, MOD_UNKNOWN);
+			self->style = 0;
+		}
+	}
+
+	if (!M_CheckBottom(self))
+	{
+		if (self->groundentity)
+		{
+			self->monsterinfo.nextframe = FRAME_leap04;
+			self->touch = nullptr;
+		}
+		return;
+	}
+
+	self->touch = nullptr;
+}
+
+void hound_jump_takeoff(edict_t* self)
+{
+	vec3_t	forward;
+
+	gi.sound(self, CHAN_VOICE, sound_jump, 1, ATTN_NORM, 0);
+	AngleVectors(self->s.angles, forward, nullptr, nullptr);
+	self->s.origin[2] += 1;
+	self->velocity = forward * 400;
+	self->velocity[2] = 200;
+	self->groundentity = nullptr;
+	self->monsterinfo.aiflags |= AI_DUCKED;
+	self->monsterinfo.attack_finished = level.time + 3_sec;
+	self->style = 1;
+	self->touch = hound_jump_touch;
+}
+
+void hound_check_landing(edict_t* self)
+{
+	monster_jump_finished(self);
+
+	if (self->groundentity)
+	{
+		gi.sound(self, CHAN_WEAPON, sound_impact, 1, ATTN_NORM, 0);
+		self->monsterinfo.attack_finished = level.time + random_time(500_ms, 1.5_sec);
+
+		if (self->monsterinfo.unduck)
+			self->monsterinfo.unduck(self);
+
+		if (range_to(self, self->enemy) <= RANGE_MELEE * 2.f)
+			self->monsterinfo.melee(self);
+
+		return;
+	}
+
+	if (level.time > self->monsterinfo.attack_finished)
+		self->monsterinfo.nextframe = FRAME_leap04;
+	else
+		self->monsterinfo.nextframe = FRAME_leap05;
+}
+
+void hound_check_landing2(edict_t* self)
+{
+	monster_jump_finished(self);
+
+	self->owner = nullptr;
+
+	if (self->groundentity)
+	{
+		gi.sound(self, CHAN_WEAPON, sound_impact, 1, ATTN_NORM, 0);
+		self->monsterinfo.attack_finished = level.time + random_time(500_ms, 1.5_sec);
+
+		if (self->monsterinfo.unduck)
+			self->monsterinfo.unduck(self);
+
+		if (range_to(self, self->enemy) <= RANGE_MELEE * 2.f)
+			self->monsterinfo.melee(self);
+
+		return;
+	}
+
+	if (level.time > self->monsterinfo.attack_finished)
+		self->monsterinfo.nextframe = FRAME_restrain14;
+	else
+		self->monsterinfo.nextframe = FRAME_restrain15;
+}
+
+mframe_t hound_frames_handlerjump[] =
+{
+	{ai_charge,  0},
+	{ai_charge,  20,	hound_jump_takeoff},
+	{ai_move,  40},
+	{ai_move,  30,	hound_check_landing2},
+	{ai_move,   0},
+	{ai_move,  0},
+	{ai_move,  0},
+};
+MMOVE_T(hound_move_handlerjump) = { FRAME_restrain12, FRAME_restrain18, hound_frames_handlerjump, hound_run };
+
+mframe_t hound_frames_jump[] =
+{
+	{ai_charge,	20},
+	{ai_charge,	20,	hound_jump_takeoff},
+	{ai_move,	40},
+	{ai_move,	30,	hound_check_landing},
+	{ai_move,	 0},
+	{ai_move,	 0},
+	{ai_move,	 0}
+};
+MMOVE_T(hound_move_jump) = { FRAME_leap01, FRAME_leap07, hound_frames_jump, hound_run };
+
+MONSTERINFO_ATTACK(hound_jump) (edict_t* self) -> void
+{
+	M_SetAnimation(self, &hound_move_jump);
+}
+
+//
+// CHECKATTACK
+//
+
+bool hound_check_melee(edict_t* self)
+{
+	return range_to(self, self->enemy) <= RANGE_MELEE && self->monsterinfo.melee_debounce_time <= level.time;
+}
+
+bool hound_check_jump(edict_t* self)
+{
+	vec3_t	v;
+	float	distance;
+
+	if (self->absmin[2] > (self->enemy->absmin[2] + 0.75 * self->enemy->size[2]))
+		return false;
+
+	if (self->absmax[2] < (self->enemy->absmin[2] + 0.25 * self->enemy->size[2]))
+		return false;
+
+	v[0] = self->s.origin[0] - self->enemy->s.origin[0];
+	v[1] = self->s.origin[1] - self->enemy->s.origin[1];
+	v[2] = 0;
+	distance = v.length();
+
+	if (distance < 100 && self->monsterinfo.melee_debounce_time <= level.time)
+		return false;
+	if (distance > 100)
+	{
+		if (frandom() < 0.9f)
+			return false;
+	}
+
+	return true;
+}
+
+MONSTERINFO_CHECKATTACK(hound_checkattack) (edict_t* self) -> bool
+{
+	if (!self->enemy || self->enemy->health <= 0)
+		return false;
+
+	if (hound_check_melee(self))
+	{
+		self->monsterinfo.attack_state = AS_MELEE;
+		return true;
+	}
+
+	if (!self->spawnflags.has(SPAWNFLAG_HOUND_NOJUMPING) && hound_check_jump(self))
+	{
+		self->monsterinfo.attack_state = AS_MISSILE;
+		return true;
+	}
+
+	return false;
+}
+
+//
+// PAIN
+//
+
+mframe_t hound_frames_pain1[] =
+{
+	{ai_move,  6},
+	{ai_move, 16},
+	{ai_move, -6},
+	{ai_move, -7}
+};
+MMOVE_T(hound_move_pain1) = { FRAME_pain101, FRAME_pain104, hound_frames_pain1, hound_run };
+
+mframe_t hound_frames_pain2[] =
+{
+	{ai_move,  0},
+	{ai_move,  0},
+	{ai_move,  0},
+	{ai_move,  6},
+	{ai_move, 16},
+	{ai_move, -6},
+	{ai_move, -7},
+	{ai_move,  0}
+};
+MMOVE_T(hound_move_pain2) = { FRAME_pain201, FRAME_pain208, hound_frames_pain2, hound_run };
+
+PAIN(hound_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	float r;
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	r = frandom();
+	if (r < 0.5f)
+		gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	if (r < 0.5f)
+		M_SetAnimation(self, &hound_move_pain1);
+	else
+		M_SetAnimation(self, &hound_move_pain2);
+}
+
+MONSTERINFO_SETSKIN(hound_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// DEATH
+//
+
+void hound_shrink(edict_t* self)
+{
+	self->maxs[2] = 0;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t hound_frames_death[] =
+{
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move, 0, hound_shrink},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move},
+	{ai_move}
+};
+MMOVE_T(hound_move_death) = { FRAME_death01, FRAME_death11, hound_frames_death, monster_dead };
+
+DIE(hound_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ 2, "models/objects/gibs/bone/tris.md2" },
+			{ 4, "models/objects/gibs/sm_meat/tris.md2" },
+			//{ "models/monsters/guard/hound/gibs/chest.md2", GIB_SKINNED },
+			{ "models/objects/gibs/chest/tris.md2" },
+			//{ "models/monsters/guard/hound/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			{ "models/monsters/gibs/sm_meat/head.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	gi.sound(self, CHAN_VOICE, sound_die, 1, ATTN_NORM, 0);
+	self->deadflag = true;
+	self->takedamage = true;
+	M_SetAnimation(self, &hound_move_death);
+}
+
+void hound_precache()
+{
+	sound_pain1.assign("hound/hpain1.wav");
+	sound_pain2.assign("hound/hpain2.wav");
+	sound_die.assign("hound/hdeth1.wav");
+	sound_launch.assign("hound/hlaunch.wav");
+	sound_impact.assign("hound/himpact.wav");
+	sound_sight.assign("hound/hsight1.wav");
+	sound_search.assign("hound/hsearch1.wav");
+	sound_jump.assign("hound/hjump.wav");
+	sound_bite.assign("hound/hbite1.wav");
+	sound_bitemiss.assign("hound/hbite2.wav");
+
+	gi.modelindex("models/monsters/guard/hound/tris.md2");
+}
+
+/*QUAKED monster_hound (1 .5 0) (-16 -16 -24) (16 16 32) Ambush Trigger_Spawn Sight
+*/
+void SP_monster_hound(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	hound_precache();
+
+	self->monsterinfo.aiflags |= AI_STINKY;
+
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+	self->s.modelindex = gi.modelindex("models/monsters/guard/hound/tris.md2");
+
+	self->mins = { -16, -16, -24 };
+	self->maxs = { 16, 16, 24 };
+
+	self->health = 100 * st.health_multiplier;
+	self->gib_health = -75;
+	self->mass = 150;
+
+	self->pain = hound_pain;
+	self->die = hound_die;
+
+	self->monsterinfo.stand = hound_stand;
+	self->monsterinfo.walk = hound_walk;
+	self->monsterinfo.run = hound_run;
+	self->monsterinfo.dodge = nullptr;
+	self->monsterinfo.attack = hound_jump;
+	self->monsterinfo.melee = hound_melee;
+	self->monsterinfo.sight = hound_sight;
+	self->monsterinfo.search = hound_search;
+	self->monsterinfo.checkattack = hound_checkattack;
+	self->monsterinfo.blocked = nullptr;
+	self->monsterinfo.setskin = hound_setskin;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &hound_stand1);
+
+	self->monsterinfo.combat_style = COMBAT_MELEE;
+
+	self->monsterinfo.scale = MODEL_SCALE;
+	self->monsterinfo.can_jump = !(self->spawnflags & SPAWNFLAG_HOUND_NOJUMPING);
+	self->monsterinfo.drop_height = 256;
+	self->monsterinfo.jump_height = 68;
+
+	walkmonster_start(self);
+}
+
+THINK(HoundSpawn) (edict_t* self) -> void
+{
+	vec3_t	 vec;
+	edict_t* player;
+
+	SP_monster_hound(self);
+	self->think(self);
+
+	// jump at player
+	if (self->enemy && self->enemy->inuse && self->enemy->health > 0)
+		player = self->enemy;
+	else
+		player = AI_GetSightClient(self);
+
+	if (!player)
+		return;
+
+	vec = player->s.origin - self->s.origin;
+	self->s.angles[YAW] = vectoyaw(vec);
+	vec.normalize();
+	self->velocity = vec * 200;
+	self->velocity[2] = 400;
+	self->groundentity = nullptr;
+	self->enemy = player;
+	FoundTarget(self);
+	self->monsterinfo.sight(self, self->enemy);
+	self->s.frame = self->monsterinfo.nextframe = FRAME_restrain12;
+}
+
+void hound_createHound(edict_t* self, float healthPercent)
+{
+	edict_t* ent = G_Spawn();
+	ent->classname = "monster_hound";
+	ent->target = self->target;
+	ent->s.origin = self->s.origin;
+	ent->enemy = self->enemy;
+
+	ent->health *= healthPercent;
+
+	HoundSpawn(ent);
+
+	// [Paril-KEX] set health bar over to Makron when we throw him out
+	for (size_t i = 0; i < 2; i++)
+		if (level.health_bar_entities[i] && level.health_bar_entities[i]->enemy == self)
+			level.health_bar_entities[i]->enemy = ent;
+}
--- /dev/null
+++ b/zaero/m_zaero_hound.h	2025-09-04 19:53:48
@@ -0,0 +1,242 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+// G:/quake2/baseq2/models/monsters/mutant
+
+enum
+{
+	FRAME_idle101,
+	FRAME_idle102,
+	FRAME_idle103,
+	FRAME_idle104,
+	FRAME_idle105,
+	FRAME_idle106,
+	FRAME_idle107,
+	FRAME_idle108,
+	FRAME_idle109,
+	FRAME_idle110,
+	FRAME_idle111,
+	FRAME_idle112,
+	FRAME_idle113,
+	FRAME_idle114,
+	FRAME_idle115,
+	FRAME_idle116,
+	FRAME_idle117,
+	FRAME_idle118,
+	FRAME_idle119,
+	FRAME_idle120,
+	FRAME_idle121,
+	FRAME_idle122,
+	FRAME_idle123,
+	FRAME_idle124,
+	FRAME_idle125,
+	FRAME_idle126,
+	FRAME_idle127,
+	FRAME_idle128,
+	FRAME_idle129,
+	FRAME_idle130,
+	FRAME_idle131,
+	FRAME_idle201,
+	FRAME_idle202,
+	FRAME_idle203,
+	FRAME_idle204,
+	FRAME_idle205,
+	FRAME_idle206,
+	FRAME_idle207,
+	FRAME_idle208,
+	FRAME_idle209,
+	FRAME_idle210,
+	FRAME_idle211,
+	FRAME_idle212,
+	FRAME_idle213,
+	FRAME_idle214,
+	FRAME_idle215,
+	FRAME_idle216,
+	FRAME_idle217,
+	FRAME_idle218,
+	FRAME_idle219,
+	FRAME_idle220,
+	FRAME_idle221,
+	FRAME_idle222,
+	FRAME_idle223,
+	FRAME_idle224,
+	FRAME_idle225,
+	FRAME_idle226,
+	FRAME_idle227,
+	FRAME_idle228,
+	FRAME_idle229,
+	FRAME_idle301,
+	FRAME_idle302,
+	FRAME_idle303,
+	FRAME_idle304,
+	FRAME_idle305,
+	FRAME_idle306,
+	FRAME_idle307,
+	FRAME_idle308,
+	FRAME_idle309,
+	FRAME_idle310,
+	FRAME_idle311,
+	FRAME_idle312,
+	FRAME_idle313,
+	FRAME_idle314,
+	FRAME_idle315,
+	FRAME_idle316,
+	FRAME_idle317,
+	FRAME_idle318,
+	FRAME_idle319,
+	FRAME_idle320,
+	FRAME_idle321,
+	FRAME_idle322,
+	FRAME_idle323,
+	FRAME_idle324,
+	FRAME_idle325,
+	FRAME_idle326,
+	FRAME_idle327,
+	FRAME_idle328,
+	FRAME_idle329,
+	FRAME_idle330,
+	FRAME_stand01,
+	FRAME_stand02,
+	FRAME_stand03,
+	FRAME_stand04,
+	FRAME_stand05,
+	FRAME_stand06,
+	FRAME_stand07,
+	FRAME_stand08,
+	FRAME_stand09,
+	FRAME_stand10,
+	FRAME_stand11,
+	FRAME_sit01,
+	FRAME_sit02,
+	FRAME_sit03,
+	FRAME_sit04,
+	FRAME_sit05,
+	FRAME_sit06,
+	FRAME_sit07,
+	FRAME_sit08,
+	FRAME_sit09,
+	FRAME_sit10,
+	FRAME_restrain01,
+	FRAME_restrain02,
+	FRAME_restrain03,
+	FRAME_restrain04,
+	FRAME_restrain05,
+	FRAME_restrain06,
+	FRAME_restrain07,
+	FRAME_restrain08,
+	FRAME_restrain09,
+	FRAME_restrain10,
+	FRAME_restrain11,
+	FRAME_restrain12,
+	FRAME_restrain13,
+	FRAME_restrain14,
+	FRAME_restrain15,
+	FRAME_restrain16,
+	FRAME_restrain17,
+	FRAME_restrain18,
+	FRAME_idle401,
+	FRAME_idle402,
+	FRAME_idle403,
+	FRAME_idle404,
+	FRAME_idle405,
+	FRAME_idle406,
+	FRAME_idle407,
+	FRAME_idle408,
+	FRAME_idle409,
+	FRAME_idle410,
+	FRAME_idle411,
+	FRAME_idle412,
+	FRAME_idle413,
+	FRAME_idle414,
+	FRAME_idle415,
+	FRAME_idle416,
+	FRAME_idle417,
+	FRAME_idle418,
+	FRAME_idle419,
+	FRAME_idle501,
+	FRAME_idle502,
+	FRAME_idle503,
+	FRAME_idle504,
+	FRAME_idle505,
+	FRAME_idle506,
+	FRAME_idle507,
+	FRAME_idle508,
+	FRAME_idle509,
+	FRAME_idle510,
+	FRAME_idle511,
+	FRAME_idle512,
+	FRAME_idle513,
+	FRAME_idle514,
+	FRAME_idle515,
+	FRAME_idle516,
+	FRAME_idle517,
+	FRAME_idle518,
+	FRAME_idle519,
+	FRAME_idle520,
+	FRAME_idle521,
+	FRAME_walk01,
+	FRAME_walk02,
+	FRAME_walk03,
+	FRAME_walk04,
+	FRAME_walk05,
+	FRAME_walk06,
+	FRAME_walk07,
+	FRAME_walk08,
+	FRAME_run01,
+	FRAME_run02,
+	FRAME_run03,
+	FRAME_run04,
+	FRAME_run05,
+	FRAME_run06,
+	FRAME_run07,
+	FRAME_leap01,
+	FRAME_leap02,
+	FRAME_leap03,
+	FRAME_leap04,
+	FRAME_leap05,
+	FRAME_leap06,
+	FRAME_leap07,
+	FRAME_attack101,
+	FRAME_attack102,
+	FRAME_attack103,
+	FRAME_attack104,
+	FRAME_attack201,
+	FRAME_attack202,
+	FRAME_attack203,
+	FRAME_attack204,
+	FRAME_attack205,
+	FRAME_attack206,
+	FRAME_attack207,
+	FRAME_attack208,
+	FRAME_attack209,
+	FRAME_attack210,
+	FRAME_attack211,
+	FRAME_attack212,
+	FRAME_attack213,
+	FRAME_attack214,
+	FRAME_pain101,
+	FRAME_pain102,
+	FRAME_pain103,
+	FRAME_pain104,
+	FRAME_pain201,
+	FRAME_pain202,
+	FRAME_pain203,
+	FRAME_pain204,
+	FRAME_pain205,
+	FRAME_pain206,
+	FRAME_pain207,
+	FRAME_pain208,
+	FRAME_death01,
+	FRAME_death02,
+	FRAME_death03,
+	FRAME_death04,
+	FRAME_death05,
+	FRAME_death06,
+	FRAME_death07,
+	FRAME_death08,
+	FRAME_death09,
+	FRAME_death10,
+	FRAME_death11,
+	FRAME_death12
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
--- /dev/null
+++ b/zaero/m_zaero_sentien.cpp	2025-09-04 19:53:48
@@ -0,0 +1,934 @@
+// Licensed under the GNU General Public License 2.0.
+/*
+==============================================================================
+
+SENTIEN
+
+==============================================================================
+*/
+
+#include "../g_local.h"
+#include "m_zaero_sentien.h"
+#include "../m_flash.h"
+
+static cached_soundindex sound_fend;
+static cached_soundindex sound_pain1, sound_pain2, sound_pain3;
+static cached_soundindex sound_idle1, sound_idle2, sound_idle3;
+static cached_soundindex sound_die1, sound_die2;
+static cached_soundindex sound_step;
+static cached_soundindex sound_sight;
+static cached_soundindex sound_attack1, sound_attack2;
+static cached_soundindex sound_strike;
+
+void sentien_run(edict_t* self);
+void sentien_walk(edict_t* self);
+void sentien_machinegun(edict_t* self);
+void sentien_blast_attack(edict_t* self);
+void sentien_post_blast_attack(edict_t* self);
+void sentien_laser_attack(edict_t* self);
+void sentien_post_laser_attack(edict_t* self);
+
+MONSTERINFO_SIGHT(sentien_sight) (edict_t* self, edict_t* other) -> void
+{
+	gi.sound(self, CHAN_VOICE, sound_sight, 1, ATTN_NORM, 0);
+}
+
+void sentien_step(edict_t* self)
+{
+	gi.sound(self, CHAN_BODY, sound_step, 1, ATTN_NORM, 0);
+}
+
+MONSTERINFO_IDLE(sentien_idle) (edict_t* self) -> void
+{
+	int n = irandom(3);
+	if (n == 0)
+		gi.sound(self, CHAN_BODY, sound_idle1, 1, ATTN_NORM, 0);
+	else if (n == 1)
+		gi.sound(self, CHAN_BODY, sound_idle2, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_BODY, sound_idle3, 1, ATTN_NORM, 0);
+}
+
+void sentien_sound_fend(edict_t* self)
+{
+	gi.sound(self, CHAN_BODY, sound_fend, 1, ATTN_NORM, 0);
+}
+
+//
+// stand
+//
+
+mframe_t sentien_frames_stand1[] =
+{
+   {ai_stand, 0, sentien_idle},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand}
+};
+MMOVE_T(sentien_move_stand1) = { FRAME_idle101, FRAME_idle129, sentien_frames_stand1, nullptr };
+
+mframe_t sentien_frames_stand2[] =
+{
+   {ai_stand, 0, sentien_idle},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand},
+   {ai_stand}
+};
+MMOVE_T(sentien_move_stand2) = { FRAME_idle201, FRAME_idle220, sentien_frames_stand2, nullptr };
+
+mframe_t sentien_frames_stand3[] =
+{
+	{ai_stand, 0, sentien_idle},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, //10
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, //20
+
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand},
+	{ai_stand}, //30
+
+	{ai_stand}
+};
+MMOVE_T(sentien_move_stand3) = { FRAME_idle301, FRAME_idle331, sentien_frames_stand3, nullptr };
+
+MONSTERINFO_STAND(sentien_stand) (edict_t* self) -> void
+{
+	float r;
+
+	r = frandom();
+	if (r < 0.33f)
+		M_SetAnimation(self, &sentien_move_stand1);
+	else if (r < 0.66f)
+		M_SetAnimation(self, &sentien_move_stand2);
+	else
+		M_SetAnimation(self, &sentien_move_stand3);
+}
+
+//
+// walk
+//
+
+mframe_t sentien_frames_start_walk[] =
+{
+   {ai_walk},
+   {ai_walk, 2},
+   {ai_walk, 3},
+   {ai_walk, 2},
+   {ai_walk, 2},
+   {ai_walk, 3},
+   {ai_walk, 2},
+   {ai_walk, 2, sentien_step}
+};
+MMOVE_T(sentien_move_start_walk) = { FRAME_walk01, FRAME_walk08, sentien_frames_start_walk, sentien_walk };
+
+mframe_t sentien_frames_walk[] =
+{
+   {ai_walk},
+   {ai_walk, 2},
+   {ai_walk, 4},
+   {ai_walk, 4},
+   {ai_walk, 4},
+   {ai_walk, 4},
+   {ai_walk, 4},
+   {ai_walk, 5, sentien_step},
+
+   {ai_walk, 2},
+   {ai_walk, 3},
+   {ai_walk, 4},
+   {ai_walk, 4},
+   {ai_walk, 4},
+   {ai_walk, 4},
+   {ai_walk, 5},
+   {ai_walk, 5, sentien_step}
+};
+MMOVE_T(sentien_move_walk) = { FRAME_walk09, FRAME_walk24, sentien_frames_walk, nullptr };
+#if 0
+mframe_t sentien_frames_end_walk[] =
+{
+   {ai_walk, 1},
+   {ai_walk, 1},
+   {ai_walk, 2},
+   {ai_walk, 1},
+   {ai_walk, 2},
+   {ai_walk, 1},
+   {ai_walk, 2},
+   {ai_walk, 2, sentien_step}
+};
+MMOVE_T(sentien_move_end_walk) = { FRAME_walk25, FRAME_walk32, sentien_frames_end_walk, sentien_stand };
+#endif
+MONSTERINFO_WALK(sentien_walk) (edict_t* self) -> void
+{
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+	{
+		M_SetAnimation(self, &sentien_move_stand1);
+		return;
+	}
+
+	if (self->monsterinfo.active_move == &sentien_move_start_walk)
+	{
+		M_SetAnimation(self, &sentien_move_walk);
+	}
+	else
+	{
+		M_SetAnimation(self, &sentien_move_start_walk);
+	}
+}
+
+//
+// run
+//
+
+mframe_t sentien_frames_start_run[] =
+{
+   {ai_run},
+   {ai_run, 2},
+   {ai_run, 3},
+   {ai_run, 2},
+   {ai_run, 2},
+   {ai_run, 3},
+   {ai_run, 2},
+   {ai_run, 2, sentien_step}
+};
+MMOVE_T(sentien_move_start_run) = { FRAME_walk01, FRAME_walk08, sentien_frames_start_run, sentien_run };
+
+mframe_t sentien_frames_run[] =
+{
+   {ai_run},
+   {ai_run, 2},
+   {ai_run, 4},
+   {ai_run, 4},
+   {ai_run, 4},
+   {ai_run, 4},
+   {ai_run, 4},
+   {ai_run, 5, sentien_step},
+
+   {ai_run, 2},
+   {ai_run, 3},
+   {ai_run, 4},
+   {ai_run, 4},
+   {ai_run, 4},
+   {ai_run, 4},
+   {ai_run, 5},
+   {ai_run, 5, sentien_step}
+};
+MMOVE_T(sentien_move_run) = { FRAME_walk09, FRAME_walk24, sentien_frames_run, nullptr };
+#if 0
+mframe_t sentien_frames_run_end[] =
+{
+   {ai_run, 1},
+   {ai_run, 1},
+   {ai_run, 2},
+   {ai_run, 1},
+   {ai_run, 2},
+   {ai_run, 1},
+   {ai_run, 2},
+   {ai_run, 2, sentien_step}
+};
+MMOVE_T(sentien_move_run_end) = { FRAME_walk25, FRAME_walk32, sentien_frames_run_end, sentien_walk };
+#endif
+MONSTERINFO_RUN(sentien_run) (edict_t* self) -> void
+{
+	if (self->enemy && self->enemy->client)
+		self->monsterinfo.aiflags |= AI_BRUTAL;
+	else
+		self->monsterinfo.aiflags &= ~AI_BRUTAL;
+
+	if (self->monsterinfo.aiflags & AI_STAND_GROUND)
+	{
+		M_SetAnimation(self, &sentien_move_stand1);
+		return;
+	}
+
+	if (self->monsterinfo.active_move == &sentien_move_walk ||
+		self->monsterinfo.active_move == &sentien_move_start_run)
+	{
+		M_SetAnimation(self, &sentien_move_run);
+	}
+	else
+	{
+		M_SetAnimation(self, &sentien_move_start_run);
+	}
+}
+
+//
+// pain
+//
+
+mframe_t sentien_frames_pain1[] =
+{
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move}
+};
+MMOVE_T(sentien_move_pain1) = { FRAME_pain101, FRAME_pain104, sentien_frames_pain1, sentien_run };
+
+mframe_t sentien_frames_pain2[] =
+{
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move}
+};
+MMOVE_T(sentien_move_pain2) = { FRAME_pain201, FRAME_pain206, sentien_frames_pain2, sentien_run };
+
+mframe_t sentien_frames_pain3[] =
+{
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move}
+};
+MMOVE_T(sentien_move_pain3) = { FRAME_pain301, FRAME_pain321, sentien_frames_pain3, sentien_run };
+
+PAIN(sentien_pain) (edict_t* self, edict_t* other, float kick, int damage, const mod_t& mod) -> void
+{
+	float r;
+
+	if (mod.id != MOD_CHAINFIST && damage <= 10)
+		return;
+
+	if (level.time < self->pain_debounce_time)
+		return;
+
+	// less than this we don't flinch
+	if (damage <= 10)
+		return;
+
+	if (mod.id != MOD_CHAINFIST)
+	{
+		if (damage <= 30)
+			if (frandom() > 0.2f)
+				return;
+
+		// don't go into pain while attacking
+		if (skill->integer >= 1)
+		{
+			if ((self->s.frame >= FRAME_attak301) && (self->s.frame <= FRAME_attak322))
+				return;
+			if ((self->s.frame >= FRAME_attak101) && (self->s.frame <= FRAME_attak114))
+				return;
+		}
+	}
+
+	self->pain_debounce_time = level.time + 3_sec;
+
+	r = frandom();
+	if (r < 0.33f)
+		gi.sound(self, CHAN_VOICE, sound_pain1, 1, ATTN_NORM, 0);
+	else if (r < 0.66f)
+		gi.sound(self, CHAN_VOICE, sound_pain2, 1, ATTN_NORM, 0);
+	else
+		gi.sound(self, CHAN_VOICE, sound_pain3, 1, ATTN_NORM, 0);
+
+	if (!M_ShouldReactToPain(self, mod))
+		return; // no pain anims in nightmare
+
+	if (damage > 60)
+		M_SetAnimation(self, &sentien_move_pain3);
+	else if (damage > 30)
+		M_SetAnimation(self, &sentien_move_pain2);
+	else
+		M_SetAnimation(self, &sentien_move_pain1);
+}
+
+MONSTERINFO_SETSKIN(sentien_setskin) (edict_t* self) -> void
+{
+	if (self->health < (self->max_health / 2))
+		self->s.skinnum |= 1;
+	else
+		self->s.skinnum &= ~1;
+}
+
+//
+// attacks
+//
+
+mframe_t sentien_frames_pre_blast_attack[] =
+{
+   {ai_charge},
+   {ai_charge},
+   {ai_charge},
+   {ai_charge}
+};
+MMOVE_T(sentien_move_pre_blast_attack) = { FRAME_attak101, FRAME_attak104, sentien_frames_pre_blast_attack, sentien_blast_attack };
+
+mframe_t sentien_frames_blast_attack[] =
+{
+   {ai_charge, 0, sentien_machinegun},
+   {ai_charge, 0, sentien_machinegun},
+   {ai_charge, 0, sentien_machinegun},
+   {ai_charge, 0, sentien_machinegun},
+   {ai_charge, 0, sentien_machinegun},
+   {ai_charge, 0, sentien_machinegun}
+};
+MMOVE_T(sentien_move_blast_attack) = { FRAME_attak105, FRAME_attak110, sentien_frames_blast_attack, sentien_post_blast_attack };
+
+mframe_t sentien_frames_post_blast_attack[] =
+{
+   {ai_charge},
+   {ai_charge},
+   {ai_charge},
+   {ai_charge}
+};
+MMOVE_T(sentien_move_post_blast_attack) = { FRAME_attak111, FRAME_attak114, sentien_frames_post_blast_attack, sentien_run };
+
+void sentien_blast_attack(edict_t* self)
+{
+	if (visible(self, self->enemy) && self->enemy->health > 0)
+		M_SetAnimation(self, &sentien_move_blast_attack);
+	else
+		M_SetAnimation(self, &sentien_move_post_blast_attack);
+}
+
+void sentien_post_blast_attack(edict_t* self)
+{
+	float refire = 0.25f;
+	float r;
+
+	if (visible(self, self->enemy) &&
+		infront(self, self->enemy))
+	{
+		if (skill->integer == 1)
+			refire = 0.4f;
+		else if (skill->integer == 2)
+			refire = 0.6f;
+		else if (skill->integer >= 3)
+			refire = 0.75f;
+
+		r = frandom();
+		if (r > refire)
+			M_SetAnimation(self, &sentien_move_post_blast_attack);
+	}
+	else
+		M_SetAnimation(self, &sentien_move_post_blast_attack);
+}
+
+vec3_t sentien_flash_offset[] =
+{
+	// frames 116+ (hex fire)
+	 {24, 25, 30},
+	 {24, 25, 27},
+	 {24, 28, 28},
+	 {24, 27, 31},
+	 {24, 25, 32},
+	 {24, 23, 31},
+	 {24, 23, 28}
+};
+
+void sentien_machinegun(edict_t* self)
+{
+	vec3_t					 start;
+	vec3_t					 aim;
+	vec3_t					 forward, right;
+	int						 idx;
+
+	idx = self->s.frame - FRAME_attak105 + 1;
+
+	if (!self->enemy || !self->enemy->inuse) // PGM
+		return;								 // PGM
+		
+	AngleVectors(self->s.angles, forward, right, nullptr);
+
+	start = M_ProjectFlashSource(self, sentien_flash_offset[idx], forward, right);
+	PredictAim(self, self->enemy, start, 0, true, -0.2f, &aim, nullptr);
+	
+	monster_fire_bullet(self, start, aim, 5, 4, DEFAULT_BULLET_HSPREAD, DEFAULT_BULLET_VSPREAD, MZ2_TANK_MACHINEGUN_14);
+
+	gi.sound(self, CHAN_BODY, sound_attack1, 1, ATTN_NORM, 0);
+}
+
+
+/*=========================================================================
+   Sentien laser attack.
+  =========================================================================*/
+void sentien_do_laser(edict_t* self);
+
+mframe_t sentien_frames_pre_laser_attack[] =
+{
+   {ai_charge},
+   {ai_charge},
+   {ai_charge},
+   {ai_charge},
+   {ai_charge}
+};
+MMOVE_T(sentien_move_pre_laser_attack) = { FRAME_attak201, FRAME_attak205, sentien_frames_pre_laser_attack, sentien_laser_attack };
+
+mframe_t sentien_frames_laser_attack[] =
+{
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser},
+		{nullptr, 0, sentien_do_laser}
+};
+MMOVE_T(sentien_move_laser_attack) = { FRAME_attak206, FRAME_attak216, sentien_frames_laser_attack, sentien_post_laser_attack };
+
+mframe_t sentien_frames_post_laser_attack[] =
+{
+   {ai_charge},
+   {ai_charge},
+   {ai_charge},
+   {ai_charge}
+};
+MMOVE_T(sentien_move_post_laser_attack) = { FRAME_attak217, FRAME_attak220, sentien_frames_post_laser_attack, sentien_run };
+
+void sentien_laser_attack(edict_t* self)
+{
+	// is a player right infront?
+	if (visible(self, self->enemy) &&
+		infront(self, self->enemy))
+	{
+		M_SetAnimation(self, &sentien_move_laser_attack);
+	}
+	else
+	{
+		sentien_post_laser_attack(self);
+	}
+}
+
+void sentien_post_laser_attack(edict_t* self)
+{
+	M_SetAnimation(self, &sentien_move_post_laser_attack);
+}
+
+vec3_t sentien_laser_offset[] =
+{
+	{44, -23 + 1, 44 - 1},
+	{44, -23 + 1, 44 - 1},
+	{44, -23 + 1, 44 - 1},
+	{43, -23 + 1, 44 - 1},
+	{42, -23 + 1, 44 - 1},
+	{42, -24 + 1, 44 - 1},
+	{42, -23 + 1, 44 - 1},
+	{43, -23 + 1, 44 - 1},
+	{44, -23 + 1, 44 - 1},
+	{44, -23 + 1, 44 - 1},
+	{44, -23 + 1, 44 - 1}
+};
+
+PRETHINK(sentien_fire_update) (edict_t* laser) -> void
+{
+	if (!laser->spawnflags.has(SPAWNFLAG_DABEAM_SPAWNED))
+	{
+		edict_t* self = laser->owner;
+
+		vec3_t forward, right, target;
+		vec3_t start;
+
+		AngleVectors(self->s.angles, forward, right, nullptr);
+		start = M_ProjectFlashSource(self, sentien_laser_offset[laser->spawnflags.has(SPAWNFLAG_DABEAM_SECONDARY) ? 1 : 0], forward, right);
+		PredictAim(self, self->enemy, start, 0, false, 0.3f, &forward, &target);
+
+		laser->s.origin = start;
+		forward[0] += crandom() * 0.02f;
+		forward[1] += crandom() * 0.02f;
+		forward.normalize();
+		laser->movedir = forward;
+		gi.linkentity(laser);
+	}
+	dabeam_update(laser, false);
+}
+
+void sentien_do_laser(edict_t* self)
+{
+	gi.sound(self, CHAN_BODY, sound_attack2, 1, ATTN_NORM, 0);
+	monster_fire_dabeam(self, 15, self->s.frame & 1, sentien_fire_update);
+}
+
+MONSTERINFO_ATTACK(sentien_attack) (edict_t* self) -> void
+{
+	vec3_t	vec;
+	float	range;
+	float	r;
+
+	vec = self->enemy->s.origin - self->s.origin;
+	range = vec.length();
+
+	r = frandom();
+
+	bool machinegun_visible = M_CheckClearShot(self, sentien_flash_offset[0]);
+	bool laser_visible = M_CheckClearShot(self, sentien_laser_offset[0]);
+
+	if (!machinegun_visible && !laser_visible)
+		return;
+
+	if (range <= 128)
+		M_SetAnimation(self, &sentien_move_pre_blast_attack);
+	else if (range <= 500)
+	{
+		if (r < 0.50)
+			M_SetAnimation(self, &sentien_move_pre_blast_attack);
+		else
+			M_SetAnimation(self, &sentien_move_pre_laser_attack);
+	}
+	else
+	{
+		if (r < 0.25)
+			M_SetAnimation(self, &sentien_move_pre_blast_attack);
+		else
+			M_SetAnimation(self, &sentien_move_pre_laser_attack);
+	}
+}
+
+/*=========================================================================
+   Sentien fending.
+  =========================================================================*/
+void sentien_fend_ready(edict_t* self)
+{
+	if (self->monsterinfo.aiflags & AI_REDUCEDDAMAGE)
+		return;
+	self->monsterinfo.pausetime = level.time + 1_sec;
+}
+
+void sentien_fend_hold(edict_t* self)
+{
+	if (level.time >= self->monsterinfo.pausetime)
+	{
+		self->monsterinfo.aiflags &= ~AI_HOLD_FRAME;
+		self->monsterinfo.aiflags &= ~AI_REDUCEDDAMAGE;
+	}
+	else
+	{
+		self->monsterinfo.aiflags |= (AI_HOLD_FRAME | AI_REDUCEDDAMAGE);
+	}
+}
+
+
+mframe_t sentien_frames_fend[] =
+{
+	{ai_move, 0,  sentien_sound_fend},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0,  sentien_fend_ready},
+	{ai_move, 0,  sentien_fend_hold},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0},
+	{ai_move, 0}
+};
+MMOVE_T(sentien_move_fend) = { FRAME_fend01, FRAME_fend15, sentien_frames_fend, sentien_run };
+
+MONSTERINFO_DODGE(sentien_fend) (edict_t* self, edict_t* attacker, gtime_t eta, trace_t* tr, bool gravity) -> void
+{
+	// don't flinch if attacking
+	if (self->monsterinfo.active_move == &sentien_move_laser_attack ||
+		self->monsterinfo.active_move == &sentien_move_blast_attack)
+		return;
+
+	if (skill->integer == 0)
+	{
+		if (frandom() > 0.45)
+			return;
+	}
+	else if (skill->integer == 1)
+	{
+		if (frandom() > 0.60)
+			return;
+	}
+	else
+	{
+		if (frandom() > 0.80)
+			return;
+	}
+
+	if (!self->enemy)
+		self->enemy = attacker;
+
+	M_SetAnimation(self, &sentien_move_fend);
+}
+
+//
+// DEATH
+//
+
+void sentien_dead(edict_t* self)
+{
+	self->mins = { -16, -16, -16 };
+	self->maxs = { 16, 16, -0 };
+	monster_dead(self);
+}
+
+static void sentien_shrink(edict_t* self)
+{
+	self->maxs[2] = 0;
+	self->svflags |= SVF_DEADMONSTER;
+	gi.linkentity(self);
+}
+
+mframe_t sentien_frames_death1[] =
+{
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move, 0, sentien_shrink},
+   {ai_move}
+};
+MMOVE_T(sentien_move_death1) = { FRAME_death101, FRAME_death128, sentien_frames_death1, sentien_dead };
+
+mframe_t sentien_frames_death2[] =
+{
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move, 0, sentien_shrink},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move},
+   {ai_move}
+};
+MMOVE_T(sentien_move_death2) = { FRAME_death201, FRAME_death229, sentien_frames_death2, sentien_dead };
+
+
+DIE(sentien_die) (edict_t* self, edict_t* inflictor, edict_t* attacker, int damage, const vec3_t& point, const mod_t& mod) -> void
+{
+	if (M_CheckGib(self, mod))
+	{
+		gi.sound(self, CHAN_VOICE, gi.soundindex("misc/udeath.wav"), 1, ATTN_NORM, 0);
+
+		self->s.skinnum /= 2;
+
+		ThrowGibs(self, damage, {
+			{ "models/objects/gibs/sm_meat/tris.md2" },
+			{ 3, "models/objects/gibs/sm_metal/tris.md2", GIB_METALLIC },
+			{ "models/objects/gibs/gear/tris.md2", GIB_METALLIC },
+			//{ 2, "models/monsters/sentien/gibs/leg.md2", GIB_SKINNED | GIB_METALLIC },
+			//{ "models/monsters/sentien/gibs/chest.md2", GIB_SKINNED },
+			{ "models/objects/gibs/chest/tris.md2", GIB_SKINNED },
+			//{ "models/monsters/sentien/gibs/head.md2", GIB_SKINNED | GIB_HEAD }
+			{ "models/objects/gibs/head2/tris.md2", GIB_SKINNED | GIB_HEAD }
+			});
+
+		if (!self->style)
+			ThrowGib(self, "models/monsters/tank/gibs/barm.md2", damage, GIB_SKINNED | GIB_UPRIGHT, self->s.scale);
+
+		self->deadflag = true;
+		return;
+	}
+
+	if (self->deadflag)
+		return;
+
+	self->deadflag = true;
+	self->takedamage = true;
+
+	if (frandom() < 0.80)
+	{
+		gi.sound(self, CHAN_BODY, sound_die1, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &sentien_move_death1);
+	}
+	else
+	{
+		gi.sound(self, CHAN_BODY, sound_die2, 1, ATTN_NORM, 0);
+		M_SetAnimation(self, &sentien_move_death2);
+	}
+}
+
+
+/*=========================================================================
+   Spawn code.
+  =========================================================================*/
+void SP_monster_sentien(edict_t* self)
+{
+	const spawn_temp_t& st = ED_GetSpawnTemp();
+
+	if (!M_AllowSpawn(self)) {
+		G_FreeEdict(self);
+		return;
+	}
+
+	self->s.modelindex = gi.modelindex("models/monsters/sentien/tris.md2");
+	self->mins = { -28, -28, -16 };
+	self->maxs = { 28, 28, 64 };
+	self->movetype = MOVETYPE_STEP;
+	self->solid = SOLID_BBOX;
+
+	sound_idle1.assign("sentien/sen_idle1.wav");
+	sound_idle2.assign("sentien/sen_idle2.wav");
+	sound_idle3.assign("sentien/sen_idle3.wav");
+	sound_step.assign("sentien/sen_walk.wav");
+	sound_fend.assign("sentien/sen_fend.wav");
+	sound_pain1.assign("sentien/sen_pain1.wav");
+	sound_pain2.assign("sentien/sen_pain2.wav");
+	sound_pain3.assign("sentien/sen_pain3.wav");
+	sound_die1.assign("sentien/sen_die1.wav");
+	sound_die2.assign("sentien/sen_die2.wav");
+	sound_attack1.assign("sentien/sen_att1.wav");
+	sound_attack2.assign("sentien/sen_att2.wav");
+	sound_sight.assign("sentien/sen_att3.wav");
+
+	self->mass = 500;
+	self->health = 900;
+	self->gib_health = -425;
+	self->yaw_speed = 10;
+	self->random = 1;
+
+	if (!st.was_key_specified("armor_type"))
+		self->monsterinfo.armor_type = IT_ARMOR_COMBAT;
+	if (!st.was_key_specified("armor_power"))
+		self->monsterinfo.armor_power = 200;
+
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	// setup the functions
+	self->pain = sentien_pain;
+	self->die = sentien_die;
+	self->monsterinfo.stand = sentien_stand;
+	self->monsterinfo.walk = sentien_walk;
+	self->monsterinfo.run = sentien_run;
+	self->monsterinfo.attack = sentien_attack;
+	self->monsterinfo.dodge = sentien_fend;
+	self->monsterinfo.melee = nullptr;
+	self->monsterinfo.sight = nullptr;
+	self->monsterinfo.idle = nullptr;
+	self->monsterinfo.setskin = sentien_setskin;
+
+	self->monsterinfo.aiflags |= AI_IGNORE_SHOTS;
+
+	gi.linkentity(self);
+
+	M_SetAnimation(self, &sentien_move_stand1);
+	self->monsterinfo.scale = MODEL_SCALE;
+
+	walkmonster_start(self);
+}
--- /dev/null
+++ b/zaero/m_zaero_sentien.h	2025-09-04 19:53:48
@@ -0,0 +1,328 @@
+// Copyright (c) ZeniMax Media Inc.
+// Licensed under the GNU General Public License 2.0.
+// G:\quake2\baseq2\models/monsters/sentien
+
+enum
+{
+	FRAME_idle101,
+	FRAME_idle102,
+	FRAME_idle103,
+	FRAME_idle104,
+	FRAME_idle105,
+	FRAME_idle106,
+	FRAME_idle107,
+	FRAME_idle108,
+	FRAME_idle109,
+	FRAME_idle110,
+	FRAME_idle111,
+	FRAME_idle112,
+	FRAME_idle113,
+	FRAME_idle114,
+	FRAME_idle115,
+	FRAME_idle116,
+	FRAME_idle117,
+	FRAME_idle118,
+	FRAME_idle119,
+	FRAME_idle120,
+	FRAME_idle121,
+	FRAME_idle122,
+	FRAME_idle123,
+	FRAME_idle124,
+	FRAME_idle125,
+	FRAME_idle126,
+	FRAME_idle127,
+	FRAME_idle128,
+	FRAME_idle129,
+	FRAME_idle201,
+	FRAME_idle202,
+	FRAME_idle203,
+	FRAME_idle204,
+	FRAME_idle205,
+	FRAME_idle206,
+	FRAME_idle207,
+	FRAME_idle208,
+	FRAME_idle209,
+	FRAME_idle210,
+	FRAME_idle211,
+	FRAME_idle212,
+	FRAME_idle213,
+	FRAME_idle214,
+	FRAME_idle215,
+	FRAME_idle216,
+	FRAME_idle217,
+	FRAME_idle218,
+	FRAME_idle219,
+	FRAME_idle220,
+	FRAME_idle301,
+	FRAME_idle302,
+	FRAME_idle303,
+	FRAME_idle304,
+	FRAME_idle305,
+	FRAME_idle306,
+	FRAME_idle307,
+	FRAME_idle308,
+	FRAME_idle309,
+	FRAME_idle310,
+	FRAME_idle311,
+	FRAME_idle312,
+	FRAME_idle313,
+	FRAME_idle314,
+	FRAME_idle315,
+	FRAME_idle316,
+	FRAME_idle317,
+	FRAME_idle318,
+	FRAME_idle319,
+	FRAME_idle320,
+	FRAME_idle321,
+	FRAME_idle322,
+	FRAME_idle323,
+	FRAME_idle324,
+	FRAME_idle325,
+	FRAME_idle326,
+	FRAME_idle327,
+	FRAME_idle328,
+	FRAME_idle329,
+	FRAME_idle330,
+	FRAME_idle331,
+	FRAME_walk01,
+	FRAME_walk02,
+	FRAME_walk03,
+	FRAME_walk04,
+	FRAME_walk05,
+	FRAME_walk06,
+	FRAME_walk07,
+	FRAME_walk08,
+	FRAME_walk09,
+	FRAME_walk10,
+	FRAME_walk11,
+	FRAME_walk12,
+	FRAME_walk13,
+	FRAME_walk14,
+	FRAME_walk15,
+	FRAME_walk16,
+	FRAME_walk17,
+	FRAME_walk18,
+	FRAME_walk19,
+	FRAME_walk20,
+	FRAME_walk21,
+	FRAME_walk22,
+	FRAME_walk23,
+	FRAME_walk24,
+	FRAME_walk25,
+	FRAME_walk26,
+	FRAME_walk27,
+	FRAME_walk28,
+	FRAME_walk29,
+	FRAME_walk30,
+	FRAME_walk31,
+	FRAME_walk32,
+	FRAME_attak101,
+	FRAME_attak102,
+	FRAME_attak103,
+	FRAME_attak104,
+	FRAME_attak105,
+	FRAME_attak106,
+	FRAME_attak107,
+	FRAME_attak108,
+	FRAME_attak109,
+	FRAME_attak110,
+	FRAME_attak111,
+	FRAME_attak112,
+	FRAME_attak113,
+	FRAME_attak114,
+	FRAME_attak201,
+	FRAME_attak202,
+	FRAME_attak203,
+	FRAME_attak204,
+	FRAME_attak205,
+	FRAME_attak206,
+	FRAME_attak207,
+	FRAME_attak208,
+	FRAME_attak209,
+	FRAME_attak210,
+	FRAME_attak211,
+	FRAME_attak212,
+	FRAME_attak213,
+	FRAME_attak214,
+	FRAME_attak215,
+	FRAME_attak216,
+	FRAME_attak217,
+	FRAME_attak218,
+	FRAME_attak219,
+	FRAME_attak220,
+	FRAME_attak301,
+	FRAME_attak302,
+	FRAME_attak303,
+	FRAME_attak304,
+	FRAME_attak305,
+	FRAME_attak306,
+	FRAME_attak307,
+	FRAME_attak308,
+	FRAME_attak309,
+	FRAME_attak310,
+	FRAME_attak311,
+	FRAME_attak312,
+	FRAME_attak313,
+	FRAME_attak314,
+	FRAME_attak315,
+	FRAME_attak316,
+	FRAME_attak317,
+	FRAME_attak318,
+	FRAME_attak319,
+	FRAME_attak320,
+	FRAME_attak321,
+	FRAME_attak322,
+	FRAME_fend01,
+	FRAME_fend02,
+	FRAME_fend03,
+	FRAME_fend04,
+	FRAME_fend05,
+	FRAME_fend06,
+	FRAME_fend07,
+	FRAME_fend08,
+	FRAME_fend09,
+	FRAME_fend10,
+	FRAME_fend11,
+	FRAME_fend12,
+	FRAME_fend13,
+	FRAME_fend14,
+	FRAME_fend15,
+	FRAME_pain101,
+	FRAME_pain102,
+	FRAME_pain103,
+	FRAME_pain104,
+	FRAME_pain201,
+	FRAME_pain202,
+	FRAME_pain203,
+	FRAME_pain204,
+	FRAME_pain205,
+	FRAME_pain206,
+	FRAME_pain301,
+	FRAME_pain302,
+	FRAME_pain303,
+	FRAME_pain304,
+	FRAME_pain305,
+	FRAME_pain306,
+	FRAME_pain307,
+	FRAME_pain308,
+	FRAME_pain309,
+	FRAME_pain310,
+	FRAME_pain311,
+	FRAME_pain312,
+	FRAME_pain313,
+	FRAME_pain314,
+	FRAME_pain315,
+	FRAME_pain316,
+	FRAME_pain317,
+	FRAME_pain318,
+	FRAME_pain319,
+	FRAME_pain320,
+	FRAME_pain321,
+	FRAME_death101,
+	FRAME_death102,
+	FRAME_death103,
+	FRAME_death104,
+	FRAME_death105,
+	FRAME_death106,
+	FRAME_death107,
+	FRAME_death108,
+	FRAME_death109,
+	FRAME_death110,
+	FRAME_death111,
+	FRAME_death112,
+	FRAME_death113,
+	FRAME_death114,
+	FRAME_death115,
+	FRAME_death116,
+	FRAME_death117,
+	FRAME_death118,
+	FRAME_death119,
+	FRAME_death120,
+	FRAME_death121,
+	FRAME_death122,
+	FRAME_death123,
+	FRAME_death124,
+	FRAME_death125,
+	FRAME_death126,
+	FRAME_death127,
+	FRAME_death128,
+	FRAME_death201,
+	FRAME_death202,
+	FRAME_death203,
+	FRAME_death204,
+	FRAME_death205,
+	FRAME_death206,
+	FRAME_death207,
+	FRAME_death208,
+	FRAME_death209,
+	FRAME_death210,
+	FRAME_death211,
+	FRAME_death212,
+	FRAME_death213,
+	FRAME_death214,
+	FRAME_death215,
+	FRAME_death216,
+	FRAME_death217,
+	FRAME_death218,
+	FRAME_death219,
+	FRAME_death220,
+	FRAME_death221,
+	FRAME_death222,
+	FRAME_death223,
+	FRAME_death224,
+	FRAME_death225,
+	FRAME_death226,
+	FRAME_death227,
+	FRAME_death228,
+	FRAME_death229,
+};
+
+constexpr float MODEL_SCALE = 1.000000f;
+
+/*
+#define FRAME_stand1start	0
+#define FRAME_stand1end		28
+#define FRAME_stand2start	29
+#define FRAME_stand2end		48
+#define FRAME_stand3start	49
+#define FRAME_stand3end		79
+#define FRAME_walkStartStart	80
+#define FRAME_walkStartEnd	87
+#define FRAME_walkLoopStart	88
+#define FRAME_walkLoopEnd	103
+#define FRAME_walkEndStart	104
+#define FRAME_walkEndEnd	111
+
+#define FRAME_blastPreStart	112
+#define FRAME_blastPreEnd	115
+#define FRAME_blastStart	116
+#define FRAME_blastEnd		121
+#define FRAME_blastPostStart	122
+#define FRAME_blastPostEnd	125
+#define FRAME_laserPreStart	126
+#define FRAME_laserPreEnd	130
+#define FRAME_laserStart	131
+#define FRAME_laserEnd		141
+#define FRAME_laserPostStart	142
+#define FRAME_laserPostEnd	145
+#define FRAME_slashPreStart   146
+#define FRAME_slashPreEnd     150
+#define FRAME_slashStart      151
+#define FRAME_slashEnd        154
+#define FRAME_slashPostStart  155
+#define FRAME_slashPostEnd    167
+
+#define FRAME_dodgeStart	168
+#define FRAME_dodgeHold		173
+#define FRAME_dodgeEnd		182
+#define FRAME_pain1Start	183
+#define FRAME_pain1End		186
+#define FRAME_pain2Start	187
+#define FRAME_pain2End		192
+#define FRAME_pain3Start	193
+#define FRAME_pain3End		213
+#define FRAME_die1Start		214
+#define FRAME_die1End		241
+#define FRAME_die2Start		242
+#define FRAME_die2End		270
+*/
--- /dev/null
+++ b/zaero/p_zaero_weapon.cpp	2025-09-04 19:53:48
@@ -0,0 +1,3 @@
+// Licensed under the GNU General Public License 2.0.
+
+#include "../g_local.h"
